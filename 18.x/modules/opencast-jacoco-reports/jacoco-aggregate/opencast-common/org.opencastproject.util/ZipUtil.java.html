<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ZipUtil.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.util</a> &gt; <span class="el_source">ZipUtil.java</span></div><h1>ZipUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Vector;
import java.util.zip.Deflater;

import de.schlichtherle.io.ArchiveDetector;
import de.schlichtherle.io.ArchiveException;
import de.schlichtherle.io.ArchiveWarningException;
import de.schlichtherle.io.DefaultArchiveDetector;
import de.schlichtherle.io.File;
import de.schlichtherle.io.archive.zip.ZipDriver;

/*
 * WARNING:
 * Some archivers, such as file-roller in Ubuntu, seem not to be able to uncompress zip archives containg files with special characters.
 * The pure zip standard uses the CP437 encoding which CAN'T represent special characters, but applications have implemented their own methods
 * to overcome this inconvenience. TrueZip also. However, it seems file-roller (and probably others) doesn't &quot;understand&quot; how to restore the
 * original filenames and shows strange (and un-readable) characters in the unzipped filenames
 * However, the inverse process (unzipping zip archives made with file-roller and containing files with special characters) seems to work fine
 *
 * N.B. By &quot;special characters&quot; I mean those not present in the original ASCII specification, such as accents, special letters, etc
 *
 * ruben.perez
 */

/**
 * Provides static methods for compressing and extracting zip files using zip64 extensions when necessary.
 */
public final class ZipUtil {

<span class="fc" id="L57">  private static final Logger logger = LoggerFactory.getLogger(ZipUtil.class);</span>

  public static final int BEST_SPEED = Deflater.BEST_SPEED;
  public static final int BEST_COMPRESSION = Deflater.BEST_COMPRESSION;
  public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;
  public static final int NO_COMPRESSION = Deflater.NO_COMPRESSION;

  /** Disable construction of this utility class */
  private ZipUtil() {
  }

  /**
   * Utility class to ease the process of umounting a zip file
   *
   * @param zipFile
   *          The file to umount
   * @throws IOException
   *           If some problem occurs on unmounting
   */
  private static void umount(File zipFile) throws IOException {
    try {
<span class="fc" id="L78">      File.umount(zipFile);</span>
<span class="nc" id="L79">    } catch (ArchiveWarningException awe) {</span>
<span class="nc" id="L80">      logger.warn(&quot;Umounting {} threw the following warning: {}&quot;, zipFile.getCanonicalPath(), awe.getMessage());</span>
<span class="nc" id="L81">    } catch (ArchiveException ae) {</span>
<span class="nc" id="L82">      logger.error(&quot;Unable to umount zip file: {}&quot;, zipFile.getCanonicalPath());</span>
<span class="nc" id="L83">      throw new IOException(&quot;Unable to umount zip file: &quot; + zipFile.getCanonicalPath(), ae);</span>
<span class="pc" id="L84">    }</span>
<span class="fc" id="L85">  }</span>

  /***********************************************************************************/
  /* SERVICE CLASSES - The two following classes are the ones actually doing the job */
  /***********************************************************************************/

  /**
   * Compresses source files into a zip archive
   *
   * @param sourceFiles
   *          A {@link java.io.File} array with the files to include in the root of the archive
   * @param destination
   *          A {@link java.io.File} descriptor to the location where the zip file should be created
   * @param recursive
   *          Indicate whether or not recursively zipping nested directories
   * @param level
   *          The zip algorithm compression level. Ranges between 0 (no compression) and 9 (max. compression)
   * @return A {@link java.io.File} descriptor of the zip archive file
   * @throws IOException
   *           If the zip file can not be created, or the input files names can not be correctly parsed
   */
  public static java.io.File zip(java.io.File[] sourceFiles, java.io.File destination, boolean recursive, int level)
          throws IOException {

<span class="fc bfc" id="L109" title="All 2 branches covered.">    if (sourceFiles == null) {</span>
<span class="fc" id="L110">      logger.error(&quot;The array with files to zip cannot be null&quot;);</span>
<span class="fc" id="L111">      throw new IllegalArgumentException(&quot;The array with files to zip cannot be null&quot;);</span>
    }

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">    if (sourceFiles.length &lt;= 0) {</span>
<span class="nc" id="L115">      logger.error(&quot;The array with files to zip cannot be empty&quot;);</span>
<span class="nc" id="L116">      throw new IllegalArgumentException(&quot;The array with files to zip cannot be empty&quot;);</span>
    }

<span class="fc bfc" id="L119" title="All 2 branches covered.">    if (destination == null) {</span>
<span class="fc" id="L120">      logger.error(&quot;The destination file cannot be null&quot;);</span>
<span class="fc" id="L121">      throw new IllegalArgumentException(&quot;The destination file cannot be null&quot;);</span>
    }

<span class="fc bfc" id="L124" title="All 2 branches covered.">    if (destination.exists()) {</span>
<span class="fc" id="L125">      logger.error(&quot;The destination file {} already exists&quot;, destination.getCanonicalPath());</span>
<span class="fc" id="L126">      throw new IllegalArgumentException(&quot;The destination file already exists&quot;);</span>
    }

<span class="pc bpc" id="L129" title="1 of 2 branches missed.">    if (level &lt; -1) {</span>
<span class="nc" id="L130">      logger.warn(&quot;Compression level cannot be less than 0 (or -1 for default)&quot;);</span>
<span class="nc" id="L131">      logger.warn(&quot;Reverting to default...&quot;);</span>
<span class="nc" id="L132">      level = -1;</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">    } else if (level &gt; 9) {</span>
<span class="nc" id="L134">      logger.warn(&quot;Compression level cannot be greater than 9&quot;);</span>
<span class="nc" id="L135">      logger.warn(&quot;Reverting to default...&quot;);</span>
<span class="nc" id="L136">      level = -1;</span>
    }

    // Limits the compression support to ZIP only and sets the compression level
<span class="fc" id="L140">    ZipDriver zd = new ZipDriver(level);</span>
<span class="fc" id="L141">    ArchiveDetector ad = new DefaultArchiveDetector(ArchiveDetector.NULL, &quot;zip&quot;, zd);</span>
    File zipFile;
    try {
<span class="fc" id="L144">      zipFile = new File(destination.getCanonicalFile(), ad);</span>
<span class="nc" id="L145">    } catch (IOException ioe) {</span>
<span class="nc" id="L146">      logger.error(&quot;Unable to create the zip file: {}&quot;, destination.getAbsolutePath());</span>
<span class="nc" id="L147">      throw new IOException(&quot;Unable to create the zip file: {}&quot; + destination.getAbsolutePath(), ioe);</span>
<span class="fc" id="L148">    }</span>

    try {
<span class="fc bfc" id="L151" title="All 2 branches covered.">      if (!zipFile.isArchive()) {</span>
<span class="fc" id="L152">        logger.error(&quot;The destination file does not represent a valid zip archive (.zip extension is required)&quot;);</span>
<span class="fc" id="L153">        zipFile.deleteAll();</span>
<span class="fc" id="L154">        throw new IllegalArgumentException(</span>
                &quot;The destination file does not represent a valid zip archive (.zip extension is required)&quot;);
      }

<span class="pc bpc" id="L158" title="1 of 2 branches missed.">      if (!zipFile.mkdirs())</span>
<span class="nc" id="L159">        throw new IOException(&quot;Couldn't create the destination file&quot;);</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">      for (java.io.File f : sourceFiles) {</span>

<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (f == null) {</span>
<span class="fc" id="L164">          logger.error(&quot;Null inputfile in array&quot;);</span>
<span class="fc" id="L165">          zipFile.deleteAll();</span>
<span class="fc" id="L166">          throw new IllegalArgumentException(&quot;Null inputfile in array&quot;);</span>
        }

<span class="fc" id="L169">        logger.debug(&quot;Attempting to zip file {}...&quot;, f.getAbsolutePath());</span>

        // TrueZip manual says that (archiveC|copy)All(From|To) methods work with either directories or regular files
        // Therefore, one could do zipFile.archiveCopyAllFrom(f), where f is a regular file, and it would work. Well, it
        // DOESN'T
        // This is why we have to tell if a file is a regular file or a directory BEFORE copying it with the appropriate
        // method
<span class="fc" id="L176">        boolean success = false;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (f.exists()) {</span>
<span class="fc bfc" id="L178" title="All 4 branches covered.">          if (!f.isDirectory() || recursive) {</span>
<span class="fc" id="L179">            success = new File(zipFile, f.getName()).copyAllFrom(f);</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            if (success)</span>
<span class="fc" id="L181">              logger.debug(&quot;File {} zipped successfuly&quot;, f.getAbsolutePath());</span>
            else {
<span class="nc" id="L183">              logger.error(&quot;File {} not zipped&quot;, f.getAbsolutePath());</span>
<span class="nc" id="L184">              zipFile.deleteAll();</span>
<span class="nc" id="L185">              throw new IOException(&quot;Failed to zip one of the input files: &quot; + f.getAbsolutePath());</span>
            }
          }
        } else {
<span class="fc" id="L189">          logger.error(&quot;Input file {} doesn't exist&quot;, f.getAbsolutePath());</span>
<span class="fc" id="L190">          zipFile.deleteAll();</span>
<span class="fc" id="L191">          throw new FileNotFoundException(&quot;One of the input files does not exist: &quot; + f.getAbsolutePath());</span>
        }
      }
<span class="fc" id="L194">    } catch (IOException e) {</span>
<span class="fc" id="L195">      throw e;</span>
    } finally {
<span class="fc" id="L197">      umount(zipFile);</span>
    }

<span class="fc" id="L200">    return destination;</span>
  }

  /**
   * Extracts a zip file to a directory.
   *
   * @param zipFile
   *          A {@link String} with the path to the source zip archive
   * @param destination
   *          A {@link String} with the location where the zip archive will be extracted. If this destination directory
   *          does not exist, it will be created.
   * @throws IOException
   *           if the zip file cannot be read, the destination directory cannot be created or the extraction is not
   *           successful
   */
  public static void unzip(java.io.File zipFile, java.io.File destination) throws IOException {

    boolean success;

<span class="fc bfc" id="L219" title="All 2 branches covered.">    if (zipFile == null) {</span>
<span class="fc" id="L220">      logger.error(&quot;The zip file cannot be null&quot;);</span>
<span class="fc" id="L221">      throw new IllegalArgumentException(&quot;The zip file must be set&quot;);</span>
    }

<span class="fc bfc" id="L224" title="All 2 branches covered.">    if (!zipFile.exists()) {</span>
<span class="fc" id="L225">      logger.error(&quot;The zip file does not exist: {}&quot;, zipFile.getCanonicalPath());</span>
<span class="fc" id="L226">      throw new FileNotFoundException(&quot;The zip file does not exist: &quot; + zipFile.getCanonicalPath());</span>
    }

<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (destination == null) {</span>
<span class="fc" id="L230">      logger.error(&quot;The destination file cannot be null&quot;);</span>
<span class="fc" id="L231">      throw new IllegalArgumentException(&quot;Destination file cannot be null&quot;);</span>
    }

    // FIXME Commented out for 3rd party compatibility. See comment in the zip method above -ruben.perez
    // File f = new File(zipFile.getCanonicalFile(), new DefaultArchiveDetector(ArchiveDetector.NULL, &quot;zip&quot;, new
    // ZipDriver(&quot;utf-8&quot;)));
    File f;
    try {
<span class="fc" id="L239">      f = new File(zipFile.getCanonicalFile());</span>
<span class="nc" id="L240">    } catch (IOException ioe) {</span>
<span class="nc" id="L241">      logger.error(&quot;Unable to create the zip file: {}&quot;, destination.getAbsolutePath());</span>
<span class="nc" id="L242">      throw new IOException(&quot;Unable to create the zip file: {}&quot; + destination.getAbsolutePath(), ioe);</span>
<span class="fc" id="L243">    }</span>

    try {
<span class="pc bpc" id="L246" title="1 of 4 branches missed.">      if (f.isArchive() &amp;&amp; f.isDirectory()) {</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (destination.exists()) {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">          if (!destination.isDirectory()) {</span>
<span class="fc" id="L249">            logger.error(&quot;Destination file must be a directory&quot;);</span>
<span class="fc" id="L250">            throw new IllegalArgumentException(&quot;Destination file must be a directory&quot;);</span>
          }
        }

        try {
<span class="fc" id="L255">          destination.mkdirs();</span>
<span class="nc" id="L256">        } catch (SecurityException e) {</span>
<span class="nc" id="L257">          logger.error(&quot;Cannot create destination directory: {}&quot;, e.getMessage());</span>
<span class="nc" id="L258">          throw new IOException(&quot;Cannot create destination directory&quot;, e);</span>
<span class="fc" id="L259">        }</span>

<span class="fc" id="L261">        success = f.copyAllTo(destination);</span>

<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (success)</span>
<span class="fc" id="L264">          logger.debug(&quot;File {} unzipped successfully&quot;, zipFile.getCanonicalPath());</span>
        else {
<span class="nc" id="L266">          logger.warn(&quot;File {} was not correctly unzipped&quot;, zipFile.getCanonicalPath());</span>
<span class="nc" id="L267">          throw new IOException(&quot;File &quot; + zipFile.getCanonicalPath() + &quot; was not correctly unzipped&quot;);</span>
        }
      } else {
<span class="fc" id="L270">        logger.error(&quot;The input file is not a valid zip file&quot;);</span>
<span class="fc" id="L271">        throw new IllegalArgumentException(&quot;The input file is not a valid zip file&quot;);</span>
      }
<span class="nc" id="L273">    } catch (IOException e) {</span>
<span class="nc" id="L274">      throw (e);</span>
    } finally {
<span class="fc" id="L276">      umount(f);</span>
    }

<span class="fc" id="L279">  }</span>

  /************************************************************************************* */
  /* &quot;ALIASES&quot; - For different types of input, but actually calling the previous methods */
  /***************************************************************************************/

  /**
   * Compresses source files into a zip archive
   *
   * @param sourceFiles
   *          A {@link String} array with the file names to be included in the root of the archive
   * @param destination
   *          A {@link String} with the path name of the resulting zip file
   * @param recursive
   *          Indicate whether or not recursively zipping nested directories
   * @param level
   *          The zip algorithm compression level. Ranges between 0 (no compression) and 9 (max. compression)
   * @return A {@link java.io.File} descriptor of the zip archive file
   * @throws IOException
   *           If the zip file can not be created, or the input files names can not be correctly parsed
   */
  public static java.io.File zip(String[] sourceFiles, String destination, boolean recursive, int level)
          throws IOException {

<span class="fc bfc" id="L303" title="All 2 branches covered.">    if (sourceFiles == null) {</span>
<span class="fc" id="L304">      logger.error(&quot;The input String array cannot be null&quot;);</span>
<span class="fc" id="L305">      throw new IllegalArgumentException(&quot;The input String array cannot be null&quot;);</span>
    }

<span class="fc bfc" id="L308" title="All 2 branches covered.">    if (destination == null) {</span>
<span class="fc" id="L309">      logger.error(&quot;Destination file cannot be null&quot;);</span>
<span class="fc" id="L310">      throw new IllegalArgumentException(&quot;Destination file cannot be null&quot;);</span>
    }

<span class="fc bfc" id="L313" title="All 2 branches covered.">    if (&quot;&quot;.equals(destination)) {</span>
<span class="fc" id="L314">      logger.error(&quot;Destination file name must be set&quot;);</span>
<span class="fc" id="L315">      throw new IllegalArgumentException(&quot;Destination file name must be set&quot;);</span>
    }

<span class="fc" id="L318">    Vector&lt;java.io.File&gt; files = new Vector&lt;java.io.File&gt;();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">    for (String name : sourceFiles) {</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">      if (name == null) {</span>
<span class="fc" id="L321">        logger.error(&quot;One of the input file names is null&quot;);</span>
<span class="fc" id="L322">        throw new IllegalArgumentException(&quot;One of the input file names is null&quot;);</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">      } else if (&quot;&quot;.equals(name)) {</span>
<span class="nc" id="L324">        logger.error(&quot;One of the input file names is blank&quot;);</span>
<span class="nc" id="L325">        throw new IllegalArgumentException(&quot;One of the input file names is blank&quot;);</span>
      }
<span class="fc" id="L327">      files.add(new java.io.File(name));</span>
    }

<span class="fc" id="L330">    return zip(files.toArray(new java.io.File[files.size()]), new java.io.File(destination), recursive, level);</span>

  }

  /**
   * Compresses source files into a zip archive
   *
   * @param sourceFiles
   *          A {@link String} array with the file names to be included in the root of the archive
   * @param destination
   *          A {@link java.io.File} with the path name of the resulting zip file
   * @param recursive
   *          Indicate whether or not recursively zipping nested directories
   * @param level
   *          The zip algorithm compression level. Ranges between 0 (no compression) and 9 (max. compression)
   * @return A {@link java.io.File} descriptor of the zip archive file
   * @throws IOException
   *           If the zip file can not be created, or the input files names can not be correctly parsed
   */
  public static java.io.File zip(String[] sourceFiles, java.io.File destination, boolean recursive, int level)
          throws IOException {

<span class="fc bfc" id="L352" title="All 2 branches covered.">    if (sourceFiles == null) {</span>
<span class="fc" id="L353">      logger.error(&quot;The input String array cannot be null&quot;);</span>
<span class="fc" id="L354">      throw new IllegalArgumentException(&quot;The input String array cannot be null&quot;);</span>
    }

<span class="fc" id="L357">    Vector&lt;java.io.File&gt; files = new Vector&lt;java.io.File&gt;();</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">    for (String name : sourceFiles) {</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">      if (name == null) {</span>
<span class="fc" id="L360">        logger.error(&quot;One of the input file names is null&quot;);</span>
<span class="fc" id="L361">        throw new IllegalArgumentException(&quot;One of the input file names is null&quot;);</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">      } else if (&quot;&quot;.equals(name)) {</span>
<span class="nc" id="L363">        logger.error(&quot;One of the input file names is blank&quot;);</span>
<span class="nc" id="L364">        throw new IllegalArgumentException(&quot;One of the input file names is blank&quot;);</span>
      }
<span class="fc" id="L366">      files.add(new java.io.File(name));</span>
    }

<span class="fc" id="L369">    return zip(files.toArray(new java.io.File[files.size()]), destination, recursive, level);</span>

  }

  /**
   * Compresses source files into a zip archive
   *
   * @param sourceFiles
   *          A {@link java.io.File} array with the file names to be included in the root of the archive
   * @param destination
   *          A {@link String} with the path name of the resulting zip file
   * @param recursive
   *          Indicate whether or not recursively zipping nested directories
   * @param level
   *          The zip algorithm compression level. Ranges between 0 (no compression) and 9 (max. compression)
   * @return A {@link java.io.File} descriptor of the zip archive file
   * @throws IOException
   *           If the zip file can not be created, or the input files names can not be correctly parsed
   */
  public static java.io.File zip(java.io.File[] sourceFiles, String destination, boolean recursive, int level)
          throws IOException {

<span class="fc bfc" id="L391" title="All 2 branches covered.">    if (destination == null) {</span>
<span class="fc" id="L392">      logger.error(&quot;Destination file cannot be null&quot;);</span>
<span class="fc" id="L393">      throw new IllegalArgumentException(&quot;Destination file cannot be null&quot;);</span>
    }

<span class="fc bfc" id="L396" title="All 2 branches covered.">    if (&quot;&quot;.equals(destination)) {</span>
<span class="fc" id="L397">      logger.error(&quot;Destination file name must be set&quot;);</span>
<span class="fc" id="L398">      throw new IllegalArgumentException(&quot;Destination file name must be set&quot;);</span>
    }

<span class="fc" id="L401">    return zip(sourceFiles, new java.io.File(destination), recursive, level);</span>

  }

  /**
   * Compresses source files into a zip archive (no recursive)
   *
   * @param sourceFiles
   *          A {@link java.io.File} array with the file names to be included in the root of the archive
   * @param destination
   *          A {@link java.io.File} with the path name of the resulting zip file
   * @param level
   *          The zip algorithm compression level. Ranges between 0 (no compression) and 9 (max. compression)
   * @return A {@link java.io.File} descriptor of the zip archive file
   * @throws IOException
   *           If the zip file can not be created, or the input files names can not be correctly parsed
   */
  public static java.io.File zip(java.io.File[] sourceFiles, java.io.File destination, int level) throws IOException {
<span class="nc" id="L419">    return zip(sourceFiles, destination, false, level);</span>
  }

  /**
   * Extracts a zip file to a directory.
   *
   * @param zipFile
   *          A {@link String} with the path to the source zip archive
   * @param destination
   *          A {@link String} with the location where the zip archive will be extracted. If this destination directory
   *          does not exist, it will be created.
   * @throws IOException
   *           if the zip file cannot be read, the destination directory cannot be created or the extraction is not
   *           successful
   */
  public static void unzip(String zipFile, String destination) throws IOException {

<span class="fc bfc" id="L436" title="All 2 branches covered.">    if (zipFile == null) {</span>
<span class="fc" id="L437">      logger.error(&quot;Input filename cannot be null&quot;);</span>
<span class="fc" id="L438">      throw new IllegalArgumentException(&quot;Input filename cannot be null&quot;);</span>
    }

<span class="fc bfc" id="L441" title="All 2 branches covered.">    if (&quot;&quot;.equals(zipFile)) {</span>
<span class="fc" id="L442">      logger.error(&quot;Input filename cannot be empty&quot;);</span>
<span class="fc" id="L443">      throw new IllegalArgumentException(&quot;Input filename cannot be empty&quot;);</span>
    }

<span class="fc bfc" id="L446" title="All 2 branches covered.">    if (destination == null) {</span>
<span class="fc" id="L447">      logger.error(&quot;Output filename cannot be null&quot;);</span>
<span class="fc" id="L448">      throw new IllegalArgumentException(&quot;Output filename cannot be null&quot;);</span>
    }

<span class="pc bpc" id="L451" title="1 of 2 branches missed.">    if (&quot;&quot;.equals(destination)) {</span>
<span class="fc" id="L452">      logger.error(&quot;Output filename cannot be empty&quot;);</span>
<span class="fc" id="L453">      throw new IllegalArgumentException(&quot;Output filename cannot be empty&quot;);</span>
    }

<span class="nc" id="L456">    unzip(new java.io.File(zipFile), new java.io.File(destination));</span>

<span class="nc" id="L458">  }</span>

  /**
   * Extracts a zip file to a directory.
   *
   * @param zipFile
   *          A {@link java.io.File} with the path to the source zip archive
   * @param destination
   *          A {@link String} with the location where the zip archive will be extracted.
   * @throws IOException
   *           if the zip file cannot be read, the destination directory cannot be created or the extraction is not
   *           successful
   */
  public static void unzip(java.io.File zipFile, String destination) throws IOException {

<span class="pc bpc" id="L473" title="1 of 2 branches missed.">    if (destination == null) {</span>
<span class="fc" id="L474">      logger.error(&quot;Output filename cannot be null&quot;);</span>
<span class="fc" id="L475">      throw new IllegalArgumentException(&quot;Output filename cannot be null&quot;);</span>
    }

<span class="nc bnc" id="L478" title="All 2 branches missed.">    if (&quot;&quot;.equals(destination)) {</span>
<span class="nc" id="L479">      logger.error(&quot;Output filename cannot be empty&quot;);</span>
<span class="nc" id="L480">      throw new IllegalArgumentException(&quot;Output filename cannot be empty&quot;);</span>
    }

<span class="nc" id="L483">    unzip(zipFile, new java.io.File(destination));</span>

<span class="nc" id="L485">  }</span>

  /**
   * Extracts a zip file to a directory.
   *
   * @param zipFile
   *          A {@link String} with the path to the source zip archive
   * @param destination
   *          A {@link java.io.File} with the location where the zip archive will be extracted.
   * @throws IOException
   *           if the zip file cannot be read, the destination directory cannot be created or the extraction is not
   *           successful
   */
  public static void unzip(String zipFile, java.io.File destination) throws IOException {

<span class="fc bfc" id="L500" title="All 2 branches covered.">    if (zipFile == null) {</span>
<span class="fc" id="L501">      logger.error(&quot;Input filename cannot be null&quot;);</span>
<span class="fc" id="L502">      throw new IllegalArgumentException(&quot;Input filename cannot be null&quot;);</span>
    }

<span class="pc bpc" id="L505" title="1 of 2 branches missed.">    if (&quot;&quot;.equals(zipFile)) {</span>
<span class="fc" id="L506">      logger.error(&quot;Input filename cannot be empty&quot;);</span>
<span class="fc" id="L507">      throw new IllegalArgumentException(&quot;Input filename cannot be empty&quot;);</span>
    }

<span class="nc" id="L510">    unzip(new java.io.File(zipFile), destination);</span>

<span class="nc" id="L512">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>