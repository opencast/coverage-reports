<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>XMLCatalogImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.mediapackage</a> &gt; <span class="el_source">XMLCatalogImpl.java</span></div><h1>XMLCatalogImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.mediapackage;

import static com.entwinemedia.fn.Stream.$;
import static java.lang.String.format;
import static javax.xml.XMLConstants.DEFAULT_NS_PREFIX;
import static javax.xml.XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI;
import static javax.xml.XMLConstants.XMLNS_ATTRIBUTE;
import static javax.xml.XMLConstants.XML_NS_URI;
import static org.opencastproject.util.EqualsUtil.hash;

import org.opencastproject.util.RequireUtil;
import org.opencastproject.util.XmlNamespaceBinding;
import org.opencastproject.util.XmlNamespaceContext;
import org.opencastproject.util.XmlSafeParser;

import com.entwinemedia.fn.Fn;
import com.entwinemedia.fn.Fns;
import com.entwinemedia.fn.P2;
import com.entwinemedia.fn.fns.Booleans;

import org.apache.commons.lang3.StringUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.bootstrap.DOMImplementationRegistry;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSOutput;
import org.w3c.dom.ls.LSSerializer;
import org.xml.sax.Attributes;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

/**
 * This is a basic implementation for handling simple catalogs of metadata. It provides utility methods to store
 * key-value data.
 * &lt;p&gt;
 * For a definition of the terms &lt;dfn&gt;expanded name&lt;/dfn&gt;, &lt;dfn&gt;qualified name&lt;/dfn&gt; or &lt;dfn&gt;QName&lt;/dfn&gt;, &lt;dfn&gt;namespace
 * prefix&lt;/dfn&gt;, &lt;dfn&gt;local part&lt;/dfn&gt; and &lt;dfn&gt;local name&lt;/dfn&gt;, please see &lt;a
 * href=&quot;http://www.w3.org/TR/REC-xml-names&quot;&gt;http://www.w3.org/TR/REC-xml-names&lt;/a&gt;
 * &lt;p&gt;
 * By default the following namespace prefixes are bound:
 * &lt;ul&gt;
 * &lt;li&gt;xml - http://www.w3.org/XML/1998/namespace
 * &lt;li&gt;xmlns - http://www.w3.org/2000/xmlns/
 * &lt;li&gt;xsi - http://www.w3.org/2001/XMLSchema-instance
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;h2&gt;Limitations&lt;/h2&gt;
 * XMLCatalog supports only &lt;em&gt;one&lt;/em&gt; prefix binding per namespace name, so you cannot create documents like the
 * following using XMLCatalog:
 *
 * &lt;pre&gt;
 * &amp;lt;root xmlns:x=&amp;quot;http://x.demo.org&amp;quot; xmlns:y=&amp;quot;http://x.demo.org&amp;quot;&amp;gt;
 *   &amp;lt;x:elem&amp;gt;value&amp;lt;/x:elem&amp;gt;
 *   &amp;lt;y:elem&amp;gt;value&amp;lt;/y:elem&amp;gt;
 * &amp;lt;/root&amp;gt;
 * &lt;/pre&gt;
 *
 * However, reading of those documents is supported.
 */
public abstract class XMLCatalogImpl extends CatalogImpl implements XMLCatalog {
  private static final long serialVersionUID = -7580292199527168951L;

  /** Expanded name of the XML language attribute &lt;code&gt;xml:lang&lt;/code&gt;. */
<span class="fc" id="L103">  public static final EName XML_LANG_ATTR = new EName(XML_NS_URI, &quot;lang&quot;);</span>

  /** Namespace prefix for XML schema instance. */
  public static final String XSI_NS_PREFIX = &quot;xsi&quot;;

  /** To marshaling empty fields to remove existing values during merge, default is not to marshal empty elements */
<span class="fc" id="L109">  protected boolean includeEmpty = false;</span>

  /**
   * Expanded name of the XSI type attribute.
   * &lt;p&gt;
   * See &lt;a href=&quot;http://www.w3.org/TR/xmlschema-1/#xsi_type&quot;&gt;http://www.w3.org/TR/xmlschema-1/#xsi_type&lt;/a&gt; for the
   * definition.
   */
<span class="fc" id="L117">  public static final EName XSI_TYPE_ATTR = new EName(W3C_XML_SCHEMA_INSTANCE_NS_URI, &quot;type&quot;);</span>

  /** Key (QName) value meta data */
<span class="fc" id="L120">  protected final Map&lt;EName, List&lt;CatalogEntry&gt;&gt; data = new HashMap&lt;&gt;();</span>

  /** Namespace - prefix bindings */
  protected XmlNamespaceContext bindings;

  /**
   * Create an empty catalog and register the {@link javax.xml.XMLConstants#W3C_XML_SCHEMA_INSTANCE_NS_URI}
   * namespace.
   */
  protected XMLCatalogImpl() {
<span class="fc" id="L130">    super();</span>
<span class="fc" id="L131">    bindings = XmlNamespaceContext.mk(XSI_NS_PREFIX, W3C_XML_SCHEMA_INSTANCE_NS_URI);</span>
<span class="fc" id="L132">  }</span>

  protected void addBinding(XmlNamespaceBinding binding) {
<span class="nc" id="L135">    bindings = bindings.add(binding);</span>
<span class="nc" id="L136">  }</span>

  protected XmlNamespaceContext getBindings() {
<span class="nc" id="L139">    return bindings;</span>
  }

  /**
   * Clears the catalog.
   */
  protected void clear() {
<span class="nc" id="L146">    data.clear();</span>
<span class="nc" id="L147">  }</span>

  /**
   * Adds the element to the metadata collection.
   *
   * @param element
   *          the expanded name of the element
   * @param value
   *          the value
   */
  protected void addElement(EName element, String value) {
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">    if (element == null)</span>
<span class="nc" id="L159">      throw new IllegalArgumentException(&quot;Expanded name must not be null&quot;);</span>

<span class="fc" id="L161">    addElement(new CatalogEntry(element, value, NO_ATTRIBUTES));</span>
<span class="fc" id="L162">  }</span>

  /**
   * Adds the element with the &lt;code&gt;xml:lang&lt;/code&gt; attribute to the metadata collection.
   *
   * @param element
   *          the expanded name of the element
   * @param value
   *          the value
   * @param language
   *          the language identifier (two letter ISO 639)
   */
  protected void addLocalizedElement(EName element, String value, String language) {
<span class="fc" id="L175">    RequireUtil.notNull(element, &quot;expanded name&quot;);</span>
<span class="fc" id="L176">    RequireUtil.notNull(language, &quot;language&quot;);</span>

<span class="fc" id="L178">    Map&lt;EName, String&gt; attributes = new HashMap&lt;&gt;(1);</span>
<span class="fc" id="L179">    attributes.put(XML_LANG_ATTR, language);</span>
<span class="fc" id="L180">    addElement(new CatalogEntry(element, value, attributes));</span>
<span class="fc" id="L181">  }</span>

  /**
   * Adds the element with the &lt;code&gt;xsi:type&lt;/code&gt; attribute to the metadata collection.
   *
   * @param value
   *          the value
   * @param type
   *          the element type
   */
  protected void addTypedElement(EName element, String value, EName type) {
<span class="fc" id="L192">    RequireUtil.notNull(element, &quot;expanded name&quot;);</span>
<span class="fc" id="L193">    RequireUtil.notNull(type, &quot;type&quot;);</span>

<span class="fc" id="L195">    Map&lt;EName, String&gt; attributes = new HashMap&lt;&gt;(1);</span>
<span class="fc" id="L196">    attributes.put(XSI_TYPE_ATTR, toQName(type));</span>
<span class="fc" id="L197">    addElement(new CatalogEntry(element, value, attributes));</span>
<span class="fc" id="L198">  }</span>

  /**
   * Adds an element with the &lt;code&gt;xml:lang&lt;/code&gt; and &lt;code&gt;xsi:type&lt;/code&gt; attributes to the metadata collection.
   *
   * @param element
   *          the expanded name of the element
   * @param value
   *          the value
   * @param language
   *          the language identifier (two letter ISO 639)
   * @param type
   *          the element type
   */
  protected void addTypedLocalizedElement(EName element, String value, String language, EName type) {
<span class="nc bnc" id="L213" title="All 2 branches missed.">    if (element == null)</span>
<span class="nc" id="L214">      throw new IllegalArgumentException(&quot;EName name must not be null&quot;);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">    if (type == null)</span>
<span class="nc" id="L216">      throw new IllegalArgumentException(&quot;Type must not be null&quot;);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">    if (language == null)</span>
<span class="nc" id="L218">      throw new IllegalArgumentException(&quot;Language must not be null&quot;);</span>

<span class="nc" id="L220">    Map&lt;EName, String&gt; attributes = new HashMap&lt;&gt;(2);</span>
<span class="nc" id="L221">    attributes.put(XML_LANG_ATTR, language);</span>
<span class="nc" id="L222">    attributes.put(XSI_TYPE_ATTR, toQName(type));</span>
<span class="nc" id="L223">    addElement(new CatalogEntry(element, value, attributes));</span>
<span class="nc" id="L224">  }</span>

  /**
   * Adds an element with attributes to the catalog.
   *
   * @param element
   *          the expanded name of the element
   * @param value
   *          the element's value
   * @param attributes
   *          the attributes. May be null
   */
  protected void addElement(EName element, String value, Attributes attributes) {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">    if (element == null)</span>
<span class="nc" id="L238">      throw new IllegalArgumentException(&quot;Expanded name must not be null&quot;);</span>

<span class="fc" id="L240">    Map&lt;EName, String&gt; attributeMap = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">    if (attributes != null) {</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">      for (int i = 0; i &lt; attributes.getLength(); i++) {</span>
<span class="fc" id="L243">        attributeMap.put(new EName(attributes.getURI(i), attributes.getLocalName(i)), attributes.getValue(i));</span>
      }
    }
<span class="fc" id="L246">    addElement(new CatalogEntry(element, value, attributeMap));</span>
<span class="fc" id="L247">  }</span>

  /**
   * Adds the catalog element to the list of elements.
   *
   * @param element
   *          the element
   */
  private void addElement(CatalogEntry element) {

    // Option includeEmpty allows marshaling empty elements
    // for deleting existing values during a catalog merge
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">    if (element == null)</span>
<span class="nc" id="L260">      return;</span>
<span class="fc bfc" id="L261" title="All 4 branches covered.">    if (StringUtils.trimToNull(element.getValue()) == null &amp;&amp; !includeEmpty)</span>
<span class="fc" id="L262">      return;</span>
<span class="fc" id="L263">    List&lt;CatalogEntry&gt; values = data.get(element.getEName());</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">    if (values == null) {</span>
<span class="fc" id="L265">      values = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L266">      data.put(element.getEName(), values);</span>
    }
<span class="fc" id="L268">    values.add(element);</span>
<span class="fc" id="L269">  }</span>

  /**
   * Completely removes an element.
   *
   * @param element
   *          the expanded name of the element
   */
  protected void removeElement(EName element) {
<span class="fc" id="L278">    removeValues(element, null, true);</span>
<span class="fc" id="L279">  }</span>

  /**
   * Removes all entries in a certain language from an element.
   *
   * @param element
   *          the expanded name of the element
   * @param language
   *          the language code (two letter ISO 639) or null to &lt;em&gt;only&lt;/em&gt; remove entries without an
   *          &lt;code&gt;xml:lang&lt;/code&gt; attribute
   */
  protected void removeLocalizedValues(EName element, String language) {
<span class="fc" id="L291">    removeValues(element, language, false);</span>
<span class="fc" id="L292">  }</span>

  /**
   * Removes values from an element or the complete element from the catalog.
   *
   * @param element
   *          the expanded name of the element
   * @param language
   *          the language code (two letter ISO 639) to remove or null to remove entries without language code
   * @param all
   *          true - remove all entries for that element. This parameter overrides the language parameter.
   */
  private void removeValues(EName element, String language, boolean all) {
<span class="fc bfc" id="L305" title="All 2 branches covered.">    if (all) {</span>
<span class="fc" id="L306">      data.remove(element);</span>
    } else {
<span class="fc" id="L308">      List&lt;CatalogEntry&gt; entries = data.get(element);</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">      if (entries != null) {</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        for (Iterator&lt;CatalogEntry&gt; i = entries.iterator(); i.hasNext();) {</span>
<span class="fc" id="L311">          CatalogEntry entry = i.next();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">          if (equal(language, entry.getAttribute(XML_LANG_ATTR))) {</span>
<span class="fc" id="L313">            i.remove();</span>
          }
<span class="fc" id="L315">        }</span>
      }
    }
<span class="fc" id="L318">  }</span>

  /**
   * Returns the values that are associated with the specified key.
   *
   * @param element
   *          the expanded name of the element
   * @return the elements
   */
  protected CatalogEntry[] getValues(EName element) {
<span class="fc" id="L328">    List&lt;CatalogEntry&gt; values = data.get(element);</span>
<span class="pc bpc" id="L329" title="2 of 4 branches missed.">    if (values != null &amp;&amp; values.size() &gt; 0) {</span>
<span class="fc" id="L330">      return values.toArray(new CatalogEntry[values.size()]);</span>
    }
<span class="nc" id="L332">    return new CatalogEntry[] {};</span>
  }

  protected List&lt;CatalogEntry&gt; getEntriesSorted() {
<span class="fc" id="L336">    return $(data.values())</span>
<span class="fc" id="L337">        .bind(Fns.&lt;List&lt;CatalogEntry&gt;&gt;id())</span>
<span class="fc" id="L338">        .sort(catalogEntryComparator)</span>
<span class="fc" id="L339">        .toList();</span>
  }

  /**
   * Returns the values that are associated with the specified key.
   *
   * @param element
   *          the expanded name of the element
   * @return all values of the element or an empty list if this element does not exist or does not have any values
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  protected List&lt;CatalogEntry&gt; getValuesAsList(EName element) {
<span class="fc" id="L351">    List&lt;CatalogEntry&gt; values = data.get(element);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">    return values != null ? values : Collections.EMPTY_LIST;</span>
  }

  /**
   * Returns the values that are associated with the specified key.
   *
   * @param element
   *          the expandend name of the element
   * @param language
   *          a language code or null to get values without &lt;code&gt;xml:lang&lt;/code&gt; attribute
   * @return all values of the element
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  protected List&lt;CatalogEntry&gt; getLocalizedValuesAsList(EName element, String language) {
<span class="fc" id="L366">    List&lt;CatalogEntry&gt; values = data.get(element);</span>

<span class="pc bpc" id="L368" title="1 of 2 branches missed.">    if (values != null) {</span>
<span class="fc" id="L369">      List&lt;CatalogEntry&gt; filtered = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">      for (CatalogEntry value : values) {</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">        if (equal(language, value.getAttribute(XML_LANG_ATTR))) {</span>
<span class="fc" id="L372">          filtered.add(value);</span>
        }
<span class="fc" id="L374">      }</span>
<span class="fc" id="L375">      return filtered;</span>
    } else {
<span class="nc" id="L377">      return Collections.EMPTY_LIST;</span>
    }
  }

  /**
   * Returns the first value that is associated with the specified name.
   *
   * @param element
   *          the expanded name of the element
   * @return the first value
   */
  protected CatalogEntry getFirstValue(EName element) {
<span class="nc" id="L389">    List&lt;CatalogEntry&gt; elements = data.get(element);</span>
<span class="nc bnc" id="L390" title="All 4 branches missed.">    if (elements != null &amp;&amp; elements.size() &gt; 0) {</span>
<span class="nc" id="L391">      return elements.get(0);</span>
    }
<span class="nc" id="L393">    return null;</span>
  }

  /**
   * Returns the first element that is associated with the specified name and attribute.
   *
   * @param element
   *          the expanded name of the element
   * @param attributeEName
   *          the expanded attribute name
   * @param attributeValue
   *          the attribute value
   * @return the first value
   */
  protected CatalogEntry getFirstValue(EName element, EName attributeEName, String attributeValue) {
<span class="fc" id="L408">    List&lt;CatalogEntry&gt; elements = data.get(element);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">    if (elements != null) {</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">      for (CatalogEntry entry : elements) {</span>
<span class="fc" id="L411">        String v = entry.getAttribute(attributeEName);</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if (equal(attributeValue, v))</span>
<span class="fc" id="L413">          return entry;</span>
<span class="fc" id="L414">      }</span>
    }
<span class="fc" id="L416">    return null;</span>
  }

  /**
   * Returns the first value that is associated with the specified name and language.
   *
   * @param element
   *          the expanded name of the element
   * @param language
   *          the language identifier or null to get only elements without &lt;code&gt;xml:lang&lt;/code&gt; attribute
   * @return the first value
   */
  protected CatalogEntry getFirstLocalizedValue(EName element, String language) {
<span class="fc" id="L429">    return getFirstValue(element, XML_LANG_ATTR, language);</span>
  }

  /**
   * Returns the first value that is associated with the specified name and language.
   *
   * @param element
   *          the expanded name of the element
   * @param type
   *          the &lt;code&gt;xsi:type&lt;/code&gt; value
   * @return the element
   */
  protected CatalogEntry getFirstTypedValue(EName element, String type) {
<span class="nc" id="L442">    return getFirstValue(element, XSI_TYPE_ATTR, type);</span>
  }

  /**
   * Tests two objects for equality.
   */
  protected boolean equal(Object a, Object b) {
<span class="fc bfc" id="L449" title="All 8 branches covered.">    return (a == null &amp;&amp; b == null) || (a != null &amp;&amp; a.equals(b));</span>
  }

  /**
   * Creates an xml document root and returns it.
   *
   * @return the document
   * @throws ParserConfigurationException
   *           If the xml parser environment is not correctly configured
   */
  protected Document newDocument() throws ParserConfigurationException {
<span class="nc" id="L460">    DocumentBuilderFactory docBuilderFactory = XmlSafeParser.newDocumentBuilderFactory();</span>
<span class="nc" id="L461">    docBuilderFactory.setNamespaceAware(true);</span>
<span class="nc" id="L462">    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();</span>
<span class="nc" id="L463">    return docBuilder.newDocument();</span>
  }

  /**
   * @see org.opencastproject.mediapackage.AbstractMediaPackageElement#toManifest(org.w3c.dom.Document,
   *      org.opencastproject.mediapackage.MediaPackageSerializer)
   */
  @Override
  public Node toManifest(Document document, MediaPackageSerializer serializer) throws MediaPackageException {
<span class="nc" id="L472">    return super.toManifest(document, serializer);</span>
  }

  /**
   * Get a prefix from {@link #bindings} but throw a {@link NamespaceBindingException} if none found.
   */
  protected String getPrefix(String namespaceURI) {
<span class="fc" id="L479">    final String prefix = bindings.getPrefix(namespaceURI);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">    if (prefix != null) {</span>
<span class="fc" id="L481">      return prefix;</span>
    } else {
<span class="fc" id="L483">      throw new NamespaceBindingException(format(&quot;Namespace URI %s is not bound to a prefix&quot;, namespaceURI));</span>
    }
  }

  /**
   * @see org.opencastproject.mediapackage.XMLCatalog#includeEmpty(boolean)
   */
  @Override
  public
  void includeEmpty(boolean includeEmpty) {
<span class="fc" id="L493">    this.includeEmpty = includeEmpty;</span>
<span class="fc" id="L494">  }</span>

  /**
   * Transform an expanded name to a qualified name based on the registered binding.
   *
   * @param eName
   *          the expanded name to transform
   * @return the qualified name, e.g. &lt;code&gt;dcterms:title&lt;/code&gt;
   * @throws NamespaceBindingException
   *           if the namespace name is not bound to a prefix
   */
  protected String toQName(EName eName) {
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">    if (eName.hasNamespace()) {</span>
<span class="fc" id="L507">      return toQName(getPrefix(eName.getNamespaceURI()), eName.getLocalName());</span>
    } else {
<span class="nc" id="L509">      return eName.getLocalName();</span>
    }
  }

  /**
   * Transform an qualified name consisting of prefix and local part to an expanded name, based on the registered
   * binding.
   *
   * @param prefix
   *          the prefix
   * @param localName
   *          the local part
   * @return the expanded name
   * @throws NamespaceBindingException
   *           if the namespace name is not bound to a prefix
   */
  protected EName toEName(String prefix, String localName) {
<span class="nc" id="L526">    return new EName(bindings.getNamespaceURI(prefix), localName);</span>
  }

  /**
   * Transform a qualified name to an expanded name, based on the registered binding.
   *
   * @param qName
   *          the qualified name, e.g. &lt;code&gt;dcterms:title&lt;/code&gt; or &lt;code&gt;title&lt;/code&gt;
   * @return the expanded name
   * @throws NamespaceBindingException
   *           if the namespace name is not bound to a prefix
   */
  protected EName toEName(String qName) {
<span class="fc" id="L539">    String[] parts = splitQName(qName);</span>
<span class="fc" id="L540">    return new EName(bindings.getNamespaceURI(parts[0]), parts[1]);</span>
  }

  /**
   * Splits a QName into its parts.
   *
   * @param qName
   *          the qname to split
   * @return an array of prefix (0) and local part (1). The prefix is &quot;&quot; if the qname belongs to the default namespace.
   */
  private static String[] splitQName(String qName) {
<span class="fc" id="L551">    final String[] parts = qName.split(&quot;:&quot;, 3);</span>
<span class="pc bpc" id="L552" title="1 of 3 branches missed.">    switch (parts.length) {</span>
      case 1:
<span class="fc" id="L554">        return new String[] { DEFAULT_NS_PREFIX, parts[0] };</span>
      case 2:
<span class="fc" id="L556">        return parts;</span>
      default:
<span class="nc" id="L558">        throw new IllegalArgumentException(&quot;Local name must not contain ':'&quot;);</span>
    }
  }

  /**
   * Returns a &quot;prefixed name&quot; consisting of namespace prefix and local name.
   *
   * @param prefix
   *          the namespace prefix, may be &lt;code&gt;null&lt;/code&gt;
   * @param localName
   *          the local name
   * @return the &quot;prefixed name&quot; &lt;code&gt;prefix:localName&lt;/code&gt;
   */
  private static String toQName(String prefix, String localName) {
<span class="fc" id="L572">    final StringBuilder b = new StringBuilder();</span>
<span class="pc bpc" id="L573" title="1 of 4 branches missed.">    if (prefix != null &amp;&amp; !DEFAULT_NS_PREFIX.equals(prefix)) {</span>
<span class="fc" id="L574">      b.append(prefix);</span>
<span class="fc" id="L575">      b.append(&quot;:&quot;);</span>
    }
<span class="fc" id="L577">    b.append(localName);</span>
<span class="fc" id="L578">    return b.toString();</span>
  }

  // --------------------------------------------------------------------------------------------

<span class="fc" id="L583">  private static final Map&lt;EName, String&gt; NO_ATTRIBUTES = new HashMap&lt;&gt;();</span>

  CatalogEntry mkCatalogEntry(EName name, String value, Map&lt;EName, String&gt; attributes) {
<span class="fc" id="L586">    return new CatalogEntry(name, value, attributes);</span>
  }

  /**
   * Element representation.
   */
  public final class CatalogEntry implements XmlElement, Comparable&lt;CatalogEntry&gt;, Serializable {

    /** The serial version UID */
    private static final long serialVersionUID = 7195298081966562710L;

    private final EName name;

    private final String value;

    /** The attributes of this element */
    private final Map&lt;EName, String&gt; attributes;

    /**
     * Creates a new catalog element representation with name, value and attributes.
     *
     * @param value
     *          the element value
     * @param attributes
     *          the element attributes
     */
<span class="fc" id="L612">    public CatalogEntry(EName name, String value, Map&lt;EName, String&gt; attributes) {</span>
<span class="fc" id="L613">      this.name = name;</span>
<span class="fc" id="L614">      this.value = value;</span>
<span class="fc" id="L615">      this.attributes = new HashMap&lt;&gt;(attributes);</span>
<span class="fc" id="L616">    }</span>

    /**
     * Returns the qualified name of the entry as a string. The namespace of the entry has to be bound to a prefix for
     * this method to succeed.
     */
    public String getQName() {
<span class="nc" id="L623">      return toQName(name);</span>
    }

    /**
     * Returns the expanded name of the entry.
     */
    public EName getEName() {
<span class="fc" id="L630">      return name;</span>
    }

    /**
     * Returns the element value.
     *
     * @return the value
     */
    public String getValue() {
<span class="fc" id="L639">      return value;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the element contains attributes.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the element contains attributes
     */
    public boolean hasAttributes() {
<span class="nc bnc" id="L648" title="All 2 branches missed.">      return attributes.size() &gt; 0;</span>
    }

    /**
     * Returns the element's attributes.
     *
     * @return the attributes
     */
    public Map&lt;EName, String&gt; getAttributes() {
<span class="fc" id="L657">      return Collections.unmodifiableMap(attributes);</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the element contains an attribute with the given name.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the element contains the attribute
     */
    public boolean hasAttribute(EName name) {
<span class="fc" id="L666">      return attributes.containsKey(name);</span>
    }

    /**
     * Returns the attribute value for the given attribute.
     *
     * @return the attribute or null
     */
    public String getAttribute(EName name) {
<span class="fc" id="L675">      return attributes.get(name);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L680">      return hash(name, value);</span>
    }

    @Override
    public boolean equals(Object that) {
<span class="pc bpc" id="L685" title="2 of 6 branches missed.">      return (this == that) || (that instanceof CatalogEntry &amp;&amp; eqFields((CatalogEntry) that));</span>
    }

    private boolean eqFields(CatalogEntry that) {
<span class="fc bfc" id="L689" title="All 2 branches covered.">      return this.compareTo(that) == 0;</span>
    }

    /**
     * Returns the XML representation of this entry.
     *
     * @param document
     *          the document
     * @return the xml node
     */
    @Override
    public Node toXml(Document document) {
<span class="fc" id="L701">      Element node = document.createElement(toQName(name));</span>
      // Write prefix binding to document root element
<span class="fc" id="L703">      bindNamespaceFor(document, name);</span>

<span class="fc" id="L705">      List&lt;EName&gt; keySet = new ArrayList&lt;&gt;(attributes.keySet());</span>
<span class="fc" id="L706">      Collections.sort(keySet);</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">      for (EName attrEName : keySet) {</span>
<span class="fc" id="L708">        String value = attributes.get(attrEName);</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">        if (attrEName.hasNamespace()) {</span>
          // Write prefix binding to document root element
<span class="fc" id="L711">          bindNamespaceFor(document, attrEName);</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">          if (XSI_TYPE_ATTR.equals(attrEName)) {</span>
            // Special treatment for xsi:type attributes
            try {
<span class="fc" id="L715">              EName typeName = toEName(value);</span>
<span class="fc" id="L716">              bindNamespaceFor(document, typeName);</span>
<span class="nc" id="L717">            } catch (NamespaceBindingException ignore) {</span>
              // Type is either not a QName or its namespace is not bound.
              // We decide to gently ignore those cases.
<span class="fc" id="L720">            }</span>
          }
        }
<span class="fc" id="L723">        node.setAttribute(toQName(attrEName), value);</span>
<span class="fc" id="L724">      }</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">      if (value != null) {</span>
<span class="fc" id="L726">        node.appendChild(document.createTextNode(value));</span>
      }
<span class="fc" id="L728">      return node;</span>
    }

    /**
     * Compare two catalog entries. Comparison order:
     * - e_name
     * - number of attributes (less come first)
     * - attribute comparison (e_name -&amp;gt; value)
     */
    @Override
    public int compareTo(CatalogEntry o) {
      int c;
<span class="fc" id="L740">      c = getEName().compareTo(o.getEName());</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">      if (c != 0) {</span>
<span class="fc" id="L742">        return c;</span>
      } else { // compare attributes
<span class="fc" id="L744">        c = attributes.size() - o.attributes.size();</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">        if (c != 0) {</span>
<span class="fc" id="L746">          return c;</span>
        } else {
<span class="fc" id="L748">          return $(attributes.entrySet()).sort(attributeComparator)</span>
<span class="fc" id="L749">              .zip($(o.attributes.entrySet()).sort(attributeComparator))</span>
<span class="fc" id="L750">              .map(new Fn&lt;P2&lt;Entry&lt;EName, String&gt;, Entry&lt;EName, String&gt;&gt;, Integer&gt;() {</span>
                @Override public Integer apply(P2&lt;Entry&lt;EName, String&gt;, Entry&lt;EName, String&gt;&gt; as) {
<span class="fc" id="L752">                  return attributeComparator.compare(as.get1(), as.get2());</span>
                }
              })
<span class="fc" id="L755">              .find(Booleans.ne(0))</span>
<span class="fc" id="L756">              .getOr(0);</span>
        }
      }
    }

    /**
     * Writes a namespace binding for catalog entry &lt;code&gt;name&lt;/code&gt; to the documents root element.
     * &lt;code&gt;xmlns:prefix=&quot;namespace&quot;&lt;/code&gt;
     */
    private void bindNamespaceFor(Document document, EName name) {
<span class="fc" id="L766">      Element root = (Element) document.getFirstChild();</span>
<span class="fc" id="L767">      String namespace = name.getNamespaceURI();</span>
      // Do not bind the &quot;xml&quot; namespace. It is bound by default
<span class="fc bfc" id="L769" title="All 2 branches covered.">      if (!XML_NS_URI.equals(namespace)) {</span>
<span class="fc" id="L770">        root.setAttribute(XMLNS_ATTRIBUTE + &quot;:&quot; + XMLCatalogImpl.this.getPrefix(name.getNamespaceURI()),</span>
<span class="fc" id="L771">                name.getNamespaceURI());</span>
      }
<span class="fc" id="L773">    }</span>

    @Override
    public String toString() {
<span class="fc" id="L777">      return value;</span>
    }
  }

  static int doCompareTo(EName k1, String v1, EName k2, String v2) {
<span class="fc" id="L782">    final int c = k1.compareTo(k2);</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">    return c != 0 ? c : v1.compareTo(v2);</span>
  }

<span class="fc" id="L786">  private static final Comparator&lt;Map.Entry&lt;EName, String&gt;&gt; attributeComparator =</span>
<span class="fc" id="L787">      new Comparator&lt;Map.Entry&lt;EName, String&gt;&gt;() {</span>
        @Override public int compare(Entry&lt;EName, String&gt; o1, Entry&lt;EName, String&gt; o2) {
<span class="fc" id="L789">          return doCompareTo(o1.getKey(), o1.getValue(), o2.getKey(), o2.getValue());</span>
        }
      };

<span class="fc" id="L793">  private static final Comparator&lt;CatalogEntry&gt; catalogEntryComparator =</span>
<span class="fc" id="L794">      new Comparator&lt;CatalogEntry&gt;() {</span>
        @Override public int compare(CatalogEntry o1, CatalogEntry o2) {
<span class="fc" id="L796">          return o1.compareTo(o2);</span>
        }
      };

  // --------------------------------------------------------------------------------------------

  // --

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.mediapackage.XMLCatalog#toXml(java.io.OutputStream, boolean)
   */
  @Override
  public void toXml(OutputStream out, boolean format) throws IOException {
    try {
<span class="fc" id="L812">      Document doc = this.toXml();</span>
<span class="fc" id="L813">      DOMImplementationRegistry reg = DOMImplementationRegistry.newInstance();</span>
<span class="fc" id="L814">      DOMImplementationLS impl = (DOMImplementationLS) reg.getDOMImplementation(&quot;LS&quot;);</span>
<span class="fc" id="L815">      LSSerializer serializer = impl.createLSSerializer();</span>
<span class="fc" id="L816">      serializer.getDomConfig().setParameter(&quot;format-pretty-print&quot;, format);</span>
<span class="fc" id="L817">      LSOutput output = impl.createLSOutput();</span>
<span class="fc" id="L818">      output.setByteStream(out);</span>
<span class="fc" id="L819">      serializer.write(doc, output);</span>
<span class="nc" id="L820">    } catch (ParserConfigurationException e) {</span>
<span class="nc" id="L821">      throw new IOException(&quot;unable to parse document&quot;);</span>
<span class="nc" id="L822">    } catch (TransformerException e) {</span>
<span class="nc" id="L823">      throw new IOException(&quot;unable to transform dom to a stream&quot;);</span>
<span class="nc" id="L824">    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {</span>
<span class="nc" id="L825">      throw new IOException(&quot;unable to serialize DOM&quot;);</span>
<span class="fc" id="L826">    }</span>
<span class="fc" id="L827">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.mediapackage.XMLCatalog#toXmlString()
   */
  @Override
  public String toXmlString() throws IOException {
<span class="fc" id="L836">    ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
<span class="fc" id="L837">    toXml(out, true);</span>
<span class="fc" id="L838">    return new String(out.toByteArray(), StandardCharsets.UTF_8);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>