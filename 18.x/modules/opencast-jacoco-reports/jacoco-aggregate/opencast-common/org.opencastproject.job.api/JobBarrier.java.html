<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>JobBarrier.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.job.api</a> &gt; <span class="el_source">JobBarrier.java</span></div><h1>JobBarrier.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.job.api;

import org.opencastproject.job.api.Job.Status;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.util.JobCanceledException;
import org.opencastproject.util.NotFoundException;

import com.entwinemedia.fn.data.Opt;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This class is a utility implementation that will wait for all given jobs to change their status to either one of:
 * &lt;ul&gt;
 * &lt;li&gt;{@link Job.Status#FINISHED}&lt;/li&gt;
 * &lt;li&gt;{@link Job.Status#FAILED}&lt;/li&gt;
 * &lt;li&gt;{@link Job.Status#DELETED}&lt;/li&gt;
 * &lt;/ul&gt;
 */
public final class JobBarrier {
  /** The logging facility */
<span class="fc" id="L51">  private static final Logger logger = LoggerFactory.getLogger(JobBarrier.class);</span>

  /** Default polling interval is 5 seconds */
  public static final long DEFAULT_POLLING_INTERVAL = 5000L;

  /** The service registry used to do the polling */
  private final ServiceRegistry serviceRegistry;

  /** Time in milliseconds between two pools for the job status */
  private final long pollingInterval;

  /** The job that's waiting */
  private final Opt&lt;Long&gt; waiterJobId;

  /** The jobs to wait on */
  private final List&lt;Job&gt; jobs;

  /** An exception that might have been thrown while polling */
<span class="fc" id="L69">  private volatile Throwable pollingException = null;</span>

  /** The status map */
<span class="fc" id="L72">  private volatile Result status = null;</span>

  /**
   * Creates a barrier without any jobs, using &lt;code&gt;registry&lt;/code&gt; to poll for the outcome of the monitored jobs using
   * the default polling interval {@link #DEFAULT_POLLING_INTERVAL}. The &lt;code&gt;waiter&lt;/code&gt; is the job which is waiting
   * for the other jobs to finish. Use {@link #addJob(Job)} to add jobs to monitor.
   *
   * @param registry
   *          the registry
   * @param waiter
   *          the job waiting for the other jobs to finish
   */
  public JobBarrier(Job waiter, ServiceRegistry registry) {
<span class="nc" id="L85">    this(waiter, registry, DEFAULT_POLLING_INTERVAL, new Job[] {});</span>
<span class="nc" id="L86">  }</span>

  /**
   * Creates a barrier for &lt;code&gt;jobs&lt;/code&gt;, using &lt;code&gt;registry&lt;/code&gt; to poll for the outcome of the monitored jobs
   * using the default polling interval {@link #DEFAULT_POLLING_INTERVAL}. The &lt;code&gt;waiter&lt;/code&gt; is the job which is
   * waiting for the other jobs to finish.
   *
   * @param registry
   *          the registry
   * @param jobs
   *          the jobs to monitor
   * @param waiter
   *          the job waiting for the other jobs to finish
   */
  public JobBarrier(Job waiter, ServiceRegistry registry, Job... jobs) {
<span class="fc" id="L101">    this(waiter, registry, DEFAULT_POLLING_INTERVAL, jobs);</span>
<span class="fc" id="L102">  }</span>

  /**
   * Creates a wrapper for &lt;code&gt;job&lt;/code&gt;, using &lt;code&gt;registry&lt;/code&gt; to poll for the job outcome. The
   * &lt;code&gt;waiter&lt;/code&gt; is the job which is waiting for the other jobs to finish.
   *
   * @param registry
   *          the registry
   * @param pollingInterval
   *          the time in miliseconds between two polling operations
   * @param waiter
   *          the job waiting for the other jobs to finish
   */
  public JobBarrier(Job waiter, ServiceRegistry registry, long pollingInterval) {
<span class="nc" id="L116">    this(waiter, registry, pollingInterval, new Job[] {});</span>
<span class="nc" id="L117">  }</span>

  /**
   * Creates a wrapper for &lt;code&gt;job&lt;/code&gt;, using &lt;code&gt;registry&lt;/code&gt; to poll for the job outcome. The
   * &lt;code&gt;waiter&lt;/code&gt; is the job which is waiting for the other jobs to finish.
   *
   * @param jobs
   *          the job to poll
   * @param registry
   *          the registry
   * @param pollingInterval
   *          the time in miliseconds between two polling operations
   * @param waiter
   *          the job waiting for the other jobs to finish
   */
<span class="fc" id="L132">  public JobBarrier(Job waiter, ServiceRegistry registry, long pollingInterval, Job... jobs) {</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">    if (registry == null)</span>
<span class="nc" id="L134">      throw new IllegalArgumentException(&quot;Service registry must not be null&quot;);</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">    if (jobs == null)</span>
<span class="nc" id="L136">      throw new IllegalArgumentException(&quot;Jobs must not be null&quot;);</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">    if (pollingInterval &lt; 0)</span>
<span class="nc" id="L138">      throw new IllegalArgumentException(&quot;Polling interval must be a positive number&quot;);</span>
<span class="fc" id="L139">    this.serviceRegistry = registry;</span>
<span class="fc" id="L140">    this.pollingInterval = pollingInterval;</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (waiter != null)</span>
<span class="fc" id="L142">      this.waiterJobId = Opt.some(waiter.getId());</span>
    else
<span class="fc" id="L144">      this.waiterJobId = Opt.none();</span>
<span class="fc" id="L145">    this.jobs = new ArrayList&lt;Job&gt;(Arrays.asList(jobs));</span>
<span class="fc" id="L146">  }</span>

  private void suspendWaiterJob() {
<span class="fc bfc" id="L149" title="All 2 branches covered.">    if (this.waiterJobId.isSome()) {</span>
      try {
<span class="fc" id="L151">        final Job waiter = serviceRegistry.getJob(waiterJobId.get());</span>
<span class="fc" id="L152">        waiter.setStatus(Job.Status.WAITING);</span>
<span class="fc" id="L153">        logger.debug(&quot;Job {} set to WAITING state.&quot;, waiter.getId());</span>
<span class="fc" id="L154">        this.serviceRegistry.updateJob(waiter);</span>
<span class="nc" id="L155">      } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L156">        logger.warn(&quot;Unable to put {} into a waiting state, this may cause a deadlock: {}&quot;, waiterJobId, e.getMessage());</span>
<span class="nc" id="L157">      } catch (NotFoundException e) {</span>
<span class="nc" id="L158">        logger.warn(&quot;Unable to put {} into a waiting state, job not found by the service registry.  This may cause a deadlock: {}&quot;, waiterJobId, e.getMessage());</span>
<span class="pc" id="L159">      }</span>
    } else {
<span class="fc" id="L161">      logger.debug(&quot;No waiting job set, unable to put waiting job into waiting state&quot;);</span>
    }
<span class="fc" id="L163">  }</span>

  private void wakeWaiterJob() {
<span class="fc bfc" id="L166" title="All 2 branches covered.">    if (this.waiterJobId.isSome()) {</span>
      try {
<span class="fc" id="L168">        final Job waiter = serviceRegistry.getJob(waiterJobId.get());</span>
<span class="fc" id="L169">        waiter.setStatus(Job.Status.RUNNING);</span>
<span class="fc" id="L170">        logger.debug(&quot;Job {} wakened and set back to RUNNING state.&quot;, waiter.getId());</span>
<span class="fc" id="L171">        this.serviceRegistry.updateJob(waiter);</span>
<span class="nc" id="L172">      } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L173">        logger.warn(&quot;Unable to put {} into a waiting state, this may cause a deadlock: {}&quot;, waiterJobId, e.getMessage());</span>
<span class="nc" id="L174">      } catch (NotFoundException e) {</span>
<span class="nc" id="L175">        logger.warn(&quot;Unable to put {} into a waiting state, job not found by the service registry.  This may cause a deadlock: {}&quot;, waiterJobId, e.getMessage());</span>
<span class="pc" id="L176">      }</span>
    } else {
<span class="fc" id="L178">      logger.debug(&quot;No waiting job set, unable to put waiting job into waiting state&quot;);</span>
    }
<span class="fc" id="L180">  }</span>

  /**
   * Waits for a status change and returns the new status.
   *
   * @return the status
   */
  public Result waitForJobs() {
<span class="fc" id="L188">    return waitForJobs(0);</span>
  }

  /**
   * Waits for a status change on all jobs and returns. If waiting for the status exceeds a certain limit, the method
   * returns even if some or all of the jobs are not yet finished. The same is true if at least one of the jobs fails or
   * gets stopped or deleted.
   *
   * @param timeout
   *          the maximum amount of time to wait
   * @throws IllegalStateException
   *           if there are no jobs to wait for
   * @throws JobCanceledException
   *           if one of the jobs was canceled
   */
  public Result waitForJobs(long timeout) throws JobCanceledException, IllegalStateException {
<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (jobs.size() == 0)</span>
<span class="fc" id="L205">      return new Result(new HashMap&lt;Job, Status&gt;());</span>
<span class="fc" id="L206">    this.suspendWaiterJob();</span>
<span class="fc" id="L207">    synchronized (this) {</span>
<span class="fc" id="L208">      JobStatusUpdater updater = new JobStatusUpdater(timeout);</span>
      try {
<span class="fc" id="L210">        updater.start();</span>
<span class="fc" id="L211">        wait();</span>
<span class="nc" id="L212">      } catch (InterruptedException e) {</span>
<span class="nc" id="L213">        logger.debug(&quot;Interrupted while waiting for job&quot;);</span>
<span class="fc" id="L214">      }</span>
<span class="fc" id="L215">    }</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">    if (pollingException != null) {</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">      if (pollingException instanceof JobCanceledException)</span>
<span class="nc" id="L218">        throw (JobCanceledException) pollingException;</span>
<span class="fc" id="L219">      throw new IllegalStateException(pollingException);</span>
    }
<span class="fc" id="L221">    this.wakeWaiterJob();</span>
<span class="fc" id="L222">    return getStatus();</span>
  }

  /**
   * Adds the job to the list of jobs to wait for. An {@link IllegalStateException} is thrown if the barrier has already
   * been asked to wait for jobs by calling {@link #waitForJobs()}.
   *
   * @param job
   *          the job
   * @throws IllegalStateException
   *           if the barrier already started waiting
   */
  public void addJob(Job job) throws IllegalStateException {
<span class="nc bnc" id="L235" title="All 2 branches missed.">    if (job == null)</span>
<span class="nc" id="L236">      throw new IllegalArgumentException(&quot;Job must not be null&quot;);</span>
<span class="nc" id="L237">    jobs.add(job);</span>
<span class="nc" id="L238">  }</span>

  /**
   * Sets the outcome of the various jobs that were monitored.
   *
   * @param status
   *          the status
   */
  void setStatus(Result status) {
<span class="fc" id="L247">    this.status = status;</span>
<span class="fc" id="L248">  }</span>

  /**
   * Returns the resulting status map.
   *
   * @return the status of the individual jobs
   */
  public Result getStatus() {
<span class="fc" id="L256">    return status;</span>
  }

  /** Thread that keeps polling for status changes. */
  class JobStatusUpdater extends Thread {
    /** Maximum wait in milliseconds or 0 for unlimited waiting */
    private final long workTime;

    /**
     * Creates a new status updater that will wait for finished jobs. If &lt;code&gt;0&lt;/code&gt; is passed in as the work time,
     * the updater will wait as long as it takes. Otherwise, it will stop after the indicated amount of time has passed.
     *
     * @param workTime
     *          the work time
     */
<span class="fc" id="L271">    JobStatusUpdater(long workTime) {</span>
<span class="fc" id="L272">      this.workTime = workTime;</span>
<span class="fc" id="L273">    }</span>

    @Override
    public void run() {
<span class="fc bfc" id="L277" title="All 2 branches covered.">      final long endTime = workTime &gt; 0 ? System.currentTimeMillis() + workTime : 0;</span>
<span class="fc" id="L278">      final Map&lt;Job, Job.Status&gt; finishedJobs = new HashMap&lt;Job, Job.Status&gt;();</span>
      while (true) {
<span class="fc" id="L280">        final long time = System.currentTimeMillis();</span>
        // Wait a little..
        try {
<span class="fc" id="L283">          final long timeToSleep = Math.min(pollingInterval, Math.abs(endTime - time));</span>
<span class="fc" id="L284">          Thread.sleep(timeToSleep);</span>
<span class="nc" id="L285">        } catch (InterruptedException e) {</span>
<span class="nc" id="L286">          logger.debug(&quot;Job polling thread was interrupted&quot;);</span>
<span class="nc" id="L287">          return;</span>
<span class="fc" id="L288">        }</span>
        // Look at all jobs and make sure all of them have reached the expected status
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (final Job job : jobs) {</span>
          // Don't ask if we already know
<span class="fc bfc" id="L292" title="All 2 branches covered.">          if (!finishedJobs.containsKey(job)) {</span>
            // Get the job status from the service registry
            try {
<span class="fc" id="L295">              final Job processedJob = serviceRegistry.getJob(job.getId());</span>
<span class="fc" id="L296">              final Job.Status jobStatus = processedJob.getStatus();</span>
<span class="pc bpc" id="L297" title="3 of 5 branches missed.">              switch (jobStatus) {</span>
                case CANCELLED:
<span class="nc" id="L299">                  throw new JobCanceledException(processedJob);</span>
                case DELETED:
                case FAILED:
                case FINISHED:
<span class="fc" id="L303">                  job.setStatus(jobStatus);</span>
<span class="fc" id="L304">                  job.setPayload(processedJob.getPayload());</span>
<span class="fc" id="L305">                  finishedJobs.put(job, jobStatus);</span>
<span class="fc" id="L306">                  break;</span>
                case PAUSED:
                case QUEUED:
                case RESTART:
                case DISPATCHING:
                case INSTANTIATED:
                case RUNNING:
<span class="fc" id="L313">                  logger.trace(&quot;{} is still in the works&quot;, job);</span>
<span class="fc" id="L314">                  break;</span>
                case WAITING:
<span class="nc" id="L316">                  logger.trace(&quot;{} is waiting&quot;, job);</span>
<span class="nc" id="L317">                  break;</span>
                default:
<span class="nc" id="L319">                  logger.error(&quot;Unhandled job status '{}' found&quot;, jobStatus);</span>
                  break;
              }
<span class="nc" id="L322">            } catch (NotFoundException e) {</span>
<span class="nc" id="L323">              logger.warn(&quot;Error polling job {}: Not found!&quot;, job);</span>
<span class="nc" id="L324">              finishedJobs.put(job, Job.Status.DELETED);</span>
<span class="nc" id="L325">              pollingException = e;</span>
<span class="nc" id="L326">              break;</span>
<span class="nc" id="L327">            } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L328">              logger.warn(&quot;Error polling service registry for the status of {}: {}&quot;, job, e.getMessage());</span>
<span class="nc" id="L329">            } catch (JobCanceledException e) {</span>
<span class="nc" id="L330">              logger.warn(&quot;Job {} got canceled&quot;, job);</span>
<span class="nc" id="L331">              pollingException = e;</span>
<span class="nc" id="L332">              updateAndNotify(finishedJobs);</span>
<span class="nc" id="L333">              return;</span>
<span class="nc" id="L334">            } catch (Throwable t) {</span>
<span class="nc" id="L335">              logger.error(&quot;An unexpected error occured while waiting for jobs&quot;, t);</span>
<span class="nc" id="L336">              pollingException = t;</span>
<span class="nc" id="L337">              updateAndNotify(finishedJobs);</span>
<span class="nc" id="L338">              return;</span>
<span class="pc" id="L339">            }</span>
          }

          // Are we done already?
<span class="fc bfc" id="L343" title="All 2 branches covered.">          if (finishedJobs.size() == jobs.size()) {</span>
<span class="fc" id="L344">            updateAndNotify(finishedJobs);</span>
<span class="fc" id="L345">            return;</span>
<span class="pc bpc" id="L346" title="1 of 4 branches missed.">          } else if (workTime &gt; 0 &amp;&amp; endTime &gt;= time) {</span>
<span class="fc" id="L347">            pollingException = new InterruptedException(&quot;Timeout waiting for job processing&quot;);</span>
<span class="fc" id="L348">            updateAndNotify(finishedJobs);</span>
<span class="fc" id="L349">            return;</span>
          }
<span class="fc" id="L351">        }</span>
<span class="fc" id="L352">      }</span>
    }

    /**
     * Notifies listeners about the status change.
     *
     * @param status
     *          the status
     */
    private void updateAndNotify(Map&lt;Job, Job.Status&gt; status) {
<span class="fc" id="L362">      JobBarrier.this.setStatus(new Result(status));</span>
<span class="fc" id="L363">      synchronized (JobBarrier.this) {</span>
<span class="fc" id="L364">        JobBarrier.this.notifyAll();</span>
<span class="fc" id="L365">      }</span>
<span class="fc" id="L366">    }</span>

  }

  /** Result of a waiting operation on a certain number of jobs. */
  public static class Result {
    /** The outcome of this barrier */
    private final Map&lt;Job, Job.Status&gt; status;

    /**
     * Creates a new job barrier result.
     *
     * @param status
     *          the barrier outcome
     */
<span class="fc" id="L381">    public Result(Map&lt;Job, Job.Status&gt; status) {</span>
<span class="fc" id="L382">      this.status = status;</span>
<span class="fc" id="L383">    }</span>

    /**
     * Returns the status details.
     *
     * @return the status details
     */
    public Map&lt;Job, Job.Status&gt; getStatus() {
<span class="nc" id="L391">      return status;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if all jobs are in the &lt;code&gt;{@link Job.Status#FINISHED}&lt;/code&gt; state.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all jobs are finished
     */
    public boolean isSuccess() {
<span class="fc bfc" id="L400" title="All 2 branches covered.">      for (final Job.Status state : status.values()) {</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (!state.equals(Job.Status.FINISHED))</span>
<span class="fc" id="L402">          return false;</span>
<span class="fc" id="L403">      }</span>
<span class="fc" id="L404">      return true;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>