<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Option.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.util.data</a> &gt; <span class="el_source">Option.java</span></div><h1>Option.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.util.data;

import static org.opencastproject.util.data.Tuple.tuple;

import com.entwinemedia.fn.data.Opt;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

/**
 * The option type encapsulates on optional value. It contains either some value or is empty. Please make sure to NEVER
 * wrap null into a some. Instead use none.
 */
// todo clean up the mix of abstract methods and concrete implementations based on the isSome() decision
public abstract class Option&lt;A&gt; implements Iterable&lt;A&gt; {
  private Option() {
  }

  /** Safe decomposition of the option type. */
  public abstract &lt;B&gt; B fold(Match&lt;A, B&gt; visitor);

  public abstract Option&lt;A&gt; foreach(Function&lt;? super A, Void&gt; f);

  public abstract &lt;B&gt; Option&lt;B&gt; fmap(Function&lt;? super A, ? extends B&gt; f);

  public &lt;B&gt; Option&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L50">    return fmap(f);</span>
  }

  /** Monadic bind operation &lt;code&gt;m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/code&gt;. */
  public abstract &lt;B&gt; Option&lt;B&gt; bind(Function&lt;A, Option&lt;B&gt;&gt; f);

  public &lt;B&gt; Option&lt;B&gt; flatMap(Function&lt;A, Option&lt;B&gt;&gt; f) {
<span class="fc" id="L57">    return bind(f);</span>
  }

  public abstract boolean isSome();

  public boolean isNone() {
<span class="fc bfc" id="L63" title="All 2 branches covered.">    return !isSome();</span>
  }

  /** If this is none return &lt;code&gt;none&lt;/code&gt; else this. */
  public Option&lt;A&gt; orElse(Option&lt;A&gt; none) {
<span class="fc bfc" id="L68" title="All 2 branches covered.">    return isSome() ? this : none;</span>
  }

  /** Lazy version of {@link #orElse(Option)}. */
  public Option&lt;A&gt; orElse(Function0&lt;Option&lt;A&gt;&gt; none) {
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">    return isSome() ? this : none.apply();</span>
  }

  /** Throw &lt;code&gt;none&lt;/code&gt; if none. */
  public &lt;T extends Throwable&gt; Option&lt;A&gt; orError(T none) throws T {
<span class="fc bfc" id="L78" title="All 2 branches covered.">    if (isSome())</span>
<span class="fc" id="L79">      return this;</span>
    else
<span class="fc" id="L81">      throw none;</span>
  }

  public &lt;B&gt; Option&lt;Tuple&lt;A, B&gt;&gt; and(Option&lt;B&gt; b) {
<span class="fc bfc" id="L85" title="All 4 branches covered.">    if (isSome() &amp;&amp; b.isSome()) {</span>
<span class="fc" id="L86">      return some(tuple(get(), b.get()));</span>
    } else {
<span class="fc" id="L88">      return none();</span>
    }
  }

  /** Get the contained value or throw an exception. */
  public abstract A get();

  /** Get the contained value in case of being &quot;some&quot; or return parameter &lt;code&gt;none&lt;/code&gt; otherwise. */
  public abstract A getOrElse(A none);

  /** Get the contained value in case of being &quot;some&quot; or return the result of evaluating &lt;code&gt;none&lt;/code&gt; otherwise. */
  public abstract A getOrElse(Function0&lt;A&gt; none);

  /** To interface with legacy applications or frameworks that still use &lt;code&gt;null&lt;/code&gt; values. */
  public abstract A getOrElseNull();

  /** Transform an option into a list, either with a single element or an empty list. */
  public abstract List&lt;A&gt; list();

  public abstract Opt&lt;A&gt; toOpt();

  @Override
  public abstract int hashCode();

  @Override
  public abstract boolean equals(Object o);

  // -- constructor functions

  /** Create a new some. */
  public static &lt;A&gt; Option&lt;A&gt; some(final A a) {
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">    if (a == null)</span>
<span class="nc" id="L120">      throw new Error(&quot;null must not be wrapped in a some&quot;);</span>
<span class="fc" id="L121">    return new Option&lt;A&gt;() {</span>
      @Override
      public &lt;B&gt; B fold(Match&lt;A, B&gt; visitor) {
<span class="fc" id="L124">        return visitor.some(a);</span>
      }

      @Override
      public Option&lt;A&gt; foreach(Function&lt;? super A, Void&gt; f) {
<span class="fc" id="L129">        f.apply(a);</span>
<span class="fc" id="L130">        return this;</span>
      }

      @Override
      public &lt;B&gt; Option&lt;B&gt; fmap(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L135">        B b = f.apply(a);</span>
<span class="fc" id="L136">        return some(b);</span>
      }

      @Override
      public &lt;B&gt; Option&lt;B&gt; bind(Function&lt;A, Option&lt;B&gt;&gt; f) {
<span class="fc" id="L141">        return f.apply(a);</span>
      }

      @Override
      public boolean isSome() {
<span class="fc" id="L146">        return true;</span>
      }

      @Override
      public A get() {
<span class="fc" id="L151">        return a;</span>
      }

      @Override
      public A getOrElse(A none) {
<span class="fc" id="L156">        return a;</span>
      }

      @Override
      public A getOrElse(Function0&lt;A&gt; none) {
<span class="fc" id="L161">        return a;</span>
      }

      @Override
      public A getOrElseNull() {
<span class="fc" id="L166">        return a;</span>
      }

      @Override
      public Iterator&lt;A&gt; iterator() {
<span class="fc" id="L171">        return Collections.singletonList(a).iterator();</span>
      }

      @Override
      public List&lt;A&gt; list() {
<span class="fc" id="L176">        return Collections.singletonList(a);</span>
      }

      @Override
      public Opt&lt;A&gt; toOpt() {
<span class="nc" id="L181">        return Opt.some(a);</span>
      }

      @Override
      public int hashCode() {
        // since an Option should NEVER contain any null this is safe
<span class="fc" id="L187">        return a.hashCode();</span>
      }

      @Override
      public boolean equals(Object o) {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (o instanceof Option) {</span>
<span class="fc" id="L193">          Option&lt;?&gt; opt = (Option&lt;?&gt;) o;</span>
          // since an Option should NEVER contain any null this is safe
<span class="fc bfc" id="L195" title="All 4 branches covered.">          return opt.isSome() &amp;&amp; a.equals(opt.get());</span>
        } else {
<span class="nc" id="L197">          return false;</span>
        }
      }

      @Override
      public String toString() {
<span class="fc" id="L203">        return &quot;Some(&quot; + a + &quot;)&quot;;</span>
      }
    };
  }

  /** Create a new none. */
  public static &lt;A&gt; Option&lt;A&gt; none() {
<span class="fc" id="L210">    return new Option&lt;A&gt;() {</span>
      @Override
      public &lt;B&gt; B fold(Match&lt;A, B&gt; visitor) {
<span class="fc" id="L213">        return visitor.none();</span>
      }

      @Override
      public Option&lt;A&gt; foreach(Function&lt;? super A, Void&gt; f) {
<span class="fc" id="L218">        return this;</span>
      }

      @Override
      public &lt;B&gt; Option&lt;B&gt; fmap(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L223">        return none();</span>
      }

      @Override
      public &lt;B&gt; Option&lt;B&gt; bind(Function&lt;A, Option&lt;B&gt;&gt; f) {
<span class="fc" id="L228">        return none();</span>
      }

      @Override
      public boolean isSome() {
<span class="fc" id="L233">        return false;</span>
      }

      @Override
      public A get() {
<span class="nc" id="L238">        throw new IllegalStateException(&quot;a none does not contain a value&quot;);</span>
      }

      @Override
      public A getOrElse(A none) {
<span class="fc" id="L243">        return none;</span>
      }

      @Override
      public A getOrElse(Function0&lt;A&gt; none) {
<span class="fc" id="L248">        return none.apply();</span>
      }

      @Override
      public A getOrElseNull() {
<span class="fc" id="L253">        return null;</span>
      }

      @Override
      public Iterator&lt;A&gt; iterator() {
<span class="fc" id="L258">        return new ArrayList&lt;A&gt;().iterator();</span>
      }

      @Override
      public List&lt;A&gt; list() {
<span class="nc" id="L263">        return Collections.emptyList();</span>
      }

      @Override
      public Opt&lt;A&gt; toOpt() {
<span class="nc" id="L268">        return Opt.none();</span>
      }

      @Override
      public int hashCode() {
<span class="fc" id="L273">        return -1;</span>
      }

      @Override
      public boolean equals(Object o) {
<span class="pc bpc" id="L278" title="1 of 4 branches missed.">        return o instanceof Option &amp;&amp; ((Option) o).isNone();</span>
      }

      @Override
      public String toString() {
<span class="fc" id="L283">        return &quot;None&quot;;</span>
      }
    };
  }

  /**
   * Create a none with the type of &lt;code&gt;example&lt;/code&gt;. This saves some nasty typing, e.g.
   * &lt;code&gt;Option.&amp;lt;String&amp;gt;none()&lt;/code&gt; vs. &lt;code&gt;none(&quot;&quot;)&lt;/code&gt;.
   * &lt;p&gt;
   * Please note that this constructor is only due to Java's insufficient type inference.
   */
  public static &lt;A&gt; Option&lt;A&gt; none(A example) {
<span class="fc" id="L295">    return none();</span>
  }

  /** Create a none with the given type. */
  public static &lt;A&gt; Option&lt;A&gt; none(Class&lt;A&gt; clazz) {
<span class="fc" id="L300">    return none();</span>
  }

  /** Wrap an arbitrary object into an option with &lt;code&gt;null&lt;/code&gt; being mapped to none. */
  public static &lt;A&gt; Option&lt;A&gt; option(A a) {
<span class="fc bfc" id="L305" title="All 2 branches covered.">    if (a != null)</span>
<span class="fc" id="L306">      return some(a);</span>
    else
<span class="fc" id="L308">      return none();</span>
  }

  /** Convert an &lt;code&gt;Opt&lt;/code&gt; into an &lt;code&gt;Option&lt;/code&gt;. */
  public static &lt;A&gt; Option&lt;A&gt; fromOpt(Opt&lt;A&gt; a) {
<span class="nc bnc" id="L313" title="All 2 branches missed.">    for (A x : a) {</span>
<span class="nc" id="L314">      return some(x);</span>
    }
<span class="nc" id="L316">    return none();</span>
  }

  /**
   * Use this function in &lt;code&gt;getOrElse&lt;/code&gt; if it is an error being none.
   *
   * @deprecated use {@link #orError(Throwable)} or {@link #orElse(Function0)} instead since it saves the need for
   *             creating new objects just for the sake of type soundness. Java unfortunately lacks a bottom type.
   */
  @Deprecated
  public static &lt;A&gt; Function0&lt;A&gt; error(final String message) {
<span class="fc" id="L327">    return new Function0&lt;A&gt;() {</span>
      @Override
      public A apply() {
<span class="nc" id="L330">        throw new Error(message);</span>
      }
    };
  }

  /**
   * Create an equals function.
   *
   * &lt;pre&gt;
   *   some(&quot;abc&quot;).map(eq(&quot;bcd&quot;)).getOrElse(false) // false
   *   some(&quot;abc&quot;).map(eq(&quot;abc&quot;)).getOrElse(false) // true
   * &lt;/pre&gt;
   */
  public static Function&lt;String, Boolean&gt; eq(final String compare) {
<span class="fc" id="L344">    return new Function&lt;String, Boolean&gt;() {</span>
      @Override
      public Boolean apply(String s) {
<span class="fc" id="L347">        return compare.equals(s);</span>
      }
    };
  }

  public interface Match&lt;A, B&gt; {
    B some(A a);

    B none();
  }

  /** Effect match. */
<span class="fc" id="L359">  public abstract static class EMatch&lt;A&gt; implements Match&lt;A, Void&gt; {</span>
    @Override
    public final Void some(A a) {
<span class="fc" id="L362">      esome(a);</span>
<span class="fc" id="L363">      return null;</span>
    }

    @Override
    public final Void none() {
<span class="nc" id="L368">      enone();</span>
<span class="nc" id="L369">      return null;</span>
    }

    protected abstract void esome(A a);

    protected abstract void enone();
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>