<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Functions.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.util.data.functions</a> &gt; <span class="el_source">Functions.java</span></div><h1>Functions.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */


package org.opencastproject.util.data.functions;

import static org.opencastproject.util.data.Either.left;
import static org.opencastproject.util.data.Either.right;

import org.opencastproject.util.data.Effect;
import org.opencastproject.util.data.Effect0;
import org.opencastproject.util.data.Either;
import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Function0;
import org.opencastproject.util.data.Function2;
import org.opencastproject.util.data.Predicate;

/** General purpose functions, especially function transformations. */
public final class Functions {
  private Functions() {
  }

  /** Function composition: &lt;code&gt;f . g = f(g(x)) = o(f, g)&lt;/code&gt; */
  public static &lt;A, B, C&gt; Function&lt;A, C&gt; o(final Function&lt;? super B, ? extends C&gt; f,
          final Function&lt;? super A, ? extends B&gt; g) {
<span class="fc" id="L44">    return new Function&lt;A, C&gt;() {</span>
      @Override
      public C apply(A a) {
<span class="fc" id="L47">        return f.apply(g.apply(a));</span>
      }
    };
  }

  /** Function composition: &lt;code&gt;f . g = f(g) = o(f, g)&lt;/code&gt; */
  public static &lt;A, B&gt; Function0&lt;B&gt; o(final Function&lt;? super A, ? extends B&gt; f, final Function0&lt;? extends A&gt; g) {
<span class="fc" id="L54">    return new Function0&lt;B&gt;() {</span>
      @Override
      public B apply() {
<span class="fc" id="L57">        return f.apply(g.apply());</span>
      }
    };
  }

  /** Left to right composition: &lt;code&gt;f then g = g(f(x))&lt;/code&gt; */
  public static &lt;A, B, C&gt; Function&lt;A, C&gt; then(final Function&lt;? super A, ? extends B&gt; f,
          final Function&lt;? super B, ? extends C&gt; g) {
<span class="fc" id="L65">    return new Function&lt;A, C&gt;() {</span>
      @Override
      public C apply(A a) {
<span class="fc" id="L68">        return g.apply(f.apply(a));</span>
      }
    };
  }

  /** Left to right composition: &lt;code&gt;f then g = g(f)&lt;/code&gt; */
  public static &lt;A, B&gt; Function0&lt;B&gt; then(final Function0&lt;? extends A&gt; f, final Function&lt;? super A, ? extends B&gt; g) {
<span class="fc" id="L75">    return new Function0&lt;B&gt;() {</span>
      @Override
      public B apply() {
<span class="fc" id="L78">        return g.apply(f.apply());</span>
      }
    };
  }

  /** Apply &lt;code&gt;f&lt;/code&gt; and ignore its result, then apply &lt;code&gt;g&lt;/code&gt;. */
  public static &lt;A, B&gt; Function0&lt;B&gt; then(final Function0&lt;? extends A&gt; f, final Function0&lt;? extends B&gt; g) {
<span class="fc" id="L85">    return new Function0&lt;B&gt;() {</span>
      @Override
      public B apply() {
<span class="fc" id="L88">        f.apply();</span>
<span class="fc" id="L89">        return g.apply();</span>
      }
    };
  }

  /**
   * Create a new function from &lt;code&gt;f&lt;/code&gt; decorated with an exception transformer. Any exception that occurs during
   * application of &lt;code&gt;f&lt;/code&gt; is passed to &lt;code&gt;transformer&lt;/code&gt; whose return value is then being thrown.
   */
  public static &lt;A, B&gt; Function&lt;A, B&gt; rethrow(final Function&lt;? super A, ? extends B&gt; f,
          final Function&lt;? super Exception, ? extends Exception&gt; transformer) {
<span class="nc" id="L100">    return new Function&lt;A, B&gt;() {</span>
      @Override
      public B apply(A a) {
        try {
<span class="nc" id="L104">          return f.apply(a);</span>
<span class="nc" id="L105">        } catch (Exception e) {</span>
<span class="nc" id="L106">          return chuck(transformer.apply(e));</span>
        }
      }
    };
  }

  /**
   * Create a new function from &lt;code&gt;f&lt;/code&gt; decorated with an exception handler. Any exception that occurs during
   * application of &lt;code&gt;f&lt;/code&gt; is passed to &lt;code&gt;handler&lt;/code&gt; whose return value is then being returned.
   */
  public static &lt;A, B&gt; Function&lt;A, B&gt; handle(final Function&lt;? super A, ? extends B&gt; f,
          final Function&lt;? super Exception, ? extends B&gt; handler) {
<span class="nc" id="L118">    return new Function&lt;A, B&gt;() {</span>
      @Override
      public B apply(A a) {
        try {
<span class="nc" id="L122">          return f.apply(a);</span>
<span class="nc" id="L123">        } catch (Exception e) {</span>
<span class="nc" id="L124">          return handler.apply(e);</span>
        }
      }
    };
  }

  /**
   * Create a new function from &lt;code&gt;f&lt;/code&gt; decorated with an exception handler. The new function either returns the
   * value of &lt;code&gt;f&lt;/code&gt; or in case of an exception being thrown on the application of &lt;code&gt;f&lt;/code&gt; the return
   * value of &lt;code&gt;handler&lt;/code&gt;.
   */
  public static &lt;A, B, C&gt; Function&lt;A, Either&lt;C, B&gt;&gt; either(final Function&lt;? super A, ? extends B&gt; f,
          final Function&lt;? super Exception, ? extends C&gt; handler) {
<span class="nc" id="L137">    return new Function&lt;A, Either&lt;C, B&gt;&gt;() {</span>
      @Override
      public Either&lt;C, B&gt; apply(A a) {
        try {
<span class="nc" id="L141">          B b = f.apply(a);</span>
<span class="nc" id="L142">          return right(b);</span>
<span class="nc" id="L143">        } catch (Exception e) {</span>
<span class="nc" id="L144">          C c = handler.apply(e);</span>
<span class="nc" id="L145">          return left(c);</span>
        }
      }
    };
  }

  /** Curry a function of arity 2. */
  // todo rename since its actually partial application
  public static &lt;A, B, C&gt; Function&lt;B, C&gt; curry(final Function2&lt;? super A, ? super B, ? extends C&gt; f, final A a) {
<span class="fc" id="L154">    return new Function&lt;B, C&gt;() {</span>
      @Override
      public C apply(B b) {
<span class="fc" id="L157">        return f.apply(a, b);</span>
      }
    };
  }

  /** Curry a function of arity 2. (a, b) -gt; c =gt; a -gt; b -gt; c */
  public static &lt;A, B, C&gt; Function&lt;A, Function&lt;B, C&gt;&gt; curry(final Function2&lt;? super A, ? super B, ? extends C&gt; f) {
<span class="fc" id="L164">    return new Function&lt;A, Function&lt;B, C&gt;&gt;() {</span>
      @Override
      public Function&lt;B, C&gt; apply(final A a) {
<span class="fc" id="L167">        return new Function&lt;B, C&gt;() {</span>
          @Override
          public C apply(B b) {
<span class="fc" id="L170">            return f.apply(a, b);</span>
          }
        };
      }
    };
  }

  /** Uncurry to a function of arity 2. a -gt; b -gt; c =gt; (a, b) -gt; c */
  public static &lt;A, B, C&gt; Function2&lt;A, B, C&gt; uncurry(final Function&lt;? super A, Function&lt;B, C&gt;&gt; f) {
<span class="fc" id="L179">    return new Function2&lt;A, B, C&gt;() {</span>
      @Override
      public C apply(A a, B b) {
<span class="fc" id="L182">        return f.apply(a).apply(b);</span>
      }
    };
  }

  /** Curry a function of arity 1. */
  public static &lt;A, B&gt; Function0&lt;B&gt; curry(final Function&lt;? super A, ? extends B&gt; f, final A a) {
<span class="fc" id="L189">    return new Function0&lt;B&gt;() {</span>
      @Override
      public B apply() {
<span class="fc" id="L192">        return f.apply(a);</span>
      }
    };
  }

  /** Curry a function of arity 1. */
  public static &lt;A, B&gt; Function&lt;A, Function0&lt;B&gt;&gt; curry(final Function&lt;A, B&gt; f) {
<span class="fc" id="L199">    return new Function&lt;A, Function0&lt;B&gt;&gt;() {</span>
      @Override
      public Function0&lt;B&gt; apply(final A a) {
<span class="fc" id="L202">        return new Function0&lt;B&gt;() {</span>
          @Override
          public B apply() {
<span class="fc" id="L205">            return f.apply(a);</span>
          }
        };
      }
    };
  }

  /** Flip arguments of a function of arity 2. */
  public static &lt;A, B, C&gt; Function2&lt;B, A, C&gt; flip(final Function2&lt;? super A, ? super B, ? extends C&gt; f) {
<span class="fc" id="L214">    return new Function2&lt;B, A, C&gt;() {</span>
      @Override
      public C apply(B b, A a) {
<span class="fc" id="L217">        return f.apply(a, b);</span>
      }
    };
  }

  /** Turn a function into an effect by discarding its result. */
  public static &lt;A, B&gt; Effect&lt;A&gt; toEffect(final Function&lt;? super A, ? extends B&gt; f) {
<span class="nc" id="L224">    return new Effect&lt;A&gt;() {</span>
      @Override
      protected void run(A a) {
<span class="nc" id="L227">        f.apply(a);</span>
<span class="nc" id="L228">      }</span>
    };
  }

  public static &lt;A&gt; Predicate&lt;A&gt; toPredicate(final Function&lt;? super A, Boolean&gt; f) {
<span class="fc" id="L233">    return new Predicate&lt;A&gt;() {</span>
      @Override
      public Boolean apply(A a) {
<span class="nc" id="L236">        return f.apply(a);</span>
      }
    };
  }

  /** Noop effect. */
<span class="fc" id="L242">  public static final Effect0 noop = new Effect0() {</span>
    @Override
    protected void run() {
<span class="nc" id="L245">    }</span>
  };

  /** Identity function. */
  public static &lt;A&gt; Function&lt;A, A&gt; identity() {
<span class="fc" id="L250">    return new Function&lt;A, A&gt;() {</span>
      @Override
      public A apply(A a) {
<span class="fc" id="L253">        return a;</span>
      }
    };
  }

  /**
   * Identity function. The type is based on the type of the example object to save some nasty typing, e.g.
   * &lt;code&gt;Function.&amp;lt;Integer&amp;gt;identity()&lt;/code&gt; vs. &lt;code&gt;identity(0)&lt;/code&gt;
   *
   * Please note that this constructor is only due to Java's insufficient type inference.
   */
  public static &lt;A&gt; Function&lt;A, A&gt; identity(A example) {
<span class="nc" id="L265">    return identity();</span>
  }

  /**
   * Identity function.
   *
   * @param clazz
   *          to describe the functions's type
   */
  public static &lt;A&gt; Function&lt;A, A&gt; identity(Class&lt;A&gt; clazz) {
<span class="nc" id="L275">    return identity();</span>
  }

  /** Create an effect that runs its argument. */
<span class="fc" id="L279">  public static final Effect&lt;Effect0&gt; run = new Effect&lt;Effect0&gt;() {</span>
    @Override
    protected void run(Effect0 e) {
<span class="nc" id="L282">      e.apply();</span>
<span class="nc" id="L283">    }</span>
  };

  /** Pure functions are covariant in their result type. */
  public static &lt;A, B&gt; Function&lt;A, B&gt; co(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L288">    return (Function&lt;A, B&gt;) f;</span>
  }

  /** Pure functions are contravariant in their argument type. */
  public static &lt;A, B&gt; Function&lt;A, B&gt; contra(Function&lt;? super A, B&gt; f) {
<span class="fc" id="L293">    return (Function&lt;A, B&gt;) f;</span>
  }

  /** Pure functions are covariant in their result type and contravariant in their argument type. */
  public static &lt;A, B&gt; Function&lt;A, B&gt; variant(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L298">    return (Function&lt;A, B&gt;) f;</span>
  }

  private static &lt;T extends Throwable, A&gt; A castGeneric(Throwable t) throws T {
    // The cast to T does not happen here but _after_ returning from the method at _assignment_ time
    // But since there is no variable assignment. The Throwable is just thrown.
<span class="nc" id="L304">    throw (T) t;</span>
  }

  /**
   * Throw a checked exception like a RuntimeException removing any needs to declare a throws clause.
   *
   * This technique has been described by James Iry at
   * http://james-iry.blogspot.de/2010/08/on-removing-java-checked-exceptions-by.html
   */
  public static &lt;A&gt; A chuck(Throwable t) {
<span class="nc" id="L314">    return Functions.&lt;RuntimeException, A&gt; castGeneric(t);</span>
  }

  /** Convert function &lt;code&gt;f&lt;/code&gt; into a guava function. */
  public static &lt;A, B&gt; com.google.common.base.Function&lt;A, B&gt; toGuava(final Function&lt;? super A, ? extends B&gt; f) {
<span class="nc" id="L319">    return new com.google.common.base.Function&lt;A, B&gt;() {</span>
      @Override
      public B apply(A a) {
<span class="nc" id="L322">        return f.apply(a);</span>
      }
    };
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>