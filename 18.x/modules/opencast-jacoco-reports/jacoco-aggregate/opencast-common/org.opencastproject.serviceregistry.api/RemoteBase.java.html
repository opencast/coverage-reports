<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RemoteBase.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.serviceregistry.api</a> &gt; <span class="el_source">RemoteBase.java</span></div><h1>RemoteBase.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.serviceregistry.api;

import static org.opencastproject.util.data.Option.none;
import static org.opencastproject.util.data.Option.some;

import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.security.api.TrustedHttpClient;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Option;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.StatusLine;
import org.apache.http.client.methods.HttpRequestBase;
import org.joda.time.DateTimeConstants;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Base class serving as a convenience implementation for remote services.
 */
public class RemoteBase {

  private static final int TIMEOUT = 10000;

  /** The logger */
<span class="fc" id="L61">  private static final Logger logger = LoggerFactory.getLogger(RemoteBase.class);</span>

  /** The service type, used to look up remote implementations */
<span class="fc" id="L64">  protected String serviceType = null;</span>

  /** The http client to use when connecting to remote servers */
<span class="fc" id="L67">  protected TrustedHttpClient client = null;</span>

  /** The http client */
<span class="fc" id="L70">  protected ServiceRegistry remoteServiceManager = null;</span>

  /** A list of known http statuses */
<span class="fc" id="L73">  private static final List&lt;Integer&gt; knownHttpStatuses = Arrays.asList(HttpStatus.SC_SERVICE_UNAVAILABLE);</span>

  /**
   * Creates a remote implementation for the given type of service.
   *
   * @param type
   *          the service type
   */
<span class="fc" id="L81">  protected RemoteBase(String type) {</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">    if (type == null)</span>
<span class="nc" id="L83">      throw new IllegalArgumentException(&quot;Service type must not be null&quot;);</span>
<span class="fc" id="L84">    this.serviceType = type;</span>
<span class="fc" id="L85">  }</span>

  /**
   * Sets the trusted http client
   *
   * @param client
   */
  @Reference
  public void setTrustedHttpClient(TrustedHttpClient client) {
<span class="fc" id="L94">    this.client = client;</span>
<span class="fc" id="L95">  }</span>

  /**
   * Sets the remote service manager.
   *
   * @param remoteServiceManager
   */
  @Reference
  public void setRemoteServiceManager(ServiceRegistry remoteServiceManager) {
<span class="fc" id="L104">    this.remoteServiceManager = remoteServiceManager;</span>
<span class="fc" id="L105">  }</span>

  protected &lt;A&gt; Option&lt;A&gt; runRequest(HttpRequestBase req, Function&lt;HttpResponse, A&gt; f) {
<span class="nc" id="L108">    HttpResponse res = null;</span>
    try {
<span class="nc" id="L110">      res = getResponse(req);</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">      return res != null ? some(f.apply(res)) : Option.&lt;A&gt; none();</span>
    } finally {
<span class="nc" id="L113">      closeConnection(res);</span>
    }
  }



<span class="fc" id="L119">  public static final Function&lt;HttpResponse, Option&lt;List&lt;MediaPackageElement&gt;&gt;&gt; elementsFromHttpResponse =</span>
<span class="fc" id="L120">    new Function&lt;HttpResponse, Option&lt;List&lt;MediaPackageElement&gt;&gt;&gt;() {</span>
    @Override
    public Option&lt;List&lt;MediaPackageElement&gt;&gt; apply(HttpResponse response) {
      try {
<span class="nc" id="L124">        final String xml = IOUtils.toString(response.getEntity().getContent(), Charset.forName(&quot;utf-8&quot;));</span>
<span class="nc" id="L125">        List&lt;MediaPackageElement&gt; result = new ArrayList&lt;&gt;(MediaPackageElementParser.getArrayFromXml(xml));</span>
<span class="nc" id="L126">        return some(result);</span>
<span class="nc" id="L127">      } catch (Exception e) {</span>
<span class="nc" id="L128">        logger.error(&quot;Error parsing Job from HTTP response&quot;, e);</span>
<span class="nc" id="L129">        return none();</span>
      }
    }
  };

  /**
   * Makes a request to all available remote services and returns the response as soon as the first of them returns the
   * {@link HttpStatus#SC_OK} as the status code.
   *
   * @param httpRequest
   *          the http request. If the URI is specified, it should include only the path beyond the service endpoint.
   *          For example, a request intended for http://{host}/{service}/extra/path/info.xml should include the URI
   *          &quot;/extra/path/info.xml&quot;.
   * @return the response object, or null if we can not connect to any services
   */
  protected HttpResponse getResponse(HttpRequestBase httpRequest) {
<span class="fc" id="L145">    return getResponse(httpRequest, HttpStatus.SC_OK);</span>
  }

  /**
   * Makes a request to all available remote services and returns the response as soon as the first of them returns the
   * expected http status code.
   *
   * @param httpRequest
   *          the http request. If the URI is specified, it should include only the path beyond the service endpoint.
   *          For example, a request intended for http://{host}/{service}/extra/path/info.xml should include the URI
   *          &quot;/extra/path/info.xml&quot;.
   * @param expectedHttpStatus
   *          any expected status codes to include in the return.
   * @return the response object, or null if we can not connect to any services
   */
  protected HttpResponse getResponse(HttpRequestBase httpRequest, Integer... expectedHttpStatus) {

<span class="fc" id="L162">    final long maxWaitTimeMillis = System.currentTimeMillis() + DateTimeConstants.MILLIS_PER_DAY;</span>
<span class="fc" id="L163">    boolean warnedUnavailability = false;</span>

    // Try forever
    while (true) {

<span class="fc" id="L168">      List&lt;ServiceRegistration&gt; remoteServices = null;</span>
<span class="fc" id="L169">      List&lt;String&gt; servicesInWarningState = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L170">      List&lt;String&gt; servicesInKnownState = new ArrayList&lt;String&gt;();</span>

      // Find available services
<span class="fc" id="L173">      boolean warned = false;</span>
<span class="pc bpc" id="L174" title="1 of 4 branches missed.">      while (remoteServices == null || remoteServices.size() == 0) {</span>
        try {
<span class="fc" id="L176">          remoteServices = remoteServiceManager.getServiceRegistrationsByLoad(serviceType);</span>
<span class="pc bpc" id="L177" title="2 of 4 branches missed.">          if (remoteServices == null || remoteServices.size() == 0) {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if (!warned) {</span>
<span class="nc" id="L179">              logger.warn(&quot;No services of type '{}' found, waiting...&quot;, serviceType);</span>
<span class="nc" id="L180">              warned = true;</span>
            }
<span class="nc" id="L182">            logger.debug(&quot;Still no services of type '{}' found, waiting...&quot;, serviceType);</span>
            try {
<span class="nc" id="L184">              Thread.sleep(TIMEOUT);</span>
<span class="nc" id="L185">            } catch (InterruptedException e) {</span>
<span class="nc" id="L186">              logger.warn(&quot;Interrupted while waiting for remote service of type '{}'&quot;, serviceType);</span>
<span class="nc" id="L187">              return null;</span>
<span class="nc" id="L188">            }</span>
          }
<span class="nc" id="L190">        } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L191">          logger.warn(&quot;Unable to obtain a list of remote services&quot;, e);</span>
<span class="nc" id="L192">          return null;</span>
<span class="fc" id="L193">        }</span>
      }

<span class="fc" id="L196">      URI originalUri = httpRequest.getURI();</span>
<span class="fc" id="L197">      String uriSuffix = null;</span>
<span class="pc bpc" id="L198" title="3 of 4 branches missed.">      if (originalUri != null &amp;&amp; StringUtils.isNotBlank(originalUri.toString())) {</span>
<span class="nc" id="L199">        uriSuffix = originalUri.toString();</span>
      }

      // Try each available service
<span class="fc" id="L203">      String fullUrl = null;</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">      for (ServiceRegistration remoteService : remoteServices) {</span>
<span class="fc" id="L205">        HttpResponse response = null;</span>
        try {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">          if (uriSuffix == null) {</span>
<span class="fc" id="L208">            fullUrl = UrlSupport.concat(remoteService.getHost(), remoteService.getPath());</span>
          } else {
<span class="nc" id="L210">            fullUrl = UrlSupport.concat(new String[] { remoteService.getHost(), remoteService.getPath(), uriSuffix });</span>
          }

<span class="fc" id="L213">          logger.debug(&quot;Connecting to remote service of type '{}' at {}&quot;, serviceType, fullUrl);</span>

<span class="fc" id="L215">          URI uri = new URI(fullUrl);</span>
<span class="fc" id="L216">          httpRequest.setURI(uri);</span>
<span class="fc" id="L217">          response = client.execute(httpRequest);</span>
<span class="fc" id="L218">          StatusLine status = response.getStatusLine();</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">          if (Arrays.asList(expectedHttpStatus).contains(status.getStatusCode())) {</span>
<span class="pc bpc" id="L220" title="2 of 4 branches missed.">            if (servicesInWarningState.contains(fullUrl) || servicesInKnownState.contains(fullUrl)) {</span>
<span class="nc" id="L221">              logger.warn(&quot;Service at {} is back to normal with expected status code {}&quot;, fullUrl,</span>
<span class="nc" id="L222">                      status.getStatusCode());</span>
            }
<span class="fc" id="L224">            return response;</span>
          } else {
<span class="nc bnc" id="L226" title="All 4 branches missed.">            if (!knownHttpStatuses.contains(status.getStatusCode()) &amp;&amp; !servicesInWarningState.contains(fullUrl)) {</span>
<span class="nc" id="L227">              logger.warn(&quot;Service at {} returned unexpected response code {}&quot;, fullUrl, status.getStatusCode());</span>
<span class="nc" id="L228">              servicesInWarningState.add(fullUrl);</span>
<span class="nc" id="L229">              servicesInKnownState.remove(fullUrl);</span>
<span class="nc bnc" id="L230" title="All 4 branches missed.">            } else if (knownHttpStatuses.contains(status.getStatusCode()) &amp;&amp; !servicesInKnownState.contains(fullUrl)) {</span>
<span class="nc" id="L231">              logger.info(&quot;Service at {} returned known response code {}&quot;, fullUrl, status.getStatusCode());</span>
<span class="nc" id="L232">              servicesInKnownState.add(fullUrl);</span>
<span class="nc" id="L233">              servicesInWarningState.remove(fullUrl);</span>
            }
          }
<span class="nc" id="L236">        } catch (Exception e) {</span>
<span class="nc" id="L237">          logger.error(&quot;Exception while trying to dispatch job to {}&quot;, fullUrl, e);</span>
<span class="nc" id="L238">          servicesInWarningState.add(fullUrl);</span>
<span class="nc" id="L239">        }</span>
<span class="nc" id="L240">        closeConnection(response);</span>
<span class="nc" id="L241">      }</span>

<span class="nc bnc" id="L243" title="All 2 branches missed.">      if (servicesInKnownState.isEmpty()) {</span>
<span class="nc" id="L244">        logger.warn(&quot;All services of type '{}' are in unknown state, abort remote call {}&quot;, serviceType, originalUri);</span>
<span class="nc" id="L245">        return null;</span>
      }

      // Reset Original URI
<span class="nc" id="L249">      httpRequest.setURI(originalUri);</span>

      // If none of them accepted the request, let's wait and retry
<span class="nc bnc" id="L252" title="All 2 branches missed.">      if (!warnedUnavailability) {</span>
<span class="nc" id="L253">        logger.warn(&quot;No service of type '{}' is currently readily available&quot;, serviceType);</span>
<span class="nc" id="L254">        warnedUnavailability = true;</span>
      } else {
<span class="nc" id="L256">        logger.debug(&quot;All services of type '{}' are still unavailable&quot;, serviceType);</span>
      }

      try {
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (System.currentTimeMillis() &gt; maxWaitTimeMillis) {</span>
<span class="nc" id="L261">          logger.warn(</span>
                  &quot;Still no service of type '{}' available while waiting for more than one day, abort remote call {}&quot;,
                  serviceType, originalUri);
<span class="nc" id="L264">          return null;</span>
        }
<span class="nc" id="L266">        Thread.sleep(TIMEOUT);</span>
<span class="nc" id="L267">      } catch (InterruptedException e) {</span>
<span class="nc" id="L268">        logger.warn(&quot;Interrupted while waiting for remote service of type '{}'&quot;, serviceType);</span>
<span class="nc" id="L269">        return null;</span>
<span class="nc" id="L270">      }</span>

<span class="nc" id="L272">    }</span>
  }

  /**
   * Closes any http connections kept open by this http response.
   */
  protected void closeConnection(HttpResponse response) {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">    if (response != null)</span>
      try {
<span class="fc" id="L281">        client.close(response);</span>
<span class="nc" id="L282">      } catch (IOException e) {</span>
        // ignore
<span class="fc" id="L284">      }</span>
<span class="fc" id="L285">  }</span>

  /**
   * A stream wrapper that closes the http response when the stream is closed. If a remote service proxy returns an
   * inputstream, this implementation should be used to ensure that the http connection is closed properly.
   */
  public class HttpClientClosingInputStream extends InputStream {

    /** The input stream delivering the actual data */
<span class="nc" id="L294">    protected InputStream delegateStream = null;</span>

    /** The http response to close when the stream is closed */
<span class="nc" id="L297">    protected HttpResponse httpResponse = null;</span>

    /**
     * Constructs an HttpClientClosingInputStream from a source stream and an http response.
     *
     * @throws IOException
     * @throws IllegalStateException
     */
<span class="nc" id="L305">    public HttpClientClosingInputStream(HttpResponse resp) throws IllegalStateException, IOException {</span>
<span class="nc" id="L306">      this.delegateStream = resp.getEntity().getContent();</span>
<span class="nc" id="L307">      this.httpResponse = resp;</span>
<span class="nc" id="L308">    }</span>

    /**
     * {@inheritDoc}
     *
     * @see java.io.InputStream#read()
     */
    @Override
    public int read() throws IOException {
<span class="nc" id="L317">      return delegateStream.read();</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see java.io.InputStream#available()
     */
    @Override
    public int available() throws IOException {
<span class="nc" id="L327">      return delegateStream.available();</span>
    }

    /**
     * @throws IOException
     * @see java.io.InputStream#close()
     */
    @Override
    public void close() throws IOException {
<span class="nc" id="L336">      delegateStream.close();</span>
<span class="nc" id="L337">      closeConnection(httpResponse);</span>
<span class="nc" id="L338">    }</span>

    /**
     * @param readlimit
     * @see java.io.InputStream#mark(int)
     */
    @Override
    public void mark(int readlimit) {
<span class="nc" id="L346">      delegateStream.mark(readlimit);</span>
<span class="nc" id="L347">    }</span>

    /**
     * @return whether this stream supports marking
     * @see java.io.InputStream#markSupported()
     */
    @Override
    public boolean markSupported() {
<span class="nc" id="L355">      return delegateStream.markSupported();</span>
    }

    /**
     * @param b
     *          the buffer into which the data is read.
     * @param off
     *          the start offset in array &lt;code&gt;b&lt;/code&gt; at which the data is written.
     * @param len
     *          the maximum number of bytes to read.
     * @return the total number of bytes read into the buffer, or &lt;code&gt;-1&lt;/code&gt; if there is no more data because the
     *         end of the stream has been reached.
     * @exception IOException
     *              If the first byte cannot be read for any reason other than end of file, or if the input stream has
     *              been closed, or if some other I/O error occurs.
     * @exception NullPointerException
     *              If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @exception IndexOutOfBoundsException
     *              If &lt;code&gt;off&lt;/code&gt; is negative, &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
     *              &lt;code&gt;b.length - off&lt;/code&gt;
     * @see java.io.InputStream#read(byte[], int, int)
     */
    @Override
    public int read(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L379">      return delegateStream.read(b, off, len);</span>
    }

    /**
     * @param b
     *          the buffer into which the data is read.
     * @return the total number of bytes read into the buffer, or &lt;code&gt;-1&lt;/code&gt; is there is no more data because the
     *         end of the stream has been reached.
     * @exception IOException
     *              If the first byte cannot be read for any reason other than the end of the file, if the input stream
     *              has been closed, or if some other I/O error occurs.
     * @exception NullPointerException
     *              if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @see java.io.InputStream#read(byte[])
     */
    @Override
    public int read(byte[] b) throws IOException {
<span class="nc" id="L396">      return delegateStream.read(b);</span>
    }

    /**
     * @throws IOException
     * @see java.io.InputStream#reset()
     */
    @Override
    public void reset() throws IOException {
<span class="nc" id="L405">      delegateStream.reset();</span>
<span class="nc" id="L406">    }</span>

    /**
     * @param n
     *          the number of bytes to be skipped.
     * @return the actual number of bytes skipped.
     * @exception IOException
     *              if the stream does not support seek, or if some other I/O error occurs.
     * @see java.io.InputStream#skip(long)
     */
    @Override
    public long skip(long n) throws IOException {
<span class="nc" id="L418">      return delegateStream.skip(n);</span>
    }

    /**
     * @return
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
<span class="nc" id="L427">      return getClass().getName() + &quot; : &quot; + delegateStream.toString();</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>