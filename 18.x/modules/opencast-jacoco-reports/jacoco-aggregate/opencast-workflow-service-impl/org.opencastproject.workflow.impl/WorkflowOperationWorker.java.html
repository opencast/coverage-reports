<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WorkflowOperationWorker.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-workflow-service-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.workflow.impl</a> &gt; <span class="el_source">WorkflowOperationWorker.java</span></div><h1>WorkflowOperationWorker.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.workflow.impl;

import static java.lang.String.format;

import org.opencastproject.job.api.Incident.Severity;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.util.JobCanceledException;
import org.opencastproject.workflow.api.ResumableWorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowException;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowOperationAbortedException;
import org.opencastproject.workflow.api.WorkflowOperationException;
import org.opencastproject.workflow.api.WorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowOperationInstance;
import org.opencastproject.workflow.api.WorkflowOperationInstance.OperationState;
import org.opencastproject.workflow.api.WorkflowOperationResult;
import org.opencastproject.workflow.api.WorkflowOperationResult.Action;
import org.opencastproject.workflow.conditionparser.WorkflowConditionInterpreter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;
import java.util.function.Function;

/**
 * Handles execution of a workflow operation.
 */
final class WorkflowOperationWorker {
<span class="fc" id="L51">  private static final Logger logger = LoggerFactory.getLogger(WorkflowOperationWorker.class);</span>

  private WorkflowOperationHandler handler;
  private WorkflowInstance workflow;
  private final WorkflowServiceImpl service;
<span class="fc" id="L56">  private Map&lt;String, String&gt; properties = null;</span>

  /**
   * Creates a worker that will execute the given handler and thereby the current operation of the workflow instance.
   * When the worker is finished, a callback will be made to the workflow service reporting either success or failure of
   * the current workflow operation.
   *
   * @param handler
   *          the workflow operation handler
   * @param workflow
   *          the workflow instance
   * @param service
   *          the workflow service.
   */
  private WorkflowOperationWorker(WorkflowOperationHandler handler, WorkflowInstance workflow,
<span class="fc" id="L71">          WorkflowServiceImpl service) {</span>
<span class="fc" id="L72">    this.handler = handler;</span>
<span class="fc" id="L73">    this.workflow = workflow;</span>
<span class="fc" id="L74">    this.service = service;</span>
<span class="fc" id="L75">  }</span>

  /**
   * Creates a worker that will execute the given handler and thereby the current operation of the workflow instance.
   * When the worker is finished, a callback will be made to the workflow service reporting either success or failure of
   * the current workflow operation.
   *
   * @param handler
   *          the workflow operation handler
   * @param workflow
   *          the workflow instance
   * @param properties
   *          the properties used to execute the operation
   * @param service
   *          the workflow service.
   */
  WorkflowOperationWorker(WorkflowOperationHandler handler, WorkflowInstance workflow, Map&lt;String, String&gt; properties,
          WorkflowServiceImpl service) {
<span class="fc" id="L93">    this(handler, workflow, service);</span>
<span class="fc" id="L94">    this.properties = properties;</span>
<span class="fc" id="L95">  }</span>

  /**
   * Sets the workflow operation handler to use.
   *
   * @param operationHandler
   *          the handler
   */
  public void setHandler(WorkflowOperationHandler operationHandler) {
<span class="nc" id="L104">    handler = operationHandler;</span>
<span class="nc" id="L105">  }</span>

  /**
   * Executes the workflow operation logic.
   */
  public WorkflowInstance execute() {
<span class="fc" id="L111">    WorkflowOperationInstance operation = workflow.getCurrentOperation();</span>
    try {
      WorkflowOperationResult result;
<span class="pc bpc" id="L114" title="1 of 3 branches missed.">      switch (operation.getState()) {</span>
        case INSTANTIATED:
        case RETRY:
<span class="fc" id="L117">          result = start();</span>
<span class="fc" id="L118">          break;</span>
        case PAUSED:
<span class="fc" id="L120">          result = resume();</span>
<span class="fc" id="L121">          break;</span>
        default:
<span class="nc" id="L123">          throw new IllegalStateException(</span>
<span class="nc" id="L124">                  &quot;Workflow operation '&quot; + operation + &quot;' is in unexpected state '&quot; + operation.getState() + &quot;'&quot;);</span>
      }
<span class="pc bpc" id="L126" title="1 of 6 branches missed.">      if (result == null || Action.CONTINUE.equals(result.getAction()) || Action.SKIP.equals(result.getAction())) {</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (handler != null) {</span>
<span class="fc" id="L128">          handler.destroy(workflow, null);</span>
        }
      }
<span class="fc" id="L131">      workflow = service.handleOperationResult(workflow, result);</span>
<span class="fc" id="L132">      return workflow;</span>
<span class="nc" id="L133">    } catch (JobCanceledException e) {</span>
<span class="nc" id="L134">      logger.info(&quot;Workflow {} operation {} job cancelled: {}&quot;, workflow.getId(), operation, e.getMessage());</span>
<span class="nc" id="L135">      return workflow;</span>
<span class="fc" id="L136">    } catch (WorkflowOperationAbortedException e) {</span>
      // Don't log it as error because it was aborted by the user
<span class="fc" id="L138">      logger.info(&quot;Workflow operation '&quot; + operation + &quot;' aborted by user&quot;);</span>
<span class="fc" id="L139">    } catch (Exception e) {</span>
<span class="fc" id="L140">      logger.error(&quot;Workflow operation '&quot; + operation + &quot;' failed&quot;, e);</span>
      // the associated job shares operation's id
<span class="fc" id="L142">      service.getServiceRegistry().incident().unhandledException(operation.getId(), Severity.FAILURE, e);</span>
<span class="fc" id="L143">    }</span>
    try {
<span class="fc" id="L145">      workflow = service.handleOperationException(workflow, operation);</span>
<span class="nc" id="L146">    } catch (Exception e) {</span>
<span class="nc" id="L147">      logger.error(&quot;Error handling workflow operation '{}'&quot;, operation, e);</span>
<span class="fc" id="L148">    }</span>
<span class="fc" id="L149">    return workflow;</span>
  }

  /**
   * Starts executing the workflow operation.
   *
   * @return the workflow operation result
   * @throws WorkflowOperationException
   *           if executing the workflow operation handler fails
   * @throws WorkflowException
   *           if there is a problem processing the workflow
   */
  public WorkflowOperationResult start() throws WorkflowOperationException, WorkflowException, UnauthorizedException {
<span class="fc" id="L162">    final WorkflowOperationInstance operation = workflow.getCurrentOperation();</span>

    // Update execution condition and metadata
<span class="fc" id="L165">    final var organization = service.securityService.getOrganization();</span>
<span class="fc" id="L166">    final Function&lt;String, String&gt; variables = key -&gt; {</span>
<span class="pc bpc" id="L167" title="3 of 4 branches missed.">      if (properties != null &amp;&amp; properties.containsKey(key)) {</span>
<span class="nc" id="L168">        return properties.get(key);</span>
      }
<span class="fc bfc" id="L170" title="All 2 branches covered.">      if (workflow.getConfigurations().containsKey(key)) {</span>
<span class="fc" id="L171">        return workflow.getConfiguration(key);</span>
      }
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">      if (key.startsWith(&quot;org_&quot;)) {</span>
<span class="nc" id="L174">        return organization.getProperties().get(key.substring(4));</span>
      }
<span class="fc" id="L176">      return null;</span>
    };
<span class="fc" id="L178">    final String executionCondition = WorkflowConditionInterpreter.replaceVariables(</span>
<span class="fc" id="L179">        operation.getExecutionCondition(), variables, null, false);</span>
<span class="fc" id="L180">    operation.setExecutionCondition(executionCondition);</span>
<span class="fc" id="L181">    operation.setDescription(WorkflowConditionInterpreter.replaceVariables(</span>
<span class="fc" id="L182">        operation.getDescription(), variables, null, false));</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">    for (var cfg: operation.getConfigurations().entrySet()) {</span>
<span class="fc" id="L184">      var value = WorkflowConditionInterpreter.replaceVariables(</span>
<span class="fc" id="L185">          cfg.getValue(), variables, null, false);</span>
<span class="fc" id="L186">      operation.setConfiguration(cfg.getKey(), value);</span>
<span class="fc" id="L187">    }</span>

    // Do we need to execute the operation?
<span class="fc" id="L190">    boolean execute = true;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">    if (executionCondition != null) {</span>
      try {
<span class="fc" id="L193">        execute = WorkflowConditionInterpreter.interpret(executionCondition);</span>
<span class="nc" id="L194">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L195">        operation.setState(OperationState.FAILED);</span>
<span class="nc" id="L196">        throw new WorkflowOperationException(</span>
<span class="nc" id="L197">                format(&quot;Unable to parse execution condition '%s'&quot;, executionCondition), e);</span>
<span class="fc" id="L198">      }</span>
    }

<span class="fc" id="L201">    operation.setState(OperationState.RUNNING);</span>
<span class="fc" id="L202">    service.update(workflow);</span>

    try {
<span class="fc" id="L205">      WorkflowOperationResult result = null;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">      if (execute) {</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (handler == null) {</span>
          // If there is no handler for the operation, yet we are supposed to run it, we must fail
<span class="nc" id="L209">          logger.warn(&quot;No handler available to execute operation '{}'&quot;, operation.getTemplate());</span>
<span class="nc" id="L210">          throw new IllegalStateException(&quot;Unable to find a workflow handler for '&quot; + operation.getTemplate() + &quot;'&quot;);</span>
        }
<span class="fc" id="L212">        result = handler.start(workflow, null);</span>
      } else {
        // Allow for null handlers when we are skipping an operation
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (handler != null) {</span>
<span class="fc" id="L216">          result = handler.skip(workflow, null);</span>
<span class="fc" id="L217">          result.setAction(Action.SKIP);</span>
        }
      }
<span class="fc" id="L220">      return result;</span>
<span class="fc" id="L221">    } catch (Exception e) {</span>
<span class="fc" id="L222">      operation.setState(OperationState.FAILED);</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">      if (e instanceof WorkflowOperationException)</span>
<span class="fc" id="L224">        throw (WorkflowOperationException) e;</span>
<span class="nc" id="L225">      throw new WorkflowOperationException(e);</span>
    }
  }

  /**
   * Resumes a previously suspended workflow operation. Note that only workflow operation handlers that implement
   * {@link ResumableWorkflowOperationHandler} can be resumed.
   *
   * @return the workflow operation result
   * @throws WorkflowOperationException
   *           if executing the workflow operation handler fails
   * @throws WorkflowException
   *           if there is a problem processing the workflow
   * @throws IllegalStateException
   *           if the workflow operation cannot be resumed
   */
  public WorkflowOperationResult resume()
          throws WorkflowOperationException, WorkflowException, IllegalStateException, UnauthorizedException {
<span class="fc" id="L243">    WorkflowOperationInstance operation = workflow.getCurrentOperation();</span>

    // Make sure we have a (suitable) handler
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">    if (handler == null) {</span>
      // If there is no handler for the operation, yet we are supposed to run it, we must fail
<span class="nc" id="L248">      logger.warn(&quot;No handler available to resume operation '{}'&quot;, operation.getTemplate());</span>
<span class="nc" id="L249">      throw new IllegalStateException(&quot;Unable to find a workflow handler for '&quot; + operation.getTemplate() + &quot;'&quot;);</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">    } else if (!(handler instanceof ResumableWorkflowOperationHandler)) {</span>
<span class="nc" id="L251">      throw new IllegalStateException(&quot;An attempt was made to resume a non-resumable operation&quot;);</span>
    }

<span class="fc" id="L254">    ResumableWorkflowOperationHandler resumableHandler = (ResumableWorkflowOperationHandler) handler;</span>
<span class="fc" id="L255">    operation.setState(OperationState.RUNNING);</span>
<span class="fc" id="L256">    service.update(workflow);</span>

    try {
<span class="fc" id="L259">      return resumableHandler.resume(workflow, null, properties);</span>
<span class="fc" id="L260">    } catch (Exception e) {</span>
<span class="fc" id="L261">      operation.setState(OperationState.FAILED);</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">      if (e instanceof WorkflowOperationException)</span>
<span class="fc" id="L263">        throw (WorkflowOperationException) e;</span>
<span class="nc" id="L264">      throw new WorkflowOperationException(e);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>