<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>GoogleSpeechTranscriptionService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-transcription-service-google-speech-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.transcription.googlespeech</a> &gt; <span class="el_source">GoogleSpeechTranscriptionService.java</span></div><h1>GoogleSpeechTranscriptionService.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.transcription.googlespeech;

import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.fn.Enrichments;
import org.opencastproject.assetmanager.api.query.AQueryBuilder;
import org.opencastproject.assetmanager.api.query.AResult;
import org.opencastproject.assetmanager.util.Workflows;
import org.opencastproject.job.api.AbstractJobProducer;
import org.opencastproject.job.api.Job;
import org.opencastproject.kernel.mail.SmtpService;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementBuilder;
import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.security.api.DefaultOrganization;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.transcription.api.TranscriptionService;
import org.opencastproject.transcription.api.TranscriptionServiceException;
import org.opencastproject.transcription.persistence.TranscriptionDatabase;
import org.opencastproject.transcription.persistence.TranscriptionDatabaseException;
import org.opencastproject.transcription.persistence.TranscriptionJobControl;
import org.opencastproject.transcription.persistence.TranscriptionProviderControl;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.OsgiUtil;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.data.Option;
import org.opencastproject.workflow.api.ConfiguredWorkflow;
import org.opencastproject.workflow.api.WorkflowDatabaseException;
import org.opencastproject.workflow.api.WorkflowDefinition;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowService;
import org.opencastproject.workingfilerepository.api.WorkingFileRepository;
import org.opencastproject.workspace.api.Workspace;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHeaders;
import org.apache.http.HttpStatus;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Component(
    immediate = true,
    service = { TranscriptionService.class,GoogleSpeechTranscriptionService.class },
    property = {
        &quot;service.description=Google Speech Transcription Service&quot;,
        &quot;provider=google.speech&quot;
    }
)
public class GoogleSpeechTranscriptionService extends AbstractJobProducer implements TranscriptionService {

  /**
   * The logger
   */
<span class="fc" id="L115">  private static final Logger logger = LoggerFactory.getLogger(GoogleSpeechTranscriptionService.class);</span>

  private static final String JOB_TYPE = &quot;org.opencastproject.transcription.googlespeech&quot;;

  static final String TRANSCRIPT_COLLECTION = &quot;transcripts&quot;;
  static final String TRANSCRIPTION_ERROR = &quot;Transcription ERROR&quot;;
  static final String TRANSCRIPTION_JOB_ID_KEY = &quot;transcriptionJobId&quot;;
  static final String ACCESS_TOKEN_NAME = &quot;access_token&quot;;
  static final String ACCESS_TOKEN_EXPIRY_NAME = &quot;expires_in&quot;;
  private static final int CONNECTION_TIMEOUT = 60000; // ms, 1 minute
  private static final int SOCKET_TIMEOUT = 60000; // ms, 1 minute
  private static final int ACCESS_TOKEN_MINIMUM_TIME = 60000; // ms , 1 minute
  // Default workflow to attach transcription results to mediapackage
  public static final String DEFAULT_WF_DEF = &quot;google-speech-attach-transcripts&quot;;
  private static final long DEFAULT_COMPLETION_BUFFER = 300; // in seconds, default is 5 minutes
  private static final long DEFAULT_DISPATCH_INTERVAL = 60; // in seconds, default is 1 minute
  private static final long DEFAULT_MAX_PROCESSING_TIME = 5 * 60 * 60; // in seconds, default is 5 hours
  // Cleans up results files that are older than 7 days
  private static final int DEFAULT_CLEANUP_RESULTS_DAYS = 7;
  private static final boolean DEFAULT_PROFANITY_FILTER = false;
  private static final String DEFAULT_LANGUAGE = &quot;en-US&quot;;
  private static final boolean DEFAULT_ENABLE_PUNCTUATION = false;
  private static final String DEFAULT_MODEL = &quot;default&quot;;
  private static final String GOOGLE_SPEECH_URL = &quot;https://speech.googleapis.com/v1&quot;;
  private static final String GOOGLE_AUTH2_URL = &quot;https://www.googleapis.com/oauth2/v4/token&quot;;
  private static final String REQUEST_METHOD = &quot;speech:longrunningrecognize&quot;;
  private static final String RESULT_PATH = &quot;operations&quot;;
  private static final String INVALID_TOKEN = &quot;-1&quot;;
  private static final String PROVIDER = &quot;Google Speech&quot;;
  private static final String DEFAULT_ENCODING = &quot;flac&quot;;

  // Cluster name
<span class="fc" id="L147">  private String clusterName = &quot;&quot;;</span>

  /**
   * Service dependencies
   */
  private ServiceRegistry serviceRegistry;
  private SecurityService securityService;
  private UserDirectoryService userDirectoryService;
  private OrganizationDirectoryService organizationDirectoryService;
  private Workspace workspace;
  private TranscriptionDatabase database;
  private AssetManager assetManager;
  private WorkflowService workflowService;
  private WorkingFileRepository wfr;
  private SmtpService smtpService;

  // Only used by unit tests!
  private Workflows wfUtil;

<span class="nc" id="L166">  private enum Operation {</span>
<span class="nc" id="L167">    StartTranscription</span>
  }

  /**
   * Service configuration options
   */
  public static final String ENABLED_CONFIG = &quot;enabled&quot;;
  public static final String GOOGLE_SPEECH_LANGUAGE = &quot;google.speech.language&quot;;
  public static final String PROFANITY_FILTER = &quot;google.speech.profanity.filter&quot;;
  public static final String ENABLE_PUNCTUATION = &quot;google.speech.transcription.punctuation&quot;;
  public static final String TRANSCRIPTION_MODEL = &quot;google.speech.transcription.model&quot;;
  public static final String WORKFLOW_CONFIG = &quot;workflow&quot;;
  public static final String DISPATCH_WORKFLOW_INTERVAL_CONFIG = &quot;workflow.dispatch.interval&quot;;
  public static final String COMPLETION_CHECK_BUFFER_CONFIG = &quot;completion.check.buffer&quot;;
  public static final String MAX_PROCESSING_TIME_CONFIG = &quot;max.processing.time&quot;;
  public static final String NOTIFICATION_EMAIL_CONFIG = &quot;notification.email&quot;;
  public static final String CLEANUP_RESULTS_DAYS_CONFIG = &quot;cleanup.results.days&quot;;
  public static final String GOOGLE_CLOUD_CLIENT_ID = &quot;google.cloud.client.id&quot;;
  public static final String GOOGLE_CLOUD_CLIENT_SECRET = &quot;google.cloud.client.secret&quot;;
  public static final String GOOGLE_CLOUD_REFRESH_TOKEN = &quot;google.cloud.refresh.token&quot;;
  public static final String GOOGLE_CLOUD_BUCKET = &quot;google.cloud.storage.bucket&quot;;
  public static final String GOOGLE_CLOUD_TOKEN_ENDPOINT_URL = &quot;google.cloud.token.endpoint.url&quot;;
  public static final String ENCODING_EXTENSION = &quot;encoding.extension&quot;;

  /**
   * Service configuration values
   */
<span class="fc" id="L194">  private boolean enabled = false; // Disabled by default</span>
<span class="fc" id="L195">  private boolean profanityFilter = DEFAULT_PROFANITY_FILTER;</span>
<span class="fc" id="L196">  private boolean enablePunctuation = DEFAULT_ENABLE_PUNCTUATION;</span>
<span class="fc" id="L197">  private String model = DEFAULT_MODEL;</span>
<span class="fc" id="L198">  private String defaultLanguage = DEFAULT_LANGUAGE;</span>
<span class="fc" id="L199">  private String defaultEncoding = DEFAULT_ENCODING;</span>
<span class="fc" id="L200">  private String workflowDefinitionId = DEFAULT_WF_DEF;</span>
<span class="fc" id="L201">  private long workflowDispatchInterval = DEFAULT_DISPATCH_INTERVAL;</span>
<span class="fc" id="L202">  private long completionCheckBuffer = DEFAULT_COMPLETION_BUFFER;</span>
<span class="fc" id="L203">  private long maxProcessingSeconds = DEFAULT_MAX_PROCESSING_TIME;</span>
  private String toEmailAddress;
<span class="fc" id="L205">  private int cleanupResultDays = DEFAULT_CLEANUP_RESULTS_DAYS;</span>
  private String clientId;
  private String clientSecret;
  private String clientToken;
<span class="fc" id="L209">  private String accessToken = INVALID_TOKEN;</span>
<span class="fc" id="L210">  private String tokenEndpoint = GOOGLE_AUTH2_URL;</span>
  private String storageBucket;
<span class="fc" id="L212">  private long tokenExpiryTime = 0;</span>
  private String systemAccount;
<span class="fc" id="L214">  private ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(2);</span>

  public GoogleSpeechTranscriptionService() {
<span class="fc" id="L217">    super(JOB_TYPE);</span>
<span class="fc" id="L218">  }</span>

  @Activate
  public void activate(ComponentContext cc) {
    // Has this service been enabled?
<span class="fc" id="L223">    enabled = OsgiUtil.getOptCfgAsBoolean(cc.getProperties(), ENABLED_CONFIG).get();</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">    if (!enabled) {</span>
<span class="nc" id="L225">      logger.info(&quot;Service disabled. If you want to enable it, please update the service configuration.&quot;);</span>
<span class="nc" id="L226">      return;</span>
    }
    // Mandatory API access properties
<span class="fc" id="L229">    clientId = OsgiUtil.getComponentContextProperty(cc, GOOGLE_CLOUD_CLIENT_ID);</span>
<span class="fc" id="L230">    clientSecret = OsgiUtil.getComponentContextProperty(cc, GOOGLE_CLOUD_CLIENT_SECRET);</span>
<span class="fc" id="L231">    clientToken = OsgiUtil.getComponentContextProperty(cc, GOOGLE_CLOUD_REFRESH_TOKEN);</span>
<span class="fc" id="L232">    storageBucket = OsgiUtil.getComponentContextProperty(cc, GOOGLE_CLOUD_BUCKET);</span>

    // access token endpoint
<span class="fc" id="L235">    Option&lt;String&gt; tokenOpt = OsgiUtil.getOptCfg(cc.getProperties(), GOOGLE_CLOUD_TOKEN_ENDPOINT_URL);</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">    if (tokenOpt.isSome()) {</span>
<span class="nc" id="L237">      tokenEndpoint = tokenOpt.get();</span>
<span class="nc" id="L238">      logger.info(&quot;Access token endpoint is set to {}&quot;, tokenEndpoint);</span>
    } else {
<span class="fc" id="L240">      logger.info(&quot;Default access token endpoint will be used&quot;);</span>
    }

    // profanity filter to use
<span class="fc" id="L244">    Option&lt;String&gt; profanityOpt = OsgiUtil.getOptCfg(cc.getProperties(), PROFANITY_FILTER);</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">    if (profanityOpt.isSome()) {</span>
<span class="nc" id="L246">      profanityFilter = Boolean.parseBoolean(profanityOpt.get());</span>
<span class="nc" id="L247">      logger.info(&quot;Profanity filter is set to {}&quot;, profanityFilter);</span>
    } else {
<span class="fc" id="L249">      logger.info(&quot;Default profanity filter will be used&quot;);</span>
    }
    // Language model to be used
<span class="fc" id="L252">    Option&lt;String&gt; languageOpt = OsgiUtil.getOptCfg(cc.getProperties(), GOOGLE_SPEECH_LANGUAGE);</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">    if (languageOpt.isSome()) {</span>
<span class="nc" id="L254">      defaultLanguage = languageOpt.get();</span>
<span class="nc" id="L255">      logger.info(&quot;Language used is {}&quot;, defaultLanguage);</span>
    } else {
<span class="fc" id="L257">      logger.info(&quot;Default language will be used&quot;);</span>
    }
    // Enable punctuation or not
<span class="fc" id="L260">    Option&lt;String&gt; punctuationOpt = OsgiUtil.getOptCfg(cc.getProperties(), ENABLE_PUNCTUATION);</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">    if (punctuationOpt.isSome()) {</span>
<span class="nc" id="L262">      enablePunctuation = Boolean.parseBoolean(punctuationOpt.get());</span>
<span class="nc" id="L263">      logger.info(&quot;Enable punctuation is set to {}&quot;, enablePunctuation);</span>
    } else {
<span class="fc" id="L265">      logger.info(&quot;Default punctuation setting will be used&quot;);</span>
    }
    // Transription model to be used
<span class="fc" id="L268">    Option&lt;String&gt; transModel = OsgiUtil.getOptCfg(cc.getProperties(), TRANSCRIPTION_MODEL);</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">    if (transModel.isSome()) {</span>
<span class="nc" id="L270">      model = transModel.get();</span>
<span class="nc" id="L271">      logger.info(&quot;Transcription model used is {}&quot;, model);</span>
    } else {
<span class="fc" id="L273">      logger.info(&quot;Default Transcription model will be used&quot;);</span>
    }
    // Encoding to be used
<span class="fc" id="L276">    Option&lt;String&gt; encodingOpt = OsgiUtil.getOptCfg(cc.getProperties(), ENCODING_EXTENSION);</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">    if (encodingOpt.isSome()) {</span>
<span class="nc" id="L278">      defaultEncoding = encodingOpt.get();</span>
<span class="nc" id="L279">      logger.info(&quot;Encoding used is {}&quot;, defaultEncoding);</span>
    } else {
<span class="fc" id="L281">      logger.info(&quot;Default encoding will be used&quot;);</span>
    }

    // Workflow to execute when getting callback (optional, with default)
<span class="fc" id="L285">    Option&lt;String&gt; wfOpt = OsgiUtil.getOptCfg(cc.getProperties(), WORKFLOW_CONFIG);</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">    if (wfOpt.isSome()) {</span>
<span class="nc" id="L287">      workflowDefinitionId = wfOpt.get();</span>
    }
<span class="fc" id="L289">    logger.info(&quot;Workflow definition is {}&quot;, workflowDefinitionId);</span>
    // Interval to check for completed transcription jobs and start workflows to attach transcripts
<span class="fc" id="L291">    Option&lt;String&gt; intervalOpt = OsgiUtil.getOptCfg(cc.getProperties(), DISPATCH_WORKFLOW_INTERVAL_CONFIG);</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">    if (intervalOpt.isSome()) {</span>
      try {
<span class="nc" id="L294">        workflowDispatchInterval = Long.parseLong(intervalOpt.get());</span>
<span class="nc" id="L295">      } catch (NumberFormatException e) {</span>
        // Use default
<span class="nc" id="L297">        logger.warn(&quot;Invalid configuration for Workflow dispatch interval. Default used instead: {}&quot;,</span>
<span class="nc" id="L298">            workflowDispatchInterval);</span>
<span class="nc" id="L299">      }</span>
    }
<span class="fc" id="L301">    logger.info(&quot;Workflow dispatch interval is {} seconds&quot;, workflowDispatchInterval);</span>
    // How long to wait after a transcription is supposed to finish before starting checking
<span class="fc" id="L303">    Option&lt;String&gt; bufferOpt = OsgiUtil.getOptCfg(cc.getProperties(), COMPLETION_CHECK_BUFFER_CONFIG);</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">    if (bufferOpt.isSome()) {</span>
      try {
<span class="fc" id="L306">        completionCheckBuffer = Long.parseLong(bufferOpt.get());</span>
<span class="nc" id="L307">      } catch (NumberFormatException e) {</span>
        // Use default
<span class="nc" id="L309">        logger.warn(&quot;Invalid configuration for {} : {}. Default used instead: {}&quot;,</span>
<span class="nc" id="L310">                new Object[]{COMPLETION_CHECK_BUFFER_CONFIG, bufferOpt.get(), completionCheckBuffer});</span>
<span class="fc" id="L311">      }</span>
    }
<span class="fc" id="L313">    logger.info(&quot;Completion check buffer is {} seconds&quot;, completionCheckBuffer);</span>
    // How long to wait after a transcription is supposed to finish before marking the job as canceled in the db
<span class="fc" id="L315">    Option&lt;String&gt; maxProcessingOpt = OsgiUtil.getOptCfg(cc.getProperties(), MAX_PROCESSING_TIME_CONFIG);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">    if (maxProcessingOpt.isSome()) {</span>
      try {
<span class="fc" id="L318">        maxProcessingSeconds = Long.parseLong(maxProcessingOpt.get());</span>
<span class="nc" id="L319">      } catch (NumberFormatException e) {</span>
        // Use default
<span class="nc" id="L321">        logger.warn(&quot;Invalid configuration for maximum processing time. Default used instead: {}&quot;,</span>
<span class="nc" id="L322">            maxProcessingSeconds);</span>
<span class="fc" id="L323">      }</span>
    }
<span class="fc" id="L325">    logger.info(&quot;Maximum time a job is checked after it should have ended is {} seconds&quot;, maxProcessingSeconds);</span>
    // How long to keep result files in the working file repository
<span class="fc" id="L327">    Option&lt;String&gt; cleaupOpt = OsgiUtil.getOptCfg(cc.getProperties(), CLEANUP_RESULTS_DAYS_CONFIG);</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">    if (cleaupOpt.isSome()) {</span>
      try {
<span class="nc" id="L330">        cleanupResultDays = Integer.parseInt(cleaupOpt.get());</span>
<span class="nc" id="L331">      } catch (NumberFormatException e) {</span>
        // Use default
<span class="nc" id="L333">        logger.warn(&quot;Invalid configuration for clean up days. Default used instead: {}&quot;, cleanupResultDays);</span>
<span class="nc" id="L334">      }</span>
    }
<span class="fc" id="L336">    logger.info(&quot;Cleanup result files after {} days&quot;, cleanupResultDays);</span>

<span class="fc" id="L338">    systemAccount = OsgiUtil.getContextProperty(cc, OpencastConstants.DIGEST_USER_PROPERTY);</span>

    // Schedule the workflow dispatching, starting in 2 minutes
<span class="fc" id="L341">    scheduledExecutor.scheduleWithFixedDelay(new WorkflowDispatcher(), 120, workflowDispatchInterval,</span>
            TimeUnit.SECONDS);

    // Schedule the cleanup of old results jobs from the collection in the wfr once a day
<span class="fc" id="L345">    scheduledExecutor.scheduleWithFixedDelay(new ResultsFileCleanup(), 1, 1, TimeUnit.DAYS);</span>

    // Notification email passed in this service configuration?
<span class="fc" id="L348">    Option&lt;String&gt; optTo = OsgiUtil.getOptCfg(cc.getProperties(), NOTIFICATION_EMAIL_CONFIG);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">    if (optTo.isSome()) {</span>
<span class="fc" id="L350">      toEmailAddress = optTo.get();</span>
    } else {
      // Use admin email informed in custom.properties
<span class="nc" id="L353">      optTo = OsgiUtil.getOptContextProperty(cc, OpencastConstants.ADMIN_EMAIL_PROPERTY);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">      if (optTo.isSome()) {</span>
<span class="nc" id="L355">        toEmailAddress = optTo.get();</span>
      }
    }
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">    if (toEmailAddress != null) {</span>
<span class="fc" id="L359">      logger.info(&quot;Notification email set to {}&quot;, toEmailAddress);</span>
    } else {
<span class="nc" id="L361">      logger.warn(&quot;Email notification disabled&quot;);</span>
    }

<span class="fc" id="L364">    Option&lt;String&gt; optCluster = OsgiUtil.getOptContextProperty(cc, OpencastConstants.ENVIRONMENT_NAME_PROPERTY);</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">    if (optCluster.isSome()) {</span>
<span class="nc" id="L366">      clusterName = optCluster.get();</span>
    }
<span class="fc" id="L368">    logger.info(&quot;Environment name is {}&quot;, clusterName);</span>

<span class="fc" id="L370">    logger.info(&quot;Activated!&quot;);</span>
<span class="fc" id="L371">  }</span>

  @Override
  public Job startTranscription(String mpId, Track track, String... args) throws TranscriptionServiceException {
<span class="nc bnc" id="L375" title="All 2 branches missed.">    if (!enabled) {</span>
<span class="nc" id="L376">      throw new TranscriptionServiceException(</span>
              &quot;This service is disabled. If you want to enable it, please update the service configuration.&quot;);
    }

<span class="nc bnc" id="L380" title="All 2 branches missed.">    if (args.length == 0) {</span>
<span class="nc" id="L381">      throw new IllegalArgumentException(&quot;Additional language argument is required.&quot;);</span>
    }

    try {
<span class="nc" id="L385">      return serviceRegistry.createJob(JOB_TYPE, Operation.StartTranscription.name(),</span>
<span class="nc" id="L386">              Arrays.asList(mpId, MediaPackageElementParser.getAsXml(track), args[0]));</span>
<span class="nc" id="L387">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L388">      throw new TranscriptionServiceException(&quot;Unable to create a job&quot;, e);</span>
<span class="nc" id="L389">    } catch (MediaPackageException e) {</span>
<span class="nc" id="L390">      throw new TranscriptionServiceException(&quot;Invalid track &quot; + track.toString(), e);</span>
    }
  }

  @Override
  public Job startTranscription(String mpId, Track track) throws TranscriptionServiceException {
<span class="nc" id="L396">    throw new UnsupportedOperationException(&quot;Not supported.&quot;);</span>
  }

  @Override
  public void transcriptionDone(String mpId, Object obj) throws TranscriptionServiceException {
<span class="fc" id="L401">    JSONObject jsonObj = null;</span>
<span class="fc" id="L402">    String jobId = null;</span>
<span class="fc" id="L403">    String token = INVALID_TOKEN;</span>
    try {
<span class="fc" id="L405">      token = getRefreshAccessToken();</span>
<span class="nc" id="L406">    } catch (IOException ex) {</span>
<span class="nc" id="L407">      logger.error(&quot;Unable to create access token, error: {}&quot;, ex.toString());</span>
<span class="fc" id="L408">    }</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">    if (token.equals(INVALID_TOKEN)) {</span>
<span class="nc" id="L410">      throw new TranscriptionServiceException(&quot;Invalid access token&quot;);</span>
    }
    try {
<span class="fc" id="L413">      jsonObj = (JSONObject) obj;</span>
<span class="fc" id="L414">      jobId = (String) jsonObj.get(&quot;name&quot;);</span>
<span class="fc" id="L415">      logger.info(&quot;Transcription done for mpId {}, jobId {}&quot;, mpId, jobId);</span>
<span class="fc" id="L416">      JSONArray resultsArray = getTranscriptionResult(jsonObj);</span>

      // Update state in database
      // If there's an optimistic lock exception here, it's ok because the workflow dispatcher
      // may be doing the same thing
<span class="fc" id="L421">      database.updateJobControl(jobId, TranscriptionJobControl.Status.TranscriptionComplete.name());</span>

      // Delete audio file from Google storage
<span class="fc" id="L424">      deleteStorageFile(mpId, token);</span>

      // Save results in file system if they exist
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">      if (resultsArray != null) {</span>
<span class="fc" id="L428">        saveResults(jobId, jsonObj);</span>
      }
<span class="nc" id="L430">    } catch (IOException e) {</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">      if (jsonObj == null) {</span>
<span class="nc" id="L432">        logger.warn(&quot;Could not save transcription results file for mpId {}, jobId {}: null&quot;,</span>
                mpId, jobId);
      } else {
<span class="nc" id="L435">        logger.warn(&quot;Could not save transcription results file for mpId {}, jobId {}: {}&quot;,</span>
<span class="nc" id="L436">                mpId, jobId, jsonObj.toJSONString());</span>
      }
<span class="nc" id="L438">      throw new TranscriptionServiceException(&quot;Could not save transcription results file&quot;, e);</span>
<span class="nc" id="L439">    } catch (TranscriptionDatabaseException e) {</span>
<span class="nc" id="L440">      logger.warn(&quot;Transcription results file were saved but state in db not updated for mpId {}, jobId {}&quot;, mpId,</span>
              jobId);
<span class="nc" id="L442">      throw new TranscriptionServiceException(&quot;Could not update transcription job control db&quot;, e);</span>
<span class="fc" id="L443">    }</span>
<span class="fc" id="L444">  }</span>

  @Override
  public String getLanguage() {
<span class="nc" id="L448">    return defaultLanguage;</span>
  }

  @Override
  public Map&lt;String, Object&gt; getReturnValues(String mpId, String jobId) throws TranscriptionServiceException {
<span class="nc" id="L453">    throw new TranscriptionServiceException(&quot;Method not implemented&quot;);</span>
  }

  @Override
  public void transcriptionError(String mpId, Object obj) throws TranscriptionServiceException {
<span class="fc" id="L458">    JSONObject jsonObj = null;</span>
<span class="fc" id="L459">    String jobId = null;</span>
    try {
<span class="fc" id="L461">      jsonObj = (JSONObject) obj;</span>
<span class="fc" id="L462">      jobId = (String) jsonObj.get(&quot;name&quot;);</span>
      // Update state in database
<span class="fc" id="L464">      database.updateJobControl(jobId, TranscriptionJobControl.Status.Error.name());</span>
<span class="fc" id="L465">      TranscriptionJobControl jobControl = database.findByJob(jobId);</span>
<span class="fc" id="L466">      logger.warn(&quot;Error received for media package {}, job id {}&quot;,</span>
<span class="fc" id="L467">              jobControl.getMediaPackageId(), jobId);</span>
      // Send notification email
<span class="fc" id="L469">      sendEmail(TRANSCRIPTION_ERROR,</span>
<span class="fc" id="L470">              String.format(&quot;There was a transcription error for for media package %s, job id %s.&quot;,</span>
<span class="fc" id="L471">                      jobControl.getMediaPackageId(), jobId));</span>
<span class="nc" id="L472">    } catch (TranscriptionDatabaseException e) {</span>
<span class="nc" id="L473">      logger.warn(&quot;Transcription error. State in db could not be updated to error for mpId {}, jobId {}&quot;, mpId, jobId);</span>
<span class="nc" id="L474">      throw new TranscriptionServiceException(&quot;Could not update transcription job control db&quot;, e);</span>
<span class="fc" id="L475">    }</span>
<span class="fc" id="L476">  }</span>

  @Override
  protected String process(Job job) throws Exception {
<span class="nc" id="L480">    Operation op = null;</span>
<span class="nc" id="L481">    String operation = job.getOperation();</span>
<span class="nc" id="L482">    List&lt;String&gt; arguments = job.getArguments();</span>
<span class="nc" id="L483">    String result = &quot;&quot;;</span>
<span class="nc" id="L484">    op = Operation.valueOf(operation);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">    switch (op) {</span>
      case StartTranscription:
<span class="nc" id="L487">        String mpId = arguments.get(0);</span>
<span class="nc" id="L488">        Track track = (Track) MediaPackageElementParser.getFromXml(arguments.get(1));</span>
<span class="nc" id="L489">        String languageCode = arguments.get(2);</span>
<span class="nc" id="L490">        createRecognitionsJob(mpId, track, languageCode);</span>
<span class="nc" id="L491">        break;</span>
      default:
<span class="nc" id="L493">        throw new IllegalStateException(&quot;Don't know how to handle operation '&quot; + operation + &quot;'&quot;);</span>
    }
<span class="nc" id="L495">    return result;</span>
  }

  /**
   * Asynchronous Requests and Responses call to Google Speech API
   * https://cloud.google.com/speech-to-text/docs/basics
   */
  void createRecognitionsJob(String mpId, Track track, String languageCode)
          throws TranscriptionServiceException, IOException {
    // Use default defaultlanguage if not set by workflow
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">    if (StringUtils.isBlank(languageCode)) {</span>
<span class="nc" id="L506">      languageCode = defaultLanguage;</span>
    }
    String audioUrl;
<span class="fc" id="L509">    audioUrl = uploadAudioFileToGoogleStorage(mpId, track);</span>
<span class="fc" id="L510">    CloseableHttpClient httpClient = makeHttpClient();</span>
<span class="fc" id="L511">    CloseableHttpResponse response = null;</span>
<span class="fc" id="L512">    String token = getRefreshAccessToken();</span>
<span class="pc bpc" id="L513" title="2 of 4 branches missed.">    if (token.equals(INVALID_TOKEN) || audioUrl == null) {</span>
<span class="nc" id="L514">      throw new TranscriptionServiceException(&quot;Could not create recognition job. Audio file or access token invalid&quot;);</span>
    }

    // Create json for configuration and audio file 
<span class="fc" id="L518">    JSONObject configValues = new JSONObject();</span>
<span class="fc" id="L519">    JSONObject audioValues = new JSONObject();</span>
<span class="fc" id="L520">    JSONObject container = new JSONObject();</span>
<span class="fc" id="L521">    configValues.put(&quot;languageCode&quot;, languageCode);</span>
<span class="fc" id="L522">    configValues.put(&quot;enableWordTimeOffsets&quot;, true);</span>
<span class="fc" id="L523">    configValues.put(&quot;profanityFilter&quot;, profanityFilter);</span>
<span class="fc" id="L524">    configValues.put(&quot;enableAutomaticPunctuation&quot;, enablePunctuation);</span>
<span class="fc" id="L525">    configValues.put(&quot;model&quot;, model);</span>
<span class="fc" id="L526">    audioValues.put(&quot;uri&quot;, audioUrl);</span>
<span class="fc" id="L527">    container.put(&quot;config&quot;, configValues);</span>
<span class="fc" id="L528">    container.put(&quot;audio&quot;, audioValues);</span>

    try {
<span class="fc" id="L531">      HttpPost httpPost = new HttpPost(UrlSupport.concat(GOOGLE_SPEECH_URL, REQUEST_METHOD));</span>
<span class="fc" id="L532">      logger.debug(&quot;Url to invoke Google speech service: {}&quot;, httpPost.getURI().toString());</span>
<span class="fc" id="L533">      StringEntity params = new StringEntity(container.toJSONString());</span>
<span class="fc" id="L534">      httpPost.addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + token); // add the authorization header to the request;</span>
<span class="fc" id="L535">      httpPost.addHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json; charset=utf-8&quot;);</span>
<span class="fc" id="L536">      httpPost.setEntity(params);</span>
<span class="fc" id="L537">      response = httpClient.execute(httpPost);</span>
<span class="fc" id="L538">      int code = response.getStatusLine().getStatusCode();</span>
<span class="fc" id="L539">      HttpEntity entity = response.getEntity();</span>
<span class="fc" id="L540">      String jsonString = EntityUtils.toString(response.getEntity());</span>
<span class="fc" id="L541">      JSONParser jsonParser = new JSONParser();</span>
<span class="fc" id="L542">      JSONObject jsonObject = (JSONObject) jsonParser.parse(jsonString);</span>

<span class="pc bpc" id="L544" title="1 of 2 branches missed.">      switch (code) {</span>
        case HttpStatus.SC_OK: // 200
<span class="fc" id="L546">          logger.info(&quot;Recognitions job has been successfully created&quot;);</span>

          /**
           * Response returned is a json object: { &quot;name&quot;:
           * &quot;7612202767953098924&quot;, &quot;metadata&quot;: { &quot;@type&quot;:
           * &quot;type.googleapis.com/google.cloud.speech.v1.LongRunningRecognizeMetadata&quot;,
           * &quot;progressPercent&quot;: 90, &quot;startTime&quot;: &quot;2017-07-20T16:36:55.033650Z&quot;,
           * &quot;lastUpdateTime&quot;: &quot;2017-07-20T16:37:17.158630Z&quot; } }
           */
<span class="fc" id="L555">          String jobId = (String) jsonObject.get(&quot;name&quot;);</span>
<span class="fc" id="L556">          logger.info(</span>
                  &quot;Transcription for mp {} has been submitted. Job id: {}&quot;, mpId,
                  jobId);

<span class="fc" id="L560">          database.storeJobControl(mpId, track.getIdentifier(), jobId, TranscriptionJobControl.Status.InProgress.name(),</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">                  track.getDuration() == null ? 0 : track.getDuration().longValue(), null, PROVIDER);</span>
<span class="fc" id="L562">          EntityUtils.consume(entity);</span>
<span class="fc" id="L563">          return;</span>
        default:
<span class="nc" id="L565">          JSONObject errorObj = (JSONObject) jsonObject.get(&quot;error&quot;);</span>
<span class="nc" id="L566">          logger.warn(&quot;Invalid argument returned, status: {} with message: {}&quot;, code, (String) errorObj.get(&quot;message&quot;));</span>
          break;
      }
<span class="nc" id="L569">      throw new TranscriptionServiceException(&quot;Could not create recognition job. Status returned: &quot; + code);</span>
<span class="fc" id="L570">    } catch (Exception e) {</span>
<span class="fc" id="L571">      logger.warn(&quot;Exception when calling the recognitions endpoint&quot;, e);</span>
<span class="fc" id="L572">      throw new TranscriptionServiceException(&quot;Exception when calling the recognitions endpoint&quot;, e);</span>
    } finally {
      try {
<span class="fc" id="L575">        httpClient.close();</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">        if (response != null) {</span>
<span class="fc" id="L577">          response.close();</span>
        }
<span class="nc" id="L579">      } catch (IOException e) {</span>
<span class="fc" id="L580">      }</span>
    }
  }

  /**
   * Get transcription job result: GET /v1/operations/{name}
   *
   * &quot;response&quot;: { &quot;@type&quot;:
   * &quot;type.googleapis.com/google.cloud.speech.v1.LongRunningRecognizeResponse&quot;,
   * &quot;results&quot;: [ { &quot;alternatives&quot;: [ { &quot;transcript&quot;: &quot;Four score and
   * twenty...&quot;, &quot;confidence&quot;: 0.97186122, &quot;words&quot;: [ { &quot;startTime&quot;: &quot;1.300s&quot;,
   * &quot;endTime&quot;: &quot;1.400s&quot;, &quot;word&quot;: &quot;Four&quot; }, { &quot;startTime&quot;: &quot;1.400s&quot;, &quot;endTime&quot;:
   * &quot;1.600s&quot;, &quot;word&quot;: &quot;score&quot; }, { &quot;startTime&quot;: &quot;1.600s&quot;, &quot;endTime&quot;: &quot;1.600s&quot;,
   * &quot;word&quot;: &quot;and&quot; }, { &quot;startTime&quot;: &quot;1.600s&quot;, &quot;endTime&quot;: &quot;1.900s&quot;, &quot;word&quot;:
   * &quot;twenty&quot; }, ] } ] }
   */
  boolean getAndSaveJobResults(String jobId) throws TranscriptionServiceException, IOException {
<span class="fc" id="L597">    CloseableHttpClient httpClient = makeHttpClient();</span>
<span class="fc" id="L598">    CloseableHttpResponse response = null;</span>
<span class="fc" id="L599">    String mpId = &quot;unknown&quot;;</span>
<span class="fc" id="L600">    JSONArray resultsArray = null;</span>
<span class="fc" id="L601">    String token = getRefreshAccessToken();</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">    if (token.equals(INVALID_TOKEN)) {</span>
<span class="nc" id="L603">      return false;</span>
    }
    try {
<span class="fc" id="L606">      HttpGet httpGet = new HttpGet(UrlSupport.concat(GOOGLE_SPEECH_URL, RESULT_PATH, jobId));</span>
<span class="fc" id="L607">      logger.debug(&quot;Url to invoke Google speech service: {}&quot;, httpGet.getURI().toString());</span>
      // add the authorization header to the request;
<span class="fc" id="L609">      httpGet.addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + token);</span>
<span class="fc" id="L610">      response = httpClient.execute(httpGet);</span>
<span class="fc" id="L611">      int code = response.getStatusLine().getStatusCode();</span>

<span class="pc bpc" id="L613" title="2 of 4 branches missed.">      switch (code) {</span>
        case HttpStatus.SC_OK: // 200
<span class="fc" id="L615">          HttpEntity entity = response.getEntity();</span>
          // Response returned is a json object described above
<span class="fc" id="L617">          String jsonString = EntityUtils.toString(entity);</span>
<span class="fc" id="L618">          JSONParser jsonParser = new JSONParser();</span>
<span class="fc" id="L619">          JSONObject jsonObject = (JSONObject) jsonParser.parse(jsonString);</span>
<span class="fc" id="L620">          Boolean jobDone = (Boolean) jsonObject.get(&quot;done&quot;);</span>
<span class="fc" id="L621">          TranscriptionJobControl jc = database.findByJob(jobId);</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">          if (jc != null) {</span>
<span class="fc" id="L623">            mpId = jc.getMediaPackageId();</span>
          }
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">          if (jobDone) {</span>
<span class="fc" id="L626">            resultsArray = getTranscriptionResult(jsonObject);</span>
          }
<span class="fc" id="L628">          logger.info(&quot;Recognitions job {} has been found, completed status {}&quot;, jobId, jobDone.toString());</span>
<span class="fc" id="L629">          EntityUtils.consume(entity);</span>

<span class="pc bpc" id="L631" title="2 of 4 branches missed.">          if (jobDone &amp;&amp; resultsArray != null) {</span>
<span class="fc" id="L632">            transcriptionDone(mpId, jsonObject);</span>
<span class="fc" id="L633">            return true;</span>
          }
<span class="nc" id="L635">          return false;</span>
        case HttpStatus.SC_NOT_FOUND: // 404
<span class="nc" id="L637">          logger.warn(&quot;Job not found: {}&quot;, jobId);</span>
<span class="nc" id="L638">          break;</span>
        case HttpStatus.SC_SERVICE_UNAVAILABLE: // 503
<span class="fc" id="L640">          logger.warn(&quot;Service unavailable returned, status: {}&quot;, code);</span>
<span class="fc" id="L641">          break;</span>
        default:
<span class="nc" id="L643">          logger.warn(&quot;Error return status: {}.&quot;, code);</span>
          break;
      }
<span class="fc" id="L646">      throw new TranscriptionServiceException(</span>
<span class="fc" id="L647">              String.format(&quot;Could not check recognition job for media package %s, job id %s. Status returned: %d&quot;,</span>
<span class="fc" id="L648">                      mpId, jobId, code), code);</span>
<span class="fc" id="L649">    } catch (TranscriptionServiceException e) {</span>
<span class="fc" id="L650">      throw e;</span>
<span class="nc" id="L651">    } catch (Exception e) {</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">      if (hasTranscriptionRequestExpired(jobId)) {</span>
        // Cancel the job and inform admin
<span class="nc" id="L654">        cancelTranscription(jobId, &quot;Google Transcription job canceled due to errors&quot;);</span>
<span class="nc" id="L655">        logger.info(&quot;Google Transcription job {} has been canceled. Email notification sent&quot;, jobId);</span>
      }
<span class="nc" id="L657">      String msg = String.format(&quot;Exception when calling the recognitions endpoint for media package %s, job id %s&quot;,</span>
              mpId, jobId);
<span class="nc" id="L659">      logger.warn(msg, e);</span>
<span class="nc" id="L660">      throw new TranscriptionServiceException(String.format(</span>
              &quot;Exception when calling the recognitions endpoint for media package %s, job id %s&quot;, mpId, jobId), e);
    } finally {
      try {
<span class="fc" id="L664">        httpClient.close();</span>
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">        if (response != null) {</span>
<span class="fc" id="L666">          response.close();</span>
        }
<span class="nc" id="L668">      } catch (IOException e) {</span>
<span class="fc" id="L669">      }</span>
    }
  }

  /**
   * Get transcription result: GET /v1/operations/{name} Method mainly used by
   * the REST endpoint
   *
   * @param jobId
   * @return job details
   * @throws org.opencastproject.transcription.api.TranscriptionServiceException
   * @throws java.io.IOException
   */
  public String getTranscriptionResults(String jobId)
          throws TranscriptionServiceException, IOException {
<span class="nc" id="L684">    CloseableHttpClient httpClient = makeHttpClient();</span>
<span class="nc" id="L685">    CloseableHttpResponse response = null;</span>
<span class="nc" id="L686">    String token = getRefreshAccessToken();</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">    if (token.equals(INVALID_TOKEN)) {</span>
<span class="nc" id="L688">      logger.warn(&quot;Invalid access token&quot;);</span>
<span class="nc" id="L689">      return &quot;No results found&quot;;</span>
    }
    try {
<span class="nc" id="L692">      HttpGet httpGet = new HttpGet(UrlSupport.concat(GOOGLE_SPEECH_URL, RESULT_PATH, jobId));</span>
<span class="nc" id="L693">      logger.debug(&quot;Url to invoke Google speech service: {}&quot;, httpGet.getURI().toString());</span>
      // add the authorization header to the request;
<span class="nc" id="L695">      httpGet.addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + token);</span>
<span class="nc" id="L696">      response = httpClient.execute(httpGet);</span>
<span class="nc" id="L697">      int code = response.getStatusLine().getStatusCode();</span>

<span class="nc bnc" id="L699" title="All 2 branches missed.">      switch (code) {</span>
        case HttpStatus.SC_OK: // 200
<span class="nc" id="L701">          HttpEntity entity = response.getEntity();</span>
<span class="nc" id="L702">          logger.info(&quot;Retrieved details for transcription with job id: '{}'&quot;, jobId);</span>
<span class="nc" id="L703">          return EntityUtils.toString(entity);</span>
        default:
<span class="nc" id="L705">          logger.warn(&quot;Error retrieving details for transcription with job id: '{}', return status: {}.&quot;, jobId, code);</span>
          break;
      }
<span class="nc" id="L708">    } catch (Exception e) {</span>
<span class="nc" id="L709">      logger.warn(&quot;Exception when calling the transcription service for job id: {}&quot;, jobId, e);</span>
<span class="nc" id="L710">      throw new TranscriptionServiceException(String.format(</span>
              &quot;Exception when calling the transcription service for job id: %s&quot;, jobId), e);
    } finally {
      try {
<span class="nc" id="L714">        httpClient.close();</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">        if (response != null) {</span>
<span class="nc" id="L716">          response.close();</span>
        }
<span class="nc" id="L718">      } catch (IOException e) {</span>
<span class="nc" id="L719">      }</span>
    }
<span class="nc" id="L721">    return &quot;No results found&quot;;</span>
  }

  private void saveResults(String jobId, JSONObject jsonObj) throws IOException {
<span class="fc" id="L725">    JSONArray resultsArray = getTranscriptionResult(jsonObj);</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">    if (resultsArray != null) {</span>
      // Save the results into a collection
<span class="fc" id="L728">      workspace.putInCollection(TRANSCRIPT_COLLECTION, jobId + &quot;.json&quot;,</span>
<span class="fc" id="L729">              new ByteArrayInputStream(jsonObj.toJSONString().getBytes()));</span>
    }
<span class="fc" id="L731">  }</span>

  @Override
  public MediaPackageElement getGeneratedTranscription(String mpId, String jobId, MediaPackageElement.Type type)
          throws TranscriptionServiceException {
    try {
      // If jobId is unknown, look for all jobs associated to that mpId
<span class="pc bpc" id="L738" title="1 of 4 branches missed.">      if (jobId == null || &quot;null&quot;.equals(jobId)) {</span>
<span class="fc" id="L739">        jobId = null;</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">        for (TranscriptionJobControl jc : database.findByMediaPackage(mpId)) {</span>
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">          if (TranscriptionJobControl.Status.Closed.name().equals(jc.getStatus())</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">                  || TranscriptionJobControl.Status.TranscriptionComplete.name().equals(jc.getStatus())) {</span>
<span class="fc" id="L743">            jobId = jc.getTranscriptionJobId();</span>
          }
<span class="fc" id="L745">        }</span>
      }

<span class="pc bpc" id="L748" title="1 of 2 branches missed.">      if (jobId == null) {</span>
<span class="nc" id="L749">        throw new TranscriptionServiceException(</span>
                &quot;No completed or closed transcription job found in database for media package &quot; + mpId);
      }

      // Results already saved?
<span class="fc" id="L754">      URI uri = workspace.getCollectionURI(TRANSCRIPT_COLLECTION, jobId + &quot;.json&quot;);</span>
      try {
<span class="fc" id="L756">        workspace.get(uri);</span>
<span class="fc" id="L757">      } catch (Exception e) {</span>
        try {
          // Not saved yet so call the google speech service to get the results
<span class="fc" id="L760">          getAndSaveJobResults(jobId);</span>
<span class="nc" id="L761">        } catch (IOException ex) {</span>
<span class="nc" id="L762">          logger.error(&quot;Unable to retrieve transcription job, error: {}&quot;, ex.toString());</span>
<span class="fc" id="L763">        }</span>
<span class="fc" id="L764">      }</span>
<span class="fc" id="L765">      MediaPackageElementBuilder builder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();</span>
<span class="fc" id="L766">      return builder.elementFromURI(uri, type,</span>
          new MediaPackageElementFlavor(&quot;captions&quot;, &quot;google-speech-json&quot;));
<span class="nc" id="L768">    } catch (TranscriptionDatabaseException e) {</span>
<span class="nc" id="L769">      throw new TranscriptionServiceException(&quot;Job id not informed and could not find transcription&quot;, e);</span>
    }
  }

  /**
   * Get mediapackage transcription status
   *
   * @param mpId, mediapackage id
   * @return transcription status
   * @throws TranscriptionServiceException
   */
  public String getTranscriptionStatus(String mpId) throws TranscriptionServiceException {
    try {
<span class="nc bnc" id="L782" title="All 2 branches missed.">      for (TranscriptionJobControl jc : database.findByMediaPackage(mpId)) {</span>
<span class="nc" id="L783">        return jc.getStatus();</span>
      }
<span class="nc" id="L785">    } catch (TranscriptionDatabaseException e) {</span>
<span class="nc" id="L786">      throw new TranscriptionServiceException(&quot;Mediapackage id transcription status unknown&quot;, e);</span>
<span class="nc" id="L787">    }</span>
<span class="nc" id="L788">    return &quot;Unknown&quot;;</span>
  }

  protected CloseableHttpClient makeHttpClient() throws IOException {
<span class="nc" id="L792">    RequestConfig reqConfig = RequestConfig.custom()</span>
<span class="nc" id="L793">            .setConnectTimeout(CONNECTION_TIMEOUT)</span>
<span class="nc" id="L794">            .setSocketTimeout(SOCKET_TIMEOUT)</span>
<span class="nc" id="L795">            .setConnectionRequestTimeout(CONNECTION_TIMEOUT)</span>
<span class="nc" id="L796">            .build();</span>
<span class="nc" id="L797">    return HttpClients.custom().setDefaultRequestConfig(reqConfig).build();</span>
  }

  protected String refreshAccessToken(String clientId, String clientSecret, String refreshToken)
          throws TranscriptionServiceException, IOException {
<span class="fc" id="L802">    CloseableHttpClient httpClient = makeHttpClient();</span>
<span class="fc" id="L803">    CloseableHttpResponse response = null;</span>

    try {
<span class="fc" id="L806">      HttpPost httpPost = new HttpPost(tokenEndpoint + String.format(</span>
              &quot;?client_id=%s&amp;client_secret=%s&amp;refresh_token=%s&amp;grant_type=refresh_token&quot;,
              clientId, clientSecret, refreshToken));
<span class="fc" id="L809">      httpPost.addHeader(HttpHeaders.CONTENT_TYPE, &quot;application/x-www-form-urlencoded&quot;);</span>
<span class="fc" id="L810">      response = httpClient.execute(httpPost);</span>
<span class="fc" id="L811">      int code = response.getStatusLine().getStatusCode();</span>
<span class="nc" id="L812">      String jsonString = EntityUtils.toString(response.getEntity());</span>
<span class="nc" id="L813">      JSONParser jsonParser = new JSONParser();</span>
<span class="nc" id="L814">      JSONObject jsonObject = (JSONObject) jsonParser.parse(jsonString);</span>
<span class="nc bnc" id="L815" title="All 3 branches missed.">      switch (code) {</span>
        case HttpStatus.SC_OK: // 200
<span class="nc" id="L817">          accessToken = (String) jsonObject.get(ACCESS_TOKEN_NAME);</span>
<span class="nc" id="L818">          long duration = (long) jsonObject.get(ACCESS_TOKEN_EXPIRY_NAME); // Duration in second</span>
<span class="nc" id="L819">          tokenExpiryTime = (System.currentTimeMillis() + (duration * 1000)); // time in millisecond</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">          if (!INVALID_TOKEN.equals(accessToken)) {</span>
<span class="nc" id="L821">            logger.info(&quot;Google Cloud Service access token created&quot;);</span>
<span class="nc" id="L822">            return accessToken;</span>
          }
<span class="nc" id="L824">          throw new TranscriptionServiceException(</span>
<span class="nc" id="L825">              String.format(&quot;Created token is invalid. Status returned: %d&quot;, code), code);</span>
        case HttpStatus.SC_BAD_REQUEST: // 400
        case HttpStatus.SC_UNAUTHORIZED: // 401
<span class="nc" id="L828">          String error = (String) jsonObject.get(&quot;error&quot;);</span>
<span class="nc" id="L829">          String errorDetails = (String) jsonObject.get(&quot;error_description&quot;);</span>
<span class="nc" id="L830">          logger.warn(&quot;Invalid argument returned, status: {}&quot;, code);</span>
<span class="nc" id="L831">          logger.warn(&quot;Unable to refresh Google Cloud Service token, error: {}, error details: {}&quot;,</span>
              error, errorDetails);
<span class="nc" id="L833">          break;</span>
        default:
<span class="nc" id="L835">          logger.warn(&quot;Invalid argument returned, status: {}&quot;, code);</span>
      }
<span class="nc" id="L837">      throw new TranscriptionServiceException(</span>
<span class="nc" id="L838">              String.format(&quot;Could not create Google access token. Status returned: %d&quot;, code), code);</span>
<span class="nc" id="L839">    } catch (TranscriptionServiceException e) {</span>
<span class="nc" id="L840">      throw e;</span>
<span class="fc" id="L841">    } catch (Exception e) {</span>
<span class="fc" id="L842">      logger.warn(&quot;Unable to generate access token for Google Cloud Services&quot;);</span>
<span class="fc" id="L843">      return INVALID_TOKEN;</span>
    } finally {
      try {
<span class="fc" id="L846">        httpClient.close();</span>
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">        if (response != null) {</span>
<span class="fc" id="L848">          response.close();</span>
        }
<span class="nc" id="L850">      } catch (IOException e) {</span>
<span class="fc" id="L851">      }</span>
    }
  }

  protected String getRefreshAccessToken() throws TranscriptionServiceException, IOException {
    // Check that token hasn't expired
<span class="nc bnc" id="L857" title="All 2 branches missed.">    if ((!INVALID_TOKEN.equals(accessToken))</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        &amp;&amp; (System.currentTimeMillis() &lt; (tokenExpiryTime - ACCESS_TOKEN_MINIMUM_TIME))) {</span>
<span class="nc" id="L859">      return accessToken;</span>
    }
<span class="nc" id="L861">    return refreshAccessToken(clientId, clientSecret, clientToken);</span>
  }

  protected String uploadAudioFileToGoogleStorage(String mpId, Track track)
          throws TranscriptionServiceException, IOException {
    File audioFile;
<span class="nc" id="L867">    String audioUrl = null;</span>
    String fileExtension;
    int audioResponse;
<span class="nc" id="L870">    CloseableHttpClient httpClientStorage = makeHttpClient();</span>
<span class="nc" id="L871">    GoogleSpeechTranscriptionServiceStorage storage = new GoogleSpeechTranscriptionServiceStorage();</span>
    try {
<span class="nc" id="L873">      audioFile = workspace.get(track.getURI());</span>
<span class="nc" id="L874">      fileExtension = FilenameUtils.getExtension(audioFile.getName());</span>
<span class="nc" id="L875">      long fileSize = audioFile.length();</span>
<span class="nc" id="L876">      String contentType = track.getMimeType().toString();</span>
<span class="nc" id="L877">      String token = getRefreshAccessToken();</span>
      // Upload file to google cloud storage
<span class="nc" id="L879">      audioResponse = storage.startUpload(httpClientStorage, storageBucket, mpId, fileExtension,</span>
<span class="nc" id="L880">              audioFile, String.valueOf(fileSize), contentType, token);</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">      if (audioResponse == HttpStatus.SC_OK) {</span>
<span class="nc" id="L882">        audioUrl = String.format(&quot;gs://%s/%s.%s&quot;, storageBucket, mpId, fileExtension);</span>
<span class="nc" id="L883">        return audioUrl;</span>
      }
<span class="nc" id="L885">      logger.error(&quot;Error when uploading audio to Google Storage, error code: {}&quot;, audioResponse);</span>
<span class="nc" id="L886">      return audioUrl;</span>
<span class="nc" id="L887">    } catch (Exception e) {</span>
<span class="nc" id="L888">      throw new TranscriptionServiceException(&quot;Error reading audio track&quot;, e);</span>
    }
  }

  private JSONArray getTranscriptionResult(JSONObject jsonObj) {
<span class="fc" id="L893">    JSONObject responseObj = (JSONObject) jsonObj.get(&quot;response&quot;);</span>
<span class="fc" id="L894">    JSONArray resultsArray = (JSONArray) responseObj.get(&quot;results&quot;);</span>
<span class="fc" id="L895">    return resultsArray;</span>
  }

  protected void deleteStorageFile(String mpId, String token) throws IOException {
<span class="nc" id="L899">    CloseableHttpClient httpClientDel = makeHttpClient();</span>
<span class="nc" id="L900">    GoogleSpeechTranscriptionServiceStorage storage = new GoogleSpeechTranscriptionServiceStorage();</span>
<span class="nc" id="L901">    storage.deleteGoogleStorageFile(httpClientDel, storageBucket, mpId + &quot;.&quot; + defaultEncoding, token);</span>
<span class="nc" id="L902">  }</span>

  private void sendEmail(String subject, String body) {
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">    if (toEmailAddress == null) {</span>
<span class="fc" id="L906">      logger.info(&quot;Skipping sending email notification. Message is {}.&quot;, body);</span>
<span class="fc" id="L907">      return;</span>
    }
    try {
<span class="nc" id="L910">      logger.debug(&quot;Sending e-mail notification to {}&quot;, toEmailAddress);</span>
<span class="nc" id="L911">      smtpService.send(toEmailAddress, String.format(&quot;%s (%s)&quot;, subject, clusterName), body);</span>
<span class="nc" id="L912">      logger.info(&quot;Sent e-mail notification to {}&quot;, toEmailAddress);</span>
<span class="nc" id="L913">    } catch (Exception e) {</span>
<span class="nc" id="L914">      logger.error(&quot;Could not send email: {}\n{}&quot;, subject, body, e);</span>
<span class="nc" id="L915">    }</span>
<span class="nc" id="L916">  }</span>

  private void cancelTranscription(String jobId, String message) {
    try {
<span class="nc" id="L920">      database.updateJobControl(jobId, TranscriptionJobControl.Status.Canceled.name());</span>
<span class="nc" id="L921">      String mpId = database.findByJob(jobId).getMediaPackageId();</span>
      try {
        // Delete file stored on Google storage
<span class="nc" id="L924">        String token = getRefreshAccessToken();</span>
<span class="nc" id="L925">        deleteStorageFile(mpId, token);</span>
<span class="nc" id="L926">      } catch (Exception ex) {</span>
<span class="nc" id="L927">        logger.warn(String.format(&quot;could not delete file %s.%s from Google cloud storage&quot;, mpId, defaultEncoding), ex);</span>
      } finally {
        // Send notification email
<span class="nc" id="L930">        sendEmail(&quot;Transcription ERROR&quot;, String.format(&quot;%s(media package %s, job id %s).&quot;, message, mpId, jobId));</span>
      }
<span class="nc" id="L932">    } catch (Exception e) {</span>
<span class="nc" id="L933">      logger.error(String.format(&quot;ERROR while deleting transcription job: %s&quot;, jobId), e);</span>
<span class="nc" id="L934">    }</span>
<span class="nc" id="L935">  }</span>

  private boolean hasTranscriptionRequestExpired(String jobId) {
    try {
      // set a time limit based on video duration and maximum processing time
<span class="nc" id="L940">      if (database.findByJob(jobId).getDateCreated().getTime() + database.findByJob(jobId).getTrackDuration()</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">              + (completionCheckBuffer + maxProcessingSeconds) * 1000 &lt; System.currentTimeMillis()) {</span>
<span class="nc" id="L942">        return true;</span>
      }
<span class="nc" id="L944">    } catch (Exception e) {</span>
<span class="nc" id="L945">      logger.error(String.format(&quot;ERROR while calculating transcription request expiration for job: %s&quot;, jobId), e);</span>
      // to avoid perpetual non-expired state, transcription is set as expired
<span class="nc" id="L947">      return true;</span>
<span class="nc" id="L948">    }</span>
<span class="nc" id="L949">    return false;</span>
  }

  private long getRemainingTranscriptionExpireTimeInMin(String jobId) {
    try {
<span class="nc" id="L954">      long expiredTime = (database.findByJob(jobId).getDateCreated().getTime()</span>
<span class="nc" id="L955">          + database.findByJob(jobId).getTrackDuration()</span>
          + (completionCheckBuffer + maxProcessingSeconds) * 1000)
<span class="nc" id="L957">          - (System.currentTimeMillis());</span>
      // Transcription has expired
<span class="nc bnc" id="L959" title="All 2 branches missed.">      if (expiredTime &lt; 0) {</span>
<span class="nc" id="L960">        expiredTime = 0;</span>
      }
<span class="nc" id="L962">      return TimeUnit.MILLISECONDS.toMinutes(expiredTime);</span>
<span class="nc" id="L963">    } catch (Exception e) {</span>
<span class="nc" id="L964">      logger.error(&quot;Unable to calculate remaining transcription expired time for transcription job {}&quot;, jobId);</span>
    }
<span class="nc" id="L966">    return 0;</span>
  }

  @Reference
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L971">    this.serviceRegistry = serviceRegistry;</span>
<span class="fc" id="L972">  }</span>

  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L976">    this.securityService = securityService;</span>
<span class="fc" id="L977">  }</span>

  @Reference
  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {
<span class="fc" id="L981">    this.userDirectoryService = userDirectoryService;</span>
<span class="fc" id="L982">  }</span>

  @Reference
  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectoryService) {
<span class="fc" id="L986">    this.organizationDirectoryService = organizationDirectoryService;</span>
<span class="fc" id="L987">  }</span>

  @Reference
  public void setSmtpService(SmtpService service) {
<span class="fc" id="L991">    this.smtpService = service;</span>
<span class="fc" id="L992">  }</span>

  @Reference
  public void setWorkspace(Workspace ws) {
<span class="fc" id="L996">    this.workspace = ws;</span>
<span class="fc" id="L997">  }</span>

  @Reference
  public void setWorkingFileRepository(WorkingFileRepository wfr) {
<span class="nc" id="L1001">    this.wfr = wfr;</span>
<span class="nc" id="L1002">  }</span>

  @Reference
  public void setDatabase(TranscriptionDatabase service) {
<span class="fc" id="L1006">    this.database = service;</span>
<span class="fc" id="L1007">  }</span>

  @Reference
  public void setAssetManager(AssetManager service) {
<span class="fc" id="L1011">    this.assetManager = service;</span>
<span class="fc" id="L1012">  }</span>

  @Reference
  public void setWorkflowService(WorkflowService service) {
<span class="fc" id="L1016">    this.workflowService = service;</span>
<span class="fc" id="L1017">  }</span>

  @Override
  protected ServiceRegistry getServiceRegistry() {
<span class="nc" id="L1021">    return serviceRegistry;</span>
  }

  @Override
  protected SecurityService getSecurityService() {
<span class="nc" id="L1026">    return securityService;</span>
  }

  @Override
  protected UserDirectoryService getUserDirectoryService() {
<span class="nc" id="L1031">    return userDirectoryService;</span>
  }

  @Override
  protected OrganizationDirectoryService getOrganizationDirectoryService() {
<span class="nc" id="L1036">    return organizationDirectoryService;</span>
  }

  // Only used by unit tests!
  void setWfUtil(Workflows wfUtil) {
<span class="fc" id="L1041">    this.wfUtil = wfUtil;</span>
<span class="fc" id="L1042">  }</span>

<span class="fc" id="L1044">  class WorkflowDispatcher implements Runnable {</span>

    /**
     * {@inheritDoc}
     *
     * @see java.lang.Thread#run()
     */
    @Override
    public void run() {
<span class="fc" id="L1053">      logger.debug(&quot;WorkflowDispatcher waking up...&quot;);</span>

      try {
        // Find jobs that are in progress and jobs that had transcription complete

        long providerId;
<span class="fc" id="L1059">        TranscriptionProviderControl providerInfo = database.findIdByProvider(PROVIDER);</span>
<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">        if (providerInfo != null) {</span>
<span class="fc" id="L1061">          providerId = providerInfo.getId();</span>
        } else {
<span class="nc" id="L1063">          logger.debug(&quot;No jobs yet for provider {}&quot;, PROVIDER);</span>
<span class="nc" id="L1064">          return;</span>
        }

<span class="fc" id="L1067">        List&lt;TranscriptionJobControl&gt; jobs = database.findByStatus(TranscriptionJobControl.Status.InProgress.name(),</span>
<span class="fc" id="L1068">                TranscriptionJobControl.Status.TranscriptionComplete.name());</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        for (TranscriptionJobControl j : jobs) {</span>

          // Don't process jobs for other services
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">          if (j.getProviderId() != providerId) {</span>
<span class="nc" id="L1073">            continue;</span>
          }

<span class="fc" id="L1076">          String mpId = j.getMediaPackageId();</span>
<span class="fc" id="L1077">          String jobId = j.getTranscriptionJobId();</span>

          // If the job in progress, check if it should already have finished.
<span class="fc bfc" id="L1080" title="All 2 branches covered.">          if (TranscriptionJobControl.Status.InProgress.name().equals(j.getStatus())) {</span>
            // If job should already have been completed, try to get the results. Consider a buffer factor so that we
            // don't try it too early. Results normally should be ready 1/3 of the time of the track duration.
            // The completionCheckBuffer can be used to delay results check.
<span class="fc" id="L1084">            if (j.getDateCreated().getTime() + (j.getTrackDuration() / 3) + completionCheckBuffer * 1000 &lt; System</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">                    .currentTimeMillis()) {</span>
              try {
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">                if (!getAndSaveJobResults(jobId)) {</span>
                  // Job still running, not finished, so check if it should have finished more than N seconds ago
<span class="nc bnc" id="L1089" title="All 2 branches missed.">                  if (hasTranscriptionRequestExpired(jobId)) {</span>
                    // Processing for too long, mark job as cancelled and don't check anymore
<span class="nc" id="L1091">                    database.updateJobControl(jobId, TranscriptionJobControl.Status.Canceled.name());</span>
                    // Delete file stored on Google storage
<span class="nc" id="L1093">                    String token = getRefreshAccessToken();</span>
<span class="nc" id="L1094">                    deleteStorageFile(mpId, token);</span>
                    // Send notification email
<span class="nc" id="L1096">                    sendEmail(TRANSCRIPTION_ERROR, String.format(</span>
                        &quot;Transcription job was in processing state for too long and was marked &quot;
                            + &quot;as cancelled (media package %s, job id %s).&quot;,
                        mpId, jobId));
                  }
                  // else Job still running, not finished
<span class="nc" id="L1102">                  continue;</span>
                }
<span class="nc" id="L1104">              } catch (TranscriptionServiceException e) {</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                if (e.getCode() == 404) {</span>
                  // Job not found there, update job state to canceled
<span class="nc" id="L1107">                  database.updateJobControl(jobId, TranscriptionJobControl.Status.Canceled.name());</span>
                  // Send notification email
<span class="nc" id="L1109">                  sendEmail(TRANSCRIPTION_ERROR,</span>
<span class="nc" id="L1110">                          String.format(&quot;Transcription job was not found (media package %s, job id %s).&quot;, mpId, jobId));</span>
                }
<span class="nc" id="L1112">                continue; // Skip this one, exception was already logged</span>
<span class="nc" id="L1113">              } catch (IOException ex) {</span>
<span class="nc" id="L1114">                logger.error(&quot;Transcription job not found, error: {}&quot;, ex.toString());</span>
<span class="fc" id="L1115">              }</span>
            } else {
              continue; // Not time to check yet
            }
          }

          // Jobs that get here have state TranscriptionCompleted or had an IOException]
          try {

            // Apply workflow to attach transcripts
<span class="fc" id="L1125">            Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L1126">            params.put(TRANSCRIPTION_JOB_ID_KEY, jobId);</span>
<span class="fc" id="L1127">            String wfId = startWorkflow(mpId, workflowDefinitionId, jobId, params);</span>
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">            if (wfId == null) {</span>
<span class="nc" id="L1129">              logger.warn(&quot;Attach transcription workflow could NOT be scheduled for mp {}, google speech job {}&quot;,</span>
                  mpId, jobId);
<span class="nc" id="L1131">              continue;</span>
            }
            // Update state in the database
<span class="fc" id="L1134">            database.updateJobControl(jobId, TranscriptionJobControl.Status.Closed.name());</span>
<span class="fc" id="L1135">            logger.info(&quot;Attach transcription workflow {} scheduled for mp {}, google speech job {}&quot;,</span>
                    wfId, mpId, jobId);
<span class="nc" id="L1137">          } catch (Exception e) {</span>
<span class="nc" id="L1138">            logger.warn(&quot;Attach transcription workflow could NOT be scheduled for mp {}, google speech job {}, {}: {}&quot;,</span>
<span class="nc" id="L1139">                    mpId, jobId, e.getClass().getName(), e.getMessage());</span>
<span class="fc" id="L1140">          }</span>
<span class="fc" id="L1141">        }</span>
<span class="nc" id="L1142">      } catch (TranscriptionDatabaseException e) {</span>
<span class="nc" id="L1143">        logger.warn(&quot;Could not read transcription job control database: {}&quot;, e.getMessage());</span>
<span class="fc" id="L1144">      }</span>
<span class="fc" id="L1145">    }</span>
  }

  private String startWorkflow(String mpId, String wfDefId, String jobId, Map&lt;String, String&gt; params) {
<span class="fc" id="L1149">    DefaultOrganization defaultOrg = new DefaultOrganization();</span>
<span class="fc" id="L1150">    securityService.setOrganization(defaultOrg);</span>
<span class="fc" id="L1151">    securityService.setUser(SecurityUtil.createSystemUser(systemAccount, defaultOrg));</span>

    // Find the episode
<span class="fc" id="L1154">    final AQueryBuilder q = assetManager.createQuery();</span>
<span class="fc" id="L1155">    final AResult r = q.select(q.snapshot()).where(q.mediaPackageId(mpId).and(q.version().isLatest())).run();</span>
<span class="pc bpc" id="L1156" title="1 of 2 branches missed.">    if (r.getSize() == 0) {</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">      if (!hasTranscriptionRequestExpired(jobId)) {</span>
        // Media package not archived but still within completion time? Skip until next time.
<span class="nc" id="L1159">        logger.warn(&quot;Media package {} has not been archived yet or has been deleted. Will keep trying for {} &quot;</span>
            + &quot;more minutes before cancelling transcription job {}.&quot;,
<span class="nc" id="L1161">            mpId, getRemainingTranscriptionExpireTimeInMin(jobId), jobId);</span>
      } else {
        // Close transcription job and email admin
<span class="nc" id="L1164">        cancelTranscription(jobId, &quot; Google Transcription job canceled, archived media package not found&quot;);</span>
<span class="nc" id="L1165">        logger.info(&quot;Google Transcription job {} has been canceled. Email notification sent&quot;, jobId);</span>
      }
<span class="nc" id="L1167">      return null;</span>
    }

<span class="fc" id="L1170">    String org = Enrichments.enrich(r).getSnapshots().stream().findFirst().get().getOrganizationId();</span>
<span class="fc" id="L1171">    Organization organization = null;</span>
    try {
<span class="fc" id="L1173">      organization = organizationDirectoryService.getOrganization(org);</span>
<span class="pc bpc" id="L1174" title="1 of 2 branches missed.">      if (organization == null) {</span>
<span class="nc" id="L1175">        logger.warn(&quot;Media package {} has an unknown organization {}.&quot;, mpId, org);</span>
<span class="nc" id="L1176">        return null;</span>
      }
<span class="nc" id="L1178">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1179">      logger.warn(&quot;Organization {} not found for media package {}.&quot;, org, mpId);</span>
<span class="nc" id="L1180">      return null;</span>
<span class="fc" id="L1181">    }</span>
<span class="fc" id="L1182">    securityService.setOrganization(organization);</span>

    try {
<span class="fc" id="L1185">      WorkflowDefinition wfDef = workflowService.getWorkflowDefinitionById(wfDefId);</span>
      Workflows workflows;
<span class="pc bpc" id="L1187" title="1 of 2 branches missed.">      if (wfUtil != null) {</span>
<span class="fc" id="L1188">        workflows = wfUtil;</span>
      } else {
<span class="nc" id="L1190">        workflows = new Workflows(assetManager, workflowService);</span>
      }
<span class="fc" id="L1192">      Set&lt;String&gt; mpIds = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L1193">      mpIds.add(mpId);</span>
<span class="fc" id="L1194">      List&lt;WorkflowInstance&gt; wfList = workflows</span>
<span class="fc" id="L1195">              .applyWorkflowToLatestVersion(mpIds, ConfiguredWorkflow.workflow(wfDef, params));</span>
<span class="pc bpc" id="L1196" title="1 of 2 branches missed.">      return wfList.size() &gt; 0 ? Long.toString(wfList.get(0).getId()) : null;</span>
<span class="nc" id="L1197">    } catch (NotFoundException | WorkflowDatabaseException e) {</span>
<span class="nc" id="L1198">      logger.warn(&quot;Could not get workflow definition: {}&quot;, wfDefId);</span>
    }

<span class="nc" id="L1201">    return null;</span>
  }

<span class="fc" id="L1204">  class ResultsFileCleanup implements Runnable {</span>

    @Override
    public void run() {
<span class="nc" id="L1208">      logger.info(&quot;ResultsFileCleanup waking up...&quot;);</span>
      try {
        // Cleans up results files older than CLEANUP_RESULT_FILES_DAYS days
<span class="nc" id="L1211">        wfr.cleanupOldFilesFromCollection(TRANSCRIPT_COLLECTION, cleanupResultDays);</span>
<span class="nc" id="L1212">      } catch (IOException e) {</span>
<span class="nc" id="L1213">        logger.warn(&quot;Could not cleanup old transcript results files&quot;, e);</span>
<span class="nc" id="L1214">      }</span>
<span class="nc" id="L1215">    }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>