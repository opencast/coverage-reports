<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SeriesEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-admin-ui</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.adminui.endpoint</a> &gt; <span class="el_source">SeriesEndpoint.java</span></div><h1>SeriesEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.adminui.endpoint;

import static com.entwinemedia.fn.Stream.$;
import static com.entwinemedia.fn.data.json.Jsons.arr;
import static com.entwinemedia.fn.data.json.Jsons.f;
import static com.entwinemedia.fn.data.json.Jsons.obj;
import static com.entwinemedia.fn.data.json.Jsons.v;
import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
import static javax.servlet.http.HttpServletResponse.SC_NO_CONTENT;
import static javax.servlet.http.HttpServletResponse.SC_OK;
import static javax.servlet.http.HttpServletResponse.SC_SERVICE_UNAVAILABLE;
import static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;
import static javax.ws.rs.core.Response.Status.BAD_REQUEST;
import static javax.ws.rs.core.Response.Status.NOT_FOUND;
import static javax.ws.rs.core.Response.Status.NO_CONTENT;
import static org.apache.commons.lang3.StringUtils.trimToNull;
import static org.opencastproject.adminui.endpoint.EndpointUtil.transformAccessControList;
import static org.opencastproject.index.service.util.RestUtils.notFound;
import static org.opencastproject.index.service.util.RestUtils.okJson;
import static org.opencastproject.index.service.util.RestUtils.okJsonList;
import static org.opencastproject.util.DateTimeSupport.toUTC;
import static org.opencastproject.util.RestUtil.R.badRequest;
import static org.opencastproject.util.RestUtil.R.conflict;
import static org.opencastproject.util.RestUtil.R.forbidden;
import static org.opencastproject.util.RestUtil.R.notFound;
import static org.opencastproject.util.RestUtil.R.ok;
import static org.opencastproject.util.RestUtil.R.serverError;
import static org.opencastproject.util.doc.rest.RestParameter.Type.BOOLEAN;
import static org.opencastproject.util.doc.rest.RestParameter.Type.INTEGER;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;
import static org.opencastproject.util.doc.rest.RestParameter.Type.TEXT;

import org.opencastproject.adminui.impl.AdminUIConfiguration;
import org.opencastproject.adminui.tobira.TobiraException;
import org.opencastproject.adminui.tobira.TobiraService;
import org.opencastproject.authorization.xacml.manager.api.AclService;
import org.opencastproject.authorization.xacml.manager.api.AclServiceFactory;
import org.opencastproject.authorization.xacml.manager.api.ManagedAcl;
import org.opencastproject.authorization.xacml.manager.util.AccessInformationUtil;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.api.SearchResultItem;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.objects.event.EventSearchQuery;
import org.opencastproject.elasticsearch.index.objects.series.Series;
import org.opencastproject.elasticsearch.index.objects.series.SeriesIndexSchema;
import org.opencastproject.elasticsearch.index.objects.series.SeriesSearchQuery;
import org.opencastproject.elasticsearch.index.objects.theme.IndexTheme;
import org.opencastproject.elasticsearch.index.objects.theme.ThemeSearchQuery;
import org.opencastproject.index.service.api.IndexService;
import org.opencastproject.index.service.exception.IndexServiceException;
import org.opencastproject.index.service.resources.list.provider.SeriesListProvider;
import org.opencastproject.index.service.resources.list.query.SeriesListQuery;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.list.api.ListProviderException;
import org.opencastproject.list.api.ListProvidersService;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.MetadataJson;
import org.opencastproject.metadata.dublincore.MetadataList;
import org.opencastproject.metadata.dublincore.SeriesCatalogUIAdapter;
import org.opencastproject.rest.BulkOperationResult;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.series.api.SeriesException;
import org.opencastproject.series.api.SeriesService;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RestUtil;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestParameter.Type;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.util.requests.SortCriterion;
import org.opencastproject.util.requests.SortCriterion.Order;
import org.opencastproject.workflow.api.WorkflowInstance;

import com.entwinemedia.fn.data.Opt;
import com.entwinemedia.fn.data.json.Field;
import com.entwinemedia.fn.data.json.JValue;
import com.entwinemedia.fn.data.json.Jsons;
import com.entwinemedia.fn.data.json.Jsons.Functions;

import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Modified;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.DELETE;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Path(&quot;/admin-ng/series&quot;)
@RestService(name = &quot;SeriesProxyService&quot;, title = &quot;UI Series&quot;,
  abstractText = &quot;This service provides the series data for the UI.&quot;,
  notes = { &quot;This service offers the series CRUD Operations for the admin UI.&quot;,
            &quot;&lt;strong&gt;Important:&lt;/strong&gt; &quot;
              + &quot;&lt;em&gt;This service is for exclusive use by the module admin-ui. Its API might change &quot;
              + &quot;anytime without prior notice. Any dependencies other than the admin UI will be strictly ignored. &quot;
              + &quot;DO NOT use this for integration of third-party applications.&lt;em&gt;&quot;})
@Component(
        immediate = true,
        service = SeriesEndpoint.class,
        property = {
                &quot;service.description=Admin UI - SeriesEndpoint Endpoint&quot;,
                &quot;opencast.service.type=org.opencastproject.adminui.SeriesEndpoint&quot;,
                &quot;opencast.service.path=/admin-ng/series&quot;,
        }
)
@JaxrsResource
<span class="fc" id="L175">public class SeriesEndpoint {</span>

<span class="fc" id="L177">  private static final Logger logger = LoggerFactory.getLogger(SeriesEndpoint.class);</span>

  private static final int CREATED_BY_UI_ORDER = 9;

  /** Default number of items on page */
  private static final int DEFAULT_LIMIT = 100;

  public static final String THEME_KEY = &quot;theme&quot;;

<span class="fc" id="L186">  private Boolean deleteSeriesWithEventsAllowed = true;</span>
<span class="fc" id="L187">  private Boolean onlySeriesWithWriteAccessSeriesTab = false;</span>
<span class="fc" id="L188">  private Boolean onlySeriesWithWriteAccessEventsFilter = false;</span>

  public static final String SERIES_HASEVENTS_DELETE_ALLOW_KEY = &quot;series.hasEvents.delete.allow&quot;;
  public static final String SERIESTAB_ONLYSERIESWITHWRITEACCESS_KEY = &quot;seriesTab.onlySeriesWithWriteAccess&quot;;
  public static final String EVENTSFILTER_ONLYSERIESWITHWRITEACCESS_KEY = &quot;eventsFilter.onlySeriesWithWriteAccess&quot;;
<span class="fc" id="L193">  public static final Pattern TOBIRA_CONFIG = Pattern.compile(&quot;^tobira\\.(?&lt;organization&gt;.*)\\.(?&lt;key&gt;origin|trustedKey)$&quot;);</span>

  private SeriesService seriesService;
  private SecurityService securityService;
  private AclServiceFactory aclServiceFactory;
  private IndexService indexService;
  private ListProvidersService listProvidersService;
  private ElasticsearchIndex searchIndex;
  private AdminUIConfiguration adminUIConfiguration;
  private UserDirectoryService userDirectoryService;

  /** Default server URL */
<span class="fc" id="L205">  private String serverUrl = &quot;http://localhost:8080&quot;;</span>

  /** OSGi callback for the series service. */
  @Reference
  public void setSeriesService(SeriesService seriesService) {
<span class="fc" id="L210">    this.seriesService = seriesService;</span>
<span class="fc" id="L211">  }</span>

  /** OSGi callback for the search index. */
  @Reference
  public void setIndex(ElasticsearchIndex index) {
<span class="fc" id="L216">    this.searchIndex = index;</span>
<span class="fc" id="L217">  }</span>

  /** OSGi DI. */
  @Reference
  public void setIndexService(IndexService indexService) {
<span class="fc" id="L222">    this.indexService = indexService;</span>
<span class="fc" id="L223">  }</span>

  /** OSGi callback for the list provider service */
  @Reference
  public void setListProvidersService(ListProvidersService listProvidersService) {
<span class="nc" id="L228">    this.listProvidersService = listProvidersService;</span>
<span class="nc" id="L229">  }</span>

  /** OSGi callback for the security service */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L234">    this.securityService = securityService;</span>
<span class="fc" id="L235">  }</span>

  /** OSGi callback for the acl service factory */
  @Reference
  public void setAclServiceFactory(AclServiceFactory aclServiceFactory) {
<span class="fc" id="L240">    this.aclServiceFactory = aclServiceFactory;</span>
<span class="fc" id="L241">  }</span>

  private AclService getAclService() {
<span class="nc" id="L244">    return aclServiceFactory.serviceFor(securityService.getOrganization());</span>
  }


  /** OSGi DI. */
  @Reference
  public void setAdminUIConfiguration(AdminUIConfiguration adminUIConfiguration) {
<span class="nc" id="L251">    this.adminUIConfiguration = adminUIConfiguration;</span>
<span class="nc" id="L252">  }</span>

  /** Sets the user directory service */
  @Reference
  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {
<span class="nc" id="L257">    this.userDirectoryService = userDirectoryService;</span>
<span class="nc" id="L258">  }</span>

  @Activate
  protected void activate(ComponentContext cc, Map&lt;String, Object&gt; properties) {
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">    if (cc != null) {</span>
<span class="nc" id="L263">      String ccServerUrl = cc.getBundleContext().getProperty(OpencastConstants.SERVER_URL_PROPERTY);</span>
<span class="nc" id="L264">      logger.debug(&quot;Configured server url is {}&quot;, ccServerUrl);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">      if (ccServerUrl != null)</span>
<span class="nc" id="L266">        this.serverUrl = ccServerUrl;</span>

<span class="nc" id="L268">      modified(properties);</span>
    }
<span class="fc" id="L270">    logger.info(&quot;Activate series endpoint&quot;);</span>
<span class="fc" id="L271">  }</span>

  /** OSGi callback if properties file is present */
  @Modified
  public void modified(Map&lt;String, Object&gt; properties) {
<span class="nc bnc" id="L276" title="All 2 branches missed.">    if (properties == null) {</span>
<span class="nc" id="L277">      logger.info(&quot;No configuration available, using defaults&quot;);</span>
<span class="nc" id="L278">      return;</span>
    }

<span class="nc" id="L281">    Object mapValue = properties.get(SERIES_HASEVENTS_DELETE_ALLOW_KEY);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">    if (mapValue != null) {</span>
<span class="nc" id="L283">      deleteSeriesWithEventsAllowed = BooleanUtils.toBoolean(mapValue.toString());</span>
    }

<span class="nc" id="L286">    mapValue = properties.get(SERIESTAB_ONLYSERIESWITHWRITEACCESS_KEY);</span>
<span class="nc" id="L287">    onlySeriesWithWriteAccessSeriesTab = BooleanUtils.toBoolean(Objects.toString(mapValue, &quot;true&quot;));</span>

<span class="nc" id="L289">    mapValue = properties.get(EVENTSFILTER_ONLYSERIESWITHWRITEACCESS_KEY);</span>
<span class="nc" id="L290">    onlySeriesWithWriteAccessEventsFilter = BooleanUtils.toBoolean(Objects.toString(mapValue, &quot;true&quot;));</span>

<span class="nc" id="L292">    properties.forEach((key, value) -&gt; {</span>
<span class="nc" id="L293">      var matches = TOBIRA_CONFIG.matcher(key);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">      if (!matches.matches()) {</span>
<span class="nc" id="L295">        return;</span>
      }
<span class="nc" id="L297">      var tobira = TobiraService.getTobira(matches.group(&quot;organization&quot;));</span>
<span class="nc bnc" id="L298" title="All 3 branches missed.">      switch (matches.group(&quot;key&quot;)) {</span>
        case &quot;origin&quot;:
<span class="nc" id="L300">          tobira.setOrigin((String) value);</span>
<span class="nc" id="L301">          break;</span>
        case &quot;trustedKey&quot;:
<span class="nc" id="L303">          tobira.setTrustedKey((String) value);</span>
<span class="nc" id="L304">          break;</span>
        default:
<span class="nc" id="L306">          throw new RuntimeException(&quot;unhandled Tobira config key&quot;);</span>
      }
<span class="nc" id="L308">    });</span>

<span class="nc" id="L310">    logger.info(&quot;Configuration updated&quot;);</span>
<span class="nc" id="L311">  }</span>

  @GET
  @Path(&quot;{seriesId}/access.json&quot;)
  @SuppressWarnings(&quot;unchecked&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getseriesaccessinformation&quot;, description = &quot;Get the access information of a series&quot;, returnDescription = &quot;The access information&quot;, pathParameters = { @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = Type.STRING) }, responses = {
          @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;The required form params were missing in the request.&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;If the series has not been found.&quot;),
          @RestResponse(responseCode = SC_OK, description = &quot;The access information &quot;) })
  public Response getSeriesAccessInformation(@PathParam(&quot;seriesId&quot;) String seriesId) throws NotFoundException {
<span class="nc bnc" id="L322" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesId))</span>
<span class="nc" id="L323">      return RestUtil.R.badRequest(&quot;Path parameter series ID is missing&quot;);</span>

<span class="nc" id="L325">    boolean hasProcessingEvents = hasProcessingEvents(seriesId);</span>

    // Add all available ACLs to the response
<span class="nc" id="L328">    JSONArray systemAclsJson = new JSONArray();</span>
<span class="nc" id="L329">    List&lt;ManagedAcl&gt; acls = getAclService().getAcls();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">    for (ManagedAcl acl : acls) {</span>
<span class="nc" id="L331">      systemAclsJson.add(AccessInformationUtil.serializeManagedAcl(acl));</span>
<span class="nc" id="L332">    }</span>

<span class="nc" id="L334">    JSONObject seriesAccessJson = new JSONObject();</span>
    try {
<span class="nc" id="L336">      AccessControlList seriesAccessControl = seriesService.getSeriesAccessControl(seriesId);</span>
<span class="nc" id="L337">      Option&lt;ManagedAcl&gt; currentAcl = AccessInformationUtil.matchAclsLenient(acls, seriesAccessControl,</span>
<span class="nc" id="L338">              adminUIConfiguration.getMatchManagedAclRolePrefixes());</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">      seriesAccessJson.put(&quot;current_acl&quot;, currentAcl.isSome() ? currentAcl.get().getId() : 0);</span>
<span class="nc" id="L340">      seriesAccessJson.put(&quot;privileges&quot;, AccessInformationUtil.serializePrivilegesByRole(seriesAccessControl));</span>
<span class="nc" id="L341">      seriesAccessJson.put(&quot;acl&quot;, transformAccessControList(seriesAccessControl, userDirectoryService));</span>
<span class="nc" id="L342">      seriesAccessJson.put(&quot;locked&quot;, hasProcessingEvents);</span>
<span class="nc" id="L343">    } catch (SeriesException e) {</span>
<span class="nc" id="L344">      logger.error(&quot;Unable to get ACL from series {}&quot;, seriesId, e);</span>
<span class="nc" id="L345">      return RestUtil.R.serverError();</span>
<span class="nc" id="L346">    }</span>

<span class="nc" id="L348">    JSONObject jsonReturnObj = new JSONObject();</span>
<span class="nc" id="L349">    jsonReturnObj.put(&quot;system_acls&quot;, systemAclsJson);</span>
<span class="nc" id="L350">    jsonReturnObj.put(&quot;series_access&quot;, seriesAccessJson);</span>

<span class="nc" id="L352">    return Response.ok(jsonReturnObj.toString()).build();</span>
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;{seriesId}/metadata.json&quot;)
  @RestQuery(name = &quot;getseriesmetadata&quot;, description = &quot;Returns the series metadata as JSON&quot;, returnDescription = &quot;Returns the series metadata as JSON&quot;, pathParameters = { @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The series metadata as JSON.&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The series has not been found&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;) })
  public Response getSeriesMetadata(@PathParam(&quot;seriesId&quot;) String series) throws UnauthorizedException,
          NotFoundException, SearchIndexException {
<span class="nc" id="L364">    Optional&lt;Series&gt; optSeries = searchIndex.getSeries(series, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">    if (optSeries.isEmpty())</span>
<span class="nc" id="L366">      return notFound(&quot;Cannot find a series with id '%s'.&quot;, series);</span>

<span class="nc" id="L368">    MetadataList metadataList = new MetadataList();</span>
<span class="nc" id="L369">    List&lt;SeriesCatalogUIAdapter&gt; catalogUIAdapters = indexService.getSeriesCatalogUIAdapters();</span>
<span class="nc" id="L370">    catalogUIAdapters.remove(indexService.getCommonSeriesCatalogUIAdapter());</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">    for (SeriesCatalogUIAdapter adapter : catalogUIAdapters) {</span>
<span class="nc" id="L372">      final Opt&lt;DublinCoreMetadataCollection&gt; optSeriesMetadata = adapter.getFields(series);</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">      if (optSeriesMetadata.isSome()) {</span>
<span class="nc" id="L374">        metadataList.add(adapter.getFlavor().toString(), adapter.getUITitle(), optSeriesMetadata.get());</span>
      }
<span class="nc" id="L376">    }</span>
<span class="nc" id="L377">    metadataList.add(indexService.getCommonSeriesCatalogUIAdapter(), getSeriesMetadata(optSeries.get()));</span>
<span class="nc" id="L378">    return okJson(MetadataJson.listToJson(metadataList, true));</span>
  }

  /**
   * Loads the metadata for the given series
   *
   * @param series
   *          the source {@link Series}
   * @return a {@link DublinCoreMetadataCollection} instance with all the series metadata
   */
  private DublinCoreMetadataCollection getSeriesMetadata(Series series) {
<span class="nc" id="L389">    DublinCoreMetadataCollection metadata = indexService.getCommonSeriesCatalogUIAdapter().getRawFields();</span>

<span class="nc" id="L391">    MetadataField title = metadata.getOutputFields().get(DublinCore.PROPERTY_TITLE.getLocalName());</span>
<span class="nc" id="L392">    metadata.removeField(title);</span>
<span class="nc" id="L393">    MetadataField newTitle = new MetadataField(title);</span>
<span class="nc" id="L394">    newTitle.setValue(series.getTitle());</span>
<span class="nc" id="L395">    metadata.addField(newTitle);</span>

<span class="nc" id="L397">    MetadataField subject = metadata.getOutputFields().get(DublinCore.PROPERTY_SUBJECT.getLocalName());</span>
<span class="nc" id="L398">    metadata.removeField(subject);</span>
<span class="nc" id="L399">    MetadataField newSubject = new MetadataField(subject);</span>
<span class="nc" id="L400">    newSubject.setValue(series.getSubject());</span>
<span class="nc" id="L401">    metadata.addField(newSubject);</span>

<span class="nc" id="L403">    MetadataField description = metadata.getOutputFields().get(DublinCore.PROPERTY_DESCRIPTION.getLocalName());</span>
<span class="nc" id="L404">    metadata.removeField(description);</span>
<span class="nc" id="L405">    MetadataField newDescription = new MetadataField(description);</span>
<span class="nc" id="L406">    newDescription.setValue(series.getDescription());</span>
<span class="nc" id="L407">    metadata.addField(newDescription);</span>

<span class="nc" id="L409">    MetadataField language = metadata.getOutputFields().get(DublinCore.PROPERTY_LANGUAGE.getLocalName());</span>
<span class="nc" id="L410">    metadata.removeField(language);</span>
<span class="nc" id="L411">    MetadataField newLanguage = new MetadataField(language);</span>
<span class="nc" id="L412">    newLanguage.setValue(series.getLanguage());</span>
<span class="nc" id="L413">    metadata.addField(newLanguage);</span>

<span class="nc" id="L415">    MetadataField rightsHolder = metadata.getOutputFields().get(DublinCore.PROPERTY_RIGHTS_HOLDER.getLocalName());</span>
<span class="nc" id="L416">    metadata.removeField(rightsHolder);</span>
<span class="nc" id="L417">    MetadataField newRightsHolder = new MetadataField(rightsHolder);</span>
<span class="nc" id="L418">    newRightsHolder.setValue(series.getRightsHolder());</span>
<span class="nc" id="L419">    metadata.addField(newRightsHolder);</span>

<span class="nc" id="L421">    MetadataField license = metadata.getOutputFields().get(DublinCore.PROPERTY_LICENSE.getLocalName());</span>
<span class="nc" id="L422">    metadata.removeField(license);</span>
<span class="nc" id="L423">    MetadataField newLicense = new MetadataField(license);</span>
<span class="nc" id="L424">    newLicense.setValue(series.getLicense());</span>
<span class="nc" id="L425">    metadata.addField(newLicense);</span>

<span class="nc" id="L427">    MetadataField organizers = metadata.getOutputFields().get(DublinCore.PROPERTY_CREATOR.getLocalName());</span>
<span class="nc" id="L428">    metadata.removeField(organizers);</span>
<span class="nc" id="L429">    MetadataField newOrganizers = new MetadataField(organizers);</span>
<span class="nc" id="L430">    newOrganizers.setValue(series.getOrganizers());</span>
<span class="nc" id="L431">    metadata.addField(newOrganizers);</span>

<span class="nc" id="L433">    MetadataField contributors = metadata.getOutputFields().get(DublinCore.PROPERTY_CONTRIBUTOR.getLocalName());</span>
<span class="nc" id="L434">    metadata.removeField(contributors);</span>
<span class="nc" id="L435">    MetadataField newContributors = new MetadataField(contributors);</span>
<span class="nc" id="L436">    newContributors.setValue(series.getContributors());</span>
<span class="nc" id="L437">    metadata.addField(newContributors);</span>

<span class="nc" id="L439">    MetadataField publishers = metadata.getOutputFields().get(DublinCore.PROPERTY_PUBLISHER.getLocalName());</span>
<span class="nc" id="L440">    metadata.removeField(publishers);</span>
<span class="nc" id="L441">    MetadataField newPublishers = new MetadataField(publishers);</span>
<span class="nc" id="L442">    newPublishers.setValue(series.getPublishers());</span>
<span class="nc" id="L443">    metadata.addField(newPublishers);</span>

    // Admin UI only field
<span class="nc" id="L446">    MetadataField createdBy = new MetadataField(</span>
      &quot;createdBy&quot;,
      null,
      &quot;EVENTS.SERIES.DETAILS.METADATA.CREATED_BY&quot;,
      true,
      false,
      null,
      null,
      MetadataField.Type.TEXT,
      null,
      null,
<span class="nc" id="L457">      CREATED_BY_UI_ORDER,</span>
      null,
      null,
      null,
      null);
<span class="nc" id="L462">    createdBy.setValue(series.getCreator());</span>
<span class="nc" id="L463">    metadata.addField(createdBy);</span>

<span class="nc" id="L465">    MetadataField uid = metadata.getOutputFields().get(DublinCore.PROPERTY_IDENTIFIER.getLocalName());</span>
<span class="nc" id="L466">    metadata.removeField(uid);</span>
<span class="nc" id="L467">    MetadataField newUID = new MetadataField(uid);</span>
<span class="nc" id="L468">    newUID.setValue(series.getIdentifier());</span>
<span class="nc" id="L469">    metadata.addField(newUID);</span>

<span class="nc" id="L471">    return metadata;</span>
  }

  @PUT
  @Path(&quot;{seriesId}/metadata&quot;)
  @RestQuery(name = &quot;updateseriesmetadata&quot;, description = &quot;Update the series metadata with the one given JSON&quot;, returnDescription = &quot;Returns OK if the metadata have been saved.&quot;, pathParameters = { @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING) }, restParameters = { @RestParameter(name = &quot;metadata&quot;, isRequired = true, type = RestParameter.Type.TEXT, description = &quot;The list of metadata to update&quot;) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The series metadata as JSON.&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The series has not been found&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;) })
  public Response updateSeriesMetadata(@PathParam(&quot;seriesId&quot;) String seriesID,
          @FormParam(&quot;metadata&quot;) String metadataJSON) throws UnauthorizedException, NotFoundException,
          SearchIndexException {
    try {
<span class="nc" id="L484">      MetadataList metadataList = indexService.updateAllSeriesMetadata(seriesID, metadataJSON, searchIndex);</span>
<span class="nc" id="L485">      return okJson(MetadataJson.listToJson(metadataList, true));</span>
<span class="nc" id="L486">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L487">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L488">    } catch (IndexServiceException e) {</span>
<span class="nc" id="L489">      return RestUtil.R.serverError();</span>
    }
  }

  @GET
  @Path(&quot;new/metadata&quot;)
  @RestQuery(name = &quot;getNewMetadata&quot;, description = &quot;Returns all the data related to the metadata tab in the new series modal as JSON&quot;, returnDescription = &quot;All the data related to the series metadata tab as JSON&quot;, responses = { @RestResponse(responseCode = SC_OK, description = &quot;Returns all the data related to the series metadata tab as JSON&quot;) })
  public Response getNewMetadata() {
<span class="nc" id="L497">    MetadataList metadataList = indexService.getMetadataListWithAllSeriesCatalogUIAdapters();</span>
<span class="nc" id="L498">    final DublinCoreMetadataCollection metadataByAdapter = metadataList</span>
<span class="nc" id="L499">            .getMetadataByAdapter(indexService.getCommonSeriesCatalogUIAdapter());</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">    if (metadataByAdapter != null) {</span>
<span class="nc" id="L501">      DublinCoreMetadataCollection collection = metadataByAdapter;</span>
<span class="nc" id="L502">      safelyRemoveField(collection, &quot;identifier&quot;);</span>
<span class="nc" id="L503">      metadataList.add(indexService.getCommonSeriesCatalogUIAdapter(), collection);</span>
    }
<span class="nc" id="L505">    return okJson(MetadataJson.listToJson(metadataList, true));</span>
  }

  private void safelyRemoveField(DublinCoreMetadataCollection collection, String fieldName) {
<span class="nc" id="L509">    MetadataField metadataField = collection.getOutputFields().get(fieldName);</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">    if (metadataField != null) {</span>
<span class="nc" id="L511">      collection.removeField(metadataField);</span>
    }
<span class="nc" id="L513">  }</span>

  @GET
  @Path(&quot;new/themes&quot;)
  @SuppressWarnings(&quot;unchecked&quot;)
  @RestQuery(name = &quot;getNewThemes&quot;, description = &quot;Returns all the data related to the themes tab in the new series modal as JSON&quot;, returnDescription = &quot;All the data related to the series themes tab as JSON&quot;, responses = { @RestResponse(responseCode = SC_OK, description = &quot;Returns all the data related to the series themes tab as JSON&quot;) })
  public Response getNewThemes() {
<span class="fc" id="L520">    ThemeSearchQuery query = new ThemeSearchQuery(securityService.getOrganization().getId(), securityService.getUser());</span>
    // need to set limit because elasticsearch limit results by 10 per default
<span class="fc" id="L522">    query.withLimit(Integer.MAX_VALUE);</span>
<span class="fc" id="L523">    query.withOffset(0);</span>
<span class="fc" id="L524">    query.sortByName(Order.Ascending);</span>
<span class="fc" id="L525">    SearchResult&lt;IndexTheme&gt; results = null;</span>
    try {
<span class="fc" id="L527">      results = searchIndex.getByQuery(query);</span>
<span class="nc" id="L528">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L529">      logger.error(&quot;The admin UI Search Index was not able to get the themes&quot;, e);</span>
<span class="nc" id="L530">      return RestUtil.R.serverError();</span>
<span class="fc" id="L531">    }</span>

<span class="fc" id="L533">    JSONObject themesJson = new JSONObject();</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">    for (SearchResultItem&lt;IndexTheme&gt; item : results.getItems()) {</span>
<span class="fc" id="L535">      JSONObject themeInfoJson = new JSONObject();</span>
<span class="fc" id="L536">      IndexTheme theme = item.getSource();</span>
<span class="fc" id="L537">      themeInfoJson.put(&quot;name&quot;, theme.getName());</span>
<span class="fc" id="L538">      themeInfoJson.put(&quot;description&quot;, theme.getDescription());</span>
<span class="fc" id="L539">      themesJson.put(theme.getIdentifier(), themeInfoJson);</span>
    }
<span class="fc" id="L541">    return Response.ok(themesJson.toJSONString()).build();</span>
  }

  private TobiraService getTobira() {
<span class="nc" id="L545">    return TobiraService.getTobira(securityService.getOrganization().getId());</span>
  }

  @GET
  @Path(&quot;new/tobira/page&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(
          name = &quot;getTobiraPage&quot;,
          description = &quot;Returns data about the page tree of a connected Tobira instance for use in the series creation wizard&quot;,
          returnDescription = &quot;Information about a given page in Tobira, and its direct children&quot;,
          restParameters = { @RestParameter(
                          name = &quot;path&quot;,
                          isRequired = true,
                          type = STRING,
                          description = &quot;The path of the page you want information about&quot;
                  ) },
          responses = {
                  @RestResponse(
                          responseCode = SC_OK,
                          description = &quot;Data about the given page in Tobira. Note that this does not mean the page exists!&quot;),
                  @RestResponse(
                          responseCode = SC_NOT_FOUND,
                          description = &quot;Nonexistent `path`&quot;),
                  @RestResponse(
                          responseCode = SC_BAD_REQUEST,
                          description = &quot;missing `path`&quot;),
                  @RestResponse(
                          responseCode = SC_SERVICE_UNAVAILABLE,
                          description = &quot;Tobira is not configured (correctly)&quot;) })
  public Response getTobiraPage(@QueryParam(&quot;path&quot;) String path) throws IOException, InterruptedException {
<span class="nc bnc" id="L575" title="All 2 branches missed.">    if (path == null) {</span>
<span class="nc" id="L576">      throw new WebApplicationException(&quot;`path` missing&quot;, BAD_REQUEST);</span>
    }

<span class="nc" id="L579">    var tobira = getTobira();</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">    if (!tobira.ready()) {</span>
<span class="nc" id="L581">      return Response.status(Status.SERVICE_UNAVAILABLE)</span>
<span class="nc" id="L582">              .entity(&quot;Tobira is not configured (correctly)&quot;)</span>
<span class="nc" id="L583">              .build();</span>
    }

    try {
<span class="nc" id="L587">      var page = (JSONObject) tobira.getPage(path).get(&quot;page&quot;);</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">      if (page == null) {</span>
<span class="nc" id="L589">        throw new WebApplicationException(NOT_FOUND);</span>
      }
<span class="nc" id="L591">      return Response.ok(page.toJSONString()).build();</span>
<span class="nc" id="L592">    } catch (TobiraException e) {</span>
<span class="nc" id="L593">      throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @POST
  @Path(&quot;new&quot;)
  @RestQuery(name = &quot;createNewSeries&quot;, description = &quot;Creates a new series by the given metadata as JSON&quot;, returnDescription = &quot;The created series id&quot;, restParameters = { @RestParameter(name = &quot;metadata&quot;, isRequired = true, description = &quot;The metadata as JSON&quot;, type = RestParameter.Type.TEXT) }, responses = {
          @RestResponse(responseCode = HttpServletResponse.SC_CREATED, description = &quot;Returns the created series id&quot;),
          @RestResponse(responseCode = HttpServletResponse.SC_BAD_REQUEST, description = &quot;he request could not be fulfilled due to the incorrect syntax of the request&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If user doesn't have rights to create the series&quot;) })
  public Response createNewSeries(@FormParam(&quot;metadata&quot;) String metadata) throws UnauthorizedException {
    try {
      JSONObject metadataJson;
      try {
<span class="nc" id="L607">        metadataJson = (JSONObject) new JSONParser().parse(metadata);</span>
<span class="nc" id="L608">      } catch (Exception e) {</span>
<span class="nc" id="L609">        throw new IllegalArgumentException(&quot;Unable to parse metadata &quot; + metadata, e);</span>
<span class="nc" id="L610">      }</span>

<span class="nc bnc" id="L612" title="All 2 branches missed.">      if (metadataJson == null) {</span>
<span class="nc" id="L613">        throw new IllegalArgumentException(&quot;No metadata set to create series&quot;);</span>
      }

<span class="nc" id="L616">      String seriesId = indexService.createSeries(metadataJson);</span>

<span class="nc" id="L618">      var mounted = mountSeriesInTobira(seriesId, metadataJson);</span>

<span class="nc" id="L620">      var responseObject = new JSONObject();</span>
<span class="nc" id="L621">      responseObject.put(&quot;id&quot;, seriesId);</span>
<span class="nc" id="L622">      responseObject.put(&quot;mounted&quot;, mounted);</span>

<span class="nc" id="L624">      return Response.created(URI.create(UrlSupport.concat(serverUrl, &quot;admin-ng/series/&quot;, seriesId, &quot;metadata.json&quot;)))</span>
<span class="nc" id="L625">              .entity(responseObject.toString()).build();</span>
<span class="nc" id="L626">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L627">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L628">    } catch (IndexServiceException e) {</span>
<span class="nc" id="L629">      return RestUtil.R.serverError();</span>
    }
  }

  private boolean mountSeriesInTobira(String seriesId, JSONObject params) {
<span class="nc" id="L634">    var tobira = getTobira();</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">    if (!tobira.ready()) {</span>
<span class="nc" id="L636">      return false;</span>
    }

<span class="nc" id="L639">    var tobiraParams = params.get(&quot;tobira&quot;);</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">    if (tobiraParams == null) {</span>
<span class="nc" id="L641">      return false;</span>
    }
<span class="nc bnc" id="L643" title="All 2 branches missed.">    if (!(tobiraParams instanceof JSONObject)) {</span>
<span class="nc" id="L644">      return false;</span>
    }
<span class="nc" id="L646">    var tobiraParamsObject = (JSONObject) tobiraParams;</span>

<span class="nc" id="L648">    var metadataCatalogs = (JSONArray) params.get(&quot;metadata&quot;);</span>
<span class="nc" id="L649">    var firstCatalog = (JSONObject) metadataCatalogs.get(0);</span>
<span class="nc" id="L650">    var metadataFields = (List&lt;JSONObject&gt;) firstCatalog.get(&quot;fields&quot;);</span>
<span class="nc" id="L651">    var title = metadataFields.stream()</span>
<span class="nc" id="L652">            .filter(field -&gt; field.get(&quot;id&quot;).equals(&quot;title&quot;))</span>
<span class="nc" id="L653">            .findAny()</span>
<span class="nc" id="L654">            .map(field -&gt; field.get(&quot;value&quot;))</span>
<span class="nc" id="L655">            .map(String.class::cast)</span>
<span class="nc" id="L656">            .get();</span>

<span class="nc" id="L658">    var series = new JSONObject(Map.of(</span>
            &quot;opencastId&quot;, seriesId,
            &quot;title&quot;, title));
<span class="nc" id="L661">    tobiraParamsObject.put(&quot;series&quot;, series);</span>

    try {
<span class="nc" id="L664">      tobira.mount(tobiraParamsObject);</span>
<span class="nc" id="L665">    } catch (TobiraException e) {</span>
<span class="nc" id="L666">      return false;</span>
<span class="nc" id="L667">    }</span>

<span class="nc" id="L669">    return true;</span>
  }

  @DELETE
  @Path(&quot;{seriesId}&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;deleteseries&quot;, description = &quot;Delete a series.&quot;, returnDescription = &quot;Ok if the series has been deleted.&quot;, pathParameters = { @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The id of the series to delete.&quot;, type = STRING), }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The series has been deleted.&quot;),
          @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;The series could not be found.&quot;) })
  public Response deleteSeries(@PathParam(&quot;seriesId&quot;) String id) throws NotFoundException {
    try {
<span class="nc" id="L680">      indexService.removeSeries(id);</span>
<span class="nc" id="L681">      return Response.ok().build();</span>
<span class="nc" id="L682">    } catch (NotFoundException e) {</span>
<span class="nc" id="L683">      throw e;</span>
<span class="nc" id="L684">    } catch (Exception e) {</span>
<span class="nc" id="L685">      logger.error(&quot;Unable to delete the series '{}' due to&quot;, id, e);</span>
<span class="nc" id="L686">      return Response.serverError().build();</span>
    }
  }

  @POST
  @Path(&quot;deleteSeries&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;deletemultipleseries&quot;, description = &quot;Deletes a json list of series by their given ids e.g. [\&quot;Series-1\&quot;, \&quot;Series-2\&quot;]&quot;, returnDescription = &quot;A JSON object with arrays that show whether a series was deleted, was not found or there was an error deleting it.&quot;, responses = {
          @RestResponse(description = &quot;Series have been deleted&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;The list of ids could not be parsed into a json list.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) })
  public Response deleteMultipleSeries(String seriesIdsContent) throws NotFoundException {
<span class="nc bnc" id="L697" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesIdsContent)) {</span>
<span class="nc" id="L698">      return Response.status(Status.BAD_REQUEST).build();</span>
    }

<span class="nc" id="L701">    JSONParser parser = new JSONParser();</span>
    JSONArray seriesIdsArray;
    try {
<span class="nc" id="L704">      seriesIdsArray = (JSONArray) parser.parse(seriesIdsContent);</span>
<span class="nc" id="L705">    } catch (org.json.simple.parser.ParseException e) {</span>
<span class="nc" id="L706">      logger.error(&quot;Unable to parse '{}'&quot;, seriesIdsContent, e);</span>
<span class="nc" id="L707">      return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L708">    } catch (ClassCastException e) {</span>
<span class="nc" id="L709">      logger.error(&quot;Unable to cast '{}' to a JSON array&quot;, seriesIdsContent, e);</span>
<span class="nc" id="L710">      return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L711">    }</span>

<span class="nc" id="L713">    BulkOperationResult result = new BulkOperationResult();</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">    for (Object seriesId : seriesIdsArray) {</span>
      try {
<span class="nc" id="L716">        indexService.removeSeries(seriesId.toString());</span>
<span class="nc" id="L717">        result.addOk(seriesId.toString());</span>
<span class="nc" id="L718">      } catch (NotFoundException e) {</span>
<span class="nc" id="L719">        result.addNotFound(seriesId.toString());</span>
<span class="nc" id="L720">      } catch (Exception e) {</span>
<span class="nc" id="L721">        logger.error(&quot;Unable to remove the series '{}'&quot;, seriesId.toString(), e);</span>
<span class="nc" id="L722">        result.addServerError(seriesId.toString());</span>
<span class="nc" id="L723">      }</span>
<span class="nc" id="L724">    }</span>
<span class="nc" id="L725">    return Response.ok(result.toJson()).build();</span>
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;series.json&quot;)
  @RestQuery(name = &quot;listSeriesAsJson&quot;, description = &quot;Returns the series matching the query parameters&quot;, returnDescription = &quot;Returns the series search results as JSON&quot;, restParameters = {
          @RestParameter(name = &quot;sortorganizer&quot;, isRequired = false, description = &quot;The sort type to apply to the series organizer or organizers either Ascending or Descending.&quot;, type = STRING),
          @RestParameter(name = &quot;sort&quot;, description = &quot;The order instructions used to sort the query result. Must be in the form '&lt;field name&gt;:(ASC|DESC)'&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;filter&quot;, isRequired = false, description = &quot;The filter used for the query. They should be formated like that: 'filter1:value1,filter2,value2'&quot;, type = STRING),
          @RestParameter(name = &quot;offset&quot;, isRequired = false, description = &quot;The page offset&quot;, type = INTEGER, defaultValue = &quot;0&quot;),
          @RestParameter(name = &quot;limit&quot;, isRequired = false, description = &quot;The limit to define the number of returned results (-1 for all)&quot;, type = INTEGER, defaultValue = &quot;100&quot;) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The access control list.&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;) })
  public Response getSeries(@QueryParam(&quot;filter&quot;) String filter, @QueryParam(&quot;sort&quot;) String sort,
          @QueryParam(&quot;offset&quot;) int offset, @QueryParam(&quot;limit&quot;) int limit)
          throws UnauthorizedException {
    try {
<span class="fc" id="L743">      logger.debug(&quot;Requested series list&quot;);</span>
<span class="fc" id="L744">      SeriesSearchQuery query = new SeriesSearchQuery(securityService.getOrganization().getId(),</span>
<span class="fc" id="L745">              securityService.getUser());</span>
<span class="fc" id="L746">      Option&lt;String&gt; optSort = Option.option(trimToNull(sort));</span>

<span class="pc bpc" id="L748" title="1 of 2 branches missed.">      if (offset != 0) {</span>
<span class="nc" id="L749">        query.withOffset(offset);</span>
      }

      // If limit is 0, we set the default limit
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">      query.withLimit(limit == 0 ? DEFAULT_LIMIT : limit);</span>

<span class="fc" id="L755">      Map&lt;String, String&gt; filters = RestUtils.parseFilter(filter);</span>
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">      for (String name : filters.keySet()) {</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">        if (SeriesListQuery.FILTER_ACL_NAME.equals(name)) {</span>
<span class="nc" id="L758">          query.withManagedAcl(filters.get(name));</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">        } else if (SeriesListQuery.FILTER_CONTRIBUTORS_NAME.equals(name)) {</span>
<span class="nc" id="L760">          query.withContributor(filters.get(name));</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        } else if (SeriesListQuery.FILTER_CREATIONDATE_NAME.equals(name)) {</span>
          try {
<span class="nc" id="L763">            Tuple&lt;Date, Date&gt; fromAndToCreationRange = RestUtils.getFromAndToDateRange(filters.get(name));</span>
<span class="nc" id="L764">            query.withCreatedFrom(fromAndToCreationRange.getA());</span>
<span class="nc" id="L765">            query.withCreatedTo(fromAndToCreationRange.getB());</span>
<span class="nc" id="L766">          } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L767">            return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L768">          }</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">        } else if (SeriesListQuery.FILTER_CREATOR_NAME.equals(name)) {</span>
<span class="nc" id="L770">          query.withCreator(filters.get(name));</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">        } else if (SeriesListQuery.FILTER_TEXT_NAME.equals(name)) {</span>
<span class="nc" id="L772">          query.withText(filters.get(name));</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">        } else if (SeriesListQuery.FILTER_LANGUAGE_NAME.equals(name)) {</span>
<span class="nc" id="L774">          query.withLanguage(filters.get(name));</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">        } else if (SeriesListQuery.FILTER_LICENSE_NAME.equals(name)) {</span>
<span class="nc" id="L776">          query.withLicense(filters.get(name));</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">        } else if (SeriesListQuery.FILTER_ORGANIZERS_NAME.equals(name)) {</span>
<span class="nc" id="L778">          query.withOrganizer(filters.get(name));</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">        } else if (SeriesListQuery.FILTER_SUBJECT_NAME.equals(name)) {</span>
<span class="nc" id="L780">          query.withSubject(filters.get(name));</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">        } else if (SeriesListQuery.FILTER_TITLE_NAME.equals(name)) {</span>
<span class="nc" id="L782">          query.withTitle(filters.get(name));</span>
        }
<span class="nc" id="L784">      }</span>

<span class="fc bfc" id="L786" title="All 2 branches covered.">      if (optSort.isSome()) {</span>
<span class="fc" id="L787">        ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(optSort.get());</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">        for (SortCriterion criterion : sortCriteria) {</span>

<span class="pc bpc" id="L790" title="1 of 6 branches missed.">          switch (criterion.getFieldName()) {</span>
            case SeriesIndexSchema.TITLE:
<span class="fc" id="L792">              query.sortByTitle(criterion.getOrder());</span>
<span class="fc" id="L793">              break;</span>
            case SeriesIndexSchema.CONTRIBUTORS:
<span class="fc" id="L795">              query.sortByContributors(criterion.getOrder());</span>
<span class="fc" id="L796">              break;</span>
            case SeriesIndexSchema.ORGANIZERS:
<span class="fc" id="L798">              query.sortByOrganizers(criterion.getOrder());</span>
<span class="fc" id="L799">              break;</span>
            case SeriesIndexSchema.CREATED_DATE_TIME:
<span class="fc" id="L801">              query.sortByCreatedDateTime(criterion.getOrder());</span>
<span class="fc" id="L802">              break;</span>
            case SeriesIndexSchema.MANAGED_ACL:
<span class="fc" id="L804">              query.sortByManagedAcl(criterion.getOrder());</span>
<span class="fc" id="L805">              break;</span>
            default:
<span class="nc" id="L807">              logger.info(&quot;Unknown filter criteria {}&quot;, criterion.getFieldName());</span>
<span class="nc" id="L808">              return Response.status(SC_BAD_REQUEST).build();</span>
          }
<span class="fc" id="L810">        }</span>
      }

      // We search for write actions
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">      if (onlySeriesWithWriteAccessSeriesTab) {</span>
<span class="nc" id="L815">        query.withoutActions();</span>
<span class="nc" id="L816">        query.withAction(Permissions.Action.WRITE);</span>
<span class="nc" id="L817">        query.withAction(Permissions.Action.READ);</span>
      }

<span class="fc" id="L820">      logger.trace(&quot;Using Query: &quot; + query.toString());</span>

<span class="fc" id="L822">      SearchResult&lt;Series&gt; result = searchIndex.getByQuery(query);</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">      if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L824">        logger.debug(&quot;Found {} results in {} ms&quot;, result.getDocumentCount(), result.getSearchTime());</span>
      }

<span class="fc" id="L827">      List&lt;JValue&gt; series = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">      for (SearchResultItem&lt;Series&gt; item : result.getItems()) {</span>
<span class="fc" id="L829">        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L830">        Series s = item.getSource();</span>
<span class="fc" id="L831">        String sId = s.getIdentifier();</span>
<span class="fc" id="L832">        fields.add(f(&quot;id&quot;, v(sId)));</span>
<span class="fc" id="L833">        fields.add(f(&quot;title&quot;, v(s.getTitle(), Jsons.BLANK)));</span>
<span class="fc" id="L834">        fields.add(f(&quot;organizers&quot;, arr($(s.getOrganizers()).map(Functions.stringToJValue))));</span>
<span class="fc" id="L835">        fields.add(f(&quot;contributors&quot;, arr($(s.getContributors()).map(Functions.stringToJValue))));</span>
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">        if (s.getCreator() != null) {</span>
<span class="nc" id="L837">          fields.add(f(&quot;createdBy&quot;, v(s.getCreator())));</span>
        }
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">        if (s.getCreatedDateTime() != null) {</span>
<span class="fc" id="L840">          fields.add(f(&quot;creation_date&quot;, v(toUTC(s.getCreatedDateTime().getTime()), Jsons.BLANK)));</span>
        }
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">        if (s.getLanguage() != null) {</span>
<span class="nc" id="L843">          fields.add(f(&quot;language&quot;, v(s.getLanguage())));</span>
        }
<span class="pc bpc" id="L845" title="1 of 2 branches missed.">        if (s.getLicense() != null) {</span>
<span class="nc" id="L846">          fields.add(f(&quot;license&quot;, v(s.getLicense())));</span>
        }
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">        if (s.getRightsHolder() != null) {</span>
<span class="nc" id="L849">          fields.add(f(&quot;rightsHolder&quot;, v(s.getRightsHolder())));</span>
        }
<span class="pc bpc" id="L851" title="1 of 2 branches missed.">        if (StringUtils.isNotBlank(s.getManagedAcl())) {</span>
<span class="nc" id="L852">          fields.add(f(&quot;managedAcl&quot;, v(s.getManagedAcl())));</span>
        }
<span class="fc" id="L854">        series.add(obj(fields));</span>
      }
<span class="fc" id="L856">      logger.debug(&quot;Request done&quot;);</span>

<span class="fc" id="L858">      return okJsonList(series, offset, limit, result.getHitCount());</span>
<span class="nc" id="L859">    } catch (Exception e) {</span>
<span class="nc" id="L860">      logger.warn(&quot;Could not perform search query&quot;, e);</span>
<span class="nc" id="L861">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Search all user series with write or read-only permissions.
   *
   * @param writeAccess
   *         true: write access
   *         false: read-only access
   * @return user series with write or read-only access,
   *         depending on the parameter
   */
  public Map&lt;String, String&gt; getUserSeriesByAccess(boolean writeAccess) {
<span class="nc" id="L875">    SeriesListQuery query = new SeriesListQuery();</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">    if (writeAccess) {</span>
<span class="nc" id="L877">      query.withoutPermissions();</span>
<span class="nc" id="L878">      query.withReadPermission(true);</span>
<span class="nc" id="L879">      query.withWritePermission(true);</span>
    }
    try {
<span class="nc" id="L882">      return listProvidersService.getList(SeriesListProvider.PROVIDER_PREFIX, query, true);</span>
<span class="nc" id="L883">    } catch (ListProviderException e) {</span>
<span class="nc" id="L884">      logger.warn(&quot;Could not perform search query.&quot;, e);</span>
<span class="nc" id="L885">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;{id}/properties&quot;)
  @RestQuery(name = &quot;getSeriesProperties&quot;, description = &quot;Returns the series properties&quot;, returnDescription = &quot;Returns the series properties as JSON&quot;, pathParameters = { @RestParameter(name = &quot;id&quot;, description = &quot;ID of series&quot;, isRequired = true, type = Type.STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The access control list.&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;) })
  public Response getSeriesPropertiesAsJson(@PathParam(&quot;id&quot;) String seriesId) throws UnauthorizedException,
          NotFoundException {
<span class="nc bnc" id="L898" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesId)) {</span>
<span class="nc" id="L899">      logger.warn(&quot;Series id parameter is blank '{}'.&quot;, seriesId);</span>
<span class="nc" id="L900">      return Response.status(BAD_REQUEST).build();</span>
    }
    try {
<span class="nc" id="L903">      Map&lt;String, String&gt; properties = seriesService.getSeriesProperties(seriesId);</span>
<span class="nc" id="L904">      JSONArray jsonProperties = new JSONArray();</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">      for (String name : properties.keySet()) {</span>
<span class="nc" id="L906">        JSONObject property = new JSONObject();</span>
<span class="nc" id="L907">        property.put(name, properties.get(name));</span>
<span class="nc" id="L908">        jsonProperties.add(property);</span>
<span class="nc" id="L909">      }</span>
<span class="nc" id="L910">      return Response.ok(jsonProperties.toString()).build();</span>
<span class="nc" id="L911">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L912">      throw e;</span>
<span class="nc" id="L913">    } catch (NotFoundException e) {</span>
<span class="nc" id="L914">      throw e;</span>
<span class="nc" id="L915">    } catch (Exception e) {</span>
<span class="nc" id="L916">      logger.warn(&quot;Could not perform search query: {}&quot;, e.getMessage());</span>
    }
<span class="nc" id="L918">    throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;{seriesId}/property/{propertyName}.json&quot;)
  @RestQuery(name = &quot;getSeriesProperty&quot;, description = &quot;Returns a series property value&quot;, returnDescription = &quot;Returns the series property value&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;ID of series&quot;, isRequired = true, type = Type.STRING),
          @RestParameter(name = &quot;propertyName&quot;, description = &quot;Name of series property&quot;, isRequired = true, type = Type.STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The access control list.&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;) })
  public Response getSeriesProperty(@PathParam(&quot;seriesId&quot;) String seriesId,
          @PathParam(&quot;propertyName&quot;) String propertyName) throws UnauthorizedException, NotFoundException {
<span class="nc bnc" id="L931" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesId)) {</span>
<span class="nc" id="L932">      logger.warn(&quot;Series id parameter is blank '{}'.&quot;, seriesId);</span>
<span class="nc" id="L933">      return Response.status(BAD_REQUEST).build();</span>
    }
<span class="nc bnc" id="L935" title="All 2 branches missed.">    if (StringUtils.isBlank(propertyName)) {</span>
<span class="nc" id="L936">      logger.warn(&quot;Series property name parameter is blank '{}'.&quot;, propertyName);</span>
<span class="nc" id="L937">      return Response.status(BAD_REQUEST).build();</span>
    }
    try {
<span class="nc" id="L940">      String propertyValue = seriesService.getSeriesProperty(seriesId, propertyName);</span>
<span class="nc" id="L941">      return Response.ok(propertyValue).build();</span>
<span class="nc" id="L942">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L943">      throw e;</span>
<span class="nc" id="L944">    } catch (NotFoundException e) {</span>
<span class="nc" id="L945">      throw e;</span>
<span class="nc" id="L946">    } catch (Exception e) {</span>
<span class="nc" id="L947">      logger.warn(&quot;Could not perform search query&quot;, e);</span>
    }
<span class="nc" id="L949">    throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
  }

  @POST
  @Path(&quot;/{seriesId}/property&quot;)
  @RestQuery(name = &quot;updateSeriesProperty&quot;, description = &quot;Updates a series property&quot;, returnDescription = &quot;No content.&quot;, restParameters = {
          @RestParameter(name = &quot;name&quot;, isRequired = true, description = &quot;The property's name&quot;, type = TEXT),
          @RestParameter(name = &quot;value&quot;, isRequired = true, description = &quot;The property's value&quot;, type = TEXT) }, pathParameters = { @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;No series with this identifier was found.&quot;),
          @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;The access control list has been updated.&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;),
          @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;The required path or form params were missing in the request.&quot;) })
  public Response updateSeriesProperty(@PathParam(&quot;seriesId&quot;) String seriesId, @FormParam(&quot;name&quot;) String name,
          @FormParam(&quot;value&quot;) String value) throws UnauthorizedException {
<span class="nc bnc" id="L963" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesId)) {</span>
<span class="nc" id="L964">      logger.warn(&quot;Series id parameter is blank '{}'.&quot;, seriesId);</span>
<span class="nc" id="L965">      return Response.status(BAD_REQUEST).build();</span>
    }
<span class="nc bnc" id="L967" title="All 2 branches missed.">    if (StringUtils.isBlank(name)) {</span>
<span class="nc" id="L968">      logger.warn(&quot;Name parameter is blank '{}'.&quot;, name);</span>
<span class="nc" id="L969">      return Response.status(BAD_REQUEST).build();</span>
    }
<span class="nc bnc" id="L971" title="All 2 branches missed.">    if (StringUtils.isBlank(value)) {</span>
<span class="nc" id="L972">      logger.warn(&quot;Series id parameter is blank '{}'.&quot;, value);</span>
<span class="nc" id="L973">      return Response.status(BAD_REQUEST).build();</span>
    }
    try {
<span class="nc" id="L976">      seriesService.updateSeriesProperty(seriesId, name, value);</span>
<span class="nc" id="L977">      return Response.status(NO_CONTENT).build();</span>
<span class="nc" id="L978">    } catch (NotFoundException e) {</span>
<span class="nc" id="L979">      return Response.status(NOT_FOUND).build();</span>
<span class="nc" id="L980">    } catch (SeriesException e) {</span>
<span class="nc" id="L981">      logger.warn(&quot;Could not update series property for series {} property {}:{}&quot;, seriesId, name, value, e);</span>
    }
<span class="nc" id="L983">    throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
  }

  @DELETE
  @Path(&quot;{seriesId}/property/{propertyName}&quot;)
  @RestQuery(name = &quot;deleteSeriesProperty&quot;, description = &quot;Deletes a series property&quot;, returnDescription = &quot;No Content&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;ID of series&quot;, isRequired = true, type = Type.STRING),
          @RestParameter(name = &quot;propertyName&quot;, description = &quot;Name of series property&quot;, isRequired = true, type = Type.STRING) }, responses = {
          @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;The series property has been deleted.&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The series or property has not been found.&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;) })
  public Response deleteSeriesProperty(@PathParam(&quot;seriesId&quot;) String seriesId,
          @PathParam(&quot;propertyName&quot;) String propertyName) throws UnauthorizedException, NotFoundException {
<span class="nc bnc" id="L996" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesId)) {</span>
<span class="nc" id="L997">      logger.warn(&quot;Series id parameter is blank '{}'.&quot;, seriesId);</span>
<span class="nc" id="L998">      return Response.status(BAD_REQUEST).build();</span>
    }
<span class="nc bnc" id="L1000" title="All 2 branches missed.">    if (StringUtils.isBlank(propertyName)) {</span>
<span class="nc" id="L1001">      logger.warn(&quot;Series property name parameter is blank '{}'.&quot;, propertyName);</span>
<span class="nc" id="L1002">      return Response.status(BAD_REQUEST).build();</span>
    }
    try {
<span class="nc" id="L1005">      seriesService.deleteSeriesProperty(seriesId, propertyName);</span>
<span class="nc" id="L1006">      return Response.status(NO_CONTENT).build();</span>
<span class="nc" id="L1007">    } catch (UnauthorizedException | NotFoundException e) {</span>
<span class="nc" id="L1008">      throw e;</span>
<span class="nc" id="L1009">    } catch (Exception e) {</span>
<span class="nc" id="L1010">      logger.warn(&quot;Could not delete series '{}' property '{}' query&quot;, seriesId, propertyName, e);</span>
    }
<span class="nc" id="L1012">    throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
  }

  /**
   * Creates an ok response with the entity being the theme id and name.
   *
   * @param theme
   *          The theme to get the id and name from.
   * @return A {@link Response} with the theme id and name as json contents
   */
  private Response getSimpleThemeJsonResponse(IndexTheme theme) {
<span class="fc" id="L1023">    return okJson(obj(f(Long.toString(theme.getIdentifier()), v(theme.getName()))));</span>
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;{seriesId}/theme.json&quot;)
  @RestQuery(name = &quot;getSeriesTheme&quot;, description = &quot;Returns the series theme id and name as JSON&quot;, returnDescription = &quot;Returns the series theme name and id as JSON&quot;, pathParameters = { @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The series theme id and name as JSON.&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The series or theme has not been found&quot;) })
  public Response getSeriesTheme(@PathParam(&quot;seriesId&quot;) String seriesId) {
    Long themeId;
    try {
<span class="fc" id="L1035">      Optional&lt;Series&gt; series = searchIndex.getSeries(seriesId, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="fc bfc" id="L1036" title="All 2 branches covered.">      if (series.isEmpty())</span>
<span class="fc" id="L1037">        return notFound(&quot;Cannot find a series with id {}&quot;, seriesId);</span>

<span class="fc" id="L1039">      themeId = series.get().getTheme();</span>
<span class="nc" id="L1040">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1041">      logger.error(&quot;Unable to get series {}&quot;, seriesId, e);</span>
<span class="nc" id="L1042">      throw new WebApplicationException(e);</span>
<span class="fc" id="L1043">    }</span>

    // If no theme is set return empty JSON
<span class="fc bfc" id="L1046" title="All 2 branches covered.">    if (themeId == null)</span>
<span class="fc" id="L1047">      return okJson(obj());</span>

    try {
<span class="fc" id="L1050">      Opt&lt;IndexTheme&gt; themeOpt = getTheme(themeId);</span>
<span class="pc bpc" id="L1051" title="1 of 2 branches missed.">      if (themeOpt.isNone())</span>
<span class="nc" id="L1052">        return notFound(&quot;Cannot find a theme with id {}&quot;, themeId);</span>

<span class="fc" id="L1054">      return getSimpleThemeJsonResponse(themeOpt.get());</span>
<span class="nc" id="L1055">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1056">      logger.error(&quot;Unable to get theme {}&quot;, themeId, e);</span>
<span class="nc" id="L1057">      throw new WebApplicationException(e);</span>
    }
  }

  @PUT
  @Path(&quot;{seriesId}/theme&quot;)
  @RestQuery(name = &quot;updateSeriesTheme&quot;, description = &quot;Update the series theme id&quot;, returnDescription = &quot;Returns the id and name of the theme.&quot;, pathParameters = { @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING) }, restParameters = { @RestParameter(name = &quot;themeId&quot;, isRequired = true, type = RestParameter.Type.INTEGER, description = &quot;The id of the theme for this series&quot;) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The series theme has been updated and the theme id and name are returned as JSON.&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The series or theme has not been found&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;) })
  public Response updateSeriesTheme(@PathParam(&quot;seriesId&quot;) String seriesID, @FormParam(&quot;themeId&quot;) long themeId)
          throws UnauthorizedException, NotFoundException {
    try {
<span class="fc" id="L1070">      Opt&lt;IndexTheme&gt; themeOpt = getTheme(themeId);</span>
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">      if (themeOpt.isNone())</span>
<span class="nc" id="L1072">        return notFound(&quot;Cannot find a theme with id {}&quot;, themeId);</span>

<span class="fc" id="L1074">      seriesService.updateSeriesProperty(seriesID, THEME_KEY, Long.toString(themeId));</span>
<span class="fc" id="L1075">      return getSimpleThemeJsonResponse(themeOpt.get());</span>
<span class="nc" id="L1076">    } catch (SeriesException e) {</span>
<span class="nc" id="L1077">      logger.error(&quot;Unable to update series theme {}&quot;, themeId, e);</span>
<span class="nc" id="L1078">      throw new WebApplicationException(e);</span>
<span class="nc" id="L1079">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1080">      logger.error(&quot;Unable to get theme {}&quot;, themeId, e);</span>
<span class="nc" id="L1081">      throw new WebApplicationException(e);</span>
    }
  }

  @DELETE
  @Path(&quot;{seriesId}/theme&quot;)
  @RestQuery(name = &quot;deleteSeriesTheme&quot;, description = &quot;Removes the theme from the series&quot;, returnDescription = &quot;Returns no content&quot;, pathParameters = { @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;The series theme has been removed&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The series has not been found&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;) })
  public Response deleteSeriesTheme(@PathParam(&quot;seriesId&quot;) String seriesID) throws UnauthorizedException,
          NotFoundException {
    try {
<span class="fc" id="L1094">      seriesService.deleteSeriesProperty(seriesID, THEME_KEY);</span>
<span class="fc" id="L1095">      return Response.noContent().build();</span>
<span class="nc" id="L1096">    } catch (SeriesException e) {</span>
<span class="nc" id="L1097">      logger.error(&quot;Unable to remove theme from series {}&quot;, seriesID, e);</span>
<span class="nc" id="L1098">      throw new WebApplicationException(e);</span>
    }
  }

  @GET
  @Path(&quot;{seriesId}/tobira/pages&quot;)
  @RestQuery(
          name = &quot;getSeriesHostPages&quot;,
          description = &quot;Returns the pages of a connected Tobira instance that contain the given series&quot;,
          returnDescription = &quot;The Tobira pages that contain the given series&quot;,
          pathParameters = { @RestParameter(
                  name = &quot;seriesId&quot;,
                  isRequired = true,
                  description = &quot;The series identifier&quot;,
                  type = STRING) },
          responses = {
                  @RestResponse(
                          responseCode = SC_OK,
                          description = &quot;The Tobira pages containing the given series&quot;),
                  @RestResponse(
                          responseCode = SC_NOT_FOUND,
                          description = &quot;Tobira doesn't know about the given series&quot;),
                  @RestResponse(
                          responseCode = SC_SERVICE_UNAVAILABLE,
                          description = &quot;Tobira is not configured (correctly)&quot;) })
public Response getSeriesHostPages(@PathParam(&quot;seriesId&quot;) String seriesId) {
<span class="nc" id="L1124">    var tobira = getTobira();</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">    if (!tobira.ready()) {</span>
<span class="nc" id="L1126">      return Response.status(Status.SERVICE_UNAVAILABLE)</span>
<span class="nc" id="L1127">              .entity(&quot;Tobira is not configured (correctly)&quot;)</span>
<span class="nc" id="L1128">              .build();</span>
    }

    try {
<span class="nc" id="L1132">      var seriesData = tobira.getHostPages(seriesId);</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">      if (seriesData == null) {</span>
<span class="nc" id="L1134">        throw new WebApplicationException(NOT_FOUND);</span>
      }
<span class="nc" id="L1136">      seriesData.put(&quot;baseURL&quot;, tobira.getOrigin());</span>
<span class="nc" id="L1137">      return Response.ok(seriesData.toJSONString()).build();</span>
<span class="nc" id="L1138">    } catch (TobiraException e) {</span>
<span class="nc" id="L1139">      throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @POST
  @Path(&quot;{seriesId}/tobira/path&quot;)
  @RestQuery(
          name = &quot;updateSeriesTobiraPath&quot;,
          description = &quot;Updates the path of the given series in a connected Tobira instance&quot;,
          returnDescription = &quot;Status code&quot;,
          pathParameters = { @RestParameter(
                  name = &quot;seriesId&quot;,
                  isRequired = true,
                  description = &quot;The series id&quot;,
                  type = STRING) },
          restParameters = {
                  @RestParameter(
                          name = &quot;pathComponents&quot;,
                          isRequired = true,
                          description = &quot;List of realms with name and path segment on path to series.&quot;,
                          type = TEXT),
                  @RestParameter(
                          name = &quot;currentPath&quot;,
                          isRequired = false,
                          description = &quot;Path where the series is currently mounted.&quot;,
                          type = STRING),
                  @RestParameter(
                          name = &quot;targetPath&quot;,
                          isRequired = true,
                          description = &quot;Path where the series will be mounted.&quot;,
                          type = STRING) },
          responses = {
                  @RestResponse(
                          responseCode = SC_OK,
                          description = &quot;The path of the series has successfully been updated in Tobira.&quot;),
                  @RestResponse(
                          responseCode = SC_NOT_FOUND,
                          description = &quot;Tobira doesn't know about the given series&quot;),
                  @RestResponse(
                          responseCode = SC_SERVICE_UNAVAILABLE,
                          description = &quot;Tobira is not configured (correctly)&quot;) })
  public Response updateSeriesTobiraPath(
    @PathParam(&quot;seriesId&quot;) String seriesId,
    @FormParam(&quot;pathComponents&quot;) String pathComponents,
    @FormParam(&quot;currentPath&quot;) String currentPath,
    @FormParam(&quot;targetPath&quot;) String targetPath
  ) throws IOException, InterruptedException {
<span class="nc bnc" id="L1186" title="All 2 branches missed.">    if (targetPath == null) {</span>
<span class="nc" id="L1187">      throw new WebApplicationException(&quot;target path is missing&quot;, BAD_REQUEST);</span>
    }

<span class="nc" id="L1190">    var tobira = getTobira();</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">    if (!tobira.ready()) {</span>
<span class="nc" id="L1192">      return Response.status(Status.SERVICE_UNAVAILABLE)</span>
<span class="nc" id="L1193">              .entity(&quot;Tobira is not configured (correctly)&quot;)</span>
<span class="nc" id="L1194">              .build();</span>
    }

    try {
<span class="nc" id="L1198">      var paths = (List&lt;JSONObject&gt;) new JSONParser().parse(pathComponents);</span>

<span class="nc" id="L1200">      var mountParams = new JSONObject();</span>
<span class="nc" id="L1201">      mountParams.put(&quot;seriesId&quot;, seriesId);</span>
<span class="nc" id="L1202">      mountParams.put(&quot;targetPath&quot;, targetPath);</span>

<span class="nc" id="L1204">      tobira.createRealmLineage(paths);</span>
<span class="nc" id="L1205">      tobira.addSeriesMountPoint(mountParams);</span>

<span class="nc bnc" id="L1207" title="All 4 branches missed.">      if (currentPath != null &amp;&amp; !currentPath.trim().isEmpty()) {</span>
<span class="nc" id="L1208">        var unmountParams = new JSONObject();</span>
<span class="nc" id="L1209">        unmountParams.put(&quot;seriesId&quot;, seriesId);</span>
<span class="nc" id="L1210">        unmountParams.put(&quot;currentPath&quot;, currentPath);</span>
<span class="nc" id="L1211">        tobira.removeSeriesMountPoint(unmountParams);</span>
      }

<span class="nc" id="L1214">      return ok();</span>
<span class="nc" id="L1215">    } catch (Exception e) {</span>
<span class="nc" id="L1216">      return Response.status(Status.INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L1217">              .entity(&quot;Internal server error: &quot; + e.getMessage())</span>
<span class="nc" id="L1218">              .build();</span>
    }
  }

  @DELETE
  @Path(&quot;{seriesId}/tobira/{currentPath}&quot;)
  @RestQuery(
          name = &quot;removeSeriesTobiraPath&quot;,
          description = &quot;Removes the path of the given series in a connected Tobira instance&quot;,
          returnDescription = &quot;Status code&quot;,
          pathParameters = {
                  @RestParameter(
                          name = &quot;seriesId&quot;,
                          isRequired = true,
                          description = &quot;The series id&quot;,
                          type = STRING),
                  @RestParameter(
                          name = &quot;currentPath&quot;,
                          isRequired = true,
                          description = &quot;URL encoded path where the series is currently mounted.&quot;,
                          type = STRING) },
          responses = {
                  @RestResponse(
                          responseCode = SC_OK,
                          description = &quot;The path of the series has successfully been removed in Tobira.&quot;),
                  @RestResponse(
                          responseCode = SC_NOT_FOUND,
                          description = &quot;Tobira doesn't know about the given series&quot;),
                  @RestResponse(
                          responseCode = SC_SERVICE_UNAVAILABLE,
                          description = &quot;Tobira is not configured (correctly)&quot;) })
  public Response removeSeriesTobiraPath(
    @PathParam(&quot;seriesId&quot;) String seriesId,
    @PathParam(&quot;currentPath&quot;) String currentPath
  ) throws IOException, InterruptedException {
<span class="nc" id="L1253">    var tobira = getTobira();</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">    if (!tobira.ready()) {</span>
<span class="nc" id="L1255">      return Response.status(Status.SERVICE_UNAVAILABLE)</span>
<span class="nc" id="L1256">              .entity(&quot;Tobira is not configured (correctly)&quot;)</span>
<span class="nc" id="L1257">              .build();</span>
    }

    try {
<span class="nc bnc" id="L1261" title="All 4 branches missed.">      if (currentPath != null &amp;&amp; !currentPath.trim().isEmpty()) {</span>
<span class="nc" id="L1262">        var unmountParams = new JSONObject();</span>
<span class="nc" id="L1263">        unmountParams.put(&quot;seriesId&quot;, seriesId);</span>
<span class="nc" id="L1264">        unmountParams.put(&quot;currentPath&quot;, currentPath);</span>
<span class="nc" id="L1265">        tobira.removeSeriesMountPoint(unmountParams);</span>
      }

<span class="nc" id="L1268">      return ok();</span>
<span class="nc" id="L1269">    } catch (Exception e) {</span>
<span class="nc" id="L1270">      return Response.status(Status.INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L1271">              .entity(&quot;Internal server error: &quot; + e.getMessage())</span>
<span class="nc" id="L1272">              .build();</span>
    }
  }

  @POST
  @Path(&quot;/{seriesId}/access&quot;)
  @RestQuery(name = &quot;applyAclToSeries&quot;, description = &quot;Immediate application of an ACL to a series&quot;, returnDescription = &quot;Status code&quot;, pathParameters = { @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The series ID&quot;, type = STRING) }, restParameters = {
          @RestParameter(name = &quot;acl&quot;, isRequired = true, description = &quot;The ACL to apply&quot;, type = STRING),
          @RestParameter(name = &quot;override&quot;, isRequired = false, defaultValue = &quot;false&quot;, description = &quot;If true the series ACL will take precedence over any existing episode ACL&quot;, type = BOOLEAN) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The ACL has been successfully applied&quot;),
          @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;Unable to parse the given ACL&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The series has not been found&quot;),
          @RestResponse(responseCode = SC_INTERNAL_SERVER_ERROR, description = &quot;Internal error&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;) })
  public Response applyAclToSeries(@PathParam(&quot;seriesId&quot;) String seriesId, @FormParam(&quot;acl&quot;) String acl,
          @DefaultValue(&quot;false&quot;) @FormParam(&quot;override&quot;) boolean override) throws SearchIndexException {

    AccessControlList accessControlList;
    try {
<span class="fc" id="L1291">      accessControlList = AccessControlParser.parseAcl(acl);</span>
<span class="fc" id="L1292">    } catch (Exception e) {</span>
<span class="fc" id="L1293">      logger.warn(&quot;Unable to parse ACL '{}'&quot;, acl);</span>
<span class="fc" id="L1294">      return badRequest();</span>
<span class="fc" id="L1295">    }</span>

<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">    if (!accessControlList.isValid()) {</span>
<span class="nc" id="L1298">      logger.debug(&quot;POST api/series/{}/access: Invalid series ACL detected&quot;, seriesId);</span>
<span class="nc" id="L1299">      return badRequest();</span>
    }

<span class="fc" id="L1302">    Optional&lt;Series&gt; series = searchIndex.getSeries(seriesId, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="fc bfc" id="L1303" title="All 2 branches covered.">    if (series.isEmpty())</span>
<span class="fc" id="L1304">      return notFound(&quot;Cannot find a series with id {}&quot;, seriesId);</span>

<span class="pc bpc" id="L1306" title="1 of 2 branches missed.">    if (hasProcessingEvents(seriesId)) {</span>
<span class="nc" id="L1307">      logger.warn(&quot;Can not update the ACL from series {}. Events being part of the series are currently processed.&quot;,</span>
              seriesId);
<span class="nc" id="L1309">      return conflict();</span>
    }

    try {
<span class="fc" id="L1313">      seriesService.updateAccessControl(seriesId, accessControlList, override);</span>
<span class="fc" id="L1314">      return ok();</span>
<span class="nc" id="L1315">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1316">      logger.warn(&quot;Unable to find series '{}' to apply the ACL.&quot;, seriesId);</span>
<span class="nc" id="L1317">      return notFound();</span>
<span class="nc" id="L1318">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1319">      return forbidden();</span>
<span class="nc" id="L1320">    } catch (SeriesException e) {</span>
<span class="nc" id="L1321">      logger.error(&quot;Error applying acl to series {}&quot;, seriesId);</span>
<span class="nc" id="L1322">      return serverError();</span>
    }
  }

  /**
   * Check if the series with the given Id has events being currently processed
   *
   * @param seriesId
   *          the series Id
   * @return true if events being part of the series are currently processed
   */
  private boolean hasProcessingEvents(String seriesId) {
<span class="fc" id="L1334">    EventSearchQuery query = new EventSearchQuery(securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="fc" id="L1335">    long elementsCount = 0;</span>
<span class="fc" id="L1336">    query.withSeriesId(seriesId);</span>

    try {
<span class="fc" id="L1339">      query.withWorkflowState(WorkflowInstance.WorkflowState.RUNNING.toString());</span>
<span class="fc" id="L1340">      SearchResult&lt;Event&gt; events = searchIndex.getByQuery(query);</span>
<span class="fc" id="L1341">      elementsCount = events.getHitCount();</span>
<span class="fc" id="L1342">      query.withWorkflowState(WorkflowInstance.WorkflowState.INSTANTIATED.toString());</span>
<span class="fc" id="L1343">      events = searchIndex.getByQuery(query);</span>
<span class="fc" id="L1344">      elementsCount += events.getHitCount();</span>
<span class="nc" id="L1345">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1346">      logger.warn(&quot;Could not perform search query&quot;, e);</span>
<span class="nc" id="L1347">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="fc" id="L1348">    }</span>

<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">    return elementsCount &gt; 0;</span>
  }

  @GET
  @Path(&quot;{seriesId}/hasEvents.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;hasEvents&quot;, description = &quot;Check if given series has events&quot;, returnDescription = &quot;true if series has events, otherwise false&quot;, pathParameters = {
    @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = Type.STRING) }, responses = {
    @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;The required form params were missing in the request.&quot;),
    @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;If the series has not been found.&quot;),
    @RestResponse(responseCode = SC_OK, description = &quot;The access information &quot;) })
  public Response getSeriesEvents(@PathParam(&quot;seriesId&quot;) String seriesId) throws Exception {
<span class="nc bnc" id="L1362" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesId))</span>
<span class="nc" id="L1363">      return RestUtil.R.badRequest(&quot;Path parameter series ID is missing&quot;);</span>

<span class="nc" id="L1365">    long elementsCount = 0;</span>

    try {
<span class="nc" id="L1368">      EventSearchQuery query = new EventSearchQuery(securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="nc" id="L1369">      query.withSeriesId(seriesId);</span>
<span class="nc" id="L1370">      SearchResult&lt;Event&gt; result = searchIndex.getByQuery(query);</span>
<span class="nc" id="L1371">      elementsCount = result.getHitCount();</span>
<span class="nc" id="L1372">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1373">      logger.warn(&quot;Could not perform search query&quot;, e);</span>
<span class="nc" id="L1374">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L1375">    }</span>

<span class="nc" id="L1377">    JSONObject jsonReturnObj = new JSONObject();</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">    jsonReturnObj.put(&quot;hasEvents&quot;, elementsCount &gt; 0);</span>
<span class="nc" id="L1379">    return Response.ok(jsonReturnObj.toString()).build();</span>
  }

  /**
   * Get a single theme
   *
   * @param id
   *          the theme id
   * @return a theme or none if not found, wrapped in an option
   * @throws SearchIndexException
   */
  private Opt&lt;IndexTheme&gt; getTheme(long id) throws SearchIndexException {
<span class="fc" id="L1391">    SearchResult&lt;IndexTheme&gt; result = searchIndex.getByQuery(new ThemeSearchQuery(securityService.getOrganization().getId(),</span>
<span class="fc" id="L1392">            securityService.getUser()).withIdentifier(id));</span>
<span class="pc bpc" id="L1393" title="1 of 2 branches missed.">    if (result.getPageSize() == 0) {</span>
<span class="nc" id="L1394">      logger.debug(&quot;Didn't find theme with id {}&quot;, id);</span>
<span class="nc" id="L1395">      return Opt.&lt;IndexTheme&gt; none();</span>
    }
<span class="fc" id="L1397">    return Opt.some(result.getItems()[0].getSource());</span>
  }

  @GET
  @Path(&quot;configuration.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getseriesconfiguration&quot;, description = &quot;Get the series configuration&quot;, returnDescription = &quot;List of configuration keys&quot;, responses = {
    @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;The required form params were missing in the request.&quot;),
    @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;If the series has not been found.&quot;),
    @RestResponse(responseCode = SC_OK, description = &quot;The access information &quot;) })
  public Response getSeriesOptions() {
<span class="nc" id="L1408">    JSONObject jsonReturnObj = new JSONObject();</span>
<span class="nc" id="L1409">    jsonReturnObj.put(&quot;deleteSeriesWithEventsAllowed&quot;, deleteSeriesWithEventsAllowed);</span>
<span class="nc" id="L1410">    return Response.ok(jsonReturnObj.toString()).build();</span>
  }

  public Boolean getOnlySeriesWithWriteAccessSeriesTab() {
<span class="nc" id="L1414">    return onlySeriesWithWriteAccessSeriesTab;</span>
  }

  public Boolean getOnlySeriesWithWriteAccessEventsFilter() {
<span class="nc" id="L1418">    return onlySeriesWithWriteAccessEventsFilter;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>