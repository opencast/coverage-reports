<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractEventEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-admin-ui</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.adminui.endpoint</a> &gt; <span class="el_source">AbstractEventEndpoint.java</span></div><h1>AbstractEventEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.adminui.endpoint;

import static com.entwinemedia.fn.Stream.$;
import static com.entwinemedia.fn.data.Opt.nul;
import static com.entwinemedia.fn.data.json.Jsons.BLANK;
import static com.entwinemedia.fn.data.json.Jsons.NULL;
import static com.entwinemedia.fn.data.json.Jsons.arr;
import static com.entwinemedia.fn.data.json.Jsons.f;
import static com.entwinemedia.fn.data.json.Jsons.obj;
import static com.entwinemedia.fn.data.json.Jsons.v;
import static java.lang.String.format;
import static javax.servlet.http.HttpServletResponse.SC_ACCEPTED;
import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
import static javax.servlet.http.HttpServletResponse.SC_NO_CONTENT;
import static javax.servlet.http.HttpServletResponse.SC_OK;
import static javax.servlet.http.HttpServletResponse.SC_SERVICE_UNAVAILABLE;
import static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;
import static javax.ws.rs.core.Response.Status.NOT_FOUND;
import static org.apache.commons.lang3.StringUtils.trimToNull;
import static org.opencastproject.adminui.endpoint.EndpointUtil.transformAccessControList;
import static org.opencastproject.index.service.util.RestUtils.conflictJson;
import static org.opencastproject.index.service.util.RestUtils.notFound;
import static org.opencastproject.index.service.util.RestUtils.notFoundJson;
import static org.opencastproject.index.service.util.RestUtils.okJson;
import static org.opencastproject.index.service.util.RestUtils.okJsonList;
import static org.opencastproject.index.service.util.RestUtils.serverErrorJson;
import static org.opencastproject.util.DateTimeSupport.toUTC;
import static org.opencastproject.util.RestUtil.R.badRequest;
import static org.opencastproject.util.RestUtil.R.conflict;
import static org.opencastproject.util.RestUtil.R.forbidden;
import static org.opencastproject.util.RestUtil.R.noContent;
import static org.opencastproject.util.RestUtil.R.notFound;
import static org.opencastproject.util.RestUtil.R.ok;
import static org.opencastproject.util.RestUtil.R.serverError;
import static org.opencastproject.util.doc.rest.RestParameter.Type.BOOLEAN;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;
import static org.opencastproject.util.doc.rest.RestParameter.Type.TEXT;

import org.opencastproject.adminui.exception.JobEndpointException;
import org.opencastproject.adminui.impl.AdminUIConfiguration;
import org.opencastproject.adminui.tobira.TobiraException;
import org.opencastproject.adminui.tobira.TobiraService;
import org.opencastproject.adminui.util.BulkUpdateUtil;
import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.authorization.xacml.manager.api.AclService;
import org.opencastproject.authorization.xacml.manager.api.ManagedAcl;
import org.opencastproject.authorization.xacml.manager.util.AccessInformationUtil;
import org.opencastproject.capture.CaptureParameters;
import org.opencastproject.capture.admin.api.Agent;
import org.opencastproject.capture.admin.api.CaptureAgentStateService;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.api.SearchResultItem;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.objects.event.EventIndexSchema;
import org.opencastproject.elasticsearch.index.objects.event.EventSearchQuery;
import org.opencastproject.event.comment.EventComment;
import org.opencastproject.event.comment.EventCommentException;
import org.opencastproject.event.comment.EventCommentReply;
import org.opencastproject.event.comment.EventCommentService;
import org.opencastproject.index.service.api.IndexService;
import org.opencastproject.index.service.api.IndexService.Source;
import org.opencastproject.index.service.exception.IndexServiceException;
import org.opencastproject.index.service.exception.UnsupportedAssetException;
import org.opencastproject.index.service.impl.util.EventUtils;
import org.opencastproject.index.service.resources.list.provider.EventsListProvider.Comments;
import org.opencastproject.index.service.resources.list.provider.EventsListProvider.IsPublished;
import org.opencastproject.index.service.resources.list.query.EventListQuery;
import org.opencastproject.index.service.resources.list.query.SeriesListQuery;
import org.opencastproject.index.service.util.JSONUtils;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.list.api.ResourceListQuery;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.AudioStream;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Publication;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.VideoStream;
import org.opencastproject.mediapackage.track.AudioStreamImpl;
import org.opencastproject.mediapackage.track.SubtitleStreamImpl;
import org.opencastproject.mediapackage.track.VideoStreamImpl;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.EventCatalogUIAdapter;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.MetadataJson;
import org.opencastproject.metadata.dublincore.MetadataList;
import org.opencastproject.metadata.dublincore.MetadataList.Locked;
import org.opencastproject.rest.BulkOperationResult;
import org.opencastproject.rest.RestConstants;
import org.opencastproject.scheduler.api.Recording;
import org.opencastproject.scheduler.api.SchedulerException;
import org.opencastproject.scheduler.api.SchedulerService;
import org.opencastproject.scheduler.api.TechnicalMetadata;
import org.opencastproject.scheduler.api.Util;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.AclScope;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.api.User;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.security.urlsigning.exception.UrlSigningException;
import org.opencastproject.security.urlsigning.service.UrlSigningService;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.util.DateTimeSupport;
import org.opencastproject.util.Jsons.Val;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RestUtil;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.util.data.Tuple3;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.requests.SortCriterion;
import org.opencastproject.workflow.api.RetryStrategy;
import org.opencastproject.workflow.api.WorkflowDatabaseException;
import org.opencastproject.workflow.api.WorkflowDefinition;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowOperationInstance;
import org.opencastproject.workflow.api.WorkflowService;
import org.opencastproject.workflow.api.WorkflowStateException;
import org.opencastproject.workflow.api.WorkflowUtil;

import com.entwinemedia.fn.Fn;
import com.entwinemedia.fn.Stream;
import com.entwinemedia.fn.data.Opt;
import com.entwinemedia.fn.data.json.Field;
import com.entwinemedia.fn.data.json.JObject;
import com.entwinemedia.fn.data.json.JValue;
import com.entwinemedia.fn.data.json.Jsons;
import com.entwinemedia.fn.data.json.Jsons.Functions;

import net.fortuna.ical4j.model.property.RRule;

import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.jettison.json.JSONException;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.text.ParseException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.TimeZone;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

/**
 * The event endpoint acts as a facade for WorkflowService and Archive providing a unified query interface and result
 * set.
 * &lt;p&gt;
 * This first implementation uses the {@link org.opencastproject.assetmanager.api.AssetManager}. In a later iteration
 * the endpoint may abstract over the concrete archive.
 */
@Path(&quot;/admin-ng/event&quot;)
<span class="fc" id="L224">public abstract class AbstractEventEndpoint {</span>

  /**
   * Scheduling JSON keys
   */
  public static final String SCHEDULING_AGENT_ID_KEY = &quot;agentId&quot;;
  public static final String SCHEDULING_START_KEY = &quot;start&quot;;
  public static final String SCHEDULING_END_KEY = &quot;end&quot;;
  private static final String SCHEDULING_AGENT_CONFIGURATION_KEY = &quot;agentConfiguration&quot;;
  public static final String SCHEDULING_PREVIOUS_AGENTID = &quot;previousAgentId&quot;;
  public static final String SCHEDULING_PREVIOUS_PREVIOUSENTRIES = &quot;previousEntries&quot;;

  private static final String WORKFLOW_ACTION_STOP = &quot;STOP&quot;;

  /** The logging facility */
<span class="fc" id="L239">  static final Logger logger = LoggerFactory.getLogger(AbstractEventEndpoint.class);</span>

  /** The configuration key that defines the default workflow definition */
  //TODO Move to a constants file instead of declaring it at the top of multiple files?
  protected static final String WORKFLOW_DEFINITION_DEFAULT = &quot;org.opencastproject.workflow.default.definition&quot;;

  private static final String WORKFLOW_STATUS_TRANSLATION_PREFIX = &quot;EVENTS.EVENTS.DETAILS.WORKFLOWS.OPERATION_STATUS.&quot;;

  /** The default time before a piece of signed content expires. 2 Hours. */
  protected static final long DEFAULT_URL_SIGNING_EXPIRE_DURATION = 2 * 60 * 60;

  public abstract AssetManager getAssetManager();

  public abstract WorkflowService getWorkflowService();

  public abstract ElasticsearchIndex getIndex();

  public abstract JobEndpoint getJobService();

  public abstract SeriesEndpoint getSeriesEndpoint();

  public abstract AclService getAclService();

  public abstract EventCommentService getEventCommentService();

  public abstract SecurityService getSecurityService();

  public abstract IndexService getIndexService();

  public abstract AuthorizationService getAuthorizationService();

  public abstract SchedulerService getSchedulerService();

  public abstract CaptureAgentStateService getCaptureAgentStateService();

  public abstract AdminUIConfiguration getAdminUIConfiguration();

  public abstract long getUrlSigningExpireDuration();

  public abstract UrlSigningService getUrlSigningService();

  public abstract Boolean signWithClientIP();

  public abstract Boolean getOnlySeriesWithWriteAccessEventModal();

  public abstract Boolean getOnlyEventsWithWriteAccessEventsTab();

  public abstract UserDirectoryService getUserDirectoryService();

  /** Default server URL */
<span class="fc" id="L289">  protected String serverUrl = &quot;http://localhost:8080&quot;;</span>

  /** Service url */
<span class="fc" id="L292">  protected String serviceUrl = null;</span>

  /** The default workflow identifier, if one is configured */
<span class="fc" id="L295">  protected String defaultWorkflowDefinionId = null;</span>

  /** The system user name (default set here for unit tests) */
<span class="fc" id="L298">  private String systemUserName = &quot;opencast_system_account&quot;;</span>

  /**
   * Activates REST service.
   *
   * @param cc
   *          ComponentContext
   */
  @Activate
  public void activate(ComponentContext cc) {
<span class="nc bnc" id="L308" title="All 2 branches missed.">    if (cc != null) {</span>
<span class="nc" id="L309">      String ccServerUrl = cc.getBundleContext().getProperty(OpencastConstants.SERVER_URL_PROPERTY);</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">      if (StringUtils.isNotBlank(ccServerUrl))</span>
<span class="nc" id="L311">        this.serverUrl = ccServerUrl;</span>

<span class="nc" id="L313">      this.serviceUrl = (String) cc.getProperties().get(RestConstants.SERVICE_PATH_PROPERTY);</span>

<span class="nc" id="L315">      String ccDefaultWorkflowDefinionId = StringUtils.trimToNull(cc.getBundleContext().getProperty(WORKFLOW_DEFINITION_DEFAULT));</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">      if (StringUtils.isNotBlank(ccDefaultWorkflowDefinionId))</span>
<span class="nc" id="L318">        this.defaultWorkflowDefinionId = ccDefaultWorkflowDefinionId;</span>

<span class="nc" id="L320">      systemUserName = SecurityUtil.getSystemUserName(cc);</span>
    }
<span class="nc" id="L322">  }</span>

  /* As the list of event ids can grow large, we use a POST request to avoid problems with too large query strings */
  @POST
  @Path(&quot;workflowProperties&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;workflowProperties&quot;, description = &quot;Returns workflow properties for the specified events&quot;,
             returnDescription = &quot;The workflow properties for every event as JSON&quot;, restParameters = {
                @RestParameter(name = &quot;eventIds&quot;, description = &quot;A JSON array of ids of the events&quot;, isRequired = true, type = RestParameter.Type.STRING)},
             responses = {
                @RestResponse(description = &quot;Returns the workflow properties for the events as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                @RestResponse(description = &quot;The list of ids could not be parsed into a json list.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST)
              })
  public Response getEventWorkflowProperties(@FormParam(&quot;eventIds&quot;) String eventIds) throws UnauthorizedException {
<span class="nc bnc" id="L336" title="All 2 branches missed.">    if (StringUtils.isBlank(eventIds)) {</span>
<span class="nc" id="L337">      return Response.status(Response.Status.BAD_REQUEST).build();</span>
    }

<span class="nc" id="L340">    JSONParser parser = new JSONParser();</span>
    List&lt;String&gt; ids;
    try {
<span class="nc" id="L343">      ids = (List&lt;String&gt;) parser.parse(eventIds);</span>
<span class="nc" id="L344">    } catch (org.json.simple.parser.ParseException e) {</span>
<span class="nc" id="L345">      logger.error(&quot;Unable to parse '{}'&quot;, eventIds, e);</span>
<span class="nc" id="L346">      return Response.status(Response.Status.BAD_REQUEST).build();</span>
<span class="nc" id="L347">    } catch (ClassCastException e) {</span>
<span class="nc" id="L348">      logger.error(&quot;Unable to cast '{}'&quot;, eventIds, e);</span>
<span class="nc" id="L349">      return Response.status(Response.Status.BAD_REQUEST).build();</span>
<span class="nc" id="L350">    }</span>

<span class="nc" id="L352">    final Map&lt;String, Map&lt;String, String&gt;&gt; eventWithProperties = getIndexService().getEventWorkflowProperties(ids);</span>
<span class="nc" id="L353">    final Map&lt;String, Field&gt; jsonEvents = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">    for (Entry&lt;String, Map&lt;String, String&gt;&gt; event : eventWithProperties.entrySet()) {</span>
<span class="nc" id="L355">      final Collection&lt;Field&gt; jsonProperties = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">      for (Entry&lt;String, String&gt; property : event.getValue().entrySet()) {</span>
<span class="nc" id="L357">        jsonProperties.add(f(property.getKey(),property.getValue()));</span>
<span class="nc" id="L358">      }</span>
<span class="nc" id="L359">      jsonEvents.put(event.getKey(), f(event.getKey(), obj(jsonProperties)));</span>
<span class="nc" id="L360">    }</span>
<span class="nc" id="L361">    return okJson(obj(jsonEvents));</span>
  }


  @GET
  @Path(&quot;catalogAdapters&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getcataloguiadapters&quot;, description = &quot;Returns the available catalog UI adapters as JSON&quot;, returnDescription = &quot;The catalog UI adapters as JSON&quot;, responses = {
          @RestResponse(description = &quot;Returns the available catalog UI adapters as JSON&quot;, responseCode = HttpServletResponse.SC_OK) })
  public Response getCatalogAdapters() {
<span class="fc" id="L371">    List&lt;JValue&gt; adapters = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">    for (EventCatalogUIAdapter adapter : getIndexService().getEventCatalogUIAdapters()) {</span>
<span class="fc" id="L373">      List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L374">      fields.add(f(&quot;flavor&quot;, v(adapter.getFlavor().toString())));</span>
<span class="fc" id="L375">      fields.add(f(&quot;title&quot;, v(adapter.getUITitle())));</span>
<span class="fc" id="L376">      adapters.add(obj(fields));</span>
<span class="fc" id="L377">    }</span>
<span class="fc" id="L378">    return okJson(arr(adapters));</span>
  }

  @GET
  @Path(&quot;{eventId}&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getevent&quot;, description = &quot;Returns the event by the given id as JSON&quot;, returnDescription = &quot;The event as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns the event as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventResponse(@PathParam(&quot;eventId&quot;) String id) throws Exception {
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">    for (final Event event : getIndexService().getEvent(id, getIndex())) {</span>
<span class="fc" id="L390">      event.updatePreview(getAdminUIConfiguration().getPreviewSubtype());</span>
<span class="fc" id="L391">      return okJson(eventToJSON(event, Optional.empty()));</span>
    }
<span class="nc" id="L393">    return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @DELETE
  @Path(&quot;{eventId}&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;deleteevent&quot;, description = &quot;Delete a single event.&quot;, returnDescription = &quot;Ok if the event has been deleted.&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, isRequired = true, description = &quot;The id of the event to delete.&quot;, type = STRING), }, responses = {
                  @RestResponse(responseCode = SC_OK, description = &quot;The event has been deleted.&quot;),
                  @RestResponse(responseCode = SC_ACCEPTED, description = &quot;The event will be retracted and deleted afterwards.&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;If the current user is not authorized to perform this action&quot;) })
  public Response deleteEvent(@PathParam(&quot;eventId&quot;) String id) throws UnauthorizedException, SearchIndexException {
<span class="nc" id="L405">    final Opt&lt;Event&gt; event = checkAgentAccessForEvent(id);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">    if (event.isNone()) {</span>
<span class="nc" id="L407">      return RestUtil.R.notFound(id);</span>
    }
    final IndexService.EventRemovalResult result;
    try {
<span class="nc" id="L411">      result = getIndexService().removeEvent(event.get(), getAdminUIConfiguration().getRetractWorkflowId());</span>
<span class="nc" id="L412">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L413">      logger.error(&quot;Workflow database is not reachable. This may be a temporary problem.&quot;);</span>
<span class="nc" id="L414">      return RestUtil.R.serverError();</span>
<span class="nc" id="L415">    } catch (NotFoundException e) {</span>
<span class="nc" id="L416">      logger.error(&quot;Configured retract workflow not found. Check your configuration.&quot;);</span>
<span class="nc" id="L417">      return RestUtil.R.serverError();</span>
<span class="nc" id="L418">    }</span>
<span class="nc bnc" id="L419" title="All 5 branches missed.">    switch (result) {</span>
      case SUCCESS:
<span class="nc" id="L421">        return Response.ok().build();</span>
      case RETRACTING:
<span class="nc" id="L423">        return Response.accepted().build();</span>
      case GENERAL_FAILURE:
<span class="nc" id="L425">        return Response.serverError().build();</span>
      case NOT_FOUND:
<span class="nc" id="L427">        return RestUtil.R.notFound(id);</span>
      default:
<span class="nc" id="L429">        throw new RuntimeException(&quot;Unknown EventRemovalResult type: &quot; + result.name());</span>
    }
  }

  @POST
  @Path(&quot;deleteEvents&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;deleteevents&quot;, description = &quot;Deletes a json list of events by their given ids e.g. [\&quot;1dbe7255-e17d-4279-811d-a5c7ced689bf\&quot;, \&quot;04fae22b-0717-4f59-8b72-5f824f76d529\&quot;]&quot;, returnDescription = &quot;Returns a JSON object containing a list of event ids that were deleted, not found or if there was a server error.&quot;, responses = {
          @RestResponse(description = &quot;Events have been deleted&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;The list of ids could not be parsed into a json list.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;If the current user is not authorized to perform this action&quot;, responseCode = HttpServletResponse.SC_UNAUTHORIZED) })
  public Response deleteEvents(String eventIdsContent) throws UnauthorizedException, SearchIndexException {
<span class="nc bnc" id="L441" title="All 2 branches missed.">    if (StringUtils.isBlank(eventIdsContent)) {</span>
<span class="nc" id="L442">      return Response.status(Response.Status.BAD_REQUEST).build();</span>
    }

<span class="nc" id="L445">    JSONParser parser = new JSONParser();</span>
    JSONArray eventIdsJsonArray;
    try {
<span class="nc" id="L448">      eventIdsJsonArray = (JSONArray) parser.parse(eventIdsContent);</span>
<span class="nc" id="L449">    } catch (org.json.simple.parser.ParseException e) {</span>
<span class="nc" id="L450">      logger.error(&quot;Unable to parse '{}'&quot;, eventIdsContent, e);</span>
<span class="nc" id="L451">      return Response.status(Response.Status.BAD_REQUEST).build();</span>
<span class="nc" id="L452">    } catch (ClassCastException e) {</span>
<span class="nc" id="L453">      logger.error(&quot;Unable to cast '{}'&quot;, eventIdsContent, e);</span>
<span class="nc" id="L454">      return Response.status(Response.Status.BAD_REQUEST).build();</span>
<span class="nc" id="L455">    }</span>

<span class="nc" id="L457">    BulkOperationResult result = new BulkOperationResult();</span>

<span class="nc bnc" id="L459" title="All 2 branches missed.">    for (Object eventIdObject : eventIdsJsonArray) {</span>
<span class="nc" id="L460">      final String eventId = eventIdObject.toString();</span>
      try {
<span class="nc" id="L462">        final Opt&lt;Event&gt; event = checkAgentAccessForEvent(eventId);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (event.isSome()) {</span>
<span class="nc" id="L464">          final IndexService.EventRemovalResult currentResult = getIndexService().removeEvent(event.get(),</span>
<span class="nc" id="L465">                  getAdminUIConfiguration().getRetractWorkflowId());</span>
<span class="nc bnc" id="L466" title="All 5 branches missed.">          switch (currentResult) {</span>
            case SUCCESS:
<span class="nc" id="L468">              result.addOk(eventId);</span>
<span class="nc" id="L469">              break;</span>
            case RETRACTING:
<span class="nc" id="L471">              result.addAccepted(eventId);</span>
<span class="nc" id="L472">              break;</span>
            case GENERAL_FAILURE:
<span class="nc" id="L474">              result.addServerError(eventId);</span>
<span class="nc" id="L475">              break;</span>
            case NOT_FOUND:
<span class="nc" id="L477">              result.addNotFound(eventId);</span>
<span class="nc" id="L478">              break;</span>
            default:
<span class="nc" id="L480">              throw new RuntimeException(&quot;Unknown EventRemovalResult type: &quot; + currentResult.name());</span>
          }
<span class="nc" id="L482">        } else {</span>
<span class="nc" id="L483">          result.addNotFound(eventId);</span>
        }
<span class="nc" id="L485">      } catch (UnauthorizedException e) {</span>
<span class="nc" id="L486">        result.addUnauthorized(eventId);</span>
<span class="nc" id="L487">      } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L488">        logger.error(&quot;Workflow database is not reachable. This may be a temporary problem.&quot;);</span>
<span class="nc" id="L489">        return RestUtil.R.serverError();</span>
<span class="nc" id="L490">      } catch (NotFoundException e) {</span>
<span class="nc" id="L491">        logger.error(&quot;Configured retract workflow not found. Check your configuration.&quot;);</span>
<span class="nc" id="L492">        return RestUtil.R.serverError();</span>
<span class="nc" id="L493">      }</span>
<span class="nc" id="L494">    }</span>
<span class="nc" id="L495">    return Response.ok(result.toJson()).build();</span>
  }

  @GET
  @Path(&quot;{eventId}/publications.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;geteventpublications&quot;, description = &quot;Returns all the data related to the publications tab in the event details modal as JSON&quot;, returnDescription = &quot;All the data related to the event publications tab as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id (mediapackage id).&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns all the data related to the event publications tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventPublicationsTab(@PathParam(&quot;eventId&quot;) String id) throws Exception {
<span class="fc" id="L506">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L508">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>

    // Quick actions have been temporally removed from the publications tab
    // ---------------------------------------------------------------
    // List&lt;JValue&gt; actions = new ArrayList&lt;JValue&gt;();
    // List&lt;WorkflowDefinition&gt; workflowsDefinitions = getWorkflowService().listAvailableWorkflowDefinitions();
    // for (WorkflowDefinition wflDef : workflowsDefinitions) {
    // if (wflDef.containsTag(WORKFLOWDEF_TAG)) {
    //
    // actions.add(obj(f(&quot;id&quot;, v(wflDef.getId())), f(&quot;title&quot;, v(Opt.nul(wflDef.getTitle()).or(&quot;&quot;))),
    // f(&quot;description&quot;, v(Opt.nul(wflDef.getDescription()).or(&quot;&quot;))),
    // f(&quot;configuration_panel&quot;, v(Opt.nul(wflDef.getConfigurationPanel()).or(&quot;&quot;)))));
    // }
    // }

<span class="fc" id="L523">    Event event = optEvent.get();</span>
<span class="fc" id="L524">    List&lt;JValue&gt; pubJSON = eventPublicationsToJson(event);</span>

<span class="fc" id="L526">    return okJson(obj(f(&quot;publications&quot;, arr(pubJSON)),</span>
<span class="fc" id="L527">            f(&quot;start-date&quot;, v(event.getRecordingStartDate(), Jsons.BLANK)),</span>
<span class="fc" id="L528">            f(&quot;end-date&quot;, v(event.getRecordingEndDate(), Jsons.BLANK))));</span>
  }

  private List&lt;JValue&gt; eventPublicationsToJson(Event event) {
<span class="fc" id="L532">    List&lt;JValue&gt; pubJSON = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">    for (JObject json : Stream.$(event.getPublications()).filter(EventUtils.internalChannelFilter)</span>
<span class="fc" id="L534">            .map(publicationToJson)) {</span>
<span class="fc" id="L535">      pubJSON.add(json);</span>
<span class="fc" id="L536">    }</span>
<span class="fc" id="L537">    return pubJSON;</span>
  }

  private List&lt;JObject&gt; eventCommentsToJson(List&lt;EventComment&gt; comments) {
<span class="nc" id="L541">    List&lt;JObject&gt; commentArr = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">    for (EventComment c : comments) {</span>
<span class="nc" id="L543">      JObject thing = obj(</span>
<span class="nc" id="L544">              f(&quot;reason&quot;, v(c.getReason())),</span>
<span class="nc" id="L545">              f(&quot;resolvedStatus&quot;, v(c.isResolvedStatus())),</span>
<span class="nc" id="L546">              f(&quot;modificationDate&quot;, v(c.getModificationDate().toInstant().toString())),</span>
<span class="nc" id="L547">              f(&quot;replies&quot;, arr(eventCommentRepliesToJson(c.getReplies()))),</span>
<span class="nc" id="L548">              f(&quot;author&quot;, obj(</span>
<span class="nc" id="L549">                      f(&quot;name&quot;, c.getAuthor().getName()),</span>
                      // email field of the digest user is always null
<span class="nc" id="L551">                      f(&quot;email&quot;, v(c.getAuthor().getEmail(), NULL)),</span>
<span class="nc" id="L552">                      f(&quot;username&quot;, c.getAuthor().getUsername())</span>
              )),
<span class="nc" id="L554">              f(&quot;id&quot;, v(c.getId().get())),</span>
<span class="nc" id="L555">              f(&quot;text&quot;, v(c.getText())),</span>
<span class="nc" id="L556">              f(&quot;creationDate&quot;, v(c.getCreationDate().toInstant().toString()))</span>
      );
<span class="nc" id="L558">      commentArr.add(thing);</span>
<span class="nc" id="L559">    }</span>

<span class="nc" id="L561">    return commentArr;</span>
  }

  private List&lt;JObject&gt; eventCommentRepliesToJson(List&lt;EventCommentReply&gt; replies) {
<span class="nc" id="L565">    List&lt;JObject&gt; repliesArr = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">    for (EventCommentReply r : replies) {</span>
<span class="nc" id="L567">      JObject thing = obj(</span>
<span class="nc" id="L568">              f(&quot;id&quot;, v(r.getId().get())),</span>
<span class="nc" id="L569">              f(&quot;text&quot;, v(r.getText())),</span>
<span class="nc" id="L570">              f(&quot;creationDate&quot;, v(r.getCreationDate().toInstant().toString())),</span>
<span class="nc" id="L571">              f(&quot;modificationDate&quot;, v(r.getModificationDate().toInstant().toString())),</span>
<span class="nc" id="L572">              f(&quot;author&quot;, obj(</span>
<span class="nc" id="L573">                      f(&quot;name&quot;, r.getAuthor().getName()),</span>
                      // email field of the digest user is always null
<span class="nc" id="L575">                      f(&quot;email&quot;, v(r.getAuthor().getEmail(), NULL)),</span>
<span class="nc" id="L576">                      f(&quot;username&quot;, r.getAuthor().getUsername())</span>
              ))
      );
<span class="nc" id="L579">      repliesArr.add(thing);</span>
<span class="nc" id="L580">    }</span>

<span class="nc" id="L582">    return repliesArr;</span>
  }

  @GET
  @Path(&quot;{eventId}/scheduling.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getEventSchedulingMetadata&quot;, description = &quot;Returns all of the scheduling metadata for an event&quot;, returnDescription = &quot;All the technical metadata related to scheduling as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id (mediapackage id).&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns all the data related to the event scheduling tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventScheduling(@PathParam(&quot;eventId&quot;) String eventId)
          throws NotFoundException, UnauthorizedException, SearchIndexException {
<span class="fc" id="L594">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L596">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

    try {
<span class="fc" id="L599">      TechnicalMetadata technicalMetadata = getSchedulerService().getTechnicalMetadata(eventId);</span>
<span class="fc" id="L600">      return okJson(technicalMetadataToJson.apply(technicalMetadata));</span>
<span class="nc" id="L601">    } catch (SchedulerException e) {</span>
<span class="nc" id="L602">      logger.error(&quot;Unable to get technical metadata for event with id {}&quot;, eventId);</span>
<span class="nc" id="L603">      throw new WebApplicationException(e, SC_INTERNAL_SERVER_ERROR);</span>
    }
  }

  @POST
  @Path(&quot;scheduling.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getEventsScheduling&quot;, description = &quot;Returns all of the scheduling metadata for a list of events&quot;, returnDescription = &quot;All the technical metadata related to scheduling as JSON&quot;, restParameters = {
    @RestParameter(name = &quot;eventIds&quot;, description = &quot;An array of event IDs (mediapackage id)&quot;, isRequired = true, type = RestParameter.Type.STRING),
    @RestParameter(name = &quot;ignoreNonScheduled&quot;, description = &quot;Whether events that are not really scheduled events should be ignored or produce an error&quot;, isRequired = true, type = RestParameter.Type.BOOLEAN) }, responses = {
    @RestResponse(description = &quot;Returns all the data related to the event scheduling tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
    @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventsScheduling(@FormParam(&quot;eventIds&quot;) final List&lt;String&gt; eventIds, @FormParam(&quot;ignoreNonScheduled&quot;) final boolean ignoreNonScheduled) {
<span class="fc" id="L616">    final List&lt;JValue&gt; fields = new ArrayList&lt;&gt;(eventIds.size());</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">    for (final String eventId : eventIds) {</span>
      try {
<span class="fc" id="L619">        fields.add(technicalMetadataToJson.apply(getSchedulerService().getTechnicalMetadata(eventId)));</span>
<span class="fc" id="L620">      } catch (final NotFoundException e) {</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">        if (!ignoreNonScheduled) {</span>
<span class="fc" id="L622">          logger.warn(&quot;Unable to find id {}&quot;, eventId, e);</span>
<span class="fc" id="L623">          return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
        }
<span class="nc" id="L625">      } catch (final UnauthorizedException e) {</span>
<span class="nc" id="L626">        logger.warn(&quot;Unauthorized access to event ID {}&quot;, eventId, e);</span>
<span class="nc" id="L627">        return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L628">      } catch (final SchedulerException e) {</span>
<span class="nc" id="L629">        logger.warn(&quot;Scheduler exception accessing event ID {}&quot;, eventId, e);</span>
<span class="nc" id="L630">        return Response.status(Status.BAD_REQUEST).build();</span>
<span class="fc" id="L631">      }</span>
<span class="fc" id="L632">    }</span>
<span class="fc" id="L633">    return okJson(arr(fields));</span>
  }

  @PUT
  @Path(&quot;{eventId}/scheduling&quot;)
  @RestQuery(name = &quot;updateEventScheduling&quot;, description = &quot;Updates the scheduling information of an event&quot;, returnDescription = &quot;The method doesn't return any content&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, isRequired = true, description = &quot;The event identifier&quot;, type = RestParameter.Type.STRING) }, restParameters = {
                  @RestParameter(name = &quot;scheduling&quot;, isRequired = true, description = &quot;The updated scheduling (JSON object)&quot;, type = RestParameter.Type.TEXT) }, responses = {
                          @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;The required params were missing in the request.&quot;),
                          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;If the event has not been found.&quot;),
                          @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;The method doesn't return any content&quot;) })
  public Response updateEventScheduling(@PathParam(&quot;eventId&quot;) String eventId,
          @FormParam(&quot;scheduling&quot;) String scheduling)
          throws NotFoundException, UnauthorizedException, SearchIndexException, IndexServiceException {
<span class="nc bnc" id="L647" title="All 2 branches missed.">    if (StringUtils.isBlank(scheduling))</span>
<span class="nc" id="L648">      return RestUtil.R.badRequest(&quot;Missing parameters&quot;);</span>

    try {
<span class="nc" id="L651">      final Event event = getEventOrThrowNotFoundException(eventId);</span>
<span class="nc" id="L652">      updateEventScheduling(scheduling, event);</span>
<span class="nc" id="L653">      return Response.noContent().build();</span>
<span class="nc" id="L654">    } catch (JSONException e) {</span>
<span class="nc" id="L655">      return RestUtil.R.badRequest(&quot;The scheduling object is not valid&quot;);</span>
<span class="nc" id="L656">    } catch (ParseException e) {</span>
<span class="nc" id="L657">      return RestUtil.R.badRequest(&quot;The UTC dates in the scheduling object is not valid&quot;);</span>
<span class="nc" id="L658">    } catch (SchedulerException e) {</span>
<span class="nc" id="L659">      logger.error(&quot;Unable to update scheduling technical metadata of event {}&quot;, eventId, e);</span>
<span class="nc" id="L660">      throw new WebApplicationException(e, SC_INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L661">    } catch (IllegalStateException e) {</span>
<span class="nc" id="L662">      return RestUtil.R.badRequest(e.getMessage());</span>
    }
  }

  private void updateEventScheduling(String scheduling, Event event) throws NotFoundException, UnauthorizedException,
    SchedulerException, JSONException, ParseException, SearchIndexException, IndexServiceException {
<span class="nc" id="L668">    final TechnicalMetadata technicalMetadata = getSchedulerService().getTechnicalMetadata(event.getIdentifier());</span>
<span class="nc" id="L669">    final org.codehaus.jettison.json.JSONObject schedulingJson = new org.codehaus.jettison.json.JSONObject(</span>
            scheduling);
<span class="nc" id="L671">    Optional&lt;String&gt; agentId = Optional.empty();</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">    if (schedulingJson.has(SCHEDULING_AGENT_ID_KEY)) {</span>
<span class="nc" id="L673">      agentId = Optional.of(schedulingJson.getString(SCHEDULING_AGENT_ID_KEY));</span>
<span class="nc" id="L674">      logger.trace(&quot;Updating agent id of event '{}' from '{}' to '{}'&quot;,</span>
<span class="nc" id="L675">              event.getIdentifier(), technicalMetadata.getAgentId(), agentId);</span>
    }

<span class="nc" id="L678">    Opt&lt;String&gt; previousAgentId = Opt.none();</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">    if (schedulingJson.has(SCHEDULING_PREVIOUS_AGENTID)) {</span>
<span class="nc" id="L680">      previousAgentId = Opt.some(schedulingJson.getString(SCHEDULING_PREVIOUS_AGENTID));</span>
    }

<span class="nc" id="L683">    Optional&lt;String&gt; previousAgentInputs = Optional.empty();</span>
<span class="nc" id="L684">    Optional&lt;String&gt; agentInputs = Optional.empty();</span>
<span class="nc bnc" id="L685" title="All 4 branches missed.">    if (agentId.isPresent() &amp;&amp; previousAgentId.isSome()) {</span>
<span class="nc" id="L686">      Agent previousAgent = getCaptureAgentStateService().getAgent(previousAgentId.get());</span>
<span class="nc" id="L687">      Agent agent = getCaptureAgentStateService().getAgent(agentId.get());</span>

<span class="nc" id="L689">      previousAgentInputs = Optional.ofNullable(previousAgent.getCapabilities().getProperty(CaptureParameters.CAPTURE_DEVICE_NAMES));</span>
<span class="nc" id="L690">      agentInputs = Optional.ofNullable(agent.getCapabilities().getProperty(CaptureParameters.CAPTURE_DEVICE_NAMES));</span>
    }

    // Check if we are allowed to re-schedule on this agent
<span class="nc" id="L694">    checkAgentAccessForAgent(technicalMetadata.getAgentId());</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">    if (agentId.isPresent()) {</span>
<span class="nc" id="L696">      checkAgentAccessForAgent(agentId.get());</span>
    }

<span class="nc" id="L699">    Optional&lt;Date&gt; start = Optional.empty();</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">    if (schedulingJson.has(SCHEDULING_START_KEY)) {</span>
<span class="nc" id="L701">      start = Optional.of(new Date(DateTimeSupport.fromUTC(schedulingJson.getString(SCHEDULING_START_KEY))));</span>
<span class="nc" id="L702">      logger.trace(&quot;Updating start time of event '{}' id from '{}' to '{}'&quot;,</span>
<span class="nc" id="L703">        event.getIdentifier(), DateTimeSupport.toUTC(technicalMetadata.getStartDate().getTime()),</span>
<span class="nc" id="L704">                      DateTimeSupport.toUTC(start.get().getTime()));</span>
    }

<span class="nc" id="L707">    Optional&lt;Date&gt; end = Optional.empty();</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">    if (schedulingJson.has(SCHEDULING_END_KEY)) {</span>
<span class="nc" id="L709">      end = Optional.of(new Date(DateTimeSupport.fromUTC(schedulingJson.getString(SCHEDULING_END_KEY))));</span>
<span class="nc" id="L710">      logger.trace(&quot;Updating end time of event '{}' id from '{}' to '{}'&quot;,</span>
<span class="nc" id="L711">        event.getIdentifier(), DateTimeSupport.toUTC(technicalMetadata.getEndDate().getTime()),</span>
<span class="nc" id="L712">                      DateTimeSupport.toUTC(end.get().getTime()));</span>
    }

<span class="nc" id="L715">    Optional&lt;Map&lt;String, String&gt;&gt; agentConfiguration = Optional.empty();</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">    if (schedulingJson.has(SCHEDULING_AGENT_CONFIGURATION_KEY)) {</span>
<span class="nc" id="L717">      agentConfiguration = Optional.of(JSONUtils.toMap(schedulingJson.getJSONObject(SCHEDULING_AGENT_CONFIGURATION_KEY)));</span>
<span class="nc" id="L718">      logger.trace(&quot;Updating agent configuration of event '{}' id from '{}' to '{}'&quot;,</span>
<span class="nc" id="L719">        event.getIdentifier(), technicalMetadata.getCaptureAgentConfiguration(), agentConfiguration);</span>
    }

<span class="nc" id="L722">    Opt&lt;Map&lt;String, String&gt;&gt; previousAgentInputMethods = Opt.none();</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">    if (schedulingJson.has(SCHEDULING_PREVIOUS_PREVIOUSENTRIES)) {</span>
<span class="nc" id="L724">      previousAgentInputMethods = Opt.some(</span>
<span class="nc" id="L725">              JSONUtils.toMap(schedulingJson.getJSONObject(SCHEDULING_PREVIOUS_PREVIOUSENTRIES)));</span>
    }

    // If we had previously selected an agent, and both the old and new agent have the same set of input channels,
    // copy which input channels are active to the new agent
<span class="nc bnc" id="L730" title="All 6 branches missed.">    if (previousAgentInputs.isPresent() &amp;&amp; previousAgentInputs.isPresent() &amp;&amp; agentInputs.isPresent()) {</span>
<span class="nc" id="L731">      Map&lt;String, String&gt; map = previousAgentInputMethods.get();</span>
<span class="nc" id="L732">      String mapAsString = map.keySet().stream()</span>
<span class="nc" id="L733">              .collect(Collectors.joining(&quot;,&quot;));</span>
<span class="nc" id="L734">      String previousInputs = mapAsString;</span>

<span class="nc bnc" id="L736" title="All 2 branches missed.">      if (previousAgentInputs.equals(agentInputs)) {</span>
<span class="nc" id="L737">        final Map&lt;String, String&gt; configMap = new HashMap&lt;&gt;(agentConfiguration.get());</span>
<span class="nc" id="L738">        configMap.put(CaptureParameters.CAPTURE_DEVICE_NAMES, previousInputs);</span>
<span class="nc" id="L739">        agentConfiguration = Optional.of(configMap);</span>
      }
    }

<span class="nc bnc" id="L743" title="All 4 branches missed.">    if ((start.isPresent() || end.isPresent())</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">            &amp;&amp; end.orElse(technicalMetadata.getEndDate()).before(start.orElse(technicalMetadata.getStartDate()))) {</span>
<span class="nc" id="L745">      throw new IllegalStateException(&quot;The end date is before the start date&quot;);</span>
    }

<span class="nc bnc" id="L748" title="All 8 branches missed.">    if (!start.isEmpty() || !end.isEmpty() || !agentId.isEmpty() || !agentConfiguration.isEmpty()) {</span>
<span class="nc" id="L749">      getSchedulerService()</span>
<span class="nc" id="L750">        .updateEvent(event.getIdentifier(), start, end, agentId, Optional.empty(), Optional.empty(), Optional.empty(), agentConfiguration);</span>
    }
<span class="nc" id="L752">  }</span>

  private Event getEventOrThrowNotFoundException(final String eventId) throws NotFoundException, SearchIndexException {
<span class="nc" id="L755">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">    if (optEvent.isSome()) {</span>
<span class="nc" id="L757">      return optEvent.get();</span>
    } else {
<span class="nc" id="L759">      throw new NotFoundException(format(&quot;Cannot find an event with id '%s'.&quot;, eventId));</span>
    }
  }

  @GET
  @Path(&quot;{eventId}/comments&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;geteventcomments&quot;, description = &quot;Returns all the data related to the comments tab in the event details modal as JSON&quot;, returnDescription = &quot;All the data related to the event comments tab as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns all the data related to the event comments tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventComments(@PathParam(&quot;eventId&quot;) String eventId) throws Exception {
<span class="fc" id="L771">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">    if (optEvent.isNone())</span>
<span class="nc" id="L773">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

    try {
<span class="fc" id="L776">      List&lt;EventComment&gt; comments = getEventCommentService().getComments(eventId);</span>
<span class="fc" id="L777">      List&lt;Val&gt; commentArr = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">      for (EventComment c : comments) {</span>
<span class="fc" id="L779">        commentArr.add(c.toJson());</span>
<span class="fc" id="L780">      }</span>
<span class="fc" id="L781">      return Response.ok(org.opencastproject.util.Jsons.arr(commentArr).toJson(), MediaType.APPLICATION_JSON_TYPE)</span>
<span class="fc" id="L782">              .build();</span>
<span class="nc" id="L783">    } catch (EventCommentException e) {</span>
<span class="nc" id="L784">      logger.error(&quot;Unable to get comments from event {}&quot;, eventId, e);</span>
<span class="nc" id="L785">      throw new WebApplicationException(e);</span>
    }
  }

  @GET
  @Path(&quot;{eventId}/hasActiveTransaction&quot;)
  @Produces(MediaType.TEXT_PLAIN)
  @RestQuery(name = &quot;hasactivetransaction&quot;, description = &quot;Returns whether there is currently a transaction in progress for the given event&quot;, returnDescription = &quot;Whether there is currently a transaction in progress for the given event&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns whether there is currently a transaction in progress for the given event&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response hasActiveTransaction(@PathParam(&quot;eventId&quot;) String eventId) throws Exception {
<span class="nc" id="L797">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">    if (optEvent.isNone())</span>
<span class="nc" id="L799">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

<span class="nc" id="L801">    JSONObject json = new JSONObject();</span>

<span class="nc bnc" id="L803" title="All 2 branches missed.">    if (WorkflowUtil.isActive(optEvent.get().getWorkflowState())) {</span>
<span class="nc" id="L804">      json.put(&quot;active&quot;, true);</span>
    } else {
<span class="nc" id="L806">      json.put(&quot;active&quot;, false);</span>
    }

<span class="nc" id="L809">    return Response.ok(json.toJSONString()).build();</span>
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;{eventId}/comment/{commentId}&quot;)
  @RestQuery(name = &quot;geteventcomment&quot;, description = &quot;Returns the comment with the given identifier&quot;, returnDescription = &quot;Returns the comment as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;commentId&quot;, isRequired = true, description = &quot;The comment identifier&quot;, type = STRING) }, responses = {
                  @RestResponse(responseCode = SC_OK, description = &quot;The comment as JSON.&quot;),
                  @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;No event or comment with this identifier was found.&quot;) })
  public Response getEventComment(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;commentId&quot;) long commentId)
          throws NotFoundException, Exception {
<span class="fc" id="L822">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L824">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

    try {
<span class="fc" id="L827">      EventComment comment = getEventCommentService().getComment(commentId);</span>
<span class="fc" id="L828">      return Response.ok(comment.toJson().toJson()).build();</span>
<span class="nc" id="L829">    } catch (NotFoundException e) {</span>
<span class="nc" id="L830">      throw e;</span>
<span class="fc" id="L831">    } catch (Exception e) {</span>
<span class="fc" id="L832">      logger.error(&quot;Could not retrieve comment {}&quot;, commentId, e);</span>
<span class="fc" id="L833">      throw new WebApplicationException(e);</span>
    }
  }

  @PUT
  @Path(&quot;{eventId}/comment/{commentId}&quot;)
  @RestQuery(name = &quot;updateeventcomment&quot;, description = &quot;Updates an event comment&quot;, returnDescription = &quot;The updated comment as JSON.&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;commentId&quot;, isRequired = true, description = &quot;The comment identifier&quot;, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;text&quot;, isRequired = false, description = &quot;The comment text&quot;, type = TEXT),
                  @RestParameter(name = &quot;reason&quot;, isRequired = false, description = &quot;The comment reason&quot;, type = STRING),
                  @RestParameter(name = &quot;resolved&quot;, isRequired = false, description = &quot;The comment resolved status&quot;, type = RestParameter.Type.BOOLEAN) }, responses = {
                          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The event or comment to update has not been found.&quot;),
                          @RestResponse(responseCode = SC_OK, description = &quot;The updated comment as JSON.&quot;) })
  public Response updateEventComment(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;commentId&quot;) long commentId,
          @FormParam(&quot;text&quot;) String text, @FormParam(&quot;reason&quot;) String reason, @FormParam(&quot;resolved&quot;) Boolean resolved)
                  throws Exception {
<span class="fc" id="L850">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="pc bpc" id="L851" title="1 of 2 branches missed.">    if (optEvent.isNone())</span>
<span class="nc" id="L852">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

    try {
<span class="fc" id="L855">      EventComment dto = getEventCommentService().getComment(commentId);</span>

<span class="pc bpc" id="L857" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(text)) {</span>
<span class="nc" id="L858">        text = text.trim();</span>
      } else {
<span class="fc" id="L860">        text = dto.getText();</span>
      }

<span class="pc bpc" id="L863" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(reason)) {</span>
<span class="nc" id="L864">        reason = reason.trim();</span>
      } else {
<span class="fc" id="L866">        reason = dto.getReason();</span>
      }

<span class="pc bpc" id="L869" title="1 of 2 branches missed.">      if (resolved == null)</span>
<span class="fc" id="L870">        resolved = dto.isResolvedStatus();</span>

<span class="fc" id="L872">      EventComment updatedComment = EventComment.create(dto.getId(), eventId,</span>
<span class="fc" id="L873">              getSecurityService().getOrganization().getId(), text, dto.getAuthor(), reason, resolved,</span>
<span class="fc" id="L874">              dto.getCreationDate(), new Date(), dto.getReplies());</span>

<span class="fc" id="L876">      updatedComment = getEventCommentService().updateComment(updatedComment);</span>
<span class="fc" id="L877">      List&lt;EventComment&gt; comments = getEventCommentService().getComments(eventId);</span>
<span class="fc" id="L878">      getIndexService().updateCommentCatalog(optEvent.get(), comments);</span>
<span class="fc" id="L879">      return Response.ok(updatedComment.toJson().toJson()).build();</span>
<span class="nc" id="L880">    } catch (NotFoundException e) {</span>
<span class="nc" id="L881">      throw e;</span>
<span class="nc" id="L882">    } catch (Exception e) {</span>
<span class="nc" id="L883">      logger.error(&quot;Unable to update the comments catalog on event {}&quot;, eventId, e);</span>
<span class="nc" id="L884">      throw new WebApplicationException(e);</span>
    }
  }

  @POST
  @Path(&quot;{eventId}/access&quot;)
  @RestQuery(name = &quot;applyAclToEvent&quot;, description = &quot;Immediate application of an ACL to an event&quot;, returnDescription = &quot;Status code&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, isRequired = true, description = &quot;The event ID&quot;, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;acl&quot;, isRequired = true, description = &quot;The ACL to apply&quot;, type = STRING) }, responses = {
                          @RestResponse(responseCode = SC_OK, description = &quot;The ACL has been successfully applied&quot;),
                          @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;Unable to parse the given ACL&quot;),
                          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The the event has not been found&quot;),
                          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;Not authorized to perform this action&quot;),
                          @RestResponse(responseCode = SC_INTERNAL_SERVER_ERROR, description = &quot;Internal error&quot;) })
  public Response applyAclToEvent(@PathParam(&quot;eventId&quot;) String eventId, @FormParam(&quot;acl&quot;) String acl)
          throws NotFoundException, UnauthorizedException, SearchIndexException, IndexServiceException {
    final AccessControlList accessControlList;
    try {
<span class="fc" id="L902">      accessControlList = AccessControlParser.parseAcl(acl);</span>
<span class="fc" id="L903">    } catch (Exception e) {</span>
<span class="fc" id="L904">      logger.warn(&quot;Unable to parse ACL '{}'&quot;, acl);</span>
<span class="fc" id="L905">      return badRequest();</span>
<span class="fc" id="L906">    }</span>

    try {
<span class="fc" id="L909">      final Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">      if (optEvent.isNone()) {</span>
<span class="nc" id="L911">        logger.warn(&quot;Unable to find the event '{}'&quot;, eventId);</span>
<span class="nc" id="L912">        return notFound();</span>
      }

<span class="fc" id="L915">      Source eventSource = getIndexService().getEventSource(optEvent.get());</span>
<span class="fc bfc" id="L916" title="All 2 branches covered.">      if (eventSource == Source.ARCHIVE) {</span>
<span class="fc" id="L917">        Optional&lt;MediaPackage&gt; mediaPackage = getAssetManager().getMediaPackage(eventId);</span>
<span class="fc" id="L918">        Option&lt;AccessControlList&gt; aclOpt = Option.option(accessControlList);</span>
        // the episode service is the source of authority for the retrieval of media packages
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">        if (mediaPackage.isPresent()) {</span>
<span class="fc" id="L921">          MediaPackage episodeSvcMp = mediaPackage.get();</span>
<span class="fc" id="L922">          aclOpt.fold(new Option.EMatch&lt;AccessControlList&gt;() {</span>
            // set the new episode ACL
            @Override
            public void esome(final AccessControlList acl) {
              // update in episode service
              try {
<span class="fc" id="L928">                MediaPackage mp = getAuthorizationService().setAcl(episodeSvcMp, AclScope.Episode, acl).getA();</span>
<span class="fc" id="L929">                getAssetManager().takeSnapshot(mp);</span>
<span class="nc" id="L930">              } catch (MediaPackageException e) {</span>
<span class="nc" id="L931">                logger.error(&quot;Error getting ACL from media package&quot;, e);</span>
<span class="fc" id="L932">              }</span>
<span class="fc" id="L933">            }</span>

            // if none EpisodeACLTransition#isDelete returns true so delete the episode ACL
            @Override
            public void enone() {
              // update in episode service
<span class="nc" id="L939">              MediaPackage mp = getAuthorizationService().removeAcl(episodeSvcMp, AclScope.Episode);</span>
<span class="nc" id="L940">              getAssetManager().takeSnapshot(mp);</span>
<span class="nc" id="L941">            }</span>

          });
<span class="fc" id="L944">          return ok();</span>
        }
<span class="nc" id="L946">        logger.warn(&quot;Unable to find the event '{}'&quot;, eventId);</span>
<span class="nc" id="L947">        return notFound();</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">      } else if (eventSource == Source.WORKFLOW) {</span>
<span class="fc" id="L949">        logger.warn(&quot;An ACL cannot be edited while an event is part of a current workflow because it might&quot;</span>
                + &quot; lead to inconsistent ACLs i.e. changed after distribution so that the old ACL is still &quot;
                + &quot;being used by the distribution channel.&quot;);
<span class="fc" id="L952">        JSONObject json = new JSONObject();</span>
<span class="fc" id="L953">        json.put(&quot;Error&quot;, &quot;Unable to edit an ACL for a current workflow.&quot;);</span>
<span class="fc" id="L954">        return conflict(json.toJSONString());</span>
      } else {
<span class="fc" id="L956">        MediaPackage mediaPackage = getIndexService().getEventMediapackage(optEvent.get());</span>
<span class="fc" id="L957">        mediaPackage = getAuthorizationService().setAcl(mediaPackage, AclScope.Episode, accessControlList).getA();</span>
        // We could check agent access here if we want to forbid updating ACLs for users without access.
<span class="fc" id="L959">        getSchedulerService().updateEvent(eventId, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),</span>
<span class="fc" id="L960">                Optional.of(mediaPackage), Optional.empty(), Optional.empty());</span>
<span class="fc" id="L961">        return ok();</span>
      }
<span class="nc" id="L963">    } catch (MediaPackageException e) {</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">      if (e.getCause() instanceof UnauthorizedException) {</span>
<span class="nc" id="L965">        return forbidden();</span>
      }
<span class="nc" id="L967">      logger.error(&quot;Error applying acl '{}' to event '{}'&quot;, accessControlList, eventId, e);</span>
<span class="nc" id="L968">      return serverError();</span>
<span class="nc" id="L969">    } catch (SchedulerException e) {</span>
<span class="nc" id="L970">      logger.error(&quot;Error applying ACL to scheduled event {}&quot;, eventId, e);</span>
<span class="nc" id="L971">      return serverError();</span>
    }
  }

  @POST
  @Path(&quot;{eventId}/comment&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;createeventcomment&quot;, description = &quot;Creates a comment related to the event given by the identifier&quot;, returnDescription = &quot;The comment related to the event as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, restParameters = {
                  @RestParameter(name = &quot;text&quot;, isRequired = true, description = &quot;The comment text&quot;, type = TEXT),
                  @RestParameter(name = &quot;resolved&quot;, isRequired = false, description = &quot;The comment resolved status&quot;, type = RestParameter.Type.BOOLEAN),
                  @RestParameter(name = &quot;reason&quot;, isRequired = false, description = &quot;The comment reason&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The comment has been created.&quot;, responseCode = HttpServletResponse.SC_CREATED),
                          @RestResponse(description = &quot;If no text ist set.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                          @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response createEventComment(@PathParam(&quot;eventId&quot;) String eventId, @FormParam(&quot;text&quot;) String text,
          @FormParam(&quot;reason&quot;) String reason, @FormParam(&quot;resolved&quot;) Boolean resolved) throws Exception {
<span class="fc" id="L988">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L990">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

<span class="fc bfc" id="L992" title="All 2 branches covered.">    if (StringUtils.isBlank(text))</span>
<span class="fc" id="L993">      return Response.status(Status.BAD_REQUEST).build();</span>

<span class="fc" id="L995">    User author = getSecurityService().getUser();</span>
    try {
<span class="fc" id="L997">      EventComment createdComment = EventComment.create(Option.&lt;Long&gt; none(), eventId,</span>
<span class="fc" id="L998">              getSecurityService().getOrganization().getId(), text, author, reason, BooleanUtils.toBoolean(reason));</span>
<span class="fc" id="L999">      createdComment = getEventCommentService().updateComment(createdComment);</span>
<span class="fc" id="L1000">      List&lt;EventComment&gt; comments = getEventCommentService().getComments(eventId);</span>
<span class="fc" id="L1001">      getIndexService().updateCommentCatalog(optEvent.get(), comments);</span>
<span class="fc" id="L1002">      return Response.created(getCommentUrl(eventId, createdComment.getId().get()))</span>
<span class="fc" id="L1003">              .entity(createdComment.toJson().toJson()).build();</span>
<span class="nc" id="L1004">    } catch (Exception e) {</span>
<span class="nc" id="L1005">      logger.error(&quot;Unable to create a comment on the event {}&quot;, eventId, e);</span>
<span class="nc" id="L1006">      throw new WebApplicationException(e);</span>
    }
  }

  @POST
  @Path(&quot;{eventId}/comment/{commentId}&quot;)
  @RestQuery(name = &quot;resolveeventcomment&quot;, description = &quot;Resolves an event comment&quot;, returnDescription = &quot;The resolved comment.&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;commentId&quot;, isRequired = true, description = &quot;The comment identifier&quot;, type = STRING) }, responses = {
                  @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The event or comment to resolve has not been found.&quot;),
                  @RestResponse(responseCode = SC_OK, description = &quot;The resolved comment as JSON.&quot;) })
  public Response resolveEventComment(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;commentId&quot;) long commentId)
          throws Exception {
<span class="fc" id="L1019">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L1021">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

    try {
<span class="fc" id="L1024">      EventComment dto = getEventCommentService().getComment(commentId);</span>
<span class="fc" id="L1025">      EventComment updatedComment = EventComment.create(dto.getId(), dto.getEventId(), dto.getOrganization(),</span>
<span class="fc" id="L1026">              dto.getText(), dto.getAuthor(), dto.getReason(), true, dto.getCreationDate(), new Date(),</span>
<span class="fc" id="L1027">              dto.getReplies());</span>

<span class="fc" id="L1029">      updatedComment = getEventCommentService().updateComment(updatedComment);</span>
<span class="fc" id="L1030">      List&lt;EventComment&gt; comments = getEventCommentService().getComments(eventId);</span>
<span class="fc" id="L1031">      getIndexService().updateCommentCatalog(optEvent.get(), comments);</span>
<span class="fc" id="L1032">      return Response.ok(updatedComment.toJson().toJson()).build();</span>
<span class="nc" id="L1033">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1034">      throw e;</span>
<span class="nc" id="L1035">    } catch (Exception e) {</span>
<span class="nc" id="L1036">      logger.error(&quot;Could not resolve comment {}&quot;, commentId, e);</span>
<span class="nc" id="L1037">      throw new WebApplicationException(e);</span>
    }
  }

  @DELETE
  @Path(&quot;{eventId}/comment/{commentId}&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;deleteeventcomment&quot;, description = &quot;Deletes a event related comment by its identifier&quot;, returnDescription = &quot;No content&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;commentId&quot;, description = &quot;The comment id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;The event related comment has been deleted.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                  @RestResponse(description = &quot;No event or comment with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteEventComment(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;commentId&quot;) long commentId)
          throws Exception {
<span class="fc" id="L1051">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L1053">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

    try {
<span class="fc" id="L1056">      getEventCommentService().deleteComment(commentId);</span>
<span class="fc" id="L1057">      List&lt;EventComment&gt; comments = getEventCommentService().getComments(eventId);</span>
<span class="fc" id="L1058">      getIndexService().updateCommentCatalog(optEvent.get(), comments);</span>
<span class="fc" id="L1059">      return Response.noContent().build();</span>
<span class="nc" id="L1060">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1061">      throw e;</span>
<span class="nc" id="L1062">    } catch (Exception e) {</span>
<span class="nc" id="L1063">      logger.error(&quot;Unable to delete comment {} on event {}&quot;, commentId, eventId, e);</span>
<span class="nc" id="L1064">      throw new WebApplicationException(e);</span>
    }
  }

  @DELETE
  @Path(&quot;{eventId}/comment/{commentId}/{replyId}&quot;)
  @RestQuery(name = &quot;deleteeventreply&quot;, description = &quot;Delete an event comment reply&quot;, returnDescription = &quot;The updated comment as JSON.&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;commentId&quot;, isRequired = true, description = &quot;The comment identifier&quot;, type = STRING),
          @RestParameter(name = &quot;replyId&quot;, isRequired = true, description = &quot;The comment reply identifier&quot;, type = STRING) }, responses = {
                  @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;No event comment or reply with this identifier was found.&quot;),
                  @RestResponse(responseCode = SC_OK, description = &quot;The updated comment as JSON.&quot;) })
  public Response deleteEventCommentReply(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;commentId&quot;) long commentId,
          @PathParam(&quot;replyId&quot;) long replyId) throws Exception {
<span class="fc" id="L1078">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">    if (optEvent.isNone())</span>
<span class="nc" id="L1080">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

<span class="fc" id="L1082">    EventComment comment = null;</span>
<span class="fc" id="L1083">    EventCommentReply reply = null;</span>
    try {
<span class="fc" id="L1085">      comment = getEventCommentService().getComment(commentId);</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">      for (EventCommentReply r : comment.getReplies()) {</span>
<span class="pc bpc" id="L1087" title="1 of 4 branches missed.">        if (r.getId().isNone() || replyId != r.getId().get().longValue())</span>
<span class="fc" id="L1088">          continue;</span>
<span class="fc" id="L1089">        reply = r;</span>
<span class="fc" id="L1090">        break;</span>
      }

<span class="fc bfc" id="L1093" title="All 2 branches covered.">      if (reply == null)</span>
<span class="fc" id="L1094">        throw new NotFoundException(&quot;Reply with id &quot; + replyId + &quot; not found!&quot;);</span>

<span class="fc" id="L1096">      comment.removeReply(reply);</span>

<span class="fc" id="L1098">      EventComment updatedComment = getEventCommentService().updateComment(comment);</span>
<span class="fc" id="L1099">      List&lt;EventComment&gt; comments = getEventCommentService().getComments(eventId);</span>
<span class="fc" id="L1100">      getIndexService().updateCommentCatalog(optEvent.get(), comments);</span>
<span class="fc" id="L1101">      return Response.ok(updatedComment.toJson().toJson()).build();</span>
<span class="fc" id="L1102">    } catch (NotFoundException e) {</span>
<span class="fc" id="L1103">      throw e;</span>
<span class="nc" id="L1104">    } catch (Exception e) {</span>
<span class="nc" id="L1105">      logger.warn(&quot;Could not remove event comment reply {} from comment {}&quot;, replyId, commentId, e);</span>
<span class="nc" id="L1106">      throw new WebApplicationException(e);</span>
    }
  }

  @PUT
  @Path(&quot;{eventId}/comment/{commentId}/{replyId}&quot;)
  @RestQuery(name = &quot;updateeventcommentreply&quot;, description = &quot;Updates an event comment reply&quot;, returnDescription = &quot;The updated comment as JSON.&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;commentId&quot;, isRequired = true, description = &quot;The comment identifier&quot;, type = STRING),
          @RestParameter(name = &quot;replyId&quot;, isRequired = true, description = &quot;The comment reply identifier&quot;, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;text&quot;, isRequired = true, description = &quot;The comment reply text&quot;, type = TEXT) }, responses = {
                          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The event or comment to extend with a reply or the reply has not been found.&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_BAD_REQUEST, description = &quot;If no text is set.&quot;),
                          @RestResponse(responseCode = SC_OK, description = &quot;The updated comment as JSON.&quot;) })
  public Response updateEventCommentReply(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;commentId&quot;) long commentId,
          @PathParam(&quot;replyId&quot;) long replyId, @FormParam(&quot;text&quot;) String text) throws Exception {
<span class="fc bfc" id="L1122" title="All 2 branches covered.">    if (StringUtils.isBlank(text))</span>
<span class="fc" id="L1123">      return Response.status(Status.BAD_REQUEST).build();</span>

<span class="fc" id="L1125">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">    if (optEvent.isNone())</span>
<span class="nc" id="L1127">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

<span class="fc" id="L1129">    EventComment comment = null;</span>
<span class="fc" id="L1130">    EventCommentReply reply = null;</span>
    try {
<span class="fc" id="L1132">      comment = getEventCommentService().getComment(commentId);</span>
<span class="fc bfc" id="L1133" title="All 2 branches covered.">      for (EventCommentReply r : comment.getReplies()) {</span>
<span class="pc bpc" id="L1134" title="1 of 4 branches missed.">        if (r.getId().isNone() || replyId != r.getId().get().longValue())</span>
<span class="fc" id="L1135">          continue;</span>
<span class="fc" id="L1136">        reply = r;</span>
<span class="fc" id="L1137">        break;</span>
      }

<span class="fc bfc" id="L1140" title="All 2 branches covered.">      if (reply == null)</span>
<span class="fc" id="L1141">        throw new NotFoundException(&quot;Reply with id &quot; + replyId + &quot; not found!&quot;);</span>

<span class="fc" id="L1143">      EventCommentReply updatedReply = EventCommentReply.create(reply.getId(), text.trim(), reply.getAuthor(),</span>
<span class="fc" id="L1144">              reply.getCreationDate(), new Date());</span>
<span class="fc" id="L1145">      comment.removeReply(reply);</span>
<span class="fc" id="L1146">      comment.addReply(updatedReply);</span>

<span class="fc" id="L1148">      EventComment updatedComment = getEventCommentService().updateComment(comment);</span>
<span class="fc" id="L1149">      List&lt;EventComment&gt; comments = getEventCommentService().getComments(eventId);</span>
<span class="fc" id="L1150">      getIndexService().updateCommentCatalog(optEvent.get(), comments);</span>
<span class="fc" id="L1151">      return Response.ok(updatedComment.toJson().toJson()).build();</span>
<span class="fc" id="L1152">    } catch (NotFoundException e) {</span>
<span class="fc" id="L1153">      throw e;</span>
<span class="nc" id="L1154">    } catch (Exception e) {</span>
<span class="nc" id="L1155">      logger.warn(&quot;Could not update event comment reply {} from comment {}&quot;, replyId, commentId, e);</span>
<span class="nc" id="L1156">      throw new WebApplicationException(e);</span>
    }
  }

  @POST
  @Path(&quot;{eventId}/comment/{commentId}/reply&quot;)
  @RestQuery(name = &quot;createeventcommentreply&quot;, description = &quot;Creates an event comment reply&quot;, returnDescription = &quot;The updated comment as JSON.&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;commentId&quot;, isRequired = true, description = &quot;The comment identifier&quot;, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;text&quot;, isRequired = true, description = &quot;The comment reply text&quot;, type = TEXT),
                  @RestParameter(name = &quot;resolved&quot;, isRequired = false, description = &quot;Flag defining if this reply solve or not the comment.&quot;, type = BOOLEAN) }, responses = {
                          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;The event or comment to extend with a reply has not been found.&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_BAD_REQUEST, description = &quot;If no text is set.&quot;),
                          @RestResponse(responseCode = SC_OK, description = &quot;The updated comment as JSON.&quot;) })
  public Response createEventCommentReply(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;commentId&quot;) long commentId,
          @FormParam(&quot;text&quot;) String text, @FormParam(&quot;resolved&quot;) Boolean resolved) throws Exception {
<span class="fc bfc" id="L1172" title="All 2 branches covered.">    if (StringUtils.isBlank(text))</span>
<span class="fc" id="L1173">      return Response.status(Status.BAD_REQUEST).build();</span>

<span class="fc" id="L1175">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">    if (optEvent.isNone())</span>
<span class="nc" id="L1177">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

<span class="fc" id="L1179">    EventComment comment = null;</span>
    try {
<span class="fc" id="L1181">      comment = getEventCommentService().getComment(commentId);</span>
      EventComment updatedComment;

<span class="pc bpc" id="L1184" title="2 of 4 branches missed.">      if (resolved != null &amp;&amp; resolved) {</span>
        // If the resolve flag is set to true, change to comment to resolved
<span class="fc" id="L1186">        updatedComment = EventComment.create(comment.getId(), comment.getEventId(), comment.getOrganization(),</span>
<span class="fc" id="L1187">                comment.getText(), comment.getAuthor(), comment.getReason(), true, comment.getCreationDate(),</span>
<span class="fc" id="L1188">                new Date(), comment.getReplies());</span>
      } else {
<span class="nc" id="L1190">        updatedComment = comment;</span>
      }

<span class="fc" id="L1193">      User author = getSecurityService().getUser();</span>
<span class="fc" id="L1194">      EventCommentReply reply = EventCommentReply.create(Option.&lt;Long&gt; none(), text, author);</span>
<span class="fc" id="L1195">      updatedComment.addReply(reply);</span>

<span class="fc" id="L1197">      updatedComment = getEventCommentService().updateComment(updatedComment);</span>
<span class="fc" id="L1198">      List&lt;EventComment&gt; comments = getEventCommentService().getComments(eventId);</span>
<span class="fc" id="L1199">      getIndexService().updateCommentCatalog(optEvent.get(), comments);</span>
<span class="fc" id="L1200">      return Response.ok(updatedComment.toJson().toJson()).build();</span>
<span class="nc" id="L1201">    } catch (Exception e) {</span>
<span class="nc" id="L1202">      logger.warn(&quot;Could not create event comment reply on comment {}&quot;, comment, e);</span>
<span class="nc" id="L1203">      throw new WebApplicationException(e);</span>
    }
  }

  /**
   * Removes emtpy series titles from the collection of the isPartOf Field
   * @param ml the list to modify
   */
  private void removeSeriesWithNullTitlesFromFieldCollection(MetadataList ml) {
    // get Series MetadataField from MetadataList
<span class="fc" id="L1213">    MetadataField seriesField = Optional.ofNullable(ml.getMetadataList().get(&quot;dublincore/episode&quot;))</span>
<span class="fc" id="L1214">            .flatMap(titledMetadataCollection -&gt; Optional.ofNullable(titledMetadataCollection.getCollection()))</span>
<span class="fc" id="L1215">            .flatMap(dcMetadataCollection -&gt; Optional.ofNullable(dcMetadataCollection.getOutputFields()))</span>
<span class="fc" id="L1216">            .flatMap(metadataFields -&gt; Optional.ofNullable(metadataFields.get(&quot;isPartOf&quot;)))</span>
<span class="fc" id="L1217">            .orElse(null);</span>
<span class="pc bpc" id="L1218" title="2 of 4 branches missed.">    if (seriesField == null || seriesField.getCollection() == null) {</span>
<span class="fc" id="L1219">      return;</span>
    }

    // Remove null keys
<span class="nc" id="L1223">    Map&lt;String, String&gt; seriesCollection = seriesField.getCollection();</span>
<span class="nc" id="L1224">    seriesCollection.remove(null);</span>
<span class="nc" id="L1225">    seriesField.setCollection(seriesCollection);</span>

<span class="nc" id="L1227">    return;</span>
  }

  @GET
  @Path(&quot;{eventId}/metadata.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;geteventmetadata&quot;, description = &quot;Returns all the data related to the metadata tab in the event details modal as JSON&quot;, returnDescription = &quot;All the data related to the event metadata tab as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns all the data related to the event metadata tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventMetadata(@PathParam(&quot;eventId&quot;) String eventId) throws Exception {
<span class="fc" id="L1238">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L1239" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L1240">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
<span class="fc" id="L1241">    Event event = optEvent.get();</span>
<span class="fc" id="L1242">    MetadataList metadataList = new MetadataList();</span>

    // Load extended metadata
<span class="fc" id="L1245">    List&lt;EventCatalogUIAdapter&gt; extendedCatalogUIAdapters = getIndexService().getExtendedEventCatalogUIAdapters();</span>
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">    if (!extendedCatalogUIAdapters.isEmpty()) {</span>
      MediaPackage mediaPackage;
      try {
<span class="nc" id="L1249">        mediaPackage = getIndexService().getEventMediapackage(event);</span>
<span class="nc" id="L1250">      } catch (IndexServiceException e) {</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">        if (e.getCause() instanceof NotFoundException) {</span>
<span class="nc" id="L1252">          return notFound(&quot;Cannot find data for event %s&quot;, eventId);</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">        } else if (e.getCause() instanceof UnauthorizedException) {</span>
<span class="nc" id="L1254">          return Response.status(Status.FORBIDDEN).entity(&quot;Not authorized to access &quot; + eventId).build();</span>
        }
<span class="nc" id="L1256">        logger.error(&quot;Internal error when trying to access metadata for &quot; + eventId, e);</span>
<span class="nc" id="L1257">        return serverError();</span>
<span class="nc" id="L1258">      }</span>

<span class="nc bnc" id="L1260" title="All 2 branches missed.">      for (EventCatalogUIAdapter extendedCatalogUIAdapter : extendedCatalogUIAdapters) {</span>
<span class="nc" id="L1261">        metadataList.add(extendedCatalogUIAdapter, extendedCatalogUIAdapter.getFields(mediaPackage));</span>
<span class="nc" id="L1262">      }</span>
    }

    // Load common metadata
    // We do this after extended metadata because we want to overwrite any extended metadata adapters with the same
    // flavor instead of the other way around.
<span class="fc" id="L1268">    EventCatalogUIAdapter eventCatalogUiAdapter = getIndexService().getCommonEventCatalogUIAdapter();</span>
<span class="fc" id="L1269">    DublinCoreMetadataCollection metadataCollection = eventCatalogUiAdapter.getRawFields(getCollectionQueryDisable());</span>
<span class="fc" id="L1270">    EventUtils.setEventMetadataValues(event, metadataCollection);</span>
<span class="fc" id="L1271">    metadataList.add(eventCatalogUiAdapter, metadataCollection);</span>

    // remove series with empty titles from the collection of the isPartOf field as these can't be converted to json
<span class="fc" id="L1274">    removeSeriesWithNullTitlesFromFieldCollection(metadataList);</span>

    // lock metadata?
<span class="fc" id="L1277">    final String wfState = event.getWorkflowState();</span>
<span class="pc bpc" id="L1278" title="2 of 4 branches missed.">    if (wfState != null &amp;&amp; WorkflowUtil.isActive(WorkflowInstance.WorkflowState.valueOf(wfState)))</span>
<span class="nc" id="L1279">      metadataList.setLocked(Locked.WORKFLOW_RUNNING);</span>

<span class="fc" id="L1281">    return okJson(MetadataJson.listToJson(metadataList, true));</span>
  }

  /**
   * Create a special query that disables filling the collection of a series, for performance reasons.
   * The collection can still be fetched via the listprovider endpoint.
   *
   * @return a map with resource list queries belonging to metadata fields
   */
  private Map getCollectionQueryDisable() {
<span class="fc" id="L1291">    HashMap&lt;String, ResourceListQuery&gt; collectionQueryOverrides = new HashMap();</span>
<span class="fc" id="L1292">    SeriesListQuery seriesListQuery = new SeriesListQuery();</span>
<span class="fc" id="L1293">    seriesListQuery.setLimit(0);</span>
<span class="fc" id="L1294">    collectionQueryOverrides.put(DublinCore.PROPERTY_IS_PART_OF.getLocalName(), seriesListQuery);</span>
<span class="fc" id="L1295">    return collectionQueryOverrides;</span>
  }

  @POST  // use POST instead of GET because of a possibly long list of ids
  @Path(&quot;events/metadata.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;geteventsmetadata&quot;,
             description = &quot;Returns all the data related to the edit events metadata modal as JSON&quot;,
             returnDescription = &quot;All the data related to the edit events metadata modal as JSON&quot;,
             restParameters = {
               @RestParameter(name = &quot;eventIds&quot;, description = &quot;The event ids&quot;, isRequired = true,
                              type = RestParameter.Type.STRING)
             }, responses = {
               @RestResponse(description = &quot;Returns all the data related to the edit events metadata modal as JSON&quot;,
                             responseCode = HttpServletResponse.SC_OK),
               @RestResponse(description = &quot;No events to update, either not found or with running workflow, &quot;
                                         + &quot;details in response body.&quot;,
                             responseCode = HttpServletResponse.SC_NOT_FOUND)
             })
  public Response getEventsMetadata(@FormParam(&quot;eventIds&quot;) String eventIds) throws Exception {
<span class="fc bfc" id="L1315" title="All 2 branches covered.">    if (StringUtils.isBlank(eventIds)) {</span>
<span class="fc" id="L1316">      return badRequest(&quot;Event ids can't be empty&quot;);</span>
    }

<span class="fc" id="L1319">    JSONParser parser = new JSONParser();</span>
    List&lt;String&gt; ids;
    try {
<span class="fc" id="L1322">      ids = (List&lt;String&gt;) parser.parse(eventIds);</span>
<span class="nc" id="L1323">    } catch (org.json.simple.parser.ParseException e) {</span>
<span class="nc" id="L1324">      logger.error(&quot;Unable to parse '{}'&quot;, eventIds, e);</span>
<span class="nc" id="L1325">      return badRequest(&quot;Unable to parse event ids&quot;);</span>
<span class="nc" id="L1326">    } catch (ClassCastException e) {</span>
<span class="nc" id="L1327">      logger.error(&quot;Unable to cast '{}'&quot;, eventIds, e);</span>
<span class="nc" id="L1328">      return badRequest(&quot;Unable to parse event ids&quot;);</span>
<span class="fc" id="L1329">    }</span>

<span class="fc" id="L1331">    Set&lt;String&gt; eventsNotFound = new HashSet();</span>
<span class="fc" id="L1332">    Set&lt;String&gt; eventsWithRunningWorkflow = new HashSet();</span>
<span class="fc" id="L1333">    Set&lt;String&gt; eventsMerged = new HashSet();</span>

    // collect the metadata of all events
<span class="fc" id="L1336">    List&lt;DublinCoreMetadataCollection&gt; collectedMetadata = new ArrayList();</span>
<span class="fc bfc" id="L1337" title="All 2 branches covered.">    for (String eventId: ids) {</span>
<span class="fc" id="L1338">      Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
      // not found?
<span class="fc bfc" id="L1340" title="All 2 branches covered.">      if (optEvent.isNone()) {</span>
<span class="fc" id="L1341">        eventsNotFound.add(eventId);</span>
<span class="fc" id="L1342">        continue;</span>
      }

<span class="fc" id="L1345">      Event event = optEvent.get();</span>

      // check if there's a running workflow
<span class="fc" id="L1348">      final String wfState = event.getWorkflowState();</span>
<span class="pc bpc" id="L1349" title="2 of 4 branches missed.">      if (wfState != null &amp;&amp; WorkflowUtil.isActive(WorkflowInstance.WorkflowState.valueOf(wfState))) {</span>
<span class="nc" id="L1350">        eventsWithRunningWorkflow.add(eventId);</span>
<span class="nc" id="L1351">        continue;</span>
      }

      // collect metadata
<span class="fc" id="L1355">      EventCatalogUIAdapter eventCatalogUiAdapter = getIndexService().getCommonEventCatalogUIAdapter();</span>
<span class="fc" id="L1356">      DublinCoreMetadataCollection metadataCollection = eventCatalogUiAdapter.getRawFields(</span>
<span class="fc" id="L1357">            getCollectionQueryDisable());</span>
<span class="fc" id="L1358">      EventUtils.setEventMetadataValues(event, metadataCollection);</span>
<span class="fc" id="L1359">      collectedMetadata.add(metadataCollection);</span>

<span class="fc" id="L1361">      eventsMerged.add(eventId);</span>
<span class="fc" id="L1362">    }</span>

    // no events found?
<span class="fc bfc" id="L1365" title="All 2 branches covered.">    if (collectedMetadata.isEmpty()) {</span>
<span class="fc" id="L1366">      return notFoundJson(obj(</span>
<span class="fc" id="L1367">        f(&quot;notFound&quot;, JSONUtils.setToJSON(eventsNotFound)),</span>
<span class="fc" id="L1368">        f(&quot;runningWorkflow&quot;, JSONUtils.setToJSON(eventsWithRunningWorkflow))));</span>
    }

    // merge metadata of events
    DublinCoreMetadataCollection mergedMetadata;
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">    if (collectedMetadata.size() == 1) {</span>
<span class="nc" id="L1374">      mergedMetadata = collectedMetadata.get(0);</span>
    }
    else {
      //use first metadata collection as base
<span class="fc" id="L1378">      mergedMetadata = new DublinCoreMetadataCollection(collectedMetadata.get(0));</span>
<span class="fc" id="L1379">      collectedMetadata.remove(0);</span>

<span class="fc bfc" id="L1381" title="All 2 branches covered.">      for (MetadataField field : mergedMetadata.getFields()) {</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">        for (DublinCoreMetadataCollection otherMetadataCollection : collectedMetadata) {</span>
<span class="fc" id="L1383">          MetadataField matchingField = otherMetadataCollection.getOutputFields().get(field.getOutputID());</span>

          // check if fields have the same value
<span class="fc bfc" id="L1386" title="All 2 branches covered.">          if (!Objects.equals(field.getValue(), matchingField.getValue())) {</span>
<span class="fc" id="L1387">            field.setDifferentValues();</span>
<span class="fc" id="L1388">            break;</span>
          }
<span class="fc" id="L1390">        }</span>
<span class="fc" id="L1391">      }</span>
    }

<span class="fc" id="L1394">    return okJson(obj(</span>
<span class="fc" id="L1395">      f(&quot;metadata&quot;, MetadataJson.collectionToJson(mergedMetadata, true)),</span>
<span class="fc" id="L1396">      f(&quot;notFound&quot;, JSONUtils.setToJSON(eventsNotFound)),</span>
<span class="fc" id="L1397">      f(&quot;runningWorkflow&quot;, JSONUtils.setToJSON(eventsWithRunningWorkflow)),</span>
<span class="fc" id="L1398">      f(&quot;merged&quot;, JSONUtils.setToJSON(eventsMerged))</span>
    ));
  }

  @PUT
  @Path(&quot;bulk/update&quot;)
  @RestQuery(name = &quot;bulkupdate&quot;, description = &quot;Update all of the given events at once&quot;, restParameters = {
    @RestParameter(name = &quot;update&quot;, isRequired = true, type = RestParameter.Type.TEXT, description = &quot;The list of groups with events and fields to update.&quot;)}, responses = {
    @RestResponse(description = &quot;All events have been updated successfully.&quot;, responseCode = HttpServletResponse.SC_OK),
    @RestResponse(description = &quot;Could not parse update instructions.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
    @RestResponse(description = &quot;Field updating metadata or scheduling information. Some events may have been updated. Details are available in the response body.&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR),
    @RestResponse(description = &quot;The events in the response body were not found. No events were updated.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND)},
    returnDescription = &quot;In case of success, no content is returned. In case of errors while updating the metadata or scheduling information, the errors are returned. In case events were not found, their ids are returned&quot;)
  public Response bulkUpdate(@FormParam(&quot;update&quot;) String updateJson) {

    final BulkUpdateUtil.BulkUpdateInstructions instructions;
    try {
<span class="nc" id="L1415">      instructions = new BulkUpdateUtil.BulkUpdateInstructions(updateJson);</span>
<span class="nc" id="L1416">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1417">      return badRequest(&quot;Cannot parse bulk update instructions&quot;);</span>
<span class="nc" id="L1418">    }</span>

<span class="nc" id="L1420">    final Map&lt;String, String&gt; metadataUpdateFailures = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1421">    final Map&lt;String, String&gt; schedulingUpdateFailures = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1423" title="All 2 branches missed.">    for (final BulkUpdateUtil.BulkUpdateInstructionGroup groupInstructions : instructions.getGroups()) {</span>
      // Get all the events to edit
<span class="nc" id="L1425">      final Map&lt;String, Optional&lt;Event&gt;&gt; events = groupInstructions.getEventIds().stream()</span>
<span class="nc" id="L1426">        .collect(Collectors.toMap(id -&gt; id, id -&gt; BulkUpdateUtil.getEvent(getIndexService(), getIndex(), id)));</span>

      // Check for invalid (non-existing) event ids
<span class="nc bnc" id="L1429" title="All 2 branches missed.">      final Set&lt;String&gt; notFoundIds = events.entrySet().stream().filter(e -&gt; !e.getValue().isPresent()).map(Entry::getKey).collect(Collectors.toSet());</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">      if (!notFoundIds.isEmpty()) {</span>
<span class="nc" id="L1431">        return notFoundJson(JSONUtils.setToJSON(notFoundIds));</span>
      }


<span class="nc" id="L1435">      events.values().forEach(e -&gt; e.ifPresent(event -&gt; {</span>

<span class="nc" id="L1437">        JSONObject metadata = null;</span>

        // Update the scheduling information
        try {
<span class="nc bnc" id="L1441" title="All 2 branches missed.">          if (groupInstructions.getScheduling() != null) {</span>
            // Since we only have the start/end time, we have to add the correct date(s) for this event.
<span class="nc" id="L1443">            final JSONObject scheduling = BulkUpdateUtil.addSchedulingDates(event, groupInstructions.getScheduling());</span>
<span class="nc" id="L1444">            updateEventScheduling(scheduling.toJSONString(), event);</span>
            // We have to update the non-technical metadata as well to keep them in sync with the technical ones.
<span class="nc" id="L1446">            metadata = BulkUpdateUtil.toNonTechnicalMetadataJson(scheduling);</span>
          }
<span class="nc" id="L1448">        } catch (Exception exception) {</span>
<span class="nc" id="L1449">          schedulingUpdateFailures.put(event.getIdentifier(), exception.getMessage());</span>
<span class="nc" id="L1450">        }</span>

        // Update the event metadata
        try {
<span class="nc bnc" id="L1454" title="All 4 branches missed.">          if (groupInstructions.getMetadata() != null || metadata != null) {</span>
<span class="nc" id="L1455">            metadata = BulkUpdateUtil.mergeMetadataFields(metadata, groupInstructions.getMetadata());</span>
<span class="nc" id="L1456">            getIndexService().updateAllEventMetadata(event.getIdentifier(), JSONArray.toJSONString(Collections.singletonList(metadata)), getIndex());</span>
          }
<span class="nc" id="L1458">        } catch (Exception exception) {</span>
<span class="nc" id="L1459">          metadataUpdateFailures.put(event.getIdentifier(), exception.getMessage());</span>
<span class="nc" id="L1460">        }</span>
<span class="nc" id="L1461">      }));</span>
<span class="nc" id="L1462">    }</span>

    // Check if there were any errors updating the metadata or scheduling information
<span class="nc bnc" id="L1465" title="All 4 branches missed.">    if (!metadataUpdateFailures.isEmpty() || !schedulingUpdateFailures.isEmpty()) {</span>
<span class="nc" id="L1466">      return serverErrorJson(obj(</span>
<span class="nc" id="L1467">        f(&quot;metadataFailures&quot;, JSONUtils.mapToJSON(metadataUpdateFailures)),</span>
<span class="nc" id="L1468">        f(&quot;schedulingFailures&quot;, JSONUtils.mapToJSON(schedulingUpdateFailures))</span>
      ));
    }
<span class="nc" id="L1471">    return ok();</span>
  }

  @POST
  @Path(&quot;bulk/conflicts&quot;)
  @RestQuery(name = &quot;getBulkConflicts&quot;, description = &quot;Checks if the current bulk update scheduling settings are in a conflict with another event&quot;, returnDescription = &quot;Returns NO CONTENT if no event are in conflict within specified period or list of conflicting recordings in JSON&quot;, restParameters = {
    @RestParameter(name = &quot;update&quot;, isRequired = true, type = RestParameter.Type.TEXT, description = &quot;The list of events and fields to update.&quot;)}, responses = {
    @RestResponse(responseCode = HttpServletResponse.SC_NO_CONTENT, description = &quot;No conflicting events found&quot;),
    @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;The events in the response body were not found. No events were updated.&quot;),
    @RestResponse(responseCode = HttpServletResponse.SC_CONFLICT, description = &quot;There is a conflict&quot;),
    @RestResponse(responseCode = HttpServletResponse.SC_BAD_REQUEST, description = &quot;Missing or invalid parameters&quot;)})
  public Response getBulkConflicts(@FormParam(&quot;update&quot;) final String updateJson) throws NotFoundException {
    final BulkUpdateUtil.BulkUpdateInstructions instructions;
    try {
<span class="nc" id="L1485">      instructions = new BulkUpdateUtil.BulkUpdateInstructions(updateJson);</span>
<span class="nc" id="L1486">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1487">      return badRequest(&quot;Cannot parse bulk update instructions&quot;);</span>
<span class="nc" id="L1488">    }</span>

<span class="nc" id="L1490">    final Map&lt;String, List&lt;JValue&gt;&gt; conflicts = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1491">    final List&lt;Tuple3&lt;String, Optional&lt;Event&gt;, JSONObject&gt;&gt; eventsWithSchedulingOpt = instructions.getGroups().stream()</span>
<span class="nc" id="L1492">      .flatMap(group -&gt; group.getEventIds().stream().map(eventId -&gt; Tuple3</span>
<span class="nc" id="L1493">        .tuple3(eventId, BulkUpdateUtil.getEvent(getIndexService(), getIndex(), eventId), group.getScheduling())))</span>
<span class="nc" id="L1494">      .collect(Collectors.toList());</span>
    // Check for invalid (non-existing) event ids
<span class="nc bnc" id="L1496" title="All 2 branches missed.">    final Set&lt;String&gt; notFoundIds = eventsWithSchedulingOpt.stream().filter(e -&gt; !e.getB().isPresent())</span>
<span class="nc" id="L1497">      .map(Tuple3::getA).collect(Collectors.toSet());</span>
<span class="nc bnc" id="L1498" title="All 2 branches missed.">    if (!notFoundIds.isEmpty()) {</span>
<span class="nc" id="L1499">      return notFoundJson(JSONUtils.setToJSON(notFoundIds));</span>
    }
<span class="nc" id="L1501">    final List&lt;Tuple&lt;Event, JSONObject&gt;&gt; eventsWithScheduling = eventsWithSchedulingOpt.stream()</span>
<span class="nc" id="L1502">      .map(e -&gt; Tuple.tuple(e.getB().get(), e.getC())).collect(Collectors.toList());</span>
<span class="nc" id="L1503">    final Set&lt;String&gt; changedIds = eventsWithScheduling.stream().map(e -&gt; e.getA().getIdentifier())</span>
<span class="nc" id="L1504">      .collect(Collectors.toSet());</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">    for (final Tuple&lt;Event, JSONObject&gt; eventWithGroup : eventsWithScheduling) {</span>
<span class="nc" id="L1506">      final Event event = eventWithGroup.getA();</span>
<span class="nc" id="L1507">      final JSONObject groupScheduling = eventWithGroup.getB();</span>
      try {
<span class="nc bnc" id="L1509" title="All 2 branches missed.">        if (groupScheduling != null) {</span>
          // Since we only have the start/end time, we have to add the correct date(s) for this event.
<span class="nc" id="L1511">          final JSONObject scheduling = BulkUpdateUtil.addSchedulingDates(event, groupScheduling);</span>
<span class="nc" id="L1512">          final Date start = Date.from(Instant.parse((String) scheduling.get(SCHEDULING_START_KEY)));</span>
<span class="nc" id="L1513">          final Date end = Date.from(Instant.parse((String) scheduling.get(SCHEDULING_END_KEY)));</span>
<span class="nc" id="L1514">          final String agentId = Optional.ofNullable((String) scheduling.get(SCHEDULING_AGENT_ID_KEY))</span>
<span class="nc" id="L1515">            .orElse(event.getAgentId());</span>

<span class="nc" id="L1517">          final List&lt;JValue&gt; currentConflicts = new ArrayList&lt;&gt;();</span>

          // Check for conflicts between the events themselves
<span class="nc" id="L1520">          eventsWithScheduling.stream()</span>
<span class="nc bnc" id="L1521" title="All 2 branches missed.">            .filter(otherEvent -&gt; !otherEvent.getA().getIdentifier().equals(event.getIdentifier()))</span>
<span class="nc" id="L1522">            .forEach(otherEvent -&gt; {</span>
<span class="nc" id="L1523">            final JSONObject otherScheduling = BulkUpdateUtil.addSchedulingDates(otherEvent.getA(), otherEvent.getB());</span>
<span class="nc" id="L1524">            final Date otherStart = Date.from(Instant.parse((String) otherScheduling.get(SCHEDULING_START_KEY)));</span>
<span class="nc" id="L1525">            final Date otherEnd = Date.from(Instant.parse((String) otherScheduling.get(SCHEDULING_END_KEY)));</span>
<span class="nc" id="L1526">            final String otherAgentId = Optional.ofNullable((String) otherScheduling.get(SCHEDULING_AGENT_ID_KEY))</span>
<span class="nc" id="L1527">              .orElse(otherEvent.getA().getAgentId());</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">            if (!otherAgentId.equals(agentId)) {</span>
              // different agent -&gt; no conflict
<span class="nc" id="L1530">              return;</span>
            }
<span class="nc bnc" id="L1532" title="All 2 branches missed.">            if (Util.schedulingIntervalsOverlap(start, end, otherStart, otherEnd)) {</span>
              // conflict
<span class="nc" id="L1534">              currentConflicts.add(convertEventToConflictingObject(DateTimeSupport.toUTC(otherStart.getTime()),</span>
<span class="nc" id="L1535">                DateTimeSupport.toUTC(otherEnd.getTime()), otherEvent.getA().getTitle()));</span>
            }
<span class="nc" id="L1537">          });</span>

          // Check for conflicts with other events from the database
<span class="nc" id="L1540">          final List&lt;MediaPackage&gt; conflicting = getSchedulerService().findConflictingEvents(agentId, start, end)</span>
<span class="nc" id="L1541">            .stream()</span>
<span class="nc bnc" id="L1542" title="All 2 branches missed.">            .filter(mp -&gt; !changedIds.contains(mp.getIdentifier().toString()))</span>
<span class="nc" id="L1543">            .collect(Collectors.toList());</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">          if (!conflicting.isEmpty()) {</span>
<span class="nc" id="L1545">            currentConflicts.addAll(convertToConflictObjects(event.getIdentifier(), conflicting));</span>
          }
<span class="nc" id="L1547">          conflicts.put(event.getIdentifier(), currentConflicts);</span>
        }
<span class="nc" id="L1549">      } catch (final SchedulerException | UnauthorizedException | SearchIndexException exception) {</span>
<span class="nc" id="L1550">        throw new RuntimeException(exception);</span>
<span class="nc" id="L1551">      }</span>
<span class="nc" id="L1552">    }</span>

<span class="nc bnc" id="L1554" title="All 2 branches missed.">    if (!conflicts.isEmpty()) {</span>
<span class="nc" id="L1555">      final List&lt;JValue&gt; responseJson = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1556">      conflicts.forEach((eventId, conflictingEvents) -&gt; {</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">        if (!conflictingEvents.isEmpty()) {</span>
<span class="nc" id="L1558">          responseJson.add(obj(f(&quot;eventId&quot;, eventId), f(&quot;conflicts&quot;, arr(conflictingEvents))));</span>
        }
<span class="nc" id="L1560">      });</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">      if (!responseJson.isEmpty()) {</span>
<span class="nc" id="L1562">        return conflictJson(arr(responseJson));</span>
      }
    }

<span class="nc" id="L1566">    return noContent();</span>
  }

  @PUT
  @Path(&quot;{eventId}/metadata&quot;)
  @RestQuery(name = &quot;updateeventmetadata&quot;, description = &quot;Update the passed metadata for the event with the given Id&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, restParameters = {
                  @RestParameter(name = &quot;metadata&quot;, isRequired = true, type = RestParameter.Type.TEXT, description = &quot;The list of metadata to update&quot;) }, responses = {
                          @RestResponse(description = &quot;The metadata have been updated.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;Could not parse metadata.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                          @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) }, returnDescription = &quot;No content is returned.&quot;)
  public Response updateEventMetadata(@PathParam(&quot;eventId&quot;) String id, @FormParam(&quot;metadata&quot;) String metadataJSON)
          throws Exception {
<span class="fc" id="L1579">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
<span class="fc bfc" id="L1580" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L1581">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>

    try {
<span class="fc" id="L1584">      MetadataList metadataList = getIndexService().updateAllEventMetadata(id, metadataJSON, getIndex());</span>
<span class="fc" id="L1585">      return okJson(MetadataJson.listToJson(metadataList, true));</span>
<span class="nc" id="L1586">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1587">      return badRequest(String.format(&quot;Event %s metadata can't be updated.: %s&quot;, id, e.getMessage()));</span>
    }
  }

  @PUT
  @Path(&quot;events/metadata&quot;)
  @RestQuery(name = &quot;updateeventsmetadata&quot;,
    description = &quot;Update the passed metadata for the events with the given ids&quot;,
    restParameters = {
      @RestParameter(name = &quot;eventIds&quot;, isRequired = true, type = RestParameter.Type.STRING,
        description = &quot;The ids of the events to update&quot;),
      @RestParameter(name = &quot;metadata&quot;, isRequired = true, type = RestParameter.Type.TEXT,
        description = &quot;The metadata fields to update&quot;),
    }, responses = {
    @RestResponse(description = &quot;All events have been updated successfully.&quot;,
      responseCode = HttpServletResponse.SC_NO_CONTENT),
    @RestResponse(description = &quot;One or multiple errors occured while updating event metadata. &quot;
      + &quot;Some events may have been updated successfully. &quot;
      + &quot;Details are available in the response body.&quot;,
      responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR)},
    returnDescription = &quot;In case of complete success, no content is returned. Otherwise, the response content &quot;
      + &quot;contains the ids of events that couldn't be found and the ids and errors of events where the update failed &quot;
      + &quot;as well as the ids of the events that were updated successfully.&quot;)
  public Response updateEventsMetadata(@FormParam(&quot;eventIds&quot;) String eventIds, @FormParam(&quot;metadata&quot;) String metadata)
    throws Exception {

<span class="pc bpc" id="L1613" title="1 of 2 branches missed.">    if (StringUtils.isBlank(eventIds)) {</span>
<span class="nc" id="L1614">      return badRequest(&quot;Event ids can't be empty&quot;);</span>
    }

<span class="fc" id="L1617">    JSONParser parser = new JSONParser();</span>
    List&lt;String&gt; ids;
    try {
<span class="fc" id="L1620">      ids = (List&lt;String&gt;) parser.parse(eventIds);</span>
<span class="nc" id="L1621">    } catch (org.json.simple.parser.ParseException e) {</span>
<span class="nc" id="L1622">      logger.error(&quot;Unable to parse '{}'&quot;, eventIds, e);</span>
<span class="nc" id="L1623">      return badRequest(&quot;Unable to parse event ids&quot;);</span>
<span class="nc" id="L1624">    } catch (ClassCastException e) {</span>
<span class="nc" id="L1625">      logger.error(&quot;Unable to cast '{}'&quot;, eventIds, e);</span>
<span class="nc" id="L1626">      return badRequest(&quot;Unable to parse event ids&quot;);</span>
<span class="fc" id="L1627">    }</span>

    // try to update each event
<span class="fc" id="L1630">    Set&lt;String&gt; eventsNotFound = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1631">    Set&lt;String&gt; eventsUpdated = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1632">    Set&lt;String&gt; eventsUpdateFailure = new HashSet();</span>

<span class="fc bfc" id="L1634" title="All 2 branches covered.">    for (String eventId : ids) {</span>
<span class="fc" id="L1635">      Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
      // not found?

<span class="fc bfc" id="L1638" title="All 2 branches covered.">      if (optEvent.isNone()) {</span>
<span class="fc" id="L1639">        eventsNotFound.add(eventId);</span>
<span class="fc" id="L1640">        continue;</span>
      }

      // update
      try {
<span class="fc" id="L1645">        getIndexService().updateAllEventMetadata(eventId, metadata, getIndex());</span>
<span class="fc" id="L1646">        eventsUpdated.add(eventId);</span>
<span class="fc" id="L1647">      } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L1648">        eventsUpdateFailure.add(eventId);</span>
<span class="fc" id="L1649">      }</span>
<span class="fc" id="L1650">    }</span>

    // errors occurred?
<span class="pc bpc" id="L1653" title="1 of 4 branches missed.">    if (!eventsNotFound.isEmpty() || !eventsUpdateFailure.isEmpty()) {</span>
<span class="fc" id="L1654">      return serverErrorJson(obj(</span>
<span class="fc" id="L1655">        f(&quot;updateFailures&quot;, JSONUtils.setToJSON(eventsUpdateFailure)),</span>
<span class="fc" id="L1656">        f(&quot;notFound&quot;, JSONUtils.setToJSON(eventsNotFound)),</span>
<span class="fc" id="L1657">        f(&quot;updated&quot;, JSONUtils.setToJSON(eventsUpdated))</span>
      ));
    }

<span class="fc" id="L1661">    return noContent();</span>
  }

  @GET
  @Path(&quot;{eventId}/asset/assets.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getAssetList&quot;, description = &quot;Returns the number of assets from each types as JSON&quot;, returnDescription = &quot;The number of assets from each types as JSON&quot;, pathParameters = { @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Returns the number of assets from each types as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getAssetList(@PathParam(&quot;eventId&quot;) String id) throws Exception {
<span class="fc" id="L1671">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">    if (optEvent.isNone())</span>
<span class="nc" id="L1673">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
    MediaPackage mp;
    try {
<span class="fc" id="L1676">      mp = getIndexService().getEventMediapackage(optEvent.get());</span>
<span class="nc" id="L1677">    } catch (IndexServiceException e) {</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">      if (e.getCause() instanceof NotFoundException) {</span>
<span class="nc" id="L1679">        return notFound(&quot;Cannot find data for event %s&quot;, id);</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">      } else if (e.getCause() instanceof UnauthorizedException) {</span>
<span class="nc" id="L1681">        return Response.status(Status.FORBIDDEN).entity(&quot;Not authorized to access &quot; + id).build();</span>
      }
<span class="nc" id="L1683">      logger.error(&quot;Internal error when trying to access metadata for &quot; + id, e);</span>
<span class="nc" id="L1684">      return serverError();</span>
<span class="fc" id="L1685">    }</span>
<span class="fc" id="L1686">    int attachments = mp.getAttachments().length;</span>
<span class="fc" id="L1687">    int catalogs = mp.getCatalogs().length;</span>
<span class="fc" id="L1688">    int media = mp.getTracks().length;</span>
<span class="fc" id="L1689">    int publications = mp.getPublications().length;</span>
<span class="fc" id="L1690">    return okJson(obj(f(&quot;attachments&quot;, v(attachments)), f(&quot;catalogs&quot;, v(catalogs)), f(&quot;media&quot;, v(media)),</span>
<span class="fc" id="L1691">            f(&quot;publications&quot;, v(publications))));</span>
  }

  @GET
  @Path(&quot;{eventId}/asset/attachment/attachments.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getAttachmentsList&quot;, description = &quot;Returns a list of attachments from the given event as JSON&quot;, returnDescription = &quot;The list of attachments from the given event as JSON&quot;, pathParameters = { @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Returns a list of attachments from the given event as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getAttachmentsList(@PathParam(&quot;eventId&quot;) String id) throws Exception {
<span class="fc" id="L1701">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L1703">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
<span class="fc" id="L1704">    MediaPackage mp = getIndexService().getEventMediapackage(optEvent.get());</span>
<span class="fc" id="L1705">    return okJson(arr(getEventMediaPackageElements(mp.getAttachments())));</span>
  }

  @GET
  @Path(&quot;{eventId}/asset/attachment/{id}.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getAttachment&quot;, description = &quot;Returns the details of an attachment from the given event and attachment id as JSON&quot;, returnDescription = &quot;The details of an attachment from the given event and attachment id as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;id&quot;, description = &quot;The attachment id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Returns the details of an attachment from the given event and attachment id as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;No event or attachment with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getAttachment(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;id&quot;) String id)
          throws NotFoundException, SearchIndexException, IndexServiceException {
<span class="fc" id="L1718">    MediaPackage mp = getMediaPackageByEventId(eventId);</span>

<span class="fc" id="L1720">    Attachment attachment = mp.getAttachment(id);</span>
<span class="pc bpc" id="L1721" title="1 of 2 branches missed.">    if (attachment == null)</span>
<span class="nc" id="L1722">      return notFound(&quot;Cannot find an attachment with id '%s'.&quot;, id);</span>
<span class="fc" id="L1723">    return okJson(attachmentToJSON(attachment));</span>
  }

  @GET
  @Path(&quot;{eventId}/asset/catalog/catalogs.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getCatalogList&quot;, description = &quot;Returns a list of catalogs from the given event as JSON&quot;, returnDescription = &quot;The list of catalogs from the given event as JSON&quot;, pathParameters = { @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Returns a list of catalogs from the given event as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getCatalogList(@PathParam(&quot;eventId&quot;) String id) throws Exception {
<span class="fc" id="L1733">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
<span class="fc bfc" id="L1734" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L1735">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
<span class="fc" id="L1736">    MediaPackage mp = getIndexService().getEventMediapackage(optEvent.get());</span>
<span class="fc" id="L1737">    return okJson(arr(getEventMediaPackageElements(mp.getCatalogs())));</span>
  }

  @GET
  @Path(&quot;{eventId}/asset/catalog/{id}.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getCatalog&quot;, description = &quot;Returns the details of a catalog from the given event and catalog id as JSON&quot;, returnDescription = &quot;The details of a catalog from the given event and catalog id as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;id&quot;, description = &quot;The catalog id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Returns the details of a catalog from the given event and catalog id as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;No event or catalog with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getCatalog(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;id&quot;) String id)
          throws NotFoundException, SearchIndexException, IndexServiceException {
<span class="fc" id="L1750">    MediaPackage mp = getMediaPackageByEventId(eventId);</span>

<span class="fc" id="L1752">    Catalog catalog = mp.getCatalog(id);</span>
<span class="fc bfc" id="L1753" title="All 2 branches covered.">    if (catalog == null)</span>
<span class="fc" id="L1754">      return notFound(&quot;Cannot find a catalog with id '%s'.&quot;, id);</span>
<span class="fc" id="L1755">    return okJson(catalogToJSON(catalog));</span>
  }

  @GET
  @Path(&quot;{eventId}/asset/media/media.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getMediaList&quot;, description = &quot;Returns a list of media from the given event as JSON&quot;, returnDescription = &quot;The list of media from the given event as JSON&quot;, pathParameters = { @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Returns a list of media from the given event as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getMediaList(@PathParam(&quot;eventId&quot;) String id) throws Exception {
<span class="fc" id="L1765">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
<span class="fc bfc" id="L1766" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L1767">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
<span class="fc" id="L1768">    MediaPackage mp = getIndexService().getEventMediapackage(optEvent.get());</span>
<span class="fc" id="L1769">    return okJson(arr(getEventMediaPackageElements(mp.getTracks())));</span>
  }

  @GET
  @Path(&quot;{eventId}/asset/media/{id}.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getMedia&quot;, description = &quot;Returns the details of a media from the given event and media id as JSON&quot;, returnDescription = &quot;The details of a media from the given event and media id as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;id&quot;, description = &quot;The media id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns the media of a catalog from the given event and media id as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;No event or media with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getMedia(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;id&quot;) String id)
          throws NotFoundException, SearchIndexException, IndexServiceException {
<span class="fc" id="L1782">    MediaPackage mp = getMediaPackageByEventId(eventId);</span>

<span class="fc" id="L1784">    Track track = mp.getTrack(id);</span>
<span class="fc bfc" id="L1785" title="All 2 branches covered.">    if (track == null)</span>
<span class="fc" id="L1786">      return notFound(&quot;Cannot find media with id '%s'.&quot;, id);</span>
<span class="fc" id="L1787">    return okJson(trackToJSON(track));</span>
  }

  @GET
  @Path(&quot;{eventId}/asset/publication/publications.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getPublicationList&quot;, description = &quot;Returns a list of publications from the given event as JSON&quot;, returnDescription = &quot;The list of publications from the given event as JSON&quot;, pathParameters = { @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Returns a list of publications from the given event as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getPublicationList(@PathParam(&quot;eventId&quot;) String id) throws Exception {
<span class="fc" id="L1797">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
<span class="fc bfc" id="L1798" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L1799">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
<span class="fc" id="L1800">    MediaPackage mp = getIndexService().getEventMediapackage(optEvent.get());</span>
<span class="fc" id="L1801">    return okJson(arr(getEventPublications(mp.getPublications())));</span>
  }

  @GET
  @Path(&quot;{eventId}/asset/publication/{id}.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getPublication&quot;, description = &quot;Returns the details of a publication from the given event and publication id as JSON&quot;, returnDescription = &quot;The details of a publication from the given event and publication id as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;id&quot;, description = &quot;The publication id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Returns the publication of a catalog from the given event and publication id as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;No event or publication with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getPublication(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;id&quot;) String id)
          throws NotFoundException, SearchIndexException, IndexServiceException {
<span class="fc" id="L1814">    MediaPackage mp = getMediaPackageByEventId(eventId);</span>

<span class="fc" id="L1816">    Publication publication = null;</span>
<span class="fc bfc" id="L1817" title="All 2 branches covered.">    for (Publication p : mp.getPublications()) {</span>
<span class="fc bfc" id="L1818" title="All 2 branches covered.">      if (id.equals(p.getIdentifier())) {</span>
<span class="fc" id="L1819">        publication = p;</span>
<span class="fc" id="L1820">        break;</span>
      }
    }

<span class="fc bfc" id="L1824" title="All 2 branches covered.">    if (publication == null)</span>
<span class="fc" id="L1825">      return notFound(&quot;Cannot find publication with id '%s'.&quot;, id);</span>
<span class="fc" id="L1826">    return okJson(publicationToJSON(publication));</span>
  }

  @GET
  @Path(&quot;{eventId}/tobira/pages&quot;)
  @RestQuery(
          name = &quot;getEventHostPages&quot;,
          description = &quot;Returns the pages of a connected Tobira instance that contain the given event&quot;,
          returnDescription = &quot;The Tobira pages that contain the given event&quot;,
          pathParameters = {
                  @RestParameter(
                          name = &quot;eventId&quot;,
                          isRequired = true,
                          description = &quot;The event identifier&quot;,
                          type = STRING
                  ),
          },
          responses = {
                  @RestResponse(
                          responseCode = SC_OK,
                          description = &quot;The Tobira pages containing the given event&quot;
                  ),
                  @RestResponse(
                          responseCode = SC_NOT_FOUND,
                          description = &quot;Tobira doesn't know about the given event&quot;
                  ),
                  @RestResponse(
                          responseCode = SC_SERVICE_UNAVAILABLE,
                          description = &quot;Tobira is not configured (correctly)&quot;
                  ),
          }
  )
  public Response getEventHostPages(@PathParam(&quot;eventId&quot;) String eventId) {
<span class="nc" id="L1859">    var tobira = TobiraService.getTobira(getSecurityService().getOrganization().getId());</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">    if (!tobira.ready()) {</span>
<span class="nc" id="L1861">      return Response.status(Status.SERVICE_UNAVAILABLE)</span>
<span class="nc" id="L1862">              .entity(&quot;Tobira is not configured (correctly)&quot;)</span>
<span class="nc" id="L1863">              .build();</span>
    }

    try {
<span class="nc" id="L1867">      var eventData = tobira.getEventHostPages(eventId);</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">      if (eventData == null) {</span>
<span class="nc" id="L1869">        throw new WebApplicationException(NOT_FOUND);</span>
      }
<span class="nc" id="L1871">      eventData.put(&quot;baseURL&quot;, tobira.getOrigin());</span>
<span class="nc" id="L1872">      return Response.ok(eventData.toJSONString()).build();</span>
<span class="nc" id="L1873">    } catch (TobiraException e) {</span>
<span class="nc" id="L1874">      throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @GET
  @Path(&quot;{eventId}/workflows.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;geteventworkflows&quot;, description = &quot;Returns all the data related to the workflows tab in the event details modal as JSON&quot;, returnDescription = &quot;All the data related to the event workflows tab as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns all the data related to the event workflows tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventWorkflows(@PathParam(&quot;eventId&quot;) String id)
          throws UnauthorizedException, SearchIndexException, JobEndpointException {
<span class="fc" id="L1887">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
<span class="fc bfc" id="L1888" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L1889">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>

    try {
<span class="pc bpc" id="L1892" title="1 of 2 branches missed.">      if (optEvent.get().getEventStatus().equals(&quot;EVENTS.EVENTS.STATUS.SCHEDULED&quot;)) {</span>
<span class="nc" id="L1893">        List&lt;Field&gt; fields = new ArrayList&lt;Field&gt;();</span>
<span class="nc" id="L1894">        Map&lt;String, String&gt; workflowConfig = getSchedulerService().getWorkflowConfig(id);</span>
<span class="nc bnc" id="L1895" title="All 2 branches missed.">        for (Entry&lt;String, String&gt; entry : workflowConfig.entrySet()) {</span>
<span class="nc" id="L1896">          fields.add(f(entry.getKey(), v(entry.getValue(), Jsons.BLANK)));</span>
<span class="nc" id="L1897">        }</span>

<span class="nc" id="L1899">        Map&lt;String, String&gt; agentConfiguration = getSchedulerService().getCaptureAgentConfiguration(id);</span>
<span class="nc" id="L1900">        return okJson(obj(f(&quot;workflowId&quot;, v(agentConfiguration.get(CaptureParameters.INGEST_WORKFLOW_DEFINITION), Jsons.BLANK)),</span>
<span class="nc" id="L1901">                f(&quot;configuration&quot;, obj(fields))));</span>
      } else {
<span class="fc" id="L1903">        List&lt;WorkflowInstance&gt; workflowInstances = getWorkflowService().getWorkflowInstancesByMediaPackage(id);</span>
<span class="fc" id="L1904">        List&lt;JValue&gt; jsonList = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L1906" title="All 2 branches covered.">        for (WorkflowInstance instance : workflowInstances) {</span>
<span class="fc" id="L1907">          long instanceId = instance.getId();</span>
<span class="fc" id="L1908">          Date created = instance.getDateCreated();</span>
<span class="fc" id="L1909">          String submitter = instance.getCreatorName();</span>

<span class="fc bfc" id="L1911" title="All 2 branches covered.">          User user = submitter == null ? null : getUserDirectoryService().loadUser(submitter);</span>
<span class="fc" id="L1912">          String submitterName = null;</span>
<span class="fc" id="L1913">          String submitterEmail = null;</span>
<span class="fc bfc" id="L1914" title="All 2 branches covered.">          if (user != null) {</span>
<span class="fc" id="L1915">            submitterName = user.getName();</span>
<span class="fc" id="L1916">            submitterEmail = user.getEmail();</span>
          }

<span class="fc" id="L1919">          jsonList.add(obj(f(&quot;id&quot;, v(instanceId)), f(&quot;title&quot;, v(instance.getTitle(), Jsons.BLANK)),</span>
<span class="fc" id="L1920">                  f(&quot;status&quot;, v(WORKFLOW_STATUS_TRANSLATION_PREFIX + instance.getState().toString())),</span>
<span class="pc bpc" id="L1921" title="1 of 2 branches missed.">                  f(&quot;submitted&quot;, v(created != null ? DateTimeSupport.toUTC(created.getTime()) : &quot;&quot;, Jsons.BLANK)),</span>
<span class="fc" id="L1922">                  f(&quot;submitter&quot;, v(submitter, Jsons.BLANK)),</span>
<span class="fc" id="L1923">                  f(&quot;submitterName&quot;, v(submitterName, Jsons.BLANK)),</span>
<span class="fc" id="L1924">                  f(&quot;submitterEmail&quot;, v(submitterEmail, Jsons.BLANK))));</span>
<span class="fc" id="L1925">        }</span>
<span class="fc" id="L1926">        JObject json = obj(f(&quot;results&quot;, arr(jsonList)), f(&quot;count&quot;, v(workflowInstances.size())));</span>
<span class="fc" id="L1927">        return okJson(json);</span>
      }
<span class="nc" id="L1929">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1930">      return notFound(&quot;Cannot find workflows for event %s&quot;, id);</span>
<span class="nc" id="L1931">    } catch (SchedulerException e) {</span>
<span class="nc" id="L1932">      logger.error(&quot;Unable to get workflow data for event with id {}&quot;, id);</span>
<span class="nc" id="L1933">      throw new WebApplicationException(e, SC_INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L1934">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L1935">      throw new JobEndpointException(String.format(&quot;Not able to get the list of job from the database: %s&quot;, e),</span>
<span class="nc" id="L1936">              e.getCause());</span>
    }
  }

  @PUT
  @Path(&quot;{eventId}/workflows&quot;)
  @RestQuery(name = &quot;updateEventWorkflow&quot;, description = &quot;Update the workflow configuration for the scheduled event with the given id&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, restParameters = {
                  @RestParameter(name = &quot;configuration&quot;, isRequired = true, description = &quot;The workflow configuration as JSON&quot;, type = RestParameter.Type.TEXT) }, responses = {
                          @RestResponse(description = &quot;Request executed succesfully&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) }, returnDescription = &quot;The method does not retrun any content.&quot;)
  public Response updateEventWorkflow(@PathParam(&quot;eventId&quot;) String id, @FormParam(&quot;configuration&quot;) String configuration)
          throws SearchIndexException, UnauthorizedException {
<span class="nc" id="L1949">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">    if (optEvent.isNone())</span>
<span class="nc" id="L1951">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>

<span class="nc bnc" id="L1953" title="All 4 branches missed.">    if (optEvent.get().isScheduledEvent() &amp;&amp; !optEvent.get().hasRecordingStarted()) {</span>
      try {

        JSONObject configJSON;
        try {
<span class="nc" id="L1958">          configJSON = (JSONObject) new JSONParser().parse(configuration);</span>
<span class="nc" id="L1959">        } catch (Exception e) {</span>
<span class="nc" id="L1960">          logger.warn(&quot;Unable to parse the workflow configuration {}&quot;, configuration);</span>
<span class="nc" id="L1961">          return badRequest();</span>
<span class="nc" id="L1962">        }</span>

<span class="nc" id="L1964">        Optional&lt;Map&lt;String, String&gt;&gt; caMetadataOpt = Optional.empty();</span>
<span class="nc" id="L1965">        Optional&lt;Map&lt;String, String&gt;&gt; workflowConfigOpt = Optional.empty();</span>

<span class="nc" id="L1967">        String workflowId = (String) configJSON.get(&quot;id&quot;);</span>
<span class="nc" id="L1968">        Map&lt;String, String&gt; caMetadata = new HashMap&lt;&gt;(getSchedulerService().getCaptureAgentConfiguration(id));</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">        if (!workflowId.equals(caMetadata.get(CaptureParameters.INGEST_WORKFLOW_DEFINITION))) {</span>
<span class="nc" id="L1970">          caMetadata.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, workflowId);</span>
<span class="nc" id="L1971">          caMetadataOpt = Optional.of(caMetadata);</span>
        }

<span class="nc" id="L1974">        Map&lt;String, String&gt; workflowConfig = new HashMap&lt;&gt;((JSONObject) configJSON.get(&quot;configuration&quot;));</span>
<span class="nc" id="L1975">        Map&lt;String, String&gt; oldWorkflowConfig = new HashMap&lt;&gt;(getSchedulerService().getWorkflowConfig(id));</span>
<span class="nc bnc" id="L1976" title="All 2 branches missed.">        if (!oldWorkflowConfig.equals(workflowConfig))</span>
<span class="nc" id="L1977">          workflowConfigOpt = Optional.of(workflowConfig);</span>

<span class="nc bnc" id="L1979" title="All 4 branches missed.">        if (caMetadataOpt.isEmpty() &amp;&amp; workflowConfigOpt.isEmpty())</span>
<span class="nc" id="L1980">          return Response.noContent().build();</span>

<span class="nc" id="L1982">        checkAgentAccessForAgent(optEvent.get().getAgentId());</span>

<span class="nc" id="L1984">        getSchedulerService().updateEvent(id, Optional.empty(), Optional.empty(), Optional.empty(),</span>
<span class="nc" id="L1985">            Optional.empty(), Optional.empty(), workflowConfigOpt, caMetadataOpt);</span>
<span class="nc" id="L1986">        return Response.noContent().build();</span>
<span class="nc" id="L1987">      } catch (NotFoundException e) {</span>
<span class="nc" id="L1988">        return notFound(&quot;Cannot find event %s in scheduler service&quot;, id);</span>
<span class="nc" id="L1989">      } catch (SchedulerException e) {</span>
<span class="nc" id="L1990">        logger.error(&quot;Unable to update scheduling workflow data for event with id {}&quot;, id);</span>
<span class="nc" id="L1991">        throw new WebApplicationException(e, SC_INTERNAL_SERVER_ERROR);</span>
      }
    } else {
<span class="nc" id="L1994">      return badRequest(String.format(&quot;Event %s workflow can not be updated as the recording already started.&quot;, id));</span>
    }
  }

  @GET
  @Path(&quot;{eventId}/workflows/{workflowId}&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;geteventworkflow&quot;, description = &quot;Returns all the data related to the single workflow tab in the event details modal as JSON&quot;, returnDescription = &quot;All the data related to the event singe workflow tab as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;workflowId&quot;, description = &quot;The workflow id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns all the data related to the event single workflow tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;Unable to parse workflowId&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventWorkflow(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;workflowId&quot;) String workflowId)
          throws SearchIndexException {
<span class="fc" id="L2009">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L2010" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L2011">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

    long workflowInstanceId;
    try {
<span class="fc" id="L2015">      workflowId = StringUtils.remove(workflowId, &quot;.json&quot;);</span>
<span class="fc" id="L2016">      workflowInstanceId = Long.parseLong(workflowId);</span>
<span class="fc" id="L2017">    } catch (Exception e) {</span>
<span class="fc" id="L2018">      logger.warn(&quot;Unable to parse workflow id {}&quot;, workflowId);</span>
<span class="fc" id="L2019">      return RestUtil.R.badRequest();</span>
<span class="fc" id="L2020">    }</span>

    try {
<span class="fc" id="L2023">      WorkflowInstance instance = getWorkflowService().getWorkflowById(workflowInstanceId);</span>

      // Retrieve submission date with the workflow instance main job
<span class="fc" id="L2026">      Date created = instance.getDateCreated();</span>

<span class="fc" id="L2028">      Date completed = instance.getDateCompleted();</span>
<span class="pc bpc" id="L2029" title="1 of 2 branches missed.">      if (completed == null)</span>
<span class="nc" id="L2030">        completed = new Date();</span>

<span class="fc" id="L2032">      long executionTime = completed.getTime() - created.getTime();</span>

<span class="fc" id="L2034">      var fields = instance.getConfigurations()</span>
<span class="fc" id="L2035">          .entrySet()</span>
<span class="fc" id="L2036">          .stream()</span>
<span class="pc" id="L2037">          .map(e -&gt; f(e.getKey(), v(e.getValue(), Jsons.BLANK)))</span>
<span class="fc" id="L2038">          .collect(Collectors.toList());</span>

<span class="fc" id="L2040">      return okJson(obj(</span>
<span class="fc" id="L2041">              f(&quot;status&quot;, v(WORKFLOW_STATUS_TRANSLATION_PREFIX + instance.getState(), Jsons.BLANK)),</span>
<span class="fc" id="L2042">              f(&quot;description&quot;, v(instance.getDescription(), Jsons.BLANK)),</span>
<span class="fc" id="L2043">              f(&quot;executionTime&quot;, v(executionTime, Jsons.BLANK)),</span>
<span class="fc" id="L2044">              f(&quot;wiid&quot;, v(instance.getId(), Jsons.BLANK)), f(&quot;title&quot;, v(instance.getTitle(), Jsons.BLANK)),</span>
<span class="fc" id="L2045">              f(&quot;wdid&quot;, v(instance.getTemplate(), Jsons.BLANK)),</span>
<span class="fc" id="L2046">              f(&quot;configuration&quot;, obj(fields)),</span>
<span class="fc" id="L2047">              f(&quot;submittedAt&quot;, v(toUTC(created.getTime()), Jsons.BLANK)),</span>
<span class="fc" id="L2048">              f(&quot;creator&quot;, v(instance.getCreatorName(), Jsons.BLANK))));</span>
<span class="fc" id="L2049">    } catch (NotFoundException e) {</span>
<span class="fc" id="L2050">      return notFound(&quot;Cannot find workflow  %s&quot;, workflowId);</span>
<span class="nc" id="L2051">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L2052">      logger.error(&quot;Unable to get workflow {} of event {}&quot;, workflowId, eventId, e);</span>
<span class="nc" id="L2053">      return serverError();</span>
<span class="nc" id="L2054">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L2055">      return forbidden();</span>
    }
  }

  @GET
  @Path(&quot;{eventId}/workflows/{workflowId}/operations.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;geteventoperations&quot;, description = &quot;Returns all the data related to the workflow/operations tab in the event details modal as JSON&quot;, returnDescription = &quot;All the data related to the event workflow/opertations tab as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;workflowId&quot;, description = &quot;The workflow id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns all the data related to the event workflow/operations tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;Unable to parse workflowId&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventOperations(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;workflowId&quot;) String workflowId)
          throws SearchIndexException {
<span class="fc" id="L2070">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L2071" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L2072">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

    long workflowInstanceId;
    try {
<span class="fc" id="L2076">      workflowInstanceId = Long.parseLong(workflowId);</span>
<span class="fc" id="L2077">    } catch (Exception e) {</span>
<span class="fc" id="L2078">      logger.warn(&quot;Unable to parse workflow id {}&quot;, workflowId);</span>
<span class="fc" id="L2079">      return RestUtil.R.badRequest();</span>
<span class="fc" id="L2080">    }</span>

    try {
<span class="fc" id="L2083">      WorkflowInstance instance = getWorkflowService().getWorkflowById(workflowInstanceId);</span>

<span class="fc" id="L2085">      List&lt;WorkflowOperationInstance&gt; operations = instance.getOperations();</span>
<span class="fc" id="L2086">      List&lt;JValue&gt; operationsJSON = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L2088" title="All 2 branches covered.">      for (WorkflowOperationInstance wflOp : operations) {</span>
<span class="fc" id="L2089">        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L2090" title="1 of 2 branches missed.">        for (String key : wflOp.getConfigurationKeys()) {</span>
<span class="nc" id="L2091">          fields.add(f(key, v(wflOp.getConfiguration(key), Jsons.BLANK)));</span>
<span class="nc" id="L2092">        }</span>
<span class="fc" id="L2093">        operationsJSON.add(obj(</span>
<span class="fc" id="L2094">                f(&quot;status&quot;,</span>
<span class="fc" id="L2095">                v(WORKFLOW_STATUS_TRANSLATION_PREFIX + wflOp.getState(), Jsons.BLANK)),</span>
<span class="fc" id="L2096">                f(&quot;title&quot;, v(wflOp.getTemplate(), Jsons.BLANK)),</span>
<span class="fc" id="L2097">                f(&quot;description&quot;, v(wflOp.getDescription(), Jsons.BLANK)),</span>
<span class="fc" id="L2098">                f(&quot;id&quot;, v(wflOp.getId(), Jsons.BLANK)),</span>
<span class="fc" id="L2099">                f(&quot;configuration&quot;, obj(fields))</span>
        ));
<span class="fc" id="L2101">      }</span>

<span class="fc" id="L2103">      return okJson(arr(operationsJSON));</span>
<span class="fc" id="L2104">    } catch (NotFoundException e) {</span>
<span class="fc" id="L2105">      return notFound(&quot;Cannot find workflow %s&quot;, workflowId);</span>
<span class="nc" id="L2106">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L2107">      logger.error(&quot;Unable to get workflow operations of event {} and workflow {}&quot;, eventId, workflowId, e);</span>
<span class="nc" id="L2108">      return serverError();</span>
<span class="nc" id="L2109">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L2110">      return forbidden();</span>
    }
  }

  @GET
  @Path(&quot;{eventId}/workflows/{workflowId}/operations/{operationPosition}&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;geteventoperation&quot;, description = &quot;Returns all the data related to the workflow/operation tab in the event details modal as JSON&quot;, returnDescription = &quot;All the data related to the event workflow/opertation tab as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;workflowId&quot;, description = &quot;The workflow id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;operationPosition&quot;, description = &quot;The operation position&quot;, isRequired = true, type = RestParameter.Type.INTEGER) }, responses = {
                  @RestResponse(description = &quot;Returns all the data related to the event workflow/operation tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;Unable to parse workflowId or operationPosition&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                  @RestResponse(description = &quot;No operation with these identifiers was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventOperation(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;workflowId&quot;) String workflowId,
          @PathParam(&quot;operationPosition&quot;) Integer operationPosition) throws SearchIndexException {
<span class="fc" id="L2126">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L2127" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L2128">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

    long workflowInstanceId;
    try {
<span class="fc" id="L2132">      workflowInstanceId = Long.parseLong(workflowId);</span>
<span class="fc" id="L2133">    } catch (Exception e) {</span>
<span class="fc" id="L2134">      logger.warn(&quot;Unable to parse workflow id {}&quot;, workflowId);</span>
<span class="fc" id="L2135">      return RestUtil.R.badRequest();</span>
<span class="fc" id="L2136">    }</span>

    WorkflowInstance instance;
    try {
<span class="fc" id="L2140">      instance = getWorkflowService().getWorkflowById(workflowInstanceId);</span>
<span class="fc" id="L2141">    } catch (NotFoundException e) {</span>
<span class="fc" id="L2142">      return notFound(&quot;Cannot find workflow %s&quot;, workflowId);</span>
<span class="nc" id="L2143">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L2144">      logger.error(&quot;Unable to get workflow operation of event {} and workflow {} at position {}&quot;, eventId, workflowId,</span>
              operationPosition, e);
<span class="nc" id="L2146">      return serverError();</span>
<span class="nc" id="L2147">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L2148">      return forbidden();</span>
<span class="fc" id="L2149">    }</span>

<span class="fc" id="L2151">    List&lt;WorkflowOperationInstance&gt; operations = instance.getOperations();</span>

<span class="pc bpc" id="L2153" title="1 of 2 branches missed.">    if (operations.size() &gt; operationPosition) {</span>
<span class="fc" id="L2154">      WorkflowOperationInstance wflOp = operations.get(operationPosition);</span>
<span class="fc" id="L2155">      return okJson(obj(f(&quot;retry_strategy&quot;, v(wflOp.getRetryStrategy(), Jsons.BLANK)),</span>
<span class="fc" id="L2156">              f(&quot;execution_host&quot;, v(wflOp.getExecutionHost(), Jsons.BLANK)),</span>
<span class="fc" id="L2157">              f(&quot;failed_attempts&quot;, v(wflOp.getFailedAttempts())),</span>
<span class="fc" id="L2158">              f(&quot;max_attempts&quot;, v(wflOp.getMaxAttempts())),</span>
<span class="fc" id="L2159">              f(&quot;exception_handler_workflow&quot;, v(wflOp.getExceptionHandlingWorkflow(), Jsons.BLANK)),</span>
<span class="fc" id="L2160">              f(&quot;fail_on_error&quot;, v(wflOp.isFailOnError())),</span>
<span class="fc" id="L2161">              f(&quot;description&quot;, v(wflOp.getDescription(), Jsons.BLANK)),</span>
<span class="fc" id="L2162">              f(&quot;state&quot;, v(WORKFLOW_STATUS_TRANSLATION_PREFIX + wflOp.getState(), Jsons.BLANK)),</span>
<span class="fc" id="L2163">              f(&quot;job&quot;, v(wflOp.getId(), Jsons.BLANK)),</span>
<span class="fc" id="L2164">              f(&quot;name&quot;, v(wflOp.getTemplate(), Jsons.BLANK)),</span>
<span class="fc" id="L2165">              f(&quot;time_in_queue&quot;, v(wflOp.getTimeInQueue(), v(0))),</span>
<span class="pc bpc" id="L2166" title="1 of 2 branches missed.">              f(&quot;started&quot;, wflOp.getDateStarted() != null ? v(toUTC(wflOp.getDateStarted().getTime())) : Jsons.BLANK),</span>
<span class="pc bpc" id="L2167" title="1 of 2 branches missed.">              f(&quot;completed&quot;, wflOp.getDateCompleted() != null ? v(toUTC(wflOp.getDateCompleted().getTime())) : Jsons.BLANK))</span>
      );
    }
<span class="nc" id="L2170">    return notFound(&quot;Cannot find workflow operation of workflow %s at position %s&quot;, workflowId, operationPosition);</span>
  }

  @GET
  @Path(&quot;{eventId}/workflows/{workflowId}/errors.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;geteventerrors&quot;, description = &quot;Returns all the data related to the workflow/errors tab in the event details modal as JSON&quot;, returnDescription = &quot;All the data related to the event workflow/errors tab as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;workflowId&quot;, description = &quot;The workflow id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns all the data related to the event workflow/errors tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;Unable to parse workflowId&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventErrors(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;workflowId&quot;) String workflowId,
          @Context HttpServletRequest req) throws JobEndpointException, SearchIndexException {
    // the call to #getEvent should make sure that the calling user has access rights to the workflow
    // FIXME since there is no dependency between the event and the workflow (the fetched event is
    // simply ignored) an attacker can get access by using an event he owns and a workflow ID of
    // someone else.
<span class="fc bfc" id="L2188" title="All 2 branches covered.">    for (final Event ignore : getIndexService().getEvent(eventId, getIndex())) {</span>
      final long workflowIdLong;
      try {
<span class="fc" id="L2191">        workflowIdLong = Long.parseLong(workflowId);</span>
<span class="fc" id="L2192">      } catch (Exception e) {</span>
<span class="fc" id="L2193">        logger.warn(&quot;Unable to parse workflow id {}&quot;, workflowId);</span>
<span class="fc" id="L2194">        return RestUtil.R.badRequest();</span>
<span class="fc" id="L2195">      }</span>
      try {
<span class="fc" id="L2197">        return okJson(getJobService().getIncidentsAsJSON(workflowIdLong, req.getLocale(), true));</span>
<span class="nc" id="L2198">      } catch (NotFoundException e) {</span>
<span class="nc" id="L2199">        return notFound(&quot;Cannot find the incident for the workflow %s&quot;, workflowId);</span>
      }
    }
<span class="fc" id="L2202">    return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
  }

  @GET
  @Path(&quot;{eventId}/workflows/{workflowId}/errors/{errorId}.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;geteventerror&quot;, description = &quot;Returns all the data related to the workflow/error tab in the event details modal as JSON&quot;, returnDescription = &quot;All the data related to the event workflow/error tab as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;workflowId&quot;, description = &quot;The workflow id&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;errorId&quot;, description = &quot;The error id&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Returns all the data related to the event workflow/error tab as JSON&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;Unable to parse workflowId&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventError(@PathParam(&quot;eventId&quot;) String eventId, @PathParam(&quot;workflowId&quot;) String workflowId,
          @PathParam(&quot;errorId&quot;) String errorId, @Context HttpServletRequest req)
                  throws JobEndpointException, SearchIndexException {
    // the call to #getEvent should make sure that the calling user has access rights to the workflow
    // FIXME since there is no dependency between the event and the workflow (the fetched event is
    // simply ignored) an attacker can get access by using an event he owns and a workflow ID of
    // someone else.
<span class="nc bnc" id="L2222" title="All 2 branches missed.">    for (Event ignore : getIndexService().getEvent(eventId, getIndex())) {</span>
      final long errorIdLong;
      try {
<span class="nc" id="L2225">        errorIdLong = Long.parseLong(errorId);</span>
<span class="nc" id="L2226">      } catch (Exception e) {</span>
<span class="nc" id="L2227">        logger.warn(&quot;Unable to parse error id {}&quot;, errorId);</span>
<span class="nc" id="L2228">        return RestUtil.R.badRequest();</span>
<span class="nc" id="L2229">      }</span>
      try {
<span class="nc" id="L2231">        return okJson(getJobService().getIncidentAsJSON(errorIdLong, req.getLocale()));</span>
<span class="nc" id="L2232">      } catch (NotFoundException e) {</span>
<span class="nc" id="L2233">        return notFound(&quot;Cannot find the incident %s&quot;, errorId);</span>
      }
    }
<span class="nc" id="L2236">    return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
  }

  @GET
  @Path(&quot;{eventId}/access.json&quot;)
  @SuppressWarnings(&quot;unchecked&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getEventAccessInformation&quot;, description = &quot;Get the access information of an event&quot;, returnDescription = &quot;The access information&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, isRequired = true, description = &quot;The event identifier&quot;, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;The required form params were missing in the request.&quot;),
                  @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;If the event has not been found.&quot;),
                  @RestResponse(responseCode = SC_OK, description = &quot;The access information &quot;) })
  public Response getEventAccessInformation(@PathParam(&quot;eventId&quot;) String eventId) throws Exception {
<span class="fc" id="L2249">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L2250" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L2251">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>

    // Add all available ACLs to the response
<span class="fc" id="L2254">    JSONArray systemAclsJson = new JSONArray();</span>
<span class="fc" id="L2255">    List&lt;ManagedAcl&gt; acls = getAclService().getAcls();</span>
<span class="fc bfc" id="L2256" title="All 2 branches covered.">    for (ManagedAcl acl : acls) {</span>
<span class="fc" id="L2257">      systemAclsJson.add(AccessInformationUtil.serializeManagedAcl(acl));</span>
<span class="fc" id="L2258">    }</span>

<span class="fc" id="L2260">    AccessControlList activeAcl = new AccessControlList();</span>
    try {
<span class="pc bpc" id="L2262" title="1 of 2 branches missed.">      if (optEvent.get().getAccessPolicy() != null)</span>
<span class="fc" id="L2263">        activeAcl = AccessControlParser.parseAcl(optEvent.get().getAccessPolicy());</span>
<span class="nc" id="L2264">    } catch (Exception e) {</span>
<span class="nc" id="L2265">      logger.error(&quot;Unable to parse access policy&quot;, e);</span>
<span class="fc" id="L2266">    }</span>
<span class="fc" id="L2267">    Option&lt;ManagedAcl&gt; currentAcl = AccessInformationUtil.matchAclsLenient(acls, activeAcl,</span>
<span class="fc" id="L2268">            getAdminUIConfiguration().getMatchManagedAclRolePrefixes());</span>

<span class="fc" id="L2270">    JSONObject episodeAccessJson = new JSONObject();</span>
<span class="pc bpc" id="L2271" title="1 of 2 branches missed.">    episodeAccessJson.put(&quot;current_acl&quot;, currentAcl.isSome() ? currentAcl.get().getId() : 0L);</span>
<span class="fc" id="L2272">    episodeAccessJson.put(&quot;acl&quot;, transformAccessControList(activeAcl, getUserDirectoryService()));</span>
<span class="fc" id="L2273">    episodeAccessJson.put(&quot;privileges&quot;, AccessInformationUtil.serializePrivilegesByRole(activeAcl));</span>
<span class="pc bpc" id="L2274" title="1 of 2 branches missed.">    if (StringUtils.isNotBlank(optEvent.get().getWorkflowState())</span>
<span class="pc bpc" id="L2275" title="1 of 2 branches missed.">            &amp;&amp; WorkflowUtil.isActive(WorkflowInstance.WorkflowState.valueOf(optEvent.get().getWorkflowState())))</span>
<span class="nc" id="L2276">      episodeAccessJson.put(&quot;locked&quot;, true);</span>

<span class="fc" id="L2278">    JSONObject jsonReturnObj = new JSONObject();</span>
<span class="fc" id="L2279">    jsonReturnObj.put(&quot;episode_access&quot;, episodeAccessJson);</span>
<span class="fc" id="L2280">    jsonReturnObj.put(&quot;system_acls&quot;, systemAclsJson);</span>

<span class="fc" id="L2282">    return Response.ok(jsonReturnObj.toString()).build();</span>
  }

  // MH-12085 Add manually uploaded assets, multipart file upload has to be a POST
  @POST
  @Path(&quot;{eventId}/assets&quot;)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @RestQuery(name = &quot;updateAssets&quot;, description = &quot;Update or create an asset for the eventId by the given metadata as JSON and files in the body&quot;,
  pathParameters = {
  @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = RestParameter.Type.STRING) },
  restParameters = {
  @RestParameter(name = &quot;metadata&quot;, isRequired = true, type = RestParameter.Type.TEXT, description = &quot;The list of asset metadata&quot;) },
  responses = {
  @RestResponse(description = &quot;The asset has been added.&quot;, responseCode = HttpServletResponse.SC_OK),
  @RestResponse(description = &quot;Could not add asset, problem with the metadata or files.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
  @RestResponse(description = &quot;No event with this identifier was found.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) },
  returnDescription = &quot;The workflow identifier&quot;)
  public Response updateAssets(@PathParam(&quot;eventId&quot;) final String eventId,
          @Context HttpServletRequest request)  throws Exception {
    try {
<span class="nc" id="L2302">      MediaPackage mp = getMediaPackageByEventId(eventId);</span>
<span class="nc" id="L2303">      String result = getIndexService().updateEventAssets(mp, request);</span>
<span class="nc" id="L2304">      return Response.status(Status.CREATED).entity(result).build();</span>
<span class="nc" id="L2305">    }  catch (NotFoundException e) {</span>
<span class="nc" id="L2306">      return notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
<span class="nc" id="L2307">    } catch (IllegalArgumentException | UnsupportedAssetException e) {</span>
<span class="nc" id="L2308">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L2309">    } catch (Exception e) {</span>
<span class="nc" id="L2310">      return RestUtil.R.serverError();</span>
    }
  }

  @GET
  @Path(&quot;new/metadata&quot;)
  @RestQuery(name = &quot;getNewMetadata&quot;, description = &quot;Returns all the data related to the metadata tab in the new event modal as JSON&quot;, returnDescription = &quot;All the data related to the event metadata tab as JSON&quot;, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;Returns all the data related to the event metadata tab as JSON&quot;) })
  public Response getNewMetadata() {
<span class="nc" id="L2319">    MetadataList metadataList = new MetadataList();</span>

    // Extended metadata
<span class="nc" id="L2322">    List&lt;EventCatalogUIAdapter&gt; extendedCatalogUIAdapters = getIndexService().getExtendedEventCatalogUIAdapters();</span>
<span class="nc bnc" id="L2323" title="All 2 branches missed.">    for (EventCatalogUIAdapter extendedCatalogUIAdapter : extendedCatalogUIAdapters) {</span>
<span class="nc" id="L2324">      metadataList.add(extendedCatalogUIAdapter, extendedCatalogUIAdapter.getRawFields());</span>
<span class="nc" id="L2325">    }</span>

    // Common metadata
    // We do this after extended metadata because we want to overwrite any extended metadata adapters with the same
    // flavor instead of the other way around.
<span class="nc" id="L2330">    EventCatalogUIAdapter commonCatalogUiAdapter = getIndexService().getCommonEventCatalogUIAdapter();</span>
<span class="nc" id="L2331">    DublinCoreMetadataCollection commonMetadata = commonCatalogUiAdapter.getRawFields(getCollectionQueryDisable());</span>

<span class="nc bnc" id="L2333" title="All 2 branches missed.">    if (commonMetadata.getOutputFields().containsKey(DublinCore.PROPERTY_CREATED.getLocalName()))</span>
<span class="nc" id="L2334">      commonMetadata.removeField(commonMetadata.getOutputFields().get(DublinCore.PROPERTY_CREATED.getLocalName()));</span>
<span class="nc bnc" id="L2335" title="All 2 branches missed.">    if (commonMetadata.getOutputFields().containsKey(&quot;duration&quot;))</span>
<span class="nc" id="L2336">      commonMetadata.removeField(commonMetadata.getOutputFields().get(&quot;duration&quot;));</span>
<span class="nc bnc" id="L2337" title="All 2 branches missed.">    if (commonMetadata.getOutputFields().containsKey(DublinCore.PROPERTY_IDENTIFIER.getLocalName()))</span>
<span class="nc" id="L2338">      commonMetadata.removeField(commonMetadata.getOutputFields().get(DublinCore.PROPERTY_IDENTIFIER.getLocalName()));</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">    if (commonMetadata.getOutputFields().containsKey(DublinCore.PROPERTY_SOURCE.getLocalName()))</span>
<span class="nc" id="L2340">      commonMetadata.removeField(commonMetadata.getOutputFields().get(DublinCore.PROPERTY_SOURCE.getLocalName()));</span>
<span class="nc bnc" id="L2341" title="All 2 branches missed.">    if (commonMetadata.getOutputFields().containsKey(&quot;startDate&quot;))</span>
<span class="nc" id="L2342">      commonMetadata.removeField(commonMetadata.getOutputFields().get(&quot;startDate&quot;));</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">    if (commonMetadata.getOutputFields().containsKey(&quot;startTime&quot;))</span>
<span class="nc" id="L2344">      commonMetadata.removeField(commonMetadata.getOutputFields().get(&quot;startTime&quot;));</span>
<span class="nc bnc" id="L2345" title="All 2 branches missed.">    if (commonMetadata.getOutputFields().containsKey(&quot;location&quot;))</span>
<span class="nc" id="L2346">      commonMetadata.removeField(commonMetadata.getOutputFields().get(&quot;location&quot;));</span>

    // Set publisher to user
<span class="nc bnc" id="L2349" title="All 2 branches missed.">    if (commonMetadata.getOutputFields().containsKey(DublinCore.PROPERTY_PUBLISHER.getLocalName())) {</span>
<span class="nc" id="L2350">      MetadataField publisher = commonMetadata.getOutputFields().get(DublinCore.PROPERTY_PUBLISHER.getLocalName());</span>
<span class="nc" id="L2351">      Map&lt;String, String&gt; users = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">      if (publisher.getCollection() != null) {</span>
<span class="nc" id="L2353">        users = publisher.getCollection();</span>
      }
<span class="nc" id="L2355">      String loggedInUser = getSecurityService().getUser().getName();</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">      if (!users.containsKey(loggedInUser)) {</span>
<span class="nc" id="L2357">        users.put(loggedInUser, loggedInUser);</span>
      }
<span class="nc" id="L2359">      publisher.setValue(loggedInUser);</span>
    }

<span class="nc" id="L2362">    metadataList.add(commonCatalogUiAdapter, commonMetadata);</span>

    // remove series with empty titles from the collection of the isPartOf field as these can't be converted to json
<span class="nc" id="L2365">    removeSeriesWithNullTitlesFromFieldCollection(metadataList);</span>

<span class="nc" id="L2367">    return okJson(MetadataJson.listToJson(metadataList, true));</span>
  }

  @GET
  @Path(&quot;new/processing&quot;)
  @RestQuery(name = &quot;getNewProcessing&quot;, description = &quot;Returns all the data related to the processing tab in the new event modal as JSON&quot;, returnDescription = &quot;All the data related to the event processing tab as JSON&quot;, restParameters = {
          @RestParameter(name = &quot;tags&quot;, isRequired = false, description = &quot;A comma separated list of tags to filter the workflow definitions&quot;, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(responseCode = SC_OK, description = &quot;Returns all the data related to the event processing tab as JSON&quot;) })
  public Response getNewProcessing(@QueryParam(&quot;tags&quot;) String tagsString) {
<span class="fc" id="L2376">    List&lt;String&gt; tags = RestUtil.splitCommaSeparatedParam(Option.option(tagsString)).value();</span>

<span class="fc" id="L2378">    List&lt;JValue&gt; workflows = new ArrayList&lt;&gt;();</span>
    try {
<span class="fc" id="L2380">      List&lt;WorkflowDefinition&gt; workflowsDefinitions = getWorkflowService().listAvailableWorkflowDefinitions();</span>
<span class="fc bfc" id="L2381" title="All 2 branches covered.">      for (WorkflowDefinition wflDef : workflowsDefinitions) {</span>
<span class="fc bfc" id="L2382" title="All 2 branches covered.">        if (wflDef.containsTag(tags)) {</span>

<span class="fc" id="L2384">          workflows.add(obj(f(&quot;id&quot;, v(wflDef.getId())), f(&quot;tags&quot;, arr(wflDef.getTags())),</span>
<span class="fc" id="L2385">                  f(&quot;title&quot;, v(nul(wflDef.getTitle()).getOr(&quot;&quot;))),</span>
<span class="fc" id="L2386">                  f(&quot;description&quot;, v(nul(wflDef.getDescription()).getOr(&quot;&quot;))),</span>
<span class="fc" id="L2387">                  f(&quot;displayOrder&quot;, v(wflDef.getDisplayOrder())),</span>
<span class="fc" id="L2388">                  f(&quot;configuration_panel&quot;, v(nul(wflDef.getConfigurationPanel()).getOr(&quot;&quot;))),</span>
<span class="fc" id="L2389">                  f(&quot;configuration_panel_json&quot;, v(nul(wflDef.getConfigurationPanelJson()).getOr(&quot;&quot;)))));</span>
        }
<span class="fc" id="L2391">      }</span>
<span class="nc" id="L2392">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L2393">      logger.error(&quot;Unable to get available workflow definitions&quot;, e);</span>
<span class="nc" id="L2394">      return RestUtil.R.serverError();</span>
<span class="fc" id="L2395">    }</span>

<span class="fc" id="L2397">    JValue data = obj(f(&quot;workflows&quot;,arr(workflows)), f(&quot;default_workflow_id&quot;,v(defaultWorkflowDefinionId,Jsons.NULL)));</span>

<span class="fc" id="L2399">    return okJson(data);</span>
  }

  @POST
  @Path(&quot;new/conflicts&quot;)
  @RestQuery(name = &quot;checkNewConflicts&quot;, description = &quot;Checks if the current scheduler parameters are in a conflict with another event&quot;, returnDescription = &quot;Returns NO CONTENT if no event are in conflict within specified period or list of conflicting recordings in JSON&quot;, restParameters = {
          @RestParameter(name = &quot;metadata&quot;, isRequired = true, description = &quot;The metadata as JSON&quot;, type = RestParameter.Type.TEXT) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_NO_CONTENT, description = &quot;No conflicting events found&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_CONFLICT, description = &quot;There is a conflict&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_BAD_REQUEST, description = &quot;Missing or invalid parameters&quot;) })
  public Response getNewConflicts(@FormParam(&quot;metadata&quot;) String metadata) throws NotFoundException {
<span class="fc bfc" id="L2410" title="All 2 branches covered.">    if (StringUtils.isBlank(metadata)) {</span>
<span class="fc" id="L2411">      logger.warn(&quot;Metadata is not specified&quot;);</span>
<span class="fc" id="L2412">      return Response.status(Status.BAD_REQUEST).build();</span>
    }

<span class="fc" id="L2415">    JSONParser parser = new JSONParser();</span>
    JSONObject metadataJson;
    try {
<span class="fc" id="L2418">      metadataJson = (JSONObject) parser.parse(metadata);</span>
<span class="fc" id="L2419">    } catch (Exception e) {</span>
<span class="fc" id="L2420">      logger.warn(&quot;Unable to parse metadata {}&quot;, metadata);</span>
<span class="fc" id="L2421">      return RestUtil.R.badRequest(&quot;Unable to parse metadata&quot;);</span>
<span class="fc" id="L2422">    }</span>

    String device;
    String startDate;
    String endDate;
    try {
<span class="fc" id="L2428">      device = (String) metadataJson.get(&quot;device&quot;);</span>
<span class="fc" id="L2429">      startDate = (String) metadataJson.get(&quot;start&quot;);</span>
<span class="fc" id="L2430">      endDate = (String) metadataJson.get(&quot;end&quot;);</span>
<span class="nc" id="L2431">    } catch (Exception e) {</span>
<span class="nc" id="L2432">      logger.warn(&quot;Unable to parse metadata {}&quot;, metadata);</span>
<span class="nc" id="L2433">      return RestUtil.R.badRequest(&quot;Unable to parse metadata&quot;);</span>
<span class="fc" id="L2434">    }</span>

<span class="pc bpc" id="L2436" title="3 of 6 branches missed.">    if (StringUtils.isBlank(device) || StringUtils.isBlank(startDate) || StringUtils.isBlank(endDate)) {</span>
<span class="nc" id="L2437">      logger.warn(&quot;Either device, start date or end date were not specified&quot;);</span>
<span class="nc" id="L2438">      return Response.status(Status.BAD_REQUEST).build();</span>
    }

    Date start;
    try {
<span class="fc" id="L2443">      start = new Date(DateTimeSupport.fromUTC(startDate));</span>
<span class="nc" id="L2444">    } catch (Exception e) {</span>
<span class="nc" id="L2445">      logger.warn(&quot;Unable to parse start date {}&quot;, startDate);</span>
<span class="nc" id="L2446">      return RestUtil.R.badRequest(&quot;Unable to parse start date&quot;);</span>
<span class="fc" id="L2447">    }</span>

    Date end;
    try {
<span class="fc" id="L2451">      end = new Date(DateTimeSupport.fromUTC(endDate));</span>
<span class="nc" id="L2452">    } catch (Exception e) {</span>
<span class="nc" id="L2453">      logger.warn(&quot;Unable to parse end date {}&quot;, endDate);</span>
<span class="nc" id="L2454">      return RestUtil.R.badRequest(&quot;Unable to parse end date&quot;);</span>
<span class="fc" id="L2455">    }</span>

<span class="fc" id="L2457">    String rruleString = (String) metadataJson.get(&quot;rrule&quot;);</span>

<span class="fc" id="L2459">    RRule rrule = null;</span>
<span class="fc" id="L2460">    TimeZone timeZone = TimeZone.getDefault();</span>
<span class="fc" id="L2461">    String durationString = null;</span>
<span class="pc bpc" id="L2462" title="1 of 2 branches missed.">    if (StringUtils.isNotEmpty(rruleString)) {</span>
      try {
<span class="nc" id="L2464">        rrule = new RRule(rruleString);</span>
<span class="nc" id="L2465">        rrule.validate();</span>
<span class="nc" id="L2466">      } catch (Exception e) {</span>
<span class="nc" id="L2467">        logger.warn(&quot;Unable to parse rrule {}: {}&quot;, rruleString, e.getMessage());</span>
<span class="nc" id="L2468">        return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L2469">      }</span>

<span class="nc" id="L2471">      durationString = (String) metadataJson.get(&quot;duration&quot;);</span>
<span class="nc bnc" id="L2472" title="All 2 branches missed.">      if (StringUtils.isBlank(durationString)) {</span>
<span class="nc" id="L2473">        logger.warn(&quot;If checking recurrence, must include duration.&quot;);</span>
<span class="nc" id="L2474">        return Response.status(Status.BAD_REQUEST).build();</span>
      }

<span class="nc" id="L2477">      Agent agent = getCaptureAgentStateService().getAgent(device);</span>
<span class="nc" id="L2478">      String timezone = agent.getConfiguration().getProperty(&quot;capture.device.timezone&quot;);</span>
<span class="nc bnc" id="L2479" title="All 2 branches missed.">      if (StringUtils.isBlank(timezone)) {</span>
<span class="nc" id="L2480">        timezone = TimeZone.getDefault().getID();</span>
<span class="nc" id="L2481">        logger.warn(&quot;No 'capture.device.timezone' set on agent {}. The default server timezone {} will be used.&quot;,</span>
                device, timezone);
      }
<span class="nc" id="L2484">      timeZone = TimeZone.getTimeZone(timezone);</span>
    }

<span class="fc" id="L2487">    String eventId = (String) metadataJson.get(&quot;id&quot;);</span>

    try {
<span class="fc" id="L2490">      List&lt;MediaPackage&gt; events = null;</span>
<span class="pc bpc" id="L2491" title="1 of 2 branches missed.">      if (StringUtils.isNotEmpty(rruleString)) {</span>
<span class="nc" id="L2492">        events = getSchedulerService().findConflictingEvents(device, rrule, start, end, Long.parseLong(durationString),</span>
                timeZone);
      } else {
<span class="fc" id="L2495">        events = getSchedulerService().findConflictingEvents(device, start, end);</span>
      }
<span class="pc bpc" id="L2497" title="1 of 2 branches missed.">      if (!events.isEmpty()) {</span>
<span class="fc" id="L2498">        final List&lt;JValue&gt; eventsJSON = convertToConflictObjects(eventId, events);</span>
<span class="pc bpc" id="L2499" title="1 of 2 branches missed.">        if (!eventsJSON.isEmpty())</span>
<span class="fc" id="L2500">          return conflictJson(arr(eventsJSON));</span>
      }
<span class="nc" id="L2502">      return Response.noContent().build();</span>
<span class="nc" id="L2503">    } catch (Exception e) {</span>
<span class="nc" id="L2504">      logger.error(&quot;Unable to find conflicting events for {}, {}, {}&quot;,</span>
              device, startDate, endDate, e);
<span class="nc" id="L2506">      return RestUtil.R.serverError();</span>
    }
  }

  private List&lt;JValue&gt; convertToConflictObjects(final String eventId, final List&lt;MediaPackage&gt; events) throws SearchIndexException {
<span class="fc" id="L2511">    final List&lt;JValue&gt; eventsJSON = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2512">    final Organization organization = getSecurityService().getOrganization();</span>
<span class="fc" id="L2513">    final User user = SecurityUtil.createSystemUser(systemUserName, organization);</span>

<span class="fc" id="L2515">    SecurityUtil.runAs(getSecurityService(), organization, user, () -&gt; {</span>
      try {
<span class="fc bfc" id="L2517" title="All 2 branches covered.">        for (final MediaPackage event : events) {</span>
<span class="fc" id="L2518">          final Opt&lt;Event&gt; eventOpt = getIndexService().getEvent(event.getIdentifier().toString(), getIndex());</span>
<span class="pc bpc" id="L2519" title="1 of 2 branches missed.">          if (eventOpt.isSome()) {</span>
<span class="fc" id="L2520">            final Event e = eventOpt.get();</span>
<span class="pc bpc" id="L2521" title="3 of 4 branches missed.">            if (StringUtils.isNotEmpty(eventId) &amp;&amp; eventId.equals(e.getIdentifier())) {</span>
<span class="nc" id="L2522">              continue;</span>
            }
<span class="fc" id="L2524">            eventsJSON.add(convertEventToConflictingObject(e.getTechnicalStartTime(), e.getTechnicalEndTime(), e.getTitle()));</span>
<span class="fc" id="L2525">          } else {</span>
<span class="nc" id="L2526">            logger.warn(&quot;Index out of sync! Conflicting event catalog {} not found on event index!&quot;,</span>
<span class="nc" id="L2527">              event.getIdentifier().toString());</span>
          }
<span class="fc" id="L2529">        }</span>
<span class="nc" id="L2530">      } catch (Exception e) {</span>
<span class="nc" id="L2531">         logger.error(&quot;Failed to get conflicting events&quot;, e);</span>
<span class="fc" id="L2532">      }</span>
<span class="fc" id="L2533">    });</span>

<span class="fc" id="L2535">    return eventsJSON;</span>
  }

  private JValue convertEventToConflictingObject(final String start, final String end, final String title) {
<span class="fc" id="L2539">    return obj(</span>
<span class="fc" id="L2540">      f(&quot;start&quot;, v(start)),</span>
<span class="fc" id="L2541">      f(&quot;end&quot;, v(end)),</span>
<span class="fc" id="L2542">      f(&quot;title&quot;, v(title))</span>
    );
  }

  @POST
  @Path(&quot;/new&quot;)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @RestQuery(name = &quot;createNewEvent&quot;, description = &quot;Creates a new event by the given metadata as JSON and the files in the body&quot;, returnDescription = &quot;The workflow identifier&quot;, restParameters = {
          @RestParameter(name = &quot;metadata&quot;, isRequired = true, description = &quot;The metadata as JSON&quot;, type = RestParameter.Type.TEXT) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_CREATED, description = &quot;Event sucessfully added&quot;),
                  @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;If the metadata is not set or couldn't be parsed&quot;) })
  public Response createNewEvent(@Context HttpServletRequest request) {
    try {
<span class="fc" id="L2555">      String result = getIndexService().createEvent(request);</span>
<span class="pc bpc" id="L2556" title="1 of 2 branches missed.">      if (StringUtils.isEmpty(result)) {</span>
<span class="fc" id="L2557">        return RestUtil.R.badRequest(&quot;The date range provided did not include any events&quot;);</span>
      }
<span class="nc" id="L2559">      return Response.status(Status.CREATED).entity(result).build();</span>
<span class="nc" id="L2560">    } catch (IllegalArgumentException | UnsupportedAssetException e) {</span>
<span class="nc" id="L2561">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L2562">    } catch (Exception e) {</span>
<span class="nc" id="L2563">      return RestUtil.R.serverError();</span>
    }
  }

  @GET
  @Path(&quot;events.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;getevents&quot;, description = &quot;Returns all the events as JSON&quot;, returnDescription = &quot;All the events as JSON&quot;, restParameters = {
          @RestParameter(name = &quot;filter&quot;, isRequired = false, description = &quot;The filter used for the query. They should be formated like that: 'filter1:value1,filter2:value2'&quot;, type = STRING),
          @RestParameter(name = &quot;sort&quot;, description = &quot;The order instructions used to sort the query result. Must be in the form '&lt;field name&gt;:(ASC|DESC)'&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;limit&quot;, description = &quot;The maximum number of items to return per page.&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;offset&quot;, description = &quot;The page number.&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;getComments&quot;, description = &quot;If comments should be fetched&quot;, isRequired = false, type = RestParameter.Type.BOOLEAN) }, responses = {
                  @RestResponse(description = &quot;Returns all events as JSON&quot;, responseCode = HttpServletResponse.SC_OK) })
  public Response getEvents(@QueryParam(&quot;id&quot;) String id, @QueryParam(&quot;commentReason&quot;) String reasonFilter,
          @QueryParam(&quot;commentResolution&quot;) String resolutionFilter, @QueryParam(&quot;filter&quot;) String filter,
          @QueryParam(&quot;sort&quot;) String sort, @QueryParam(&quot;offset&quot;) Integer offset, @QueryParam(&quot;limit&quot;) Integer limit,
          @QueryParam(&quot;getComments&quot;) Boolean getComments) {

<span class="fc" id="L2582">    Option&lt;Integer&gt; optLimit = Option.option(limit);</span>
<span class="fc" id="L2583">    Option&lt;Integer&gt; optOffset = Option.option(offset);</span>
<span class="fc" id="L2584">    Option&lt;String&gt; optSort = Option.option(trimToNull(sort));</span>
<span class="fc" id="L2585">    Option&lt;Boolean&gt; optGetComments = Option.option(getComments);</span>
<span class="fc" id="L2586">    ArrayList&lt;JValue&gt; eventsList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2587">    final Organization organization = getSecurityService().getOrganization();</span>
<span class="fc" id="L2588">    final User user = getSecurityService().getUser();</span>
<span class="pc bpc" id="L2589" title="2 of 4 branches missed.">    if (organization == null || user == null) {</span>
<span class="nc" id="L2590">      return Response.status(SC_SERVICE_UNAVAILABLE).build();</span>
    }
<span class="fc" id="L2592">    EventSearchQuery query = new EventSearchQuery(organization.getId(), user);</span>

    // If the limit is set to 0, this is not taken into account
<span class="pc bpc" id="L2595" title="3 of 4 branches missed.">    if (optLimit.isSome() &amp;&amp; limit == 0) {</span>
<span class="nc" id="L2596">      optLimit = Option.none();</span>
    }

<span class="fc" id="L2599">    Map&lt;String, String&gt; filters = RestUtils.parseFilter(filter);</span>
<span class="pc bpc" id="L2600" title="1 of 2 branches missed.">    for (String name : filters.keySet()) {</span>
<span class="nc bnc" id="L2601" title="All 2 branches missed.">      if (EventListQuery.FILTER_PRESENTERS_BIBLIOGRAPHIC_NAME.equals(name))</span>
<span class="nc" id="L2602">        query.withPresenter(filters.get(name));</span>
<span class="nc bnc" id="L2603" title="All 2 branches missed.">      if (EventListQuery.FILTER_PRESENTERS_TECHNICAL_NAME.equals(name))</span>
<span class="nc" id="L2604">        query.withTechnicalPresenters(filters.get(name));</span>
<span class="nc bnc" id="L2605" title="All 2 branches missed.">      if (EventListQuery.FILTER_CONTRIBUTORS_NAME.equals(name))</span>
<span class="nc" id="L2606">        query.withContributor(filters.get(name));</span>
<span class="nc bnc" id="L2607" title="All 2 branches missed.">      if (EventListQuery.FILTER_LOCATION_NAME.equals(name))</span>
<span class="nc" id="L2608">        query.withLocation(filters.get(name));</span>
<span class="nc bnc" id="L2609" title="All 2 branches missed.">      if (EventListQuery.FILTER_AGENT_NAME.equals(name))</span>
<span class="nc" id="L2610">        query.withAgentId(filters.get(name));</span>
<span class="nc bnc" id="L2611" title="All 2 branches missed.">      if (EventListQuery.FILTER_TEXT_NAME.equals(name))</span>
<span class="nc" id="L2612">        query.withText(filters.get(name));</span>
<span class="nc bnc" id="L2613" title="All 2 branches missed.">      if (EventListQuery.FILTER_SERIES_NAME.equals(name))</span>
<span class="nc" id="L2614">        query.withSeriesId(filters.get(name));</span>
<span class="nc bnc" id="L2615" title="All 2 branches missed.">      if (EventListQuery.FILTER_STATUS_NAME.equals(name))</span>
<span class="nc" id="L2616">        query.withEventStatus(filters.get(name));</span>
<span class="nc bnc" id="L2617" title="All 2 branches missed.">      if (EventListQuery.FILTER_PUBLISHER_NAME.equals(name))</span>
<span class="nc" id="L2618">        query.withPublisher(filters.get(name));</span>
<span class="nc bnc" id="L2619" title="All 2 branches missed.">      if (EventListQuery.FILTER_COMMENTS_NAME.equals(name)) {</span>
<span class="nc bnc" id="L2620" title="All 4 branches missed.">        switch (Comments.valueOf(filters.get(name))) {</span>
          case NONE:
<span class="nc" id="L2622">            query.withComments(false);</span>
<span class="nc" id="L2623">            break;</span>
          case OPEN:
<span class="nc" id="L2625">            query.withOpenComments(true);</span>
<span class="nc" id="L2626">            break;</span>
          case RESOLVED:
<span class="nc" id="L2628">            query.withComments(true);</span>
<span class="nc" id="L2629">            query.withOpenComments(false);</span>
<span class="nc" id="L2630">            break;</span>
          default:
<span class="nc" id="L2632">            logger.info(&quot;Unknown comment {}&quot;, filters.get(name));</span>
<span class="nc" id="L2633">            return Response.status(SC_BAD_REQUEST).build();</span>
        }
      }
<span class="nc bnc" id="L2636" title="All 2 branches missed.">      if (EventListQuery.FILTER_IS_PUBLISHED_NAME.equals(name)) {</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">        if (filters.containsKey(name)) {</span>
<span class="nc bnc" id="L2638" title="All 3 branches missed.">          switch (IsPublished.valueOf(filters.get(name))) {</span>
            case YES:
<span class="nc" id="L2640">              query.withIsPublished(true);</span>
<span class="nc" id="L2641">              break;</span>
            case NO:
<span class="nc" id="L2643">              query.withIsPublished(false);</span>
<span class="nc" id="L2644">              break;</span>
            default:
<span class="nc" id="L2646">              break;</span>
          }
        } else {
<span class="nc" id="L2649">          logger.info(&quot;Query for invalid published status: {}&quot;, filters.get(name));</span>
<span class="nc" id="L2650">          return Response.status(SC_BAD_REQUEST).build();</span>
        }
      }
<span class="nc bnc" id="L2653" title="All 2 branches missed.">      if (EventListQuery.FILTER_STARTDATE_NAME.equals(name)) {</span>
        try {
<span class="nc" id="L2655">          Tuple&lt;Date, Date&gt; fromAndToCreationRange = RestUtils.getFromAndToDateRange(filters.get(name));</span>
<span class="nc" id="L2656">          query.withStartFrom(fromAndToCreationRange.getA());</span>
<span class="nc" id="L2657">          query.withStartTo(fromAndToCreationRange.getB());</span>
<span class="nc" id="L2658">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L2659">          return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L2660">        }</span>
      }
<span class="nc" id="L2662">    }</span>

<span class="pc bpc" id="L2664" title="1 of 2 branches missed.">    if (optSort.isSome()) {</span>
<span class="nc" id="L2665">      ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(optSort.get());</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">      for (SortCriterion criterion : sortCriteria) {</span>
<span class="nc bnc" id="L2667" title="All 12 branches missed.">        switch (criterion.getFieldName()) {</span>
          case EventIndexSchema.UID:
<span class="nc" id="L2669">            query.sortByUID(criterion.getOrder());</span>
<span class="nc" id="L2670">            break;</span>
          case EventIndexSchema.TITLE:
<span class="nc" id="L2672">            query.sortByTitle(criterion.getOrder());</span>
<span class="nc" id="L2673">            break;</span>
          case EventIndexSchema.PRESENTER:
<span class="nc" id="L2675">            query.sortByPresenter(criterion.getOrder());</span>
<span class="nc" id="L2676">            break;</span>
          case EventIndexSchema.TECHNICAL_START:
          case &quot;technical_date&quot;:
<span class="nc" id="L2679">            query.sortByTechnicalStartDate(criterion.getOrder());</span>
<span class="nc" id="L2680">            break;</span>
          case EventIndexSchema.TECHNICAL_END:
<span class="nc" id="L2682">            query.sortByTechnicalEndDate(criterion.getOrder());</span>
<span class="nc" id="L2683">            break;</span>
          case EventIndexSchema.PUBLICATION:
<span class="nc" id="L2685">            query.sortByPublicationIgnoringInternal(criterion.getOrder());</span>
<span class="nc" id="L2686">            break;</span>
          case EventIndexSchema.START_DATE:
          case &quot;date&quot;:
<span class="nc" id="L2689">            query.sortByStartDate(criterion.getOrder());</span>
<span class="nc" id="L2690">            break;</span>
          case EventIndexSchema.END_DATE:
<span class="nc" id="L2692">            query.sortByEndDate(criterion.getOrder());</span>
<span class="nc" id="L2693">            break;</span>
          case EventIndexSchema.SERIES_NAME:
<span class="nc" id="L2695">            query.sortBySeriesName(criterion.getOrder());</span>
<span class="nc" id="L2696">            break;</span>
          case EventIndexSchema.LOCATION:
<span class="nc" id="L2698">            query.sortByLocation(criterion.getOrder());</span>
<span class="nc" id="L2699">            break;</span>
          case EventIndexSchema.EVENT_STATUS:
<span class="nc" id="L2701">            query.sortByEventStatus(criterion.getOrder());</span>
<span class="nc" id="L2702">            break;</span>
          default:
<span class="nc" id="L2704">            final String msg = String.format(&quot;Unknown sort criteria field %s&quot;, criterion.getFieldName());</span>
<span class="nc" id="L2705">            logger.debug(msg);</span>
<span class="nc" id="L2706">            return RestUtil.R.badRequest(msg);</span>
        }
<span class="nc" id="L2708">      }</span>
    }

    // We search for write actions
<span class="pc bpc" id="L2712" title="1 of 2 branches missed.">    if (getOnlyEventsWithWriteAccessEventsTab()) {</span>
<span class="nc" id="L2713">      query.withoutActions();</span>
<span class="nc" id="L2714">      query.withAction(Permissions.Action.WRITE);</span>
<span class="nc" id="L2715">      query.withAction(Permissions.Action.READ);</span>
    }

<span class="pc bpc" id="L2718" title="1 of 2 branches missed.">    if (optLimit.isSome())</span>
<span class="nc" id="L2719">      query.withLimit(optLimit.get());</span>
<span class="pc bpc" id="L2720" title="1 of 2 branches missed.">    if (optOffset.isSome())</span>
<span class="nc" id="L2721">      query.withOffset(offset);</span>
    // TODO: Add other filters to the query

<span class="fc" id="L2724">    SearchResult&lt;Event&gt; results = null;</span>
    try {
<span class="fc" id="L2726">      results = getIndex().getByQuery(query);</span>
<span class="nc" id="L2727">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L2728">      logger.error(&quot;The admin UI Search Index was not able to get the events list:&quot;, e);</span>
<span class="nc" id="L2729">      return RestUtil.R.serverError();</span>
<span class="fc" id="L2730">    }</span>

    // If the results list if empty, we return already a response.
<span class="pc bpc" id="L2733" title="1 of 2 branches missed.">    if (results.getPageSize() == 0) {</span>
<span class="nc" id="L2734">      logger.debug(&quot;No events match the given filters.&quot;);</span>
<span class="nc" id="L2735">      return okJsonList(eventsList, nul(offset).getOr(0), nul(limit).getOr(0), 0);</span>
    }

<span class="fc bfc" id="L2738" title="All 2 branches covered.">    for (SearchResultItem&lt;Event&gt; item : results.getItems()) {</span>
<span class="fc" id="L2739">      Event source = item.getSource();</span>
<span class="fc" id="L2740">      source.updatePreview(getAdminUIConfiguration().getPreviewSubtype());</span>
<span class="fc" id="L2741">      List&lt;EventComment&gt; comments = null;</span>
<span class="pc bpc" id="L2742" title="3 of 4 branches missed.">      if (optGetComments.isSome() &amp;&amp; optGetComments.get()) {</span>
        try {
<span class="nc" id="L2744">          comments = getEventCommentService().getComments(source.getIdentifier());</span>
<span class="nc" id="L2745">        } catch (EventCommentException e) {</span>
<span class="nc" id="L2746">          logger.error(&quot;Unable to get comments from event {}&quot;, source.getIdentifier(), e);</span>
<span class="nc" id="L2747">          throw new WebApplicationException(e);</span>
<span class="nc" id="L2748">        }</span>
      }
<span class="fc" id="L2750">      eventsList.add(eventToJSON(source, Optional.ofNullable(comments)));</span>
    }

<span class="fc" id="L2753">    return okJsonList(eventsList, nul(offset).getOr(0), nul(limit).getOr(0), results.getHitCount());</span>
  }

  // --

  private MediaPackage getMediaPackageByEventId(String eventId)
          throws SearchIndexException, NotFoundException, IndexServiceException {
<span class="fc" id="L2760">    Opt&lt;Event&gt; optEvent = getIndexService().getEvent(eventId, getIndex());</span>
<span class="fc bfc" id="L2761" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L2762">      throw new NotFoundException(format(&quot;Cannot find an event with id '%s'.&quot;, eventId));</span>
<span class="fc" id="L2763">    return getIndexService().getEventMediapackage(optEvent.get());</span>
  }

  private URI getCommentUrl(String eventId, long commentId) {
<span class="fc" id="L2767">    return UrlSupport.uri(serverUrl, eventId, &quot;comment&quot;, Long.toString(commentId));</span>
  }

  private JValue eventToJSON(Event event, Optional&lt;List&lt;EventComment&gt;&gt; comments) {
<span class="fc" id="L2771">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L2773">    fields.add(f(&quot;id&quot;, v(event.getIdentifier())));</span>
<span class="fc" id="L2774">    fields.add(f(&quot;title&quot;, v(event.getTitle(), BLANK)));</span>
<span class="fc" id="L2775">    fields.add(f(&quot;source&quot;, v(event.getSource(), BLANK)));</span>
<span class="fc" id="L2776">    fields.add(f(&quot;presenters&quot;, arr($(event.getPresenters()).map(Functions.stringToJValue))));</span>
<span class="pc bpc" id="L2777" title="1 of 2 branches missed.">    if (StringUtils.isNotBlank(event.getSeriesId())) {</span>
<span class="fc" id="L2778">      String seriesTitle = event.getSeriesName();</span>
<span class="fc" id="L2779">      String seriesID = event.getSeriesId();</span>

<span class="fc" id="L2781">      fields.add(f(&quot;series&quot;, obj(f(&quot;id&quot;, v(seriesID, BLANK)), f(&quot;title&quot;, v(seriesTitle, BLANK)))));</span>
    }
<span class="fc" id="L2783">    fields.add(f(&quot;location&quot;, v(event.getLocation(), BLANK)));</span>
<span class="fc" id="L2784">    fields.add(f(&quot;start_date&quot;, v(event.getRecordingStartDate(), BLANK)));</span>
<span class="fc" id="L2785">    fields.add(f(&quot;end_date&quot;, v(event.getRecordingEndDate(), BLANK)));</span>
<span class="fc" id="L2786">    fields.add(f(&quot;managedAcl&quot;, v(event.getManagedAcl(), BLANK)));</span>
<span class="fc" id="L2787">    fields.add(f(&quot;workflow_state&quot;, v(event.getWorkflowState(), BLANK)));</span>
<span class="fc" id="L2788">    fields.add(f(&quot;event_status&quot;, v(event.getEventStatus())));</span>
<span class="fc" id="L2789">    fields.add(f(&quot;displayable_status&quot;, v(event.getDisplayableStatus(getWorkflowService().getWorkflowStateMappings()))));</span>
<span class="fc" id="L2790">    fields.add(f(&quot;source&quot;, v(getIndexService().getEventSource(event).toString())));</span>
<span class="fc" id="L2791">    fields.add(f(&quot;has_comments&quot;, v(event.hasComments())));</span>
<span class="fc" id="L2792">    fields.add(f(&quot;has_open_comments&quot;, v(event.hasOpenComments())));</span>
<span class="fc" id="L2793">    fields.add(f(&quot;needs_cutting&quot;, v(event.needsCutting())));</span>
<span class="fc" id="L2794">    fields.add(f(&quot;has_preview&quot;, v(event.hasPreview())));</span>
<span class="fc" id="L2795">    fields.add(f(&quot;agent_id&quot;, v(event.getAgentId(), BLANK)));</span>
<span class="fc" id="L2796">    fields.add(f(&quot;technical_start&quot;, v(event.getTechnicalStartTime(), BLANK)));</span>
<span class="fc" id="L2797">    fields.add(f(&quot;technical_end&quot;, v(event.getTechnicalEndTime(), BLANK)));</span>
<span class="fc" id="L2798">    fields.add(f(&quot;technical_presenters&quot;, arr($(event.getTechnicalPresenters()).map(Functions.stringToJValue))));</span>
<span class="fc" id="L2799">    fields.add(f(&quot;publications&quot;, arr(eventPublicationsToJson(event))));</span>
<span class="pc bpc" id="L2800" title="1 of 2 branches missed.">    if (comments.isPresent()) {</span>
<span class="nc" id="L2801">      fields.add(f(&quot;comments&quot;, arr(eventCommentsToJson(comments.get()))));</span>
    }
<span class="fc" id="L2803">    return obj(fields);</span>
  }

  private JValue attachmentToJSON(Attachment attachment) {
<span class="fc" id="L2807">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2808">    fields.addAll(getEventMediaPackageElementFields(attachment));</span>
<span class="fc" id="L2809">    fields.addAll(getCommonElementFields(attachment));</span>
<span class="fc" id="L2810">    return obj(fields);</span>
  }

  private JValue catalogToJSON(Catalog catalog) {
<span class="fc" id="L2814">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2815">    fields.addAll(getEventMediaPackageElementFields(catalog));</span>
<span class="fc" id="L2816">    fields.addAll(getCommonElementFields(catalog));</span>
<span class="fc" id="L2817">    return obj(fields);</span>
  }

  private JValue trackToJSON(Track track) {
<span class="fc" id="L2821">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2822">    fields.addAll(getEventMediaPackageElementFields(track));</span>
<span class="fc" id="L2823">    fields.addAll(getCommonElementFields(track));</span>
<span class="fc" id="L2824">    fields.add(f(&quot;duration&quot;, v(track.getDuration(), BLANK)));</span>
<span class="fc" id="L2825">    fields.add(f(&quot;has_audio&quot;, v(track.hasAudio())));</span>
<span class="fc" id="L2826">    fields.add(f(&quot;has_video&quot;, v(track.hasVideo())));</span>
<span class="fc" id="L2827">    fields.add(f(&quot;has_subtitle&quot;, v(track.hasSubtitle())));</span>
<span class="fc" id="L2828">    fields.add(f(&quot;streams&quot;, obj(streamsToJSON(track.getStreams()))));</span>
<span class="fc" id="L2829">    return obj(fields);</span>
  }

  private List&lt;Field&gt; streamsToJSON(org.opencastproject.mediapackage.Stream[] streams) {
<span class="fc" id="L2833">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2834">    List&lt;JValue&gt; audioList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2835">    List&lt;JValue&gt; videoList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2836">    List&lt;JValue&gt; subtitleList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2837" title="All 2 branches covered.">    for (org.opencastproject.mediapackage.Stream stream : streams) {</span>
      // TODO There is a bug with the stream ids, see MH-10325
<span class="pc bpc" id="L2839" title="1 of 2 branches missed.">      if (stream instanceof AudioStreamImpl) {</span>
<span class="nc" id="L2840">        List&lt;Field&gt; audio = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2841">        AudioStream audioStream = (AudioStream) stream;</span>
<span class="nc" id="L2842">        audio.add(f(&quot;id&quot;, v(audioStream.getIdentifier(), BLANK)));</span>
<span class="nc" id="L2843">        audio.add(f(&quot;type&quot;, v(audioStream.getFormat(), BLANK)));</span>
<span class="nc" id="L2844">        audio.add(f(&quot;channels&quot;, v(audioStream.getChannels(), BLANK)));</span>
<span class="nc" id="L2845">        audio.add(f(&quot;bitrate&quot;, v(audioStream.getBitRate(), BLANK)));</span>
<span class="nc" id="L2846">        audio.add(f(&quot;bitdepth&quot;, v(audioStream.getBitDepth(), BLANK)));</span>
<span class="nc" id="L2847">        audio.add(f(&quot;samplingrate&quot;, v(audioStream.getSamplingRate(), BLANK)));</span>
<span class="nc" id="L2848">        audio.add(f(&quot;framecount&quot;, v(audioStream.getFrameCount(), BLANK)));</span>
<span class="nc" id="L2849">        audio.add(f(&quot;peakleveldb&quot;, v(audioStream.getPkLevDb(), BLANK)));</span>
<span class="nc" id="L2850">        audio.add(f(&quot;rmsleveldb&quot;, v(audioStream.getRmsLevDb(), BLANK)));</span>
<span class="nc" id="L2851">        audio.add(f(&quot;rmspeakdb&quot;, v(audioStream.getRmsPkDb(), BLANK)));</span>
<span class="nc" id="L2852">        audioList.add(obj(audio));</span>
<span class="pc bpc" id="L2853" title="1 of 2 branches missed.">      } else if (stream instanceof VideoStreamImpl) {</span>
<span class="fc" id="L2854">        List&lt;Field&gt; video = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2855">        VideoStream videoStream = (VideoStream) stream;</span>
<span class="fc" id="L2856">        video.add(f(&quot;id&quot;, v(videoStream.getIdentifier(), BLANK)));</span>
<span class="fc" id="L2857">        video.add(f(&quot;type&quot;, v(videoStream.getFormat(), BLANK)));</span>
<span class="fc" id="L2858">        video.add(f(&quot;bitrate&quot;, v(videoStream.getBitRate(), BLANK)));</span>
<span class="fc" id="L2859">        video.add(f(&quot;framerate&quot;, v(videoStream.getFrameRate(), BLANK)));</span>
<span class="fc" id="L2860">        video.add(f(&quot;resolution&quot;, v(videoStream.getFrameWidth() + &quot;x&quot; + videoStream.getFrameHeight(), BLANK)));</span>
<span class="fc" id="L2861">        video.add(f(&quot;framecount&quot;, v(videoStream.getFrameCount(), BLANK)));</span>
<span class="fc" id="L2862">        video.add(f(&quot;scantype&quot;, v(videoStream.getScanType(), BLANK)));</span>
<span class="fc" id="L2863">        video.add(f(&quot;scanorder&quot;, v(videoStream.getScanOrder(), BLANK)));</span>
<span class="fc" id="L2864">        videoList.add(obj(video));</span>
<span class="pc bnc" id="L2865" title="All 2 branches missed.">      } else if (stream instanceof SubtitleStreamImpl) {</span>
<span class="nc" id="L2866">        List&lt;Field&gt; subtitle = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2867">        SubtitleStreamImpl subtitleStream = (SubtitleStreamImpl) stream;</span>
<span class="nc" id="L2868">        subtitle.add(f(&quot;id&quot;, v(subtitleStream.getIdentifier(), BLANK)));</span>
<span class="nc" id="L2869">        subtitle.add(f(&quot;type&quot;, v(subtitleStream.getFormat(), BLANK)));</span>
<span class="nc" id="L2870">        subtitleList.add(obj(subtitle));</span>
<span class="nc" id="L2871">      } else {</span>
<span class="nc" id="L2872">        throw new IllegalArgumentException(&quot;Stream must be either audio, video or subtitle&quot;);</span>
      }
    }
<span class="fc" id="L2875">    fields.add(f(&quot;audio&quot;, arr(audioList)));</span>
<span class="fc" id="L2876">    fields.add(f(&quot;video&quot;, arr(videoList)));</span>
<span class="fc" id="L2877">    fields.add(f(&quot;subtitle&quot;, arr(subtitleList)));</span>
<span class="fc" id="L2878">    return fields;</span>
  }

  private JValue publicationToJSON(Publication publication) {
<span class="fc" id="L2882">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2883">    fields.add(f(&quot;id&quot;, v(publication.getIdentifier(), BLANK)));</span>
<span class="fc" id="L2884">    fields.add(f(&quot;channel&quot;, v(publication.getChannel(), BLANK)));</span>
<span class="fc" id="L2885">    fields.add(f(&quot;mimetype&quot;, v(publication.getMimeType(), BLANK)));</span>
<span class="fc" id="L2886">    fields.add(f(&quot;tags&quot;, arr($(publication.getTags()).map(toStringJValue))));</span>
<span class="fc" id="L2887">    fields.add(f(&quot;url&quot;, v(signUrl(publication.getURI()), BLANK)));</span>
<span class="fc" id="L2888">    fields.addAll(getCommonElementFields(publication));</span>
<span class="fc" id="L2889">    return obj(fields);</span>
  }

  private List&lt;Field&gt; getCommonElementFields(MediaPackageElement element) {
<span class="fc" id="L2893">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2894">    fields.add(f(&quot;size&quot;, v(element.getSize(), BLANK)));</span>
<span class="fc bfc" id="L2895" title="All 2 branches covered.">    fields.add(f(&quot;checksum&quot;, v(element.getChecksum() != null ? element.getChecksum().getValue() : null, BLANK)));</span>
<span class="pc bpc" id="L2896" title="1 of 2 branches missed.">    fields.add(f(&quot;reference&quot;, v(element.getReference() != null ? element.getReference().getIdentifier() : null, BLANK)));</span>
<span class="fc" id="L2897">    return fields;</span>
  }

  /**
   * Render an array of {@link Publication}s into a list of JSON values.
   *
   * @param publications
   *          The elements to pull the data from to create the list of {@link JValue}s
   * @return {@link List} of {@link JValue}s that represent the {@link Publication}
   */
  private List&lt;JValue&gt; getEventPublications(Publication[] publications) {
<span class="fc" id="L2908">    List&lt;JValue&gt; publicationJSON = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2909" title="All 2 branches covered.">    for (Publication publication : publications) {</span>
<span class="fc" id="L2910">      publicationJSON.add(obj(f(&quot;id&quot;, v(publication.getIdentifier(), BLANK)),</span>
<span class="fc" id="L2911">              f(&quot;channel&quot;, v(publication.getChannel(), BLANK)), f(&quot;mimetype&quot;, v(publication.getMimeType(), BLANK)),</span>
<span class="fc" id="L2912">              f(&quot;tags&quot;, arr($(publication.getTags()).map(toStringJValue))),</span>
<span class="fc" id="L2913">              f(&quot;url&quot;, v(signUrl(publication.getURI()), BLANK))));</span>
    }
<span class="fc" id="L2915">    return publicationJSON;</span>
  }

  private URI signUrl(URI url) {
<span class="pc bpc" id="L2919" title="1 of 2 branches missed.">    if (url == null) {</span>
<span class="nc" id="L2920">      return null;</span>
    }
<span class="pc bpc" id="L2922" title="1 of 2 branches missed.">    if (getUrlSigningService().accepts(url.toString())) {</span>
      try {
<span class="nc" id="L2924">        String clientIP = null;</span>
<span class="nc bnc" id="L2925" title="All 2 branches missed.">        if (signWithClientIP()) {</span>
<span class="nc" id="L2926">          clientIP = getSecurityService().getUserIP();</span>
        }
<span class="nc" id="L2928">        return URI.create(getUrlSigningService().sign(url.toString(), getUrlSigningExpireDuration(), null, clientIP));</span>
<span class="nc" id="L2929">      } catch (UrlSigningException e) {</span>
<span class="nc" id="L2930">        logger.warn(&quot;Unable to sign url '{}'&quot;, url, e);</span>
      }
    }
<span class="fc" id="L2933">    return url;</span>
  }

  /**
   * Render an array of {@link MediaPackageElement}s into a list of JSON values.
   *
   * @param elements
   *          The elements to pull the data from to create the list of {@link JValue}s
   * @return {@link List} of {@link JValue}s that represent the {@link MediaPackageElement}
   */
  private List&lt;JValue&gt; getEventMediaPackageElements(MediaPackageElement[] elements) {
<span class="fc" id="L2944">    List&lt;JValue&gt; elementJSON = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2945" title="All 2 branches covered.">    for (MediaPackageElement element : elements) {</span>
<span class="fc" id="L2946">      elementJSON.add(obj(getEventMediaPackageElementFields(element)));</span>
    }
<span class="fc" id="L2948">    return elementJSON;</span>
  }

  private List&lt;Field&gt; getEventMediaPackageElementFields(MediaPackageElement element) {
<span class="fc" id="L2952">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2953">    fields.add(f(&quot;id&quot;, v(element.getIdentifier(), BLANK)));</span>
<span class="fc" id="L2954">    fields.add(f(&quot;type&quot;, v(element.getFlavor(), BLANK)));</span>
<span class="fc" id="L2955">    fields.add(f(&quot;mimetype&quot;, v(element.getMimeType(), BLANK)));</span>
<span class="fc" id="L2956">    List&lt;JValue&gt; tags = Stream.$(element.getTags()).map(toStringJValue).toList();</span>
<span class="fc" id="L2957">    fields.add(f(&quot;tags&quot;, arr(tags)));</span>
<span class="fc" id="L2958">    fields.add(f(&quot;url&quot;, v(signUrl(element.getURI()), BLANK)));</span>
<span class="fc" id="L2959">    return fields;</span>
  }

<span class="fc" id="L2962">  private static final Fn&lt;String, JValue&gt; toStringJValue = new Fn&lt;String, JValue&gt;() {</span>
    @Override
    public JValue apply(String stringValue) {
<span class="fc" id="L2965">      return v(stringValue, BLANK);</span>
    }
  };

<span class="fc" id="L2969">  private final Fn&lt;Publication, JObject&gt; publicationToJson = new Fn&lt;Publication, JObject&gt;() {</span>
    @Override
    public JObject apply(Publication publication) {
<span class="fc" id="L2972">      final Opt&lt;String&gt; channel = Opt.nul(EventUtils.PUBLICATION_CHANNELS.get(publication.getChannel()));</span>
<span class="pc bpc" id="L2973" title="1 of 2 branches missed.">      String url = publication.getURI() == null ? &quot;&quot; : signUrl(publication.getURI()).toString();</span>
<span class="fc" id="L2974">      return obj(f(&quot;id&quot;, v(publication.getChannel())),</span>
<span class="fc" id="L2975">              f(&quot;name&quot;, v(channel.getOr(&quot;EVENTS.EVENTS.DETAILS.PUBLICATIONS.CUSTOM&quot;))), f(&quot;url&quot;, v(url, NULL)));</span>
    }
  };

<span class="fc" id="L2979">  protected static final Fn&lt;TechnicalMetadata, JObject&gt; technicalMetadataToJson = new Fn&lt;TechnicalMetadata, JObject&gt;() {</span>
    @Override
    public JObject apply(TechnicalMetadata technicalMetadata) {
<span class="pc bpc" id="L2982" title="1 of 2 branches missed.">      JValue agentConfig = technicalMetadata.getCaptureAgentConfiguration() == null ? v(&quot;&quot;)</span>
<span class="fc" id="L2983">              : JSONUtils.mapToJSON(technicalMetadata.getCaptureAgentConfiguration());</span>
<span class="pc bpc" id="L2984" title="1 of 2 branches missed.">      JValue start = technicalMetadata.getStartDate() == null ? v(&quot;&quot;)</span>
<span class="fc" id="L2985">              : v(DateTimeSupport.toUTC(technicalMetadata.getStartDate().getTime()));</span>
<span class="pc bpc" id="L2986" title="1 of 2 branches missed.">      JValue end = technicalMetadata.getEndDate() == null ? v(&quot;&quot;)</span>
<span class="fc" id="L2987">              : v(DateTimeSupport.toUTC(technicalMetadata.getEndDate().getTime()));</span>
<span class="fc" id="L2988">      return obj(f(&quot;agentId&quot;, v(technicalMetadata.getAgentId(), BLANK)), f(&quot;agentConfiguration&quot;, agentConfig),</span>
<span class="fc" id="L2989">              f(&quot;start&quot;, start), f(&quot;end&quot;, end), f(&quot;eventId&quot;, v(technicalMetadata.getEventId(), BLANK)),</span>
<span class="fc" id="L2990">              f(&quot;presenters&quot;, JSONUtils.setToJSON(technicalMetadata.getPresenters())),</span>
<span class="fc" id="L2991">              f(&quot;recording&quot;, recordingToJson.apply(technicalMetadata.getRecording())));</span>
    }
  };

<span class="fc" id="L2995">  protected static final Fn&lt;Optional&lt;Recording&gt;, JObject&gt; recordingToJson = new Fn&lt;Optional&lt;Recording&gt;, JObject&gt;() {</span>
    @Override
    public JObject apply(Optional&lt;Recording&gt; recording) {
<span class="fc bfc" id="L2998" title="All 2 branches covered.">      if (recording.isEmpty()) {</span>
<span class="fc" id="L2999">        return obj();</span>
      }
<span class="fc" id="L3001">      return obj(f(&quot;id&quot;, v(recording.get().getID(), BLANK)),</span>
<span class="fc" id="L3002">              f(&quot;lastCheckInTime&quot;, v(recording.get().getLastCheckinTime(), BLANK)),</span>
<span class="fc" id="L3003">              f(&quot;lastCheckInTimeUTC&quot;, v(toUTC(recording.get().getLastCheckinTime()), BLANK)),</span>
<span class="fc" id="L3004">              f(&quot;state&quot;, v(recording.get().getState(), BLANK)));</span>
    }
  };

  @PUT
  @Path(&quot;{eventId}/workflows/{workflowId}/action/{action}&quot;)
  @RestQuery(name = &quot;workflowAction&quot;, description = &quot;Performs the given action for the given workflow.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The id of the media package&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;workflowId&quot;, description = &quot;The id of the workflow&quot;, isRequired = true, type = RestParameter.Type.STRING),
          @RestParameter(name = &quot;action&quot;, description = &quot;The action to take: STOP, RETRY or NONE (abort processing)&quot;, isRequired = true, type = RestParameter.Type.STRING) }, responses = {
                  @RestResponse(responseCode = SC_OK, description = &quot;Workflow resumed.&quot;),
                  @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;Event or workflow instance not found.&quot;),
                  @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;Invalid action entered.&quot;),
                  @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;You do not have permission to perform the action. Maybe you need to authenticate.&quot;),
                  @RestResponse(responseCode = SC_INTERNAL_SERVER_ERROR, description = &quot;An exception occurred.&quot;) })
  public Response workflowAction(@PathParam(&quot;eventId&quot;) String id, @PathParam(&quot;workflowId&quot;) long wfId,
          @PathParam(&quot;action&quot;) String action) {
<span class="nc bnc" id="L3021" title="All 4 branches missed.">    if (StringUtils.isEmpty(id) || StringUtils.isEmpty(action)) {</span>
<span class="nc" id="L3022">      return badRequest();</span>
    }

    try {
<span class="nc" id="L3026">      final Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
<span class="nc bnc" id="L3027" title="All 2 branches missed.">      if (optEvent.isNone()) {</span>
<span class="nc" id="L3028">        return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
      }

<span class="nc" id="L3031">      final WorkflowInstance wfInstance = getWorkflowService().getWorkflowById(wfId);</span>
<span class="nc bnc" id="L3032" title="All 2 branches missed.">      if (!wfInstance.getMediaPackage().getIdentifier().toString().equals(id)) {</span>
<span class="nc" id="L3033">        return badRequest(String.format(&quot;Workflow %s is not associated to event %s&quot;, wfId, id));</span>
      }

<span class="nc bnc" id="L3036" title="All 2 branches missed.">      if (RetryStrategy.NONE.toString().equalsIgnoreCase(action)</span>
<span class="nc bnc" id="L3037" title="All 2 branches missed.">        || RetryStrategy.RETRY.toString().equalsIgnoreCase(action)) {</span>
<span class="nc" id="L3038">        getWorkflowService().resume(wfId, Collections.singletonMap(&quot;retryStrategy&quot;, action));</span>
<span class="nc" id="L3039">        return ok();</span>
      }

<span class="nc bnc" id="L3042" title="All 2 branches missed.">      if (WORKFLOW_ACTION_STOP.equalsIgnoreCase(action)) {</span>
<span class="nc" id="L3043">        getWorkflowService().stop(wfId);</span>
<span class="nc" id="L3044">        return ok();</span>
      }

<span class="nc" id="L3047">      return badRequest(&quot;Action not supported: &quot; + action);</span>
<span class="nc" id="L3048">    } catch (NotFoundException e) {</span>
<span class="nc" id="L3049">      return notFound(&quot;Workflow not found: '%d'.&quot;, wfId);</span>
<span class="nc" id="L3050">    } catch (IllegalStateException e) {</span>
<span class="nc" id="L3051">      return badRequest(String.format(&quot;Action %s not allowed for current workflow state. EventId: %s&quot;, action, id));</span>
<span class="nc" id="L3052">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L3053">      return forbidden();</span>
<span class="nc" id="L3054">    } catch (Exception e) {</span>
<span class="nc" id="L3055">      return serverError();</span>
    }
  }

  @DELETE
  @Path(&quot;{eventId}/workflows/{workflowId}&quot;)
  @RestQuery(name = &quot;deleteWorkflow&quot;, description = &quot;Deletes a workflow&quot;, returnDescription = &quot;The method doesn't return any content&quot;, pathParameters = {
    @RestParameter(name = &quot;eventId&quot;, isRequired = true, description = &quot;The event identifier&quot;, type = RestParameter.Type.STRING),
    @RestParameter(name = &quot;workflowId&quot;, isRequired = true, description = &quot;The workflow identifier&quot;, type = RestParameter.Type.INTEGER) }, responses = {
    @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;When trying to delete the latest workflow of the event.&quot;),
    @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;If the event or the workflow has not been found.&quot;),
    @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;The method does not return any content&quot;) })
  public Response deleteWorkflow(@PathParam(&quot;eventId&quot;) String id, @PathParam(&quot;workflowId&quot;) long wfId)
    throws SearchIndexException {
<span class="nc" id="L3069">    final Opt&lt;Event&gt; optEvent = getIndexService().getEvent(id, getIndex());</span>
    try {
<span class="nc bnc" id="L3071" title="All 2 branches missed.">      if (optEvent.isNone()) {</span>
<span class="nc" id="L3072">        return notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
      }

<span class="nc" id="L3075">      final WorkflowInstance wfInstance = getWorkflowService().getWorkflowById(wfId);</span>
<span class="nc bnc" id="L3076" title="All 2 branches missed.">      if (!wfInstance.getMediaPackage().getIdentifier().toString().equals(id)) {</span>
<span class="nc" id="L3077">        return badRequest(String.format(&quot;Workflow %s is not associated to event %s&quot;, wfId, id));</span>
      }

<span class="nc bnc" id="L3080" title="All 2 branches missed.">      if (wfId == optEvent.get().getWorkflowId()) {</span>
<span class="nc" id="L3081">        return badRequest(String.format(&quot;Cannot delete current workflow %s from event %s.&quot;</span>
<span class="nc" id="L3082">          + &quot; Only older workflows can be deleted.&quot;, wfId, id));</span>
      }

<span class="nc" id="L3085">      getWorkflowService().remove(wfId);</span>

<span class="nc" id="L3087">      return Response.noContent().build();</span>
<span class="nc" id="L3088">    } catch (WorkflowStateException e) {</span>
<span class="nc" id="L3089">      return badRequest(&quot;Deleting is not allowed for current workflow state. EventId: &quot; + id);</span>
<span class="nc" id="L3090">    } catch (NotFoundException e) {</span>
<span class="nc" id="L3091">      return notFound(&quot;Workflow not found: '%d'.&quot;, wfId);</span>
<span class="nc" id="L3092">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L3093">      return forbidden();</span>
<span class="nc" id="L3094">    } catch (Exception e) {</span>
<span class="nc" id="L3095">      return serverError();</span>
    }
  }

  private Opt&lt;Event&gt; checkAgentAccessForEvent(final String eventId) throws UnauthorizedException, SearchIndexException {
<span class="nc" id="L3100">    final Opt&lt;Event&gt; event = getIndexService().getEvent(eventId, getIndex());</span>
<span class="nc bnc" id="L3101" title="All 4 branches missed.">    if (event.isNone() || !event.get().getEventStatus().contains(&quot;SCHEDULE&quot;)) {</span>
<span class="nc" id="L3102">      return event;</span>
    }
<span class="nc" id="L3104">    SecurityUtil.checkAgentAccess(getSecurityService(), event.get().getAgentId());</span>
<span class="nc" id="L3105">    return event;</span>
  }

  private void checkAgentAccessForAgent(final String agentId) throws UnauthorizedException {
<span class="nc" id="L3109">    SecurityUtil.checkAgentAccess(getSecurityService(), agentId);</span>
<span class="nc" id="L3110">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>