<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CaptureAgentsEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-admin-ui</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.adminui.endpoint</a> &gt; <span class="el_source">CaptureAgentsEndpoint.java</span></div><h1>CaptureAgentsEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.adminui.endpoint;

import static com.entwinemedia.fn.data.json.Jsons.arr;
import static com.entwinemedia.fn.data.json.Jsons.f;
import static com.entwinemedia.fn.data.json.Jsons.obj;
import static com.entwinemedia.fn.data.json.Jsons.v;
import static org.apache.commons.lang3.StringUtils.trimToNull;
import static org.apache.http.HttpStatus.SC_OK;
import static org.opencastproject.index.service.util.RestUtils.okJson;
import static org.opencastproject.index.service.util.RestUtils.okJsonList;
import static org.opencastproject.util.DateTimeSupport.toUTC;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;

import org.opencastproject.adminui.util.TextFilter;
import org.opencastproject.capture.CaptureParameters;
import org.opencastproject.capture.admin.api.Agent;
import org.opencastproject.capture.admin.api.AgentState;
import org.opencastproject.capture.admin.api.CaptureAgentStateService;
import org.opencastproject.index.service.resources.list.query.AgentsListQuery;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.SmartIterator;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.util.requests.SortCriterion;
import org.opencastproject.util.requests.SortCriterion.Order;

import com.entwinemedia.fn.data.json.Field;
import com.entwinemedia.fn.data.json.JValue;
import com.entwinemedia.fn.data.json.Jsons;

import org.apache.commons.lang3.StringUtils;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Path(&quot;/admin-ng/capture-agents&quot;)
@RestService(name = &quot;captureAgents&quot;, title = &quot;Capture agents fa√ßade service&quot;,
  abstractText = &quot;Provides operations for the capture agents&quot;,
  notes = { &quot;This service offers the default capture agents CRUD Operations for the admin UI.&quot;,
            &quot;&lt;strong&gt;Important:&lt;/strong&gt; &quot;
              + &quot;&lt;em&gt;This service is for exclusive use by the module admin-ui. Its API might change &quot;
              + &quot;anytime without prior notice. Any dependencies other than the admin UI will be strictly ignored. &quot;
              + &quot;DO NOT use this for integration of third-party applications.&lt;em&gt;&quot;})
@Component(
  immediate = true,
  service = CaptureAgentsEndpoint.class,
  property = {
    &quot;service.description=Admin UI - Capture agents facade Endpoint&quot;,
    &quot;opencast.service.type=org.opencastproject.adminui.endpoint.UsersEndpoint&quot;,
    &quot;opencast.service.path=/admin-ng/capture-agents&quot;
  }
)
@JaxrsResource
<span class="fc" id="L103">public class CaptureAgentsEndpoint {</span>

  private static final String TRANSLATION_KEY_PREFIX = &quot;CAPTURE_AGENT.DEVICE.&quot;;

  /** The logging facility */
<span class="fc" id="L108">  private static final Logger logger = LoggerFactory.getLogger(CaptureAgentsEndpoint.class);</span>

  /** The capture agent service */
  private CaptureAgentStateService service;

  private SecurityService securityService;

  /**
   * Sets the capture agent service
   *
   * @param service
   *          the capture agent service to set
   */
  @Reference
  public void setCaptureAgentService(CaptureAgentStateService service) {
<span class="fc" id="L123">    this.service = service;</span>
<span class="fc" id="L124">  }</span>

  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="nc" id="L128">    this.securityService = securityService;</span>
<span class="nc" id="L129">  }</span>

  @GET
  @Produces({ MediaType.APPLICATION_JSON })
  @Path(&quot;agents.json&quot;)
  @RestQuery(name = &quot;getAgents&quot;, description = &quot;Return all of the known capture agents on the system&quot;, restParameters = {
          @RestParameter(name = &quot;filter&quot;, isRequired = false, description = &quot;The filter used for the query. They should be formated like that: 'filter1:value1,filter2:value2'&quot;, type = STRING),
          @RestParameter(defaultValue = &quot;100&quot;, description = &quot;The maximum number of items to return per page.&quot;, isRequired = false, name = &quot;limit&quot;, type = RestParameter.Type.STRING),
          @RestParameter(defaultValue = &quot;0&quot;, description = &quot;The page number.&quot;, isRequired = false, name = &quot;offset&quot;, type = RestParameter.Type.STRING),
          @RestParameter(defaultValue = &quot;false&quot;, description = &quot;Define if the inputs should or not returned with the capture agent.&quot;, isRequired = false, name = &quot;inputs&quot;, type = RestParameter.Type.BOOLEAN),
          @RestParameter(name = &quot;sort&quot;, isRequired = false, description = &quot;The sort order. May include any of the following: STATUS, NAME OR LAST_UPDATED.  Add '_DESC' to reverse the sort order (e.g. STATUS_DESC).&quot;, type = STRING) }, responses = { @RestResponse(description = &quot;An XML representation of the agent capabilities&quot;, responseCode = HttpServletResponse.SC_OK) }, returnDescription = &quot;&quot;)
  public Response getAgents(@QueryParam(&quot;limit&quot;) int limit, @QueryParam(&quot;offset&quot;) int offset,
          @QueryParam(&quot;inputs&quot;) boolean inputs, @QueryParam(&quot;filter&quot;) String filter, @QueryParam(&quot;sort&quot;) String sort) {
<span class="fc" id="L142">    Option&lt;String&gt; filterName = Option.none();</span>
<span class="fc" id="L143">    Option&lt;String&gt; filterStatus = Option.none();</span>
<span class="fc" id="L144">    Option&lt;Long&gt; filterLastUpdated = Option.none();</span>
<span class="fc" id="L145">    Option&lt;String&gt; filterText = Option.none();</span>
<span class="fc" id="L146">    Option&lt;String&gt; optSort = Option.option(trimToNull(sort));</span>

<span class="fc" id="L148">    Map&lt;String, String&gt; filters = RestUtils.parseFilter(filter);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">    for (String name : filters.keySet()) {</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">      if (AgentsListQuery.FILTER_NAME_NAME.equals(name))</span>
<span class="nc" id="L151">        filterName = Option.some(filters.get(name));</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">      if (AgentsListQuery.FILTER_STATUS_NAME.equals(name))</span>
<span class="nc" id="L153">        filterStatus = Option.some(filters.get(name));</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">      if (AgentsListQuery.FILTER_LAST_UPDATED.equals(name)) {</span>
        try {
<span class="nc" id="L156">          filterLastUpdated = Option.some(Long.parseLong(filters.get(name)));</span>
<span class="nc" id="L157">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L158">          logger.info(&quot;Unable to parse long {}&quot;, filters.get(name));</span>
<span class="nc" id="L159">          return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L160">        }</span>
      }
<span class="nc bnc" id="L162" title="All 4 branches missed.">      if (AgentsListQuery.FILTER_TEXT_NAME.equals(name) &amp;&amp; StringUtils.isNotBlank(filters.get(name)))</span>
<span class="nc" id="L163">        filterText = Option.some(filters.get(name));</span>
<span class="nc" id="L164">    }</span>

    // Filter agents by filter criteria
<span class="fc" id="L167">    List&lt;Agent&gt; filteredAgents = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">    for (Entry&lt;String, Agent&gt; entry : service.getKnownAgents().entrySet()) {</span>
<span class="fc" id="L169">      Agent agent = entry.getValue();</span>

      // Filter list
<span class="pc bpc" id="L172" title="3 of 4 branches missed.">      if ((filterName.isSome() &amp;&amp; !filterName.get().equals(agent.getName()))</span>
<span class="pc bpc" id="L173" title="3 of 4 branches missed.">              || (filterStatus.isSome() &amp;&amp; !filterStatus.get().equals(agent.getState()))</span>
<span class="pc bpc" id="L174" title="3 of 4 branches missed.">              || (filterLastUpdated.isSome() &amp;&amp; filterLastUpdated.get() != agent.getLastHeardFrom())</span>
<span class="pc bpc" id="L175" title="3 of 4 branches missed.">              || (filterText.isSome() &amp;&amp; !TextFilter.match(filterText.get(), agent.getName(), agent.getState())))</span>
<span class="nc" id="L176">        continue;</span>
<span class="fc" id="L177">      filteredAgents.add(agent);</span>
<span class="fc" id="L178">    }</span>
<span class="fc" id="L179">    int total = filteredAgents.size();</span>

    // Sort by status, name or last updated date
<span class="fc bfc" id="L182" title="All 2 branches covered.">    if (optSort.isSome()) {</span>
<span class="fc" id="L183">      final ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(optSort.get());</span>
<span class="fc" id="L184">      Collections.sort(filteredAgents, new Comparator&lt;Agent&gt;() {</span>
        @Override
        public int compare(Agent agent1, Agent agent2) {
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">          for (SortCriterion criterion : sortCriteria) {</span>
<span class="fc" id="L188">            Order order = criterion.getOrder();</span>
<span class="pc bpc" id="L189" title="3 of 4 branches missed.">            switch (criterion.getFieldName()) {</span>
              case &quot;status&quot;:
<span class="nc bnc" id="L191" title="All 2 branches missed.">                if (order.equals(Order.Descending))</span>
<span class="nc" id="L192">                  return agent2.getState().compareTo(agent1.getState());</span>
<span class="nc" id="L193">                return agent1.getState().compareTo(agent2.getState());</span>
              case &quot;name&quot;:
<span class="nc bnc" id="L195" title="All 2 branches missed.">                if (order.equals(Order.Descending))</span>
<span class="nc" id="L196">                  return agent2.getName().compareTo(agent1.getName());</span>
<span class="nc" id="L197">                return agent1.getName().compareTo(agent2.getName());</span>
              case &quot;updated&quot;:
<span class="fc bfc" id="L199" title="All 2 branches covered.">                if (order.equals(Order.Descending))</span>
<span class="fc" id="L200">                  return agent2.getLastHeardFrom().compareTo(agent1.getLastHeardFrom());</span>
<span class="fc" id="L201">                return agent1.getLastHeardFrom().compareTo(agent2.getLastHeardFrom());</span>
              default:
<span class="nc" id="L203">                logger.info(&quot;Unknown sort type: {}&quot;, criterion.getFieldName());</span>
<span class="nc" id="L204">                return 0;</span>
            }
          }
<span class="nc" id="L207">          return 0;</span>
        }
      });
    }

    // Apply Limit and offset
<span class="fc" id="L213">    filteredAgents = new SmartIterator&lt;Agent&gt;(limit, offset).applyLimitAndOffset(filteredAgents);</span>

    // Run through and build a map of updates (rather than states)
<span class="fc" id="L216">    List&lt;JValue&gt; agentsJSON = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">    for (Agent agent : filteredAgents) {</span>
<span class="fc" id="L218">      agentsJSON.add(generateJsonAgent(agent, inputs, false));</span>
<span class="fc" id="L219">    }</span>

<span class="fc" id="L221">    return okJsonList(agentsJSON, offset, limit, total);</span>
  }

  @DELETE
  @Path(&quot;{name}&quot;)
  @Produces({ MediaType.APPLICATION_JSON })
  @RestQuery(name = &quot;removeAgent&quot;, description = &quot;Remove record of a given capture agent&quot;, pathParameters = { @RestParameter(name = &quot;name&quot;, description = &quot;The name of a given capture agent&quot;, isRequired = true, type = RestParameter.Type.STRING) }, restParameters = {}, responses = {
          @RestResponse(description = &quot;{agentName} removed&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;The agent {agentname} does not exist&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) }, returnDescription = &quot;&quot;)
  public Response removeAgent(@PathParam(&quot;name&quot;) String agentName) throws NotFoundException, UnauthorizedException {
<span class="nc bnc" id="L231" title="All 2 branches missed.">    if (service == null)</span>
<span class="nc" id="L232">      return Response.serverError().status(Response.Status.SERVICE_UNAVAILABLE).build();</span>

<span class="nc" id="L234">    SecurityUtil.checkAgentAccess(securityService, agentName);</span>

<span class="nc" id="L236">    service.removeAgent(agentName);</span>

<span class="nc" id="L238">    logger.debug(&quot;The agent {} was successfully removed&quot;, agentName);</span>
<span class="nc" id="L239">    return Response.status(SC_OK).build();</span>
  }

  @GET
  @Path(&quot;{name}&quot;)
  @Produces({ MediaType.APPLICATION_JSON })
  @RestQuery(
    name = &quot;getAgent&quot;,
    description = &quot;Return the capture agent including its configuration and capabilities&quot;,
    pathParameters = {
      @RestParameter(description = &quot;Name of the capture agent&quot;, isRequired = true, name = &quot;name&quot;, type = RestParameter.Type.STRING),
    }, restParameters = {}, responses = {
      @RestResponse(description = &quot;A JSON representation of the capture agent&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;The agent {name} does not exist in the system&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND)
    }, returnDescription = &quot;&quot;)
  public Response getAgent(@PathParam(&quot;name&quot;) String agentName)
          throws NotFoundException {
<span class="nc bnc" id="L256" title="All 2 branches missed.">    if (service != null) {</span>
<span class="nc" id="L257">      Agent agent = service.getAgent(agentName);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">      if (agent != null) {</span>
<span class="nc" id="L259">        return okJson(generateJsonAgent(agent, true, true));</span>
      } else {
<span class="nc" id="L261">        return Response.status(Status.NOT_FOUND).build();</span>
      }
    } else {
<span class="nc" id="L264">      return Response.serverError().status(Response.Status.SERVICE_UNAVAILABLE).build();</span>
    }
  }

  /**
   * Generate a JSON Object for the given capture agent
   *
   * @param agent
   *          The target capture agent
   * @param withInputs
   *          Whether the agent has inputs
   * @param details
   *          Whether the configuration and capabilities should be serialized
   * @return A {@link JValue} representing the capture agent
   */
  private JValue generateJsonAgent(Agent agent, boolean withInputs, boolean details) {
<span class="fc" id="L280">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L281">    fields.add(f(&quot;Status&quot;, v(AgentState.TRANSLATION_PREFIX + agent.getState().toUpperCase(), Jsons.BLANK)));</span>
<span class="fc" id="L282">    fields.add(f(&quot;Name&quot;, v(agent.getName())));</span>
<span class="fc" id="L283">    fields.add(f(&quot;Update&quot;, v(toUTC(agent.getLastHeardFrom()), Jsons.BLANK)));</span>
<span class="fc" id="L284">    fields.add(f(&quot;URL&quot;, v(agent.getUrl(), Jsons.BLANK)));</span>

<span class="fc bfc" id="L286" title="All 2 branches covered.">    if (withInputs) {</span>
<span class="fc" id="L287">      String devices = (String) agent.getCapabilities().get(CaptureParameters.CAPTURE_DEVICE_NAMES);</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">      fields.add(f(&quot;inputs&quot;, (StringUtils.isEmpty(devices)) ? arr() : generateJsonDevice(devices.split(&quot;,&quot;))));</span>
    }

<span class="pc bpc" id="L291" title="1 of 2 branches missed.">    if (details) {</span>
<span class="nc" id="L292">      fields.add(f(&quot;configuration&quot;, generateJsonProperties(agent.getConfiguration())));</span>
<span class="nc" id="L293">      fields.add(f(&quot;capabilities&quot;, generateJsonProperties(agent.getCapabilities())));</span>
    }

<span class="fc" id="L296">    return obj(fields);</span>
  }

  /**
   * Generate JSON property list
   *
   * @param properties
   *          Java properties to be serialized
   * @return A JSON array containing the Java properties as key/value paris
   */
  private JValue generateJsonProperties(Properties properties) {
<span class="nc" id="L307">    List&lt;JValue&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">    if (properties != null) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">      for (String key : properties.stringPropertyNames()) {</span>
<span class="nc" id="L310">        fields.add(obj(f(&quot;key&quot;, v(key)), f(&quot;value&quot;, v(properties.getProperty(key)))));</span>
<span class="nc" id="L311">      }</span>
    }
<span class="nc" id="L313">    return arr(fields);</span>
  }

  /**
   * Generate a JSON devices list
   *
   * @param devices
   *          an array of devices String
   * @return A {@link JValue} representing the devices
   */
  private JValue generateJsonDevice(String[] devices) {
<span class="fc" id="L324">    List&lt;JValue&gt; jsonDevices = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">    for (String device : devices) {</span>
<span class="fc" id="L326">      jsonDevices.add(obj(f(&quot;id&quot;, v(device)), f(&quot;value&quot;, v(TRANSLATION_KEY_PREFIX + device.toUpperCase()))));</span>
    }
<span class="fc" id="L328">    return arr(jsonDevices);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>