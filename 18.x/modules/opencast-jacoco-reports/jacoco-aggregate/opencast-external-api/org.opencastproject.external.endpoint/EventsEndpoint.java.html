<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EventsEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-external-api</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.external.endpoint</a> &gt; <span class="el_source">EventsEndpoint.java</span></div><h1>EventsEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.external.endpoint;

import static com.entwinemedia.fn.Stream.$;
import static com.entwinemedia.fn.data.json.Jsons.BLANK;
import static com.entwinemedia.fn.data.json.Jsons.NULL;
import static com.entwinemedia.fn.data.json.Jsons.arr;
import static com.entwinemedia.fn.data.json.Jsons.f;
import static com.entwinemedia.fn.data.json.Jsons.obj;
import static com.entwinemedia.fn.data.json.Jsons.v;
import static org.apache.commons.lang3.StringUtils.trimToNull;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_11_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_1_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_4_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_7_0;
import static org.opencastproject.external.util.SchedulingUtils.SchedulingInfo;
import static org.opencastproject.external.util.SchedulingUtils.convertConflictingEvents;
import static org.opencastproject.external.util.SchedulingUtils.getConflictingEvents;
import static org.opencastproject.util.RestUtil.getEndpointUrl;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;

import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.AssetManagerException;
import org.opencastproject.capture.CaptureParameters;
import org.opencastproject.capture.admin.api.CaptureAgentStateService;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.api.SearchResultItem;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.IndexObject;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.objects.event.EventIndexSchema;
import org.opencastproject.elasticsearch.index.objects.event.EventSearchQuery;
import org.opencastproject.external.common.ApiMediaType;
import org.opencastproject.external.common.ApiResponseBuilder;
import org.opencastproject.external.common.ApiVersion;
import org.opencastproject.external.util.AclUtils;
import org.opencastproject.external.util.ExternalMetadataUtils;
import org.opencastproject.index.service.api.IndexService;
import org.opencastproject.index.service.catalog.adapter.DublinCoreMetadataUtil;
import org.opencastproject.index.service.exception.IndexServiceException;
import org.opencastproject.index.service.impl.util.EventHttpServletRequest;
import org.opencastproject.index.service.impl.util.EventUtils;
import org.opencastproject.index.service.util.RequestUtils;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.ingest.api.IngestException;
import org.opencastproject.ingest.api.IngestService;
import org.opencastproject.list.impl.EmptyResourceListQuery;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.AudioStream;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Publication;
import org.opencastproject.mediapackage.Stream;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.TrackSupport;
import org.opencastproject.mediapackage.VideoStream;
import org.opencastproject.mediapackage.track.TrackImpl;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.EventCatalogUIAdapter;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.MetadataJson;
import org.opencastproject.metadata.dublincore.MetadataList;
import org.opencastproject.metadata.dublincore.MetadataList.Locked;
import org.opencastproject.rest.RestConstants;
import org.opencastproject.scheduler.api.SchedulerConflictException;
import org.opencastproject.scheduler.api.SchedulerException;
import org.opencastproject.scheduler.api.SchedulerService;
import org.opencastproject.scheduler.api.TechnicalMetadata;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.urlsigning.exception.UrlSigningException;
import org.opencastproject.security.urlsigning.service.UrlSigningService;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.util.DateTimeSupport;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RestUtil;
import org.opencastproject.util.RestUtil.R;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestParameter.Type;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.util.requests.SortCriterion;
import org.opencastproject.workflow.api.WorkflowDatabaseException;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowService;

import com.entwinemedia.fn.Fn;
import com.entwinemedia.fn.data.Opt;
import com.entwinemedia.fn.data.json.Field;
import com.entwinemedia.fn.data.json.JObject;
import com.entwinemedia.fn.data.json.JValue;
import com.entwinemedia.fn.data.json.Jsons;
import com.entwinemedia.fn.data.json.Jsons.Functions;

import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.lang3.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.osgi.service.cm.ConfigurationException;
import org.osgi.service.cm.ManagedService;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.URI;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@Path(&quot;/api/events&quot;)
@Produces({ ApiMediaType.JSON, ApiMediaType.VERSION_1_0_0, ApiMediaType.VERSION_1_1_0, ApiMediaType.VERSION_1_2_0,
            ApiMediaType.VERSION_1_3_0, ApiMediaType.VERSION_1_4_0, ApiMediaType.VERSION_1_5_0,
            ApiMediaType.VERSION_1_6_0, ApiMediaType.VERSION_1_7_0, ApiMediaType.VERSION_1_8_0,
            ApiMediaType.VERSION_1_9_0, ApiMediaType.VERSION_1_10_0, ApiMediaType.VERSION_1_11_0 })
@RestService(name = &quot;externalapievents&quot;, title = &quot;External API Events Service&quot;, notes = {},
             abstractText = &quot;Provides resources and operations related to the events&quot;)
@Tag(name = &quot;External API&quot;)
@Tag(name = &quot;External API - Events&quot;,
    description = &quot;The events endpoint provides resources and operations related to the events&quot;)
@Component(
    immediate = true,
    service = { EventsEndpoint.class,ManagedService.class },
    property = {
        &quot;service.description=External API - Events Endpoint&quot;,
        &quot;opencast.service.type=org.opencastproject.external.events&quot;,
        &quot;opencast.service.path=/api/events&quot;
    }
)
@JaxrsResource
<span class="fc" id="L217">public class EventsEndpoint implements ManagedService {</span>

  protected static final String URL_SIGNING_EXPIRES_DURATION_SECONDS_KEY = &quot;url.signing.expires.seconds&quot;;

  /** The default time before a piece of signed content expires. 2 Hours. */
<span class="fc" id="L222">  protected static final Long DEFAULT_URL_SIGNING_EXPIRE_DURATION = 2 * 60 * 60L;</span>

  /** Subtype of previews required by the video editor */
  private static final String PREVIEW_SUBTYPE = &quot;preview.subtype&quot;;

  /** Subtype of previews required by the video editor */
  private static final String DEFAULT_PREVIEW_SUBTYPE = &quot;preview&quot;;

  /** ID of the workflow used to retract published events */
  private static final String RETRACT_WORKFLOW = &quot;retract.workflow.id&quot;;

  /** Default ID of the workflow used to retract published events */
  private static final String DEFAULT_RETRACT_WORKFLOW = &quot;delete&quot;;

  /** The logging facility */
<span class="fc" id="L237">  private static final Logger logger = LoggerFactory.getLogger(EventsEndpoint.class);</span>

  /** Base URL of this endpoint */
  protected String endpointBaseUrl;

<span class="fc" id="L242">  private static long expireSeconds = DEFAULT_URL_SIGNING_EXPIRE_DURATION;</span>

<span class="fc" id="L244">  private String previewSubtype = DEFAULT_PREVIEW_SUBTYPE;</span>

<span class="fc" id="L246">  private Map&lt;String, MetadataField&gt; configuredMetadataFields = new TreeMap&lt;&gt;();</span>

<span class="fc" id="L248">  private String retractWorkflowId = DEFAULT_RETRACT_WORKFLOW;</span>

  /** The resolutions */
<span class="nc" id="L251">  private enum CommentResolution {</span>
<span class="nc" id="L252">    ALL, UNRESOLVED, RESOLVED;</span>
  };

  /* OSGi service references */
  private AssetManager assetManager;
  private ElasticsearchIndex elasticsearchIndex;
  private IndexService indexService;
  private IngestService ingestService;
  private SecurityService securityService;
<span class="fc" id="L261">  private final List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L262">  private final Map&lt;String, List&lt;EventCatalogUIAdapter&gt;&gt; orgCatalogUIAdaptersMap = new ConcurrentHashMap&lt;&gt;();</span>
  private UrlSigningService urlSigningService;
  private SchedulerService schedulerService;
  private CaptureAgentStateService agentStateService;
  private WorkflowService workflowService;

  /** OSGi DI */
  @Reference
  public void setAssetManager(AssetManager assetManager) {
<span class="fc" id="L271">    this.assetManager = assetManager;</span>
<span class="fc" id="L272">  }</span>

  /** OSGi DI */
  @Reference
  void setElasticsearchIndex(ElasticsearchIndex elasticsearchIndex) {
<span class="fc" id="L277">    this.elasticsearchIndex = elasticsearchIndex;</span>
<span class="fc" id="L278">  }</span>

  /** OSGi DI */
  @Reference
  public void setIndexService(IndexService indexService) {
<span class="fc" id="L283">    this.indexService = indexService;</span>
<span class="fc" id="L284">  }</span>

  /** OSGi DI */
  @Reference
  public void setIngestService(IngestService ingestService) {
<span class="fc" id="L289">    this.ingestService = ingestService;</span>
<span class="fc" id="L290">  }</span>

  /** OSGi DI */
  @Reference
  void setSecurityService(SecurityService securityService) {
<span class="fc" id="L295">    this.securityService = securityService;</span>
<span class="fc" id="L296">  }</span>

  /** OSGi DI */
  @Reference
  public void setUrlSigningService(UrlSigningService urlSigningService) {
<span class="nc" id="L301">    this.urlSigningService = urlSigningService;</span>
<span class="nc" id="L302">  }</span>

  public SecurityService getSecurityService() {
<span class="fc" id="L305">    return securityService;</span>
  }

  public SchedulerService getSchedulerService() {
<span class="nc" id="L309">    return schedulerService;</span>
  }

  @Reference
  public void setSchedulerService(SchedulerService schedulerService) {
<span class="fc" id="L314">    this.schedulerService = schedulerService;</span>
<span class="fc" id="L315">  }</span>

  /** OSGi DI. */
  @Reference(
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeCatalogUIAdapter&quot;
  )
  public void addCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="fc" id="L324">    catalogUIAdapters.add(catalogUIAdapter);</span>
<span class="fc" id="L325">    invalidateOrgCatalogUIAdaptersMapFor(catalogUIAdapter);</span>
<span class="fc" id="L326">  }</span>

  /** OSGi DI. */
  public void removeCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L330">    catalogUIAdapters.remove(catalogUIAdapter);</span>
<span class="nc" id="L331">    invalidateOrgCatalogUIAdaptersMapFor(catalogUIAdapter);</span>
<span class="nc" id="L332">  }</span>

  /**
   * Invalidates caches for organizations that are handled by given catalog.
   *
   * @param catalogUIAdapter catalog used to identify affected organizations.
   */
  private void invalidateOrgCatalogUIAdaptersMapFor(EventCatalogUIAdapter catalogUIAdapter) {
    // clean cached org to catalog map
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">    for (String orgName : orgCatalogUIAdaptersMap.keySet()) {</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">      if (catalogUIAdapter.handlesOrganization(orgName)) {</span>
<span class="nc" id="L343">        orgCatalogUIAdaptersMap.remove(orgName);</span>
      }
<span class="nc" id="L345">    }</span>
<span class="fc" id="L346">  }</span>

  /** OSGi DI */
  public CaptureAgentStateService getAgentStateService() {
<span class="nc" id="L350">    return agentStateService;</span>
  }

  /** OSGi DI */
  @Reference
  public void setAgentStateService(CaptureAgentStateService agentStateService) {
<span class="nc" id="L356">    this.agentStateService = agentStateService;</span>
<span class="nc" id="L357">  }</span>

  /** OSGi DI */
  @Reference
  public void setWorkflowService(WorkflowService workflowService) {
<span class="fc" id="L362">    this.workflowService = workflowService;</span>
<span class="fc" id="L363">  }</span>


  private List&lt;EventCatalogUIAdapter&gt; getEventCatalogUIAdapters() {
<span class="fc" id="L367">    return getEventCatalogUIAdapters(getSecurityService().getOrganization().getId());</span>
  }

  public List&lt;EventCatalogUIAdapter&gt; getEventCatalogUIAdapters(String organization) {
<span class="fc" id="L371">    List&lt;EventCatalogUIAdapter&gt; cachedCatalogUIAdapters = orgCatalogUIAdaptersMap.computeIfAbsent(organization,</span>
<span class="fc" id="L372">        org -&gt; new ArrayList&lt;&gt;(catalogUIAdapters.stream()</span>
<span class="fc" id="L373">            .filter(a -&gt; a.handlesOrganization(org))</span>
<span class="fc" id="L374">            .collect(Collectors.toList())));</span>
    // create a shallow copy as callers may change it
<span class="fc" id="L376">    return new ArrayList&lt;&gt;(cachedCatalogUIAdapters);</span>
  }

  /** OSGi activation method */
  @Activate
  void activate(ComponentContext cc) {
<span class="nc" id="L382">    logger.info(&quot;Activating External API - Events Endpoint&quot;);</span>

<span class="nc" id="L384">    final Tuple&lt;String, String&gt; endpointUrl = getEndpointUrl(cc, OpencastConstants.EXTERNAL_API_URL_ORG_PROPERTY,</span>
            RestConstants.SERVICE_PATH_PROPERTY);
<span class="nc" id="L386">    endpointBaseUrl = UrlSupport.concat(endpointUrl.getA(), endpointUrl.getB());</span>
<span class="nc" id="L387">    logger.debug(&quot;Configured service endpoint is {}&quot;, endpointBaseUrl);</span>
<span class="nc" id="L388">  }</span>

  /** OSGi callback if properties file is present */
  @Override
  public void updated(Dictionary&lt;String, ?&gt; properties) throws ConfigurationException {
    // Ensure properties is not null
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">    if (properties == null) {</span>
<span class="nc" id="L395">      properties = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L396">      logger.debug(&quot;No configuration set&quot;);</span>
    }

    // Read URL Signing Expiration duration
    // Default to DEFAULT_URL_SIGNING_EXPIRE_DURATION.toString()));
<span class="fc" id="L401">    expireSeconds = Long.parseLong(Objects.toString(</span>
<span class="fc" id="L402">        properties.get(URL_SIGNING_EXPIRES_DURATION_SECONDS_KEY),</span>
<span class="fc" id="L403">        DEFAULT_URL_SIGNING_EXPIRE_DURATION.toString()));</span>
<span class="fc" id="L404">    logger.debug(&quot;URLs signatures are configured to expire in {}.&quot;, DateTimeSupport.humanReadableTime(expireSeconds));</span>

    // Read preview subtype configuration
    // Default to DEFAULT_PREVIEW_SUBTYPE
<span class="fc" id="L408">    previewSubtype = StringUtils.defaultString((String) properties.get(PREVIEW_SUBTYPE), DEFAULT_PREVIEW_SUBTYPE);</span>
<span class="fc" id="L409">    logger.debug(&quot;Preview subtype is '{}'&quot;, previewSubtype);</span>

<span class="fc" id="L411">    configuredMetadataFields = DublinCoreMetadataUtil.getDublinCoreProperties(properties);</span>

<span class="fc" id="L413">    retractWorkflowId = StringUtils.defaultString((String) properties.get(RETRACT_WORKFLOW), DEFAULT_RETRACT_WORKFLOW);</span>
<span class="fc" id="L414">    logger.debug(&quot;Retract Workflow is '{}'&quot;, retractWorkflowId);</span>
<span class="fc" id="L415">  }</span>

  public static &lt;T&gt; boolean isNullOrEmpty(List&lt;String&gt; list) {
<span class="nc bnc" id="L418" title="All 4 branches missed.">    return list == null || list.isEmpty();</span>
  }

  @GET
  @Path(&quot;{eventId}&quot;)
  @RestQuery(name = &quot;getevent&quot;, description = &quot;Returns a single event. By setting the optional sign parameter to true, the method will pre-sign distribution urls if signing is turned on in Opencast. Remember to consider the maximum validity of signed URLs when caching this response.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;sign&quot;, isRequired = false, description = &quot;Whether public distribution urls should be signed.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withacl&quot;, isRequired = false, description = &quot;Whether the acl metadata should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withmetadata&quot;, isRequired = false, description = &quot;Whether the metadata catalogs should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withscheduling&quot;, isRequired = false, description = &quot;Whether the scheduling information should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withpublications&quot;, isRequired = false, description = &quot;Whether the publication ids and urls should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;includeInternalPublication&quot;, isRequired = false, description = &quot;Whether internal publications should be included.&quot;, type = Type.BOOLEAN)}, responses = {
                          @RestResponse(description = &quot;The event is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  @Operation(summary = &quot;Get a single event&quot;, description = &quot;Returns a single event. By setting the optional sign parameter to true, the method will pre-sign distribution urls if signing is turned on in Opencast. Remember to consider the maximum validity of signed URLs when caching this response.&quot;)
  public Response getEvent(
      @HeaderParam(&quot;Accept&quot;) String acceptHeader,
      @Parameter(description = &quot;The event id&quot;, required = true)
      @PathParam(&quot;eventId&quot;) String id,
      @Parameter(description = &quot;Whether public distribution urls should be signed.&quot;)
      @QueryParam(&quot;sign&quot;) boolean sign,
      @Parameter(description = &quot;Whether the acl metadata should be included in the response.&quot;)
      @QueryParam(&quot;withacl&quot;) Boolean withAcl,
      @Parameter(description = &quot;Whether the metadata catalogs should be included in the response.&quot;)
      @QueryParam(&quot;withmetadata&quot;) Boolean withMetadata,
      @Parameter(description = &quot;Whether the scheduling information should be included in the response.&quot;)
      @QueryParam(&quot;withscheduling&quot;) Boolean withScheduling,
      @Parameter(description = &quot;Whether the publication ids and urls should be included in the response.&quot;)
      @QueryParam(&quot;withpublications&quot;) Boolean withPublications,
      @Parameter(description = &quot;Whether internal publications should be included.&quot;)
      @QueryParam(&quot;includeInternalPublication&quot;) Boolean includeInternalPublication)
        throws Exception {
<span class="nc" id="L451">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
      // withScheduling was added in version 1.1.0 and should be ignored for smaller versions
<span class="nc" id="L454">      withScheduling = false;</span>
    }
<span class="nc bnc" id="L456" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L457">      event.updatePreview(previewSubtype);</span>
<span class="nc" id="L458">      return ApiResponseBuilder.Json.ok(</span>
<span class="nc" id="L459">          requestedVersion, eventToJSON(event, withAcl, withMetadata, withScheduling, withPublications, includeInternalPublication, sign, requestedVersion));</span>
    }
<span class="nc" id="L461">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @GET
  @Path(&quot;{eventId}/media&quot;)
  @RestQuery(name = &quot;geteventmedia&quot;, description = &quot;Returns media tracks of specific single event.&quot;, returnDescription = &quot;&quot;, pathParameters = {
      @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
      @RestResponse(description = &quot;The event's media is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  @Operation(summary = &quot;Get media tracks of a single event&quot;, description = &quot;Returns media tracks of specific single event.&quot;)
  @Parameters({
      @Parameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, required = true, in = ParameterIn.PATH),
      @Parameter(name = &quot;Accept&quot;, description = &quot;The accept header&quot;, required = true, in = ParameterIn.HEADER)
  })
  @ApiResponses(value = {
      @ApiResponse(responseCode = &quot;200&quot;, description = &quot;The event's media is returned.&quot;),
      @ApiResponse(responseCode = &quot;404&quot;, description = &quot;The specified event does not exist.&quot;)
  })
  public Response getEventMedia(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
          throws Exception {
<span class="nc" id="L481">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc" id="L482">    ArrayList&lt;TrackImpl&gt; tracks = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L484" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L485">      final MediaPackage mp = indexService.getEventMediapackage(event);</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">      for (Track track : mp.getTracks()) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (track instanceof TrackImpl) {</span>
<span class="nc" id="L488">          tracks.add((TrackImpl) track);</span>
        }
      }

<span class="nc" id="L492">      List&lt;JValue&gt; tracksJson = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">      for (Track track : tracks) {</span>
<span class="nc" id="L494">        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">        if (track.getChecksum() != null)</span>
<span class="nc" id="L496">          fields.add(f(&quot;checksum&quot;, v(track.getChecksum().toString())));</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (track.getDescription() != null)</span>
<span class="nc" id="L498">          fields.add(f(&quot;description&quot;, v(track.getDescription())));</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (track.getDuration() != null)</span>
<span class="nc" id="L500">          fields.add(f(&quot;duration&quot;, v(track.getDuration())));</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (track.getElementDescription() != null)</span>
<span class="nc" id="L502">          fields.add(f(&quot;element-description&quot;, v(track.getElementDescription())));</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (track.getFlavor() != null)</span>
<span class="nc" id="L504">          fields.add(f(&quot;flavor&quot;, v(track.getFlavor().toString())));</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (track.getIdentifier() != null)</span>
<span class="nc" id="L506">          fields.add(f(&quot;identifier&quot;, v(track.getIdentifier())));</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (track.getMimeType() != null)</span>
<span class="nc" id="L508">          fields.add(f(&quot;mimetype&quot;, v(track.getMimeType().toString())));</span>
<span class="nc" id="L509">        fields.add(f(&quot;size&quot;, v(track.getSize())));</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (!requestedVersion.isSmallerThan(VERSION_1_7_0)) {</span>
<span class="nc" id="L511">          fields.add(f(&quot;has_video&quot;, v(track.hasVideo())));</span>
<span class="nc" id="L512">          fields.add(f(&quot;has_audio&quot;, v(track.hasAudio())));</span>
<span class="nc" id="L513">          fields.add(f(&quot;is_master_playlist&quot;, v(track.isMaster())));</span>
<span class="nc" id="L514">          fields.add(f(&quot;is_live&quot;, v(track.isLive())));</span>
        }
<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (track.getStreams() != null) {</span>
<span class="nc" id="L517">          List&lt;Field&gt; streams = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">          for (Stream stream : track.getStreams()) {</span>
<span class="nc" id="L519">            streams.add(f(stream.getIdentifier(), getJsonStream(stream)));</span>
          }
<span class="nc" id="L521">          fields.add(f(&quot;streams&quot;, obj(streams)));</span>
        }
<span class="nc bnc" id="L523" title="All 2 branches missed.">        if (track.getTags() != null) {</span>
<span class="nc" id="L524">          List&lt;JValue&gt; tags = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">          for (String tag : track.getTags()) {</span>
<span class="nc" id="L526">            tags.add(v(tag));</span>
          }
<span class="nc" id="L528">          fields.add(f(&quot;tags&quot;, arr(tags)));</span>
        }
<span class="nc bnc" id="L530" title="All 2 branches missed.">        if (track.getURI() != null)</span>
<span class="nc" id="L531">          fields.add(f(&quot;uri&quot;, v(track.getURI().toString())));</span>
<span class="nc" id="L532">        tracksJson.add(obj(fields));</span>
<span class="nc" id="L533">      }</span>
<span class="nc" id="L534">      return ApiResponseBuilder.Json.ok(acceptHeader, arr(tracksJson));</span>
    }
<span class="nc" id="L536">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @DELETE
  @Path(&quot;{eventId}&quot;)
  @RestQuery(name = &quot;deleteevent&quot;, description = &quot;Deletes an event.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(description = &quot;The event has been deleted.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
          @RestResponse(description = &quot;The retraction of publications has started.&quot;, responseCode = HttpServletResponse.SC_ACCEPTED),
          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteEvent(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
          throws SearchIndexException, UnauthorizedException {
<span class="nc" id="L548">    final Opt&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">    if (event.isNone()) {</span>
<span class="nc" id="L550">      return RestUtil.R.notFound(id);</span>
    }
    final IndexService.EventRemovalResult result;
    try {
<span class="nc" id="L554">      result = indexService.removeEvent(event.get(), retractWorkflowId);</span>
<span class="nc" id="L555">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L556">      logger.error(&quot;Workflow database is not reachable. This may be a temporary problem.&quot;);</span>
<span class="nc" id="L557">      return RestUtil.R.serverError();</span>
<span class="nc" id="L558">    } catch (NotFoundException e) {</span>
<span class="nc" id="L559">      logger.error(&quot;Configured retract workflow not found. Check your configuration.&quot;);</span>
<span class="nc" id="L560">      return RestUtil.R.serverError();</span>
<span class="nc" id="L561">    }</span>
<span class="nc bnc" id="L562" title="All 5 branches missed.">    switch (result) {</span>
      case SUCCESS:
<span class="nc" id="L564">        return Response.noContent().build();</span>
      case RETRACTING:
<span class="nc" id="L566">        return Response.accepted().build();</span>
      case GENERAL_FAILURE:
<span class="nc" id="L568">        return Response.serverError().build();</span>
      case NOT_FOUND:
<span class="nc" id="L570">        return RestUtil.R.notFound(id);</span>
      default:
<span class="nc" id="L572">        throw new RuntimeException(&quot;Unknown EventRemovalResult type: &quot; + result.name());</span>
    }
  }

  @POST
  @Path(&quot;{eventId}&quot;)
  @RestQuery(name = &quot;updateeventmetadata&quot;, description = &quot;Updates an event.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;acl&quot;, isRequired = false, description = &quot;A collection of roles with their possible action&quot;, type = Type.STRING),
                  @RestParameter(name = &quot;metadata&quot;, isRequired = false, description = &quot;Event metadata as Form param&quot;, type = Type.STRING),
                  @RestParameter(name = &quot;scheduling&quot;, isRequired = false, description = &quot;Scheduling information as Form param&quot;, type = Type.STRING),
                  @RestParameter(name = &quot;presenter&quot;, isRequired = false, description = &quot;Presenter movie track&quot;, type = Type.FILE),
                  @RestParameter(name = &quot;presentation&quot;, isRequired = false, description = &quot;Presentation movie track&quot;, type = Type.FILE),
                  @RestParameter(name = &quot;audio&quot;, isRequired = false, description = &quot;Audio track&quot;, type = Type.FILE),
                  @RestParameter(name = &quot;processing&quot;, isRequired = false, description = &quot;Processing instructions task configuration&quot;, type = Type.STRING), }, responses = {
                          @RestResponse(description = &quot;The event has been updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The event could not be updated due to a scheduling conflict.&quot;, responseCode = HttpServletResponse.SC_CONFLICT),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventMetadata(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @Context HttpServletRequest request,
          @PathParam(&quot;eventId&quot;) String eventId) {
<span class="fc" id="L592">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
    try {
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">      String startDatePattern = configuredMetadataFields.containsKey(&quot;startDate&quot;) ? configuredMetadataFields.get(&quot;startDate&quot;).getPattern() : null;</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">      String startTimePattern = configuredMetadataFields.containsKey(&quot;startTime&quot;) ? configuredMetadataFields.get(&quot;startTime&quot;).getPattern() : null;</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">      for (final Event event : indexService.getEvent(eventId, elasticsearchIndex)) {</span>
<span class="fc" id="L597">        EventHttpServletRequest eventHttpServletRequest = EventHttpServletRequest.updateFromHttpServletRequest(event,</span>
<span class="fc" id="L598">                request, getEventCatalogUIAdapters(), startDatePattern, startTimePattern);</span>

        // FIXME: All of these update operations should be a part of a transaction to avoid a partially updated event.
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">        if (eventHttpServletRequest.getMetadataList().isSome()) {</span>
<span class="fc" id="L602">          indexService.updateEventMetadata(eventId, eventHttpServletRequest.getMetadataList().get(), elasticsearchIndex);</span>
        }

<span class="pc bpc" id="L605" title="1 of 2 branches missed.">        if (eventHttpServletRequest.getAcl().isSome()) {</span>
<span class="nc" id="L606">          indexService.updateEventAcl(eventId, eventHttpServletRequest.getAcl().get(), elasticsearchIndex);</span>
        }

<span class="pc bpc" id="L609" title="1 of 2 branches missed.">        if (eventHttpServletRequest.getProcessing().isSome()) {</span>

<span class="nc bnc" id="L611" title="All 4 branches missed.">          if (!event.isScheduledEvent() || event.hasRecordingStarted()) {</span>
<span class="nc" id="L612">            return RestUtil.R.badRequest(&quot;Processing can't be updated for events that are already uploaded.&quot;);</span>
          }
<span class="nc" id="L614">          JSONObject processing = eventHttpServletRequest.getProcessing().get();</span>

<span class="nc" id="L616">          String workflowId = (String) processing.get(&quot;workflow&quot;);</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">          if (workflowId == null)</span>
<span class="nc" id="L618">            throw new IllegalArgumentException(&quot;No workflow template in metadata&quot;);</span>

<span class="nc" id="L620">          Map&lt;String, String&gt; configuration = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">          if (eventHttpServletRequest.getProcessing().get().get(&quot;configuration&quot;) != null) {</span>
<span class="nc" id="L622">            configuration = new HashMap&lt;&gt;((JSONObject) eventHttpServletRequest.getProcessing().get().get(&quot;configuration&quot;));</span>
          }

<span class="nc" id="L625">          Optional&lt;Map&lt;String, String&gt;&gt; caMetadataOpt = Optional.empty();</span>
<span class="nc" id="L626">          Optional&lt;Map&lt;String, String&gt;&gt; workflowConfigOpt = Optional.empty();</span>

<span class="nc" id="L628">          Map&lt;String, String&gt; caMetadata = new HashMap&lt;&gt;(getSchedulerService().getCaptureAgentConfiguration(eventId));</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">          if (!workflowId.equals(caMetadata.get(CaptureParameters.INGEST_WORKFLOW_DEFINITION))) {</span>
<span class="nc" id="L630">            caMetadata.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, workflowId);</span>
<span class="nc" id="L631">            caMetadataOpt = Optional.of(caMetadata);</span>
          }

<span class="nc" id="L634">          Map&lt;String, String&gt; oldWorkflowConfig = new HashMap&lt;&gt;(getSchedulerService().getWorkflowConfig(eventId));</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">          if (!oldWorkflowConfig.equals(configuration))</span>
<span class="nc" id="L636">            workflowConfigOpt = Optional.of(configuration);</span>

<span class="nc bnc" id="L638" title="All 4 branches missed.">          if (!caMetadataOpt.isEmpty() || !workflowConfigOpt.isEmpty()) {</span>
<span class="nc" id="L639">            getSchedulerService().updateEvent(eventId, Optional.empty(), Optional.empty(), Optional.empty(),</span>
<span class="nc" id="L640">                    Optional.empty(), Optional.empty(), workflowConfigOpt, caMetadataOpt);</span>
          }
        }

<span class="pc bpc" id="L644" title="3 of 4 branches missed.">        if (eventHttpServletRequest.getScheduling().isSome() &amp;&amp; !requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
          // Scheduling is only available for version 1.1.0 and above
<span class="nc" id="L646">          Optional&lt;Response&gt; clientError = updateSchedulingInformation(</span>
<span class="nc" id="L647">              eventHttpServletRequest.getScheduling().get(), eventId, requestedVersion, false);</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">          if (clientError.isPresent()) {</span>
<span class="nc" id="L649">            return clientError.get();</span>
          }
        }

<span class="fc" id="L653">        return Response.noContent().build();</span>
      }
<span class="nc" id="L655">      return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
<span class="nc" id="L656">    } catch (NotFoundException e) {</span>
<span class="nc" id="L657">      return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
<span class="nc" id="L658">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L659">      return Response.status(Status.UNAUTHORIZED).build();</span>
<span class="nc" id="L660">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L661">      logger.debug(&quot;Unable to update event '{}'&quot;, eventId, e);</span>
<span class="nc" id="L662">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L663">    } catch (IndexServiceException e) {</span>
<span class="nc" id="L664">      logger.error(&quot;Unable to get multi part fields or file for event '{}'&quot;, eventId, e);</span>
<span class="nc" id="L665">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L666">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L667">      logger.error(&quot;Unable to update event '{}'&quot;, eventId, e);</span>
<span class="nc" id="L668">      throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L669">    } catch (Exception e) {</span>
<span class="nc" id="L670">      throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @POST
  @Path(&quot;/&quot;)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @RestQuery(name = &quot;createevent&quot;, description = &quot;Creates an event by sending metadata, access control list, processing instructions and files in a multipart request.&quot;, returnDescription = &quot;&quot;, restParameters = {
          @RestParameter(name = &quot;acl&quot;, isRequired = false, description = &quot;A collection of roles with their possible action&quot;, type = STRING),
          @RestParameter(name = &quot;metadata&quot;, description = &quot;Event metadata as Form param&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;scheduling&quot;, description = &quot;Scheduling information as Form param&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;presenter&quot;, description = &quot;Presenter movie track&quot;, isRequired = false, type = Type.FILE),
          @RestParameter(name = &quot;presentation&quot;, description = &quot;Presentation movie track&quot;, isRequired = false, type = Type.FILE),
          @RestParameter(name = &quot;audio&quot;, description = &quot;Audio track&quot;, isRequired = false, type = Type.FILE),
          @RestParameter(name = &quot;processing&quot;, description = &quot;Processing instructions task configuration&quot;, isRequired = false, type = STRING) }, responses = {
                  @RestResponse(description = &quot;A new event is created and its identifier is returned in the Location header.&quot;, responseCode = HttpServletResponse.SC_CREATED),
                  @RestResponse(description = &quot;The event could not be created due to a scheduling conflict.&quot;, responseCode = HttpServletResponse.SC_CONFLICT),
                  @RestResponse(description = &quot;The request is invalid or inconsistent..&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) })
  public Response createNewEvent(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @Context HttpServletRequest request) {
<span class="nc" id="L689">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
    try {
<span class="nc bnc" id="L691" title="All 2 branches missed.">      String startDatePattern = configuredMetadataFields.containsKey(&quot;startDate&quot;) ? configuredMetadataFields.get(&quot;startDate&quot;).getPattern() : null;</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">      String startTimePattern = configuredMetadataFields.containsKey(&quot;startTime&quot;) ? configuredMetadataFields.get(&quot;startTime&quot;).getPattern() : null;</span>
<span class="nc" id="L693">      EventHttpServletRequest eventHttpServletRequest = EventHttpServletRequest.createFromHttpServletRequest(request,</span>
<span class="nc" id="L694">          ingestService, getEventCatalogUIAdapters(), startDatePattern, startTimePattern);</span>

      // If scheduling information is provided, the source has to be &quot;SCHEDULE_SINGLE&quot; or &quot;SCHEDULE_MULTIPLE&quot;.
<span class="nc bnc" id="L697" title="All 4 branches missed.">      if (eventHttpServletRequest.getScheduling().isSome() &amp;&amp; !requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
        // Scheduling is only available for version 1.1.0 and above
<span class="nc" id="L699">        return scheduleNewEvent(eventHttpServletRequest, eventHttpServletRequest.getScheduling().get(), requestedVersion);</span>
      }

<span class="nc" id="L702">      JSONObject source = new JSONObject();</span>
<span class="nc" id="L703">      source.put(&quot;type&quot;, &quot;UPLOAD&quot;);</span>
<span class="nc" id="L704">      eventHttpServletRequest.setSource(source);</span>
<span class="nc" id="L705">      String eventId = indexService.createEvent(eventHttpServletRequest);</span>
<span class="nc" id="L706">      return ApiResponseBuilder.Json.created(requestedVersion, URI.create(getEventUrl(eventId)), obj(f(&quot;identifier&quot;, v(eventId))));</span>
<span class="nc" id="L707">    } catch (IllegalArgumentException | DateTimeParseException e) {</span>
<span class="nc" id="L708">      logger.debug(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L709">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L710">    } catch (SchedulerException | IndexServiceException e) {</span>
<span class="nc bnc" id="L711" title="All 4 branches missed.">      if (e.getCause() != null &amp;&amp; e.getCause() instanceof NotFoundException</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">              || e.getCause() instanceof IllegalArgumentException) {</span>
<span class="nc" id="L713">        logger.debug(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L714">        return RestUtil.R.badRequest(e.getCause().getMessage());</span>
      } else {
<span class="nc" id="L716">        logger.error(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L717">        throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
      }
<span class="nc" id="L719">    } catch (Exception e) {</span>
<span class="nc" id="L720">      logger.error(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L721">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  private Response scheduleNewEvent(EventHttpServletRequest request, JSONObject scheduling, ApiVersion requestedVersion) throws
      MediaPackageException, IOException, IngestException, SchedulerException,
      NotFoundException, UnauthorizedException, SearchIndexException, java.text.ParseException {

<span class="nc" id="L729">    final SchedulingInfo schedulingInfo = SchedulingInfo.of(scheduling);</span>
<span class="nc" id="L730">    final JSONObject source = schedulingInfo.toSource();</span>
<span class="nc" id="L731">    request.setSource(source);</span>

    try {
<span class="nc" id="L734">      final String eventId = indexService.createEvent(request);</span>

<span class="nc bnc" id="L736" title="All 2 branches missed.">      if (StringUtils.isEmpty(eventId)) {</span>
<span class="nc" id="L737">        return RestUtil.R.badRequest(&quot;The date range provided did not include any events&quot;);</span>
      }

<span class="nc bnc" id="L740" title="All 2 branches missed.">      if (eventId.contains(&quot;,&quot;)) {</span>
        // This the case when SCHEDULE_MULTIPLE is performed.
<span class="nc" id="L742">        return ApiResponseBuilder.Json.ok(requestedVersion, arr(</span>
<span class="nc" id="L743">            Arrays.stream(eventId.split(&quot;,&quot;))</span>
<span class="nc" id="L744">                .map(s -&gt; obj(f(&quot;identifier&quot;, v(s))))</span>
<span class="nc" id="L745">                .collect(Collectors.toList()))</span>
        );
      }

<span class="nc" id="L749">      return ApiResponseBuilder.Json.created(requestedVersion, URI.create(getEventUrl(eventId)), obj(f(&quot;identifier&quot;, v(eventId))));</span>
<span class="nc" id="L750">    } catch (SchedulerConflictException e) {</span>
<span class="nc" id="L751">      final List&lt;MediaPackage&gt; conflictingEvents =</span>
<span class="nc" id="L752">          getConflictingEvents(schedulingInfo, agentStateService, schedulerService);</span>
<span class="nc" id="L753">      logger.debug(&quot;Client tried to schedule conflicting event(s).&quot;);</span>
<span class="nc" id="L754">      return ApiResponseBuilder.Json.conflict(requestedVersion,</span>
<span class="nc" id="L755">          arr(convertConflictingEvents(Optional.empty(), conflictingEvents, indexService, elasticsearchIndex)));</span>
    }
  }

  @GET
  @Path(&quot;/&quot;)
  @RestQuery(name = &quot;getevents&quot;, description = &quot;Returns a list of events. By setting the optional sign parameter to true, the method will pre-sign distribution urls if signing is turned on in Opencast. Remember to consider the maximum validity of signed URLs when caching this response.&quot;, returnDescription = &quot;&quot;, restParameters = {
          @RestParameter(name = &quot;sign&quot;, isRequired = false, description = &quot;Whether public distribution urls should be signed.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withacl&quot;, isRequired = false, description = &quot;Whether the acl metadata should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withmetadata&quot;, isRequired = false, description = &quot;Whether the metadata catalogs should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withscheduling&quot;, isRequired = false, description = &quot;Whether the scheduling information should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withpublications&quot;, isRequired = false, description = &quot;Whether the publication ids and urls should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;includeInternalPublication&quot;, description = &quot;Whether internal publications should be included.&quot;, isRequired = false, type = Type.BOOLEAN),
          @RestParameter(name = &quot;onlyWithWriteAccess&quot;, isRequired = false, description = &quot;Whether only to get the events to which we have write access.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;filter&quot;, isRequired = false, description = &quot;Usage [Filter Name]:[Value to Filter With]. Multiple filters can be used by combining them with commas \&quot;,\&quot;. Available Filters: presenters, contributors, location, textFilter, series, subject. If API ver &gt; 1.1.0 also: identifier, title, description, series_name, language, created, license, rightsholder, is_part_of, source, status, agent_id, start, technical_start.&quot;, type = STRING),
          @RestParameter(name = &quot;sort&quot;, description = &quot;Sort the results based upon a list of comma seperated sorting criteria. In the comma seperated list each type of sorting is specified as a pair such as: &lt;Sort Name&gt;:ASC or &lt;Sort Name&gt;:DESC. Adding the suffix ASC or DESC sets the order as ascending or descending order and is mandatory.&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;limit&quot;, description = &quot;The maximum number of results to return for a single request.&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;offset&quot;, description = &quot;The index of the first result to return.&quot;, isRequired = false, type = RestParameter.Type.INTEGER) }, responses = {
                  @RestResponse(description = &quot;A (potentially empty) list of events is returned.&quot;, responseCode = HttpServletResponse.SC_OK) })
  public Response getEvents(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @QueryParam(&quot;id&quot;) String id,
          @QueryParam(&quot;commentReason&quot;) String reasonFilter, @QueryParam(&quot;commentResolution&quot;) String resolutionFilter,
          @QueryParam(&quot;filter&quot;) List&lt;String&gt; filter, @QueryParam(&quot;sort&quot;) String sort, @QueryParam(&quot;offset&quot;) Integer offset,
          @QueryParam(&quot;limit&quot;) Integer limit, @QueryParam(&quot;sign&quot;) boolean sign, @QueryParam(&quot;withacl&quot;) Boolean withAcl,
          @QueryParam(&quot;withmetadata&quot;) Boolean withMetadata, @QueryParam(&quot;withscheduling&quot;) Boolean withScheduling,
          @QueryParam(&quot;onlyWithWriteAccess&quot;) Boolean onlyWithWriteAccess, @QueryParam(&quot;withpublications&quot;) Boolean withPublications, @QueryParam(&quot;includeInternalPublication&quot;) Boolean includeInternalPublication) {
<span class="nc" id="L780">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
      // withscheduling was added for version 1.1.0 and should be ignored for smaller versions.
<span class="nc" id="L783">      withScheduling = false;</span>
    }

<span class="nc" id="L786">    Option&lt;Integer&gt; optLimit = Option.option(limit);</span>
<span class="nc" id="L787">    Option&lt;Integer&gt; optOffset = Option.option(offset);</span>
<span class="nc" id="L788">    Option&lt;String&gt; optSort = Option.option(trimToNull(sort));</span>
<span class="nc" id="L789">    EventSearchQuery query = new EventSearchQuery(getSecurityService().getOrganization().getId(),</span>
<span class="nc" id="L790">            getSecurityService().getUser());</span>
    // If the limit is set to 0, this is not taken into account
<span class="nc bnc" id="L792" title="All 4 branches missed.">    if (optLimit.isSome() &amp;&amp; limit == 0) {</span>
<span class="nc" id="L793">      optLimit = Option.none();</span>
    }

    //List of all events from the filters
<span class="nc" id="L797">    List&lt;IndexObject&gt; allEvents = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L799" title="All 2 branches missed.">    if (!isNullOrEmpty(filter)) {</span>
      // API version 1.5.0: Additive filter
<span class="nc bnc" id="L801" title="All 2 branches missed.">      if (!requestedVersion.isSmallerThan(ApiVersion.VERSION_1_5_0)) {</span>
<span class="nc" id="L802">        filter = filter.subList(0,1);</span>
      }
<span class="nc bnc" id="L804" title="All 2 branches missed.">      for (String filterPart : filter) {</span>
        // Parse the filters

<span class="nc bnc" id="L807" title="All 2 branches missed.">        for (String f : filterPart.split(&quot;,&quot;)) {</span>
<span class="nc" id="L808">          String[] filterTuple = f.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">          if (filterTuple.length &lt; 2) {</span>
<span class="nc" id="L810">            logger.debug(&quot;No value for filter {} in filters list: {}&quot;, filterTuple[0], filter);</span>
<span class="nc" id="L811">            continue;</span>
          }

<span class="nc" id="L814">          String name = filterTuple[0];</span>
          String value;

<span class="nc bnc" id="L817" title="All 2 branches missed.">          if (!requestedVersion.isSmallerThan(ApiVersion.VERSION_1_1_0)) {</span>
            // MH-13038 - 1.1.0 and higher support colons in values
<span class="nc" id="L819">            value = f.substring(name.length() + 1);</span>
          } else {
<span class="nc" id="L821">            value = filterTuple[1];</span>
          }

<span class="nc bnc" id="L824" title="All 2 branches missed.">          if (&quot;presenters&quot;.equals(name)) {</span>
<span class="nc" id="L825">            query.withPresenter(value);</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">          } else if (&quot;contributors&quot;.equals(name)) {</span>
<span class="nc" id="L827">            query.withContributor(value);</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">          } else if (&quot;location&quot;.equals(name)) {</span>
<span class="nc" id="L829">            query.withLocation(value);</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">          } else if (&quot;textFilter&quot;.equals(name)) {</span>
<span class="nc" id="L831">            query.withText(value);</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">          } else if (&quot;series&quot;.equals(name)) {</span>
<span class="nc" id="L833">            query.withSeriesId(value);</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">          } else if (&quot;subject&quot;.equals(name)) {</span>
<span class="nc" id="L835">            query.withSubject(value);</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">          } else if (!requestedVersion.isSmallerThan(ApiVersion.VERSION_1_1_0)) {</span>
            // additional filters only available with Version 1.1.0 or higher
<span class="nc bnc" id="L838" title="All 2 branches missed.">            if (&quot;identifier&quot;.equals(name)) {</span>
<span class="nc" id="L839">              query.withIdentifier(value);</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">            } else if (&quot;title&quot;.equals(name)) {</span>
<span class="nc" id="L841">              query.withTitle(value);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">            } else if (&quot;description&quot;.equals(name)) {</span>
<span class="nc" id="L843">              query.withDescription(value);</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">            } else if (&quot;series_name&quot;.equals(name)) {</span>
<span class="nc" id="L845">              query.withSeriesName(value);</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">            } else if (&quot;language&quot;.equals(name)) {</span>
<span class="nc" id="L847">              query.withLanguage(value);</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">            } else if (&quot;created&quot;.equals(name)) {</span>
<span class="nc" id="L849">              query.withCreated(value);</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">            } else if (&quot;license&quot;.equals(name)) {</span>
<span class="nc" id="L851">              query.withLicense(value);</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">            } else if (&quot;rightsholder&quot;.equals(name)) {</span>
<span class="nc" id="L853">              query.withRights(value);</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">            } else if (&quot;is_part_of&quot;.equals(name)) {</span>
<span class="nc" id="L855">              query.withSeriesId(value);</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">            } else if (&quot;source&quot;.equals(name)) {</span>
<span class="nc" id="L857">              query.withSource(value);</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">            } else if (&quot;status&quot;.equals(name)) {</span>
<span class="nc" id="L859">              query.withEventStatus(value);</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">            } else if (&quot;agent_id&quot;.equals(name)) {</span>
<span class="nc" id="L861">              query.withAgentId(value);</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">            } else if (&quot;start&quot;.equals(name)) {</span>
              try {
<span class="nc" id="L864">                Tuple&lt;Date, Date&gt; fromAndToCreationRange = RestUtils.getFromAndToDateRange(value);</span>
<span class="nc" id="L865">                query.withStartFrom(fromAndToCreationRange.getA());</span>
<span class="nc" id="L866">                query.withStartTo(fromAndToCreationRange.getB());</span>
<span class="nc" id="L867">              } catch (Exception e) {</span>
<span class="nc" id="L868">                return RestUtil.R</span>
<span class="nc" id="L869">                        .badRequest(String.format(&quot;Filter 'start' could not be parsed: %s&quot;, e.getMessage()));</span>

<span class="nc" id="L871">              }</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">            } else if (&quot;technical_start&quot;.equals(name)) {</span>
              try {
<span class="nc" id="L874">                Tuple&lt;Date, Date&gt; fromAndToCreationRange = RestUtils.getFromAndToDateRange(value);</span>
<span class="nc" id="L875">                query.withTechnicalStartFrom(fromAndToCreationRange.getA());</span>
<span class="nc" id="L876">                query.withTechnicalStartTo(fromAndToCreationRange.getB());</span>
<span class="nc" id="L877">              } catch (Exception e) {</span>
<span class="nc" id="L878">                return RestUtil.R</span>
<span class="nc" id="L879">                        .badRequest(String.format(&quot;Filter 'technical_start' could not be parsed: %s&quot;, e.getMessage()));</span>

<span class="nc" id="L881">              }</span>
            } else {
<span class="nc" id="L883">              logger.warn(&quot;Unknown filter criteria {}&quot;, name);</span>
<span class="nc" id="L884">              return RestUtil.R.badRequest(String.format(&quot;Unknown filter criterion in request: %s&quot;, name));</span>

            }
          }
        }

<span class="nc bnc" id="L890" title="All 2 branches missed.">        if (optSort.isSome()) {</span>
<span class="nc" id="L891">          ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(optSort.get());</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">          for (SortCriterion criterion : sortCriteria) {</span>

<span class="nc bnc" id="L894" title="All 11 branches missed.">            switch (criterion.getFieldName()) {</span>
              case EventIndexSchema.TITLE:
<span class="nc" id="L896">                query.sortByTitle(criterion.getOrder());</span>
<span class="nc" id="L897">                break;</span>
              case EventIndexSchema.PRESENTER:
<span class="nc" id="L899">                query.sortByPresenter(criterion.getOrder());</span>
<span class="nc" id="L900">                break;</span>
              case EventIndexSchema.TECHNICAL_START:
              case &quot;technical_date&quot;:
<span class="nc" id="L903">                query.sortByTechnicalStartDate(criterion.getOrder());</span>
<span class="nc" id="L904">                break;</span>
              case EventIndexSchema.TECHNICAL_END:
<span class="nc" id="L906">                query.sortByTechnicalEndDate(criterion.getOrder());</span>
<span class="nc" id="L907">                break;</span>
              case EventIndexSchema.START_DATE:
              case &quot;date&quot;:
<span class="nc" id="L910">                query.sortByStartDate(criterion.getOrder());</span>
<span class="nc" id="L911">                break;</span>
              case EventIndexSchema.END_DATE:
<span class="nc" id="L913">                query.sortByEndDate(criterion.getOrder());</span>
<span class="nc" id="L914">                break;</span>
              case EventIndexSchema.WORKFLOW_STATE:
<span class="nc" id="L916">                query.sortByWorkflowState(criterion.getOrder());</span>
<span class="nc" id="L917">                break;</span>
              case EventIndexSchema.SERIES_NAME:
<span class="nc" id="L919">                query.sortBySeriesName(criterion.getOrder());</span>
<span class="nc" id="L920">                break;</span>
              case EventIndexSchema.LOCATION:
<span class="nc" id="L922">                query.sortByLocation(criterion.getOrder());</span>
<span class="nc" id="L923">                break;</span>
              // For compatibility, we mimic to support the old review_status and scheduling_status sort criteria (MH-13407)
              case &quot;review_status&quot;:
              case &quot;scheduling_status&quot;:
<span class="nc" id="L927">                break;</span>
              default:
<span class="nc" id="L929">                return RestUtil.R.badRequest(String.format(&quot;Unknown sort criterion in request: %s&quot;, criterion.getFieldName()));</span>
            }
<span class="nc" id="L931">          }</span>
        }

        // TODO: Add the comment resolution filter to the query
<span class="nc bnc" id="L935" title="All 2 branches missed.">        if (StringUtils.isNotBlank(resolutionFilter)) {</span>
          try {
<span class="nc" id="L937">            CommentResolution.valueOf(resolutionFilter);</span>
<span class="nc" id="L938">          } catch (Exception e) {</span>
<span class="nc" id="L939">            logger.debug(&quot;Unable to parse comment resolution filter {}&quot;, resolutionFilter);</span>
<span class="nc" id="L940">            return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L941">          }</span>
        }

<span class="nc bnc" id="L944" title="All 2 branches missed.">        if (optLimit.isSome())</span>
<span class="nc" id="L945">          query.withLimit(optLimit.get());</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (optOffset.isSome())</span>
<span class="nc" id="L947">          query.withOffset(offset);</span>
        // TODO: Add other filters to the query

<span class="nc" id="L950">        SearchResult&lt;Event&gt; results = null;</span>
        try {
<span class="nc" id="L952">          results = elasticsearchIndex.getByQuery(query);</span>
<span class="nc" id="L953">        } catch (SearchIndexException e) {</span>
<span class="nc" id="L954">          logger.error(&quot;The External Search Index was not able to get the events list&quot;, e);</span>
<span class="nc" id="L955">          throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L956">        }</span>

<span class="nc" id="L958">        SearchResultItem&lt;Event&gt;[] items = results.getItems();</span>
<span class="nc" id="L959">        List&lt;IndexObject&gt; events = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">        for (SearchResultItem&lt;Event&gt; item : items) {</span>
<span class="nc" id="L961">          Event source = item.getSource();</span>
<span class="nc" id="L962">          source.updatePreview(previewSubtype);</span>
<span class="nc" id="L963">          events.add(source);</span>
        }
        //Append  filtered results to the list
<span class="nc" id="L966">        allEvents.addAll(events);</span>
<span class="nc" id="L967">      }</span>
    } else {
<span class="nc bnc" id="L969" title="All 2 branches missed.">      if (optSort.isSome()) {</span>
<span class="nc" id="L970">        ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(optSort.get());</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">        for (SortCriterion criterion : sortCriteria) {</span>

<span class="nc bnc" id="L973" title="All 11 branches missed.">          switch (criterion.getFieldName()) {</span>
            case EventIndexSchema.TITLE:
<span class="nc" id="L975">              query.sortByTitle(criterion.getOrder());</span>
<span class="nc" id="L976">              break;</span>
            case EventIndexSchema.PRESENTER:
<span class="nc" id="L978">              query.sortByPresenter(criterion.getOrder());</span>
<span class="nc" id="L979">              break;</span>
            case EventIndexSchema.TECHNICAL_START:
            case &quot;technical_date&quot;:
<span class="nc" id="L982">              query.sortByTechnicalStartDate(criterion.getOrder());</span>
<span class="nc" id="L983">              break;</span>
            case EventIndexSchema.TECHNICAL_END:
<span class="nc" id="L985">              query.sortByTechnicalEndDate(criterion.getOrder());</span>
<span class="nc" id="L986">              break;</span>
            case EventIndexSchema.START_DATE:
            case &quot;date&quot;:
<span class="nc" id="L989">              query.sortByStartDate(criterion.getOrder());</span>
<span class="nc" id="L990">              break;</span>
            case EventIndexSchema.END_DATE:
<span class="nc" id="L992">              query.sortByEndDate(criterion.getOrder());</span>
<span class="nc" id="L993">              break;</span>
            case EventIndexSchema.WORKFLOW_STATE:
<span class="nc" id="L995">              query.sortByWorkflowState(criterion.getOrder());</span>
<span class="nc" id="L996">              break;</span>
            case EventIndexSchema.SERIES_NAME:
<span class="nc" id="L998">              query.sortBySeriesName(criterion.getOrder());</span>
<span class="nc" id="L999">              break;</span>
            case EventIndexSchema.LOCATION:
<span class="nc" id="L1001">              query.sortByLocation(criterion.getOrder());</span>
<span class="nc" id="L1002">              break;</span>
            // For compatibility, we mimic to support the old review_status and scheduling_status sort criteria (MH-13407)
            case &quot;review_status&quot;:
            case &quot;scheduling_status&quot;:
<span class="nc" id="L1006">              break;</span>
            default:
<span class="nc" id="L1008">              return RestUtil.R.badRequest(String.format(&quot;Unknown sort criterion in request: %s&quot;, criterion.getFieldName()));</span>
          }
<span class="nc" id="L1010">        }</span>
      }

      // TODO: Add the comment resolution filter to the query
<span class="nc bnc" id="L1014" title="All 2 branches missed.">      if (StringUtils.isNotBlank(resolutionFilter)) {</span>
        try {
<span class="nc" id="L1016">          CommentResolution.valueOf(resolutionFilter);</span>
<span class="nc" id="L1017">        } catch (Exception e) {</span>
<span class="nc" id="L1018">          logger.debug(&quot;Unable to parse comment resolution filter {}&quot;, resolutionFilter);</span>
<span class="nc" id="L1019">          return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L1020">        }</span>
      }

<span class="nc bnc" id="L1023" title="All 2 branches missed.">      if (optLimit.isSome())</span>
<span class="nc" id="L1024">        query.withLimit(optLimit.get());</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">      if (optOffset.isSome())</span>
<span class="nc" id="L1026">        query.withOffset(offset);</span>

<span class="nc bnc" id="L1028" title="All 4 branches missed.">      if (onlyWithWriteAccess != null &amp;&amp; onlyWithWriteAccess) {</span>
<span class="nc" id="L1029">        query.withoutActions();</span>
<span class="nc" id="L1030">        query.withAction(Permissions.Action.WRITE);</span>
      }
      // TODO: Add other filters to the query

<span class="nc" id="L1034">      SearchResult&lt;Event&gt; results = null;</span>
      try {
<span class="nc" id="L1036">        results = elasticsearchIndex.getByQuery(query);</span>
<span class="nc" id="L1037">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L1038">        logger.error(&quot;The External Search Index was not able to get the events list&quot;, e);</span>
<span class="nc" id="L1039">        throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L1040">      }</span>

<span class="nc" id="L1042">      SearchResultItem&lt;Event&gt;[] items = results.getItems();</span>
<span class="nc" id="L1043">      List&lt;IndexObject&gt; events = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">      for (SearchResultItem&lt;Event&gt; item : items) {</span>
<span class="nc" id="L1045">        Event source = item.getSource();</span>
<span class="nc" id="L1046">        source.updatePreview(previewSubtype);</span>
<span class="nc" id="L1047">        events.add(source);</span>
      }
      //Append  filtered results to the list
<span class="nc" id="L1050">      allEvents.addAll(events);</span>
    }
    try {
<span class="nc" id="L1053">      return getJsonEvents(</span>
<span class="nc" id="L1054">          acceptHeader, allEvents, withAcl, withMetadata, withScheduling, withPublications, includeInternalPublication, sign, requestedVersion);</span>
<span class="nc" id="L1055">    } catch (Exception e) {</span>
<span class="nc" id="L1056">      logger.error(&quot;Unable to get events&quot;, e);</span>
<span class="nc" id="L1057">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Render a collection of {@link Event}s into a json array.
   *
   * @param acceptHeader
   *          The accept header to return to the client.
   * @param events
   *          The {@link List} of {@link Event}s to render into json.
   * @param withAcl
   *          Whether to include the events' ACLs.
   * @param withMetadata
   *          Whether to include the events' metadata.
   * @param withScheduling
   *          Whether to include the events' scheduling information.
   * @param withPublications
   *          Whether to include the events' publications.
   * @param withSignedUrls
   *          Whether to sign the included urls.
   * @return A {@link Response} with the accept header and body as the Json array of {@link Event}s.
   * @throws IndexServiceException
   * @throws SchedulerException
   * @throws UnauthorizedException
   */
  protected Response getJsonEvents(String acceptHeader, List&lt;IndexObject&gt; events, Boolean withAcl, Boolean withMetadata,
          Boolean withScheduling, Boolean withPublications,Boolean includeInternalPublication, Boolean withSignedUrls, ApiVersion requestedVersion)
      throws IndexServiceException, UnauthorizedException, SchedulerException {
<span class="nc" id="L1086">    List&lt;JValue&gt; eventsList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">    for (IndexObject item : events) {</span>
<span class="nc" id="L1088">      eventsList.add(eventToJSON((Event) item, withAcl, withMetadata, withScheduling, withPublications, includeInternalPublication, withSignedUrls,</span>
              requestedVersion));
<span class="nc" id="L1090">    }</span>
<span class="nc" id="L1091">    return ApiResponseBuilder.Json.ok(requestedVersion, arr(eventsList));</span>
  }

  /**
   * Transform an {@link Event} to Json
   *
   * @param event
   *          The event to transform into json
   * @param withAcl
   *          Whether to add the acl information for the event
   * @param withMetadata
   *          Whether to add all the metadata for the event
   * @param withScheduling
   *          Whether to add the scheduling information for the event
   * @param withPublications
   *          Whether to add the publications
   * @param withSignedUrls
   *          Whether to sign the urls if they are protected by stream security.
   * @return The event in json format.
   * @throws IndexServiceException
   *           Thrown if unable to get the metadata for the event.
   * @throws SchedulerException
   * @throws UnauthorizedException
   */
  protected JValue eventToJSON(Event event, Boolean withAcl, Boolean withMetadata, Boolean withScheduling,
          Boolean withPublications, Boolean includeInternalPublication, Boolean withSignedUrls, ApiVersion requestedVersion) throws IndexServiceException, SchedulerException, UnauthorizedException {
<span class="nc" id="L1117">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">    if (event.getArchiveVersion() != null)</span>
<span class="nc" id="L1119">      fields.add(f(&quot;archive_version&quot;, v(event.getArchiveVersion())));</span>
<span class="nc" id="L1120">    fields.add(f(&quot;created&quot;, v(event.getCreated(), Jsons.BLANK)));</span>
<span class="nc" id="L1121">    fields.add(f(&quot;creator&quot;, v(event.getCreator(), Jsons.BLANK)));</span>
<span class="nc" id="L1122">    fields.add(f(&quot;contributor&quot;, arr($(event.getContributors()).map(Functions.stringToJValue))));</span>
<span class="nc" id="L1123">    fields.add(f(&quot;description&quot;, v(event.getDescription(), Jsons.BLANK)));</span>
<span class="nc" id="L1124">    fields.add(f(&quot;has_previews&quot;, v(event.hasPreview())));</span>
<span class="nc" id="L1125">    fields.add(f(&quot;identifier&quot;, v(event.getIdentifier(), BLANK)));</span>
<span class="nc" id="L1126">    fields.add(f(&quot;location&quot;, v(event.getLocation(), BLANK)));</span>
<span class="nc" id="L1127">    fields.add(f(&quot;presenter&quot;, arr($(event.getPresenters()).map(Functions.stringToJValue))));</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">    if (!requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
<span class="nc" id="L1129">      fields.add(f(&quot;language&quot;, v(event.getLanguage(), BLANK)));</span>
<span class="nc" id="L1130">      fields.add(f(&quot;rightsholder&quot;, v(event.getRights(), BLANK)));</span>
<span class="nc" id="L1131">      fields.add(f(&quot;license&quot;, v(event.getLicense(), BLANK)));</span>
<span class="nc" id="L1132">      fields.add(f(&quot;is_part_of&quot;, v(event.getSeriesId(), BLANK)));</span>
<span class="nc" id="L1133">      fields.add(f(&quot;series&quot;, v(event.getSeriesName(),BLANK)));</span>
<span class="nc" id="L1134">      fields.add(f(&quot;source&quot;, v(event.getSource(), BLANK)));</span>
<span class="nc" id="L1135">      fields.add(f(&quot;status&quot;, v(event.getEventStatus(), BLANK)));</span>
    }
<span class="nc" id="L1137">    List&lt;JValue&gt; publicationIds = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">    if (event.getPublications() != null) {</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">      for (Publication publication : event.getPublications()) {</span>
<span class="nc" id="L1140">        publicationIds.add(v(publication.getChannel()));</span>
<span class="nc" id="L1141">      }</span>
    }
<span class="nc" id="L1143">    fields.add(f(&quot;publication_status&quot;, arr(publicationIds)));</span>
<span class="nc" id="L1144">    fields.add(f(&quot;processing_state&quot;, v(event.getWorkflowState(), BLANK)));</span>

<span class="nc bnc" id="L1146" title="All 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_4_0)) {</span>
<span class="nc" id="L1147">      fields.add(f(&quot;start&quot;, v(event.getTechnicalStartTime(), BLANK)));</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">      if (event.getTechnicalEndTime() != null) {</span>
<span class="nc" id="L1149">        long duration = new DateTime(event.getTechnicalEndTime()).getMillis()</span>
<span class="nc" id="L1150">                - new DateTime(event.getTechnicalStartTime()).getMillis();</span>
<span class="nc" id="L1151">        fields.add(f(&quot;duration&quot;, v(duration)));</span>
<span class="nc" id="L1152">      }</span>
    } else {
<span class="nc" id="L1154">      fields.add(f(&quot;start&quot;, v(event.getRecordingStartDate(), BLANK)));</span>
<span class="nc" id="L1155">      fields.add(f(&quot;duration&quot;, v(event.getDuration(), NULL)));</span>
    }

<span class="nc bnc" id="L1158" title="All 2 branches missed.">    if (StringUtils.trimToNull(event.getSubject()) != null) {</span>
<span class="nc" id="L1159">      fields.add(f(&quot;subjects&quot;, arr(splitSubjectIntoArray(event.getSubject()))));</span>
    } else {
<span class="nc" id="L1161">      fields.add(f(&quot;subjects&quot;, arr()));</span>
    }
<span class="nc" id="L1163">    fields.add(f(&quot;title&quot;, v(event.getTitle(), BLANK)));</span>
<span class="nc bnc" id="L1164" title="All 4 branches missed.">    if (withAcl != null &amp;&amp; withAcl) {</span>
<span class="nc" id="L1165">      AccessControlList acl = getAclFromEvent(event);</span>
<span class="nc" id="L1166">      fields.add(f(&quot;acl&quot;, arr(AclUtils.serializeAclToJson(acl))));</span>
    }
<span class="nc bnc" id="L1168" title="All 4 branches missed.">    if (withMetadata != null &amp;&amp; withMetadata) {</span>
      try {
<span class="nc" id="L1170">        Opt&lt;MetadataList&gt; metadata = getEventMetadata(event);</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">        if (metadata.isSome()) {</span>
<span class="nc" id="L1172">          fields.add(f(&quot;metadata&quot;, MetadataJson.listToJson(metadata.get(), true)));</span>
        }
<span class="nc" id="L1174">      } catch (Exception e) {</span>
<span class="nc" id="L1175">        logger.error(&quot;Unable to get metadata for event '{}'&quot;, event.getIdentifier(), e);</span>
<span class="nc" id="L1176">        throw new IndexServiceException(&quot;Unable to add metadata to event&quot;, e);</span>
<span class="nc" id="L1177">      }</span>
    }
<span class="nc bnc" id="L1179" title="All 4 branches missed.">    if (withScheduling != null &amp;&amp; withScheduling) {</span>
<span class="nc" id="L1180">      fields.add(f(&quot;scheduling&quot;, SchedulingInfo.of(event.getIdentifier(), schedulerService).toJson()));</span>
    }
<span class="nc bnc" id="L1182" title="All 4 branches missed.">    if (withPublications != null &amp;&amp; withPublications) {</span>
<span class="nc" id="L1183">      List&lt;JValue&gt; publications = getPublications(event, withSignedUrls, includeInternalPublication,requestedVersion);</span>
<span class="nc" id="L1184">      fields.add(f(&quot;publications&quot;, arr(publications)));</span>
    }
<span class="nc" id="L1186">    return obj(fields);</span>
  }

  private List&lt;JValue&gt; splitSubjectIntoArray(final String subject) {
<span class="nc" id="L1190">    return com.entwinemedia.fn.Stream.$(subject.split(&quot;,&quot;)).map(new Fn&lt;String, JValue&gt;() {</span>
      @Override
      public JValue apply(String a) {
<span class="nc" id="L1193">        return v(a.trim());</span>
      }
<span class="nc" id="L1195">    }).toList();</span>
  }

  @GET
  @Path(&quot;{eventId}/acl&quot;)
  @RestQuery(name = &quot;geteventacl&quot;, description = &quot;Returns an event's access policy.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
                  @RestResponse(description = &quot;The access control list for the specified event is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventAcl(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
          throws Exception {
<span class="nc bnc" id="L1206" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L1207">      AccessControlList acl = getAclFromEvent(event);</span>
<span class="nc" id="L1208">      return ApiResponseBuilder.Json.ok(acceptHeader, arr(AclUtils.serializeAclToJson(acl)));</span>
    }
<span class="nc" id="L1210">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @PUT
  @Path(&quot;{eventId}/acl&quot;)
  @RestQuery(name = &quot;updateeventacl&quot;, description = &quot;Update an event's access policy.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;acl&quot;, isRequired = true, description = &quot;Access policy&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The access control list for the specified event is updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventAcl(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @FormParam(&quot;acl&quot;) String acl) throws Exception {
<span class="nc bnc" id="L1222" title="All 2 branches missed.">    if (indexService.getEvent(id, elasticsearchIndex).isSome()) {</span>
      AccessControlList accessControlList;
      try {
<span class="nc" id="L1225">        accessControlList = AclUtils.deserializeJsonToAcl(acl, false);</span>
<span class="nc" id="L1226">      } catch (ParseException e) {</span>
<span class="nc" id="L1227">        logger.debug(&quot;Unable to update event acl to '{}'&quot;, acl, e);</span>
<span class="nc" id="L1228">        return R.badRequest(String.format(&quot;Unable to parse acl '%s' because '%s'&quot;, acl, e.getMessage()));</span>
<span class="nc" id="L1229">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1230">        logger.debug(&quot;Unable to update event acl to '{}'&quot;, acl, e);</span>
<span class="nc" id="L1231">        return R.badRequest(e.getMessage());</span>
<span class="nc" id="L1232">      }</span>
      try {
<span class="nc" id="L1234">        accessControlList = indexService.updateEventAcl(id, accessControlList, elasticsearchIndex);</span>
<span class="nc" id="L1235">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1236">        logger.error(&quot;Unable to update event '{}' acl with '{}'&quot;, id, acl, e);</span>
<span class="nc" id="L1237">        return Response.status(Status.FORBIDDEN).build();</span>
<span class="nc" id="L1238">      }</span>
<span class="nc" id="L1239">      return Response.noContent().build();</span>
    } else {
<span class="nc" id="L1241">      return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
    }
  }

  @POST
  @Path(&quot;{eventId}/acl/{action}&quot;)
  @RestQuery(name = &quot;addeventace&quot;, description = &quot;Grants permission to execute action on the specified event to any user with role role. Note that this is a convenience method to avoid having to build and post a complete access control list.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;action&quot;, description = &quot;The action that is allowed to be executed&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;role&quot;, isRequired = true, description = &quot;The role that is granted permission&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The permission has been created in the access control list of the specified event.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response addEventAce(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @PathParam(&quot;action&quot;) String action, @FormParam(&quot;role&quot;) String role) throws Exception {
<span class="nc" id="L1255">    List&lt;AccessControlEntry&gt; entries = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L1257">      AccessControlList accessControlList = getAclFromEvent(event);</span>
<span class="nc" id="L1258">      AccessControlEntry newAce = new AccessControlEntry(role, action, true);</span>
<span class="nc" id="L1259">      boolean alreadyInAcl = false;</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">      for (AccessControlEntry ace : accessControlList.getEntries()) {</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">        if (ace.equals(newAce)) {</span>
          // We have found an identical access control entry so just return.
<span class="nc" id="L1263">          entries = accessControlList.getEntries();</span>
<span class="nc" id="L1264">          alreadyInAcl = true;</span>
<span class="nc" id="L1265">          break;</span>
<span class="nc bnc" id="L1266" title="All 4 branches missed.">        } else if (ace.getAction().equals(newAce.getAction()) &amp;&amp; ace.getRole().equals(newAce.getRole())</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">                &amp;&amp; !ace.isAllow()) {</span>
<span class="nc" id="L1268">          entries.add(newAce);</span>
<span class="nc" id="L1269">          alreadyInAcl = true;</span>
        } else {
<span class="nc" id="L1271">          entries.add(ace);</span>
        }
<span class="nc" id="L1273">      }</span>

<span class="nc bnc" id="L1275" title="All 2 branches missed.">      if (!alreadyInAcl) {</span>
<span class="nc" id="L1276">        entries.add(newAce);</span>
      }

<span class="nc" id="L1279">      AccessControlList withNewAce = new AccessControlList(entries);</span>
      try {
<span class="nc" id="L1281">        withNewAce = indexService.updateEventAcl(id, withNewAce, elasticsearchIndex);</span>
<span class="nc" id="L1282">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1283">        logger.error(&quot;Unable to update event '{}' acl entry with action '{}' and role '{}'&quot;, id, action, role, e);</span>
<span class="nc" id="L1284">        return Response.status(Status.FORBIDDEN).build();</span>
<span class="nc" id="L1285">      }</span>
<span class="nc" id="L1286">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1288">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @DELETE
  @Path(&quot;{eventId}/acl/{action}/{role}&quot;)
  @RestQuery(name = &quot;deleteeventace&quot;, description = &quot;Revokes permission to execute action on the specified event from any user with role role.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;action&quot;, description = &quot;The action that is no longer allowed to be executed&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;role&quot;, description = &quot;The role that is no longer granted permission&quot;, isRequired = true, type = STRING) }, responses = {
                  @RestResponse(description = &quot;The permission has been revoked from the access control list of the specified event.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteEventAce(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @PathParam(&quot;action&quot;) String action, @PathParam(&quot;role&quot;) String role) throws Exception {
<span class="nc" id="L1301">    List&lt;AccessControlEntry&gt; entries = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L1303">      AccessControlList accessControlList = getAclFromEvent(event);</span>
<span class="nc" id="L1304">      boolean foundDelete = false;</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">      for (AccessControlEntry ace : accessControlList.getEntries()) {</span>
<span class="nc bnc" id="L1306" title="All 4 branches missed.">        if (ace.getAction().equals(action) &amp;&amp; ace.getRole().equals(role)) {</span>
<span class="nc" id="L1307">          foundDelete = true;</span>
        } else {
<span class="nc" id="L1309">          entries.add(ace);</span>
        }
<span class="nc" id="L1311">      }</span>

<span class="nc bnc" id="L1313" title="All 2 branches missed.">      if (!foundDelete) {</span>
<span class="nc" id="L1314">        return ApiResponseBuilder.notFound(&quot;Unable to find an access control entry with action '%s' and role '%s'&quot;, action,</span>
                role);
      }

<span class="nc" id="L1318">      AccessControlList withoutDeleted = new AccessControlList(entries);</span>
      try {
<span class="nc" id="L1320">        withoutDeleted = indexService.updateEventAcl(id, withoutDeleted, elasticsearchIndex);</span>
<span class="nc" id="L1321">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1322">        logger.error(&quot;Unable to delete event's '{}' acl entry with action '{}' and role '{}'&quot;, id, action, role, e);</span>
<span class="nc" id="L1323">        return Response.status(Status.FORBIDDEN).build();</span>
<span class="nc" id="L1324">      }</span>
<span class="nc" id="L1325">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1327">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @GET
  @Path(&quot;{eventId}/metadata&quot;)
  @RestQuery(name = &quot;geteventmetadata&quot;, description = &quot;Returns the event's metadata of the specified type. For a metadata catalog there is the flavor such as 'dublincore/episode' and this is the unique type.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = false, description = &quot;The type of metadata to get&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The metadata collection is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getAllEventMetadata(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type) throws Exception {
<span class="fc" id="L1339">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">    if (StringUtils.trimToNull(type) == null) {</span>
<span class="fc" id="L1341">      Opt&lt;MetadataList&gt; metadataList = getEventMetadataById(id);</span>
<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">      if (metadataList.isSome()) {</span>
<span class="fc" id="L1343">        MetadataList actualList = metadataList.get();</span>

        // API v1 should return a two separate fields for start date and start time. Since those fields were merged in index service, we have to split them up.
<span class="fc" id="L1346">        final DublinCoreMetadataCollection collection = actualList.getMetadataByFlavor(&quot;dublincore/episode&quot;);</span>
<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">        final boolean withOrderedText = collection == null;</span>
<span class="pc bpc" id="L1348" title="1 of 2 branches missed.">        if (collection != null) {</span>
<span class="fc" id="L1349">          convertStartDateTimeToApiV1(collection);</span>
        }

<span class="fc" id="L1352">        return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.listToJson(actualList, withOrderedText));</span>
      }
      else
<span class="nc" id="L1355">        return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
    } else {
<span class="nc" id="L1357">      return getEventMetadataByType(id, type, requestedVersion);</span>
    }
  }

  private void convertStartDateTimeToApiV1(DublinCoreMetadataCollection collection) throws java.text.ParseException {

<span class="pc bpc" id="L1363" title="1 of 2 branches missed.">    if (!collection.getOutputFields().containsKey(&quot;startDate&quot;)) return;</span>

<span class="fc" id="L1365">    MetadataField oldStartDateField = collection.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="fc" id="L1366">    SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(oldStartDateField.getPattern());</span>
<span class="fc" id="L1367">    Date startDate = sdf.parse((String) oldStartDateField.getValue());</span>

<span class="pc bpc" id="L1369" title="1 of 2 branches missed.">    if (configuredMetadataFields.containsKey(&quot;startDate&quot;)) {</span>
<span class="fc" id="L1370">      MetadataField startDateField = configuredMetadataFields.get(&quot;startDate&quot;);</span>
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">      final String pattern = startDateField.getPattern() == null ? &quot;yyyy-MM-dd&quot; : startDateField.getPattern();</span>
<span class="fc" id="L1372">      startDateField = new MetadataField(startDateField);</span>
<span class="fc" id="L1373">      startDateField.setPattern(pattern);</span>
<span class="fc" id="L1374">      sdf.applyPattern(startDateField.getPattern());</span>
<span class="fc" id="L1375">      startDateField.setValue(sdf.format(startDate));</span>
<span class="fc" id="L1376">      collection.removeField(oldStartDateField);</span>
<span class="fc" id="L1377">      collection.addField(startDateField);</span>
    }

<span class="pc bpc" id="L1380" title="1 of 2 branches missed.">    if (configuredMetadataFields.containsKey(&quot;startTime&quot;)) {</span>
<span class="fc" id="L1381">      MetadataField startTimeField = configuredMetadataFields.get(&quot;startTime&quot;);</span>
<span class="pc bpc" id="L1382" title="1 of 2 branches missed.">      final String pattern = startTimeField.getPattern() == null ? &quot;HH:mm&quot; : startTimeField.getPattern();</span>
<span class="fc" id="L1383">      startTimeField = new MetadataField(startTimeField);</span>
<span class="fc" id="L1384">      startTimeField.setPattern(pattern);</span>
<span class="fc" id="L1385">      sdf.applyPattern(startTimeField.getPattern());</span>
<span class="fc" id="L1386">      startTimeField.setValue(sdf.format(startDate));</span>
<span class="fc" id="L1387">      collection.addField(startTimeField);</span>
    }
<span class="fc" id="L1389">  }</span>

  protected Opt&lt;MetadataList&gt; getEventMetadataById(String id) throws IndexServiceException, Exception {
<span class="pc bpc" id="L1392" title="1 of 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="fc" id="L1393">      return getEventMetadata(event);</span>
    }
<span class="nc" id="L1395">    return Opt.&lt;MetadataList&gt; none();</span>
  }

  protected Opt&lt;MetadataList&gt; getEventMetadata(Event event) throws IndexServiceException, Exception {
<span class="fc" id="L1399">    MetadataList metadataList = new MetadataList();</span>
<span class="fc" id="L1400">    List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = getEventCatalogUIAdapters();</span>
<span class="fc" id="L1401">    EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="fc" id="L1402">    catalogUIAdapters.remove(eventCatalogUIAdapter);</span>
<span class="pc bpc" id="L1403" title="1 of 2 branches missed.">    if (catalogUIAdapters.size() &gt; 0) {</span>
<span class="fc" id="L1404">      MediaPackage mediaPackage = indexService.getEventMediapackage(event);</span>
<span class="fc bfc" id="L1405" title="All 2 branches covered.">      for (EventCatalogUIAdapter catalogUIAdapter : catalogUIAdapters) {</span>
        // TODO: This is very slow:
<span class="fc" id="L1407">        DublinCoreMetadataCollection fields = catalogUIAdapter.getFields(mediaPackage);</span>
<span class="pc bpc" id="L1408" title="1 of 2 branches missed.">        if (fields != null) {</span>
<span class="nc" id="L1409">          ExternalMetadataUtils.removeCollectionList(fields);</span>
<span class="nc" id="L1410">          metadataList.add(catalogUIAdapter, fields);</span>
        }
<span class="fc" id="L1412">      }</span>
    }
<span class="fc" id="L1414">    DublinCoreMetadataCollection collection = EventUtils.getEventMetadata(event, eventCatalogUIAdapter,</span>
        new EmptyResourceListQuery());
<span class="fc" id="L1416">    ExternalMetadataUtils.changeSubjectToSubjects(collection);</span>
<span class="fc" id="L1417">    ExternalMetadataUtils.removeCollectionList(collection);</span>
<span class="fc" id="L1418">    metadataList.add(eventCatalogUIAdapter, collection);</span>
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">    if (WorkflowInstance.WorkflowState.RUNNING.toString().equals(event.getWorkflowState())) {</span>
<span class="nc" id="L1420">      metadataList.setLocked(Locked.WORKFLOW_RUNNING);</span>
    }
<span class="fc" id="L1422">    return Opt.some(metadataList);</span>
  }

  private Opt&lt;MediaPackageElementFlavor&gt; getFlavor(String flavorString) {
    try {
<span class="fc" id="L1427">      MediaPackageElementFlavor flavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>
<span class="fc" id="L1428">      return Opt.some(flavor);</span>
<span class="nc" id="L1429">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1430">      return Opt.none();</span>
    }
  }

  private Response getEventMetadataByType(String id, String type, ApiVersion requestedVersion) throws Exception {
<span class="nc bnc" id="L1435" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L1436">      Opt&lt;MediaPackageElementFlavor&gt; flavor = getFlavor(type);</span>
<span class="nc bnc" id="L1437" title="All 2 branches missed.">      if (flavor.isNone()) {</span>
<span class="nc" id="L1438">        return R.badRequest(</span>
<span class="nc" id="L1439">                String.format(&quot;Unable to parse type '%s' as a flavor so unable to find the matching catalog.&quot;, type));</span>
      }
      // Try the main catalog first as we load it from the index.
<span class="nc" id="L1442">      EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">      if (flavor.get().equals(eventCatalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1444">        DublinCoreMetadataCollection collection = EventUtils.getEventMetadata(event, eventCatalogUIAdapter,</span>
            new EmptyResourceListQuery());
<span class="nc" id="L1446">        ExternalMetadataUtils.changeSubjectToSubjects(collection);</span>
<span class="nc" id="L1447">        ExternalMetadataUtils.removeCollectionList(collection);</span>
<span class="nc" id="L1448">        convertStartDateTimeToApiV1(collection);</span>
<span class="nc" id="L1449">        return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.collectionToJson(collection, false));</span>
      }
      // Try the other catalogs
<span class="nc" id="L1452">      List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = getEventCatalogUIAdapters();</span>
<span class="nc" id="L1453">      catalogUIAdapters.remove(eventCatalogUIAdapter);</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">      if (catalogUIAdapters.size() &gt; 0) {</span>
<span class="nc" id="L1455">        MediaPackage mediaPackage = indexService.getEventMediapackage(event);</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">        for (EventCatalogUIAdapter catalogUIAdapter : catalogUIAdapters) {</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">          if (flavor.get().equals(catalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1458">            DublinCoreMetadataCollection fields = catalogUIAdapter.getFields(mediaPackage);</span>
<span class="nc" id="L1459">            ExternalMetadataUtils.removeCollectionList(fields);</span>
<span class="nc" id="L1460">            convertStartDateTimeToApiV1(fields);</span>
<span class="nc" id="L1461">            return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.collectionToJson(fields, false));</span>
          }
<span class="nc" id="L1463">        }</span>
      }
<span class="nc" id="L1465">      return ApiResponseBuilder.notFound(&quot;Cannot find a catalog with type '%s' for event with id '%s'.&quot;, type, id);</span>
    }
<span class="nc" id="L1467">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @PUT
  @Path(&quot;{eventId}/metadata&quot;)
  @RestQuery(name = &quot;updateeventmetadata&quot;, description = &quot;Update the metadata with the matching type of the specified event. For a metadata catalog there is the flavor such as 'dublincore/episode' and this is the unique type.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = true, description = &quot;The type of metadata to update&quot;, type = STRING),
                  @RestParameter(name = &quot;metadata&quot;, description = &quot;Metadata catalog in JSON format&quot;, isRequired = true, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The metadata of the given namespace has been updated.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The request is invalid or inconsistent.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventMetadataByType(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type, @FormParam(&quot;metadata&quot;) String metadataJSON) throws Exception {
    Map&lt;String, String&gt; updatedFields;
<span class="fc" id="L1482">    JSONParser parser = new JSONParser();</span>
    try {
<span class="fc" id="L1484">      updatedFields = RequestUtils.getKeyValueMap(metadataJSON);</span>
<span class="nc" id="L1485">    } catch (ParseException e) {</span>
<span class="nc" id="L1486">      logger.debug(&quot;Unable to update event '{}' with metadata type '{}' and content '{}'&quot;, id, type, metadataJSON, e);</span>
<span class="nc" id="L1487">      return RestUtil.R.badRequest(String.format(&quot;Unable to parse metadata fields as json from '%s'&quot;, metadataJSON));</span>
<span class="nc" id="L1488">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1489">      logger.debug(&quot;Unable to update event '{}' with metadata type '{}' and content '{}'&quot;, id, type, metadataJSON, e);</span>
<span class="nc" id="L1490">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="fc" id="L1491">    }</span>

<span class="pc bpc" id="L1493" title="2 of 4 branches missed.">    if (updatedFields == null || updatedFields.size() == 0) {</span>
<span class="nc" id="L1494">      return RestUtil.R.badRequest(</span>
<span class="nc" id="L1495">              String.format(&quot;Unable to parse metadata fields as json from '%s' because there were no fields to update.&quot;,</span>
                      metadataJSON));
    }

<span class="fc" id="L1499">    Opt&lt;MediaPackageElementFlavor&gt; flavor = getFlavor(type);</span>
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">    if (flavor.isNone()) {</span>
<span class="nc" id="L1501">      return R.badRequest(</span>
<span class="nc" id="L1502">              String.format(&quot;Unable to parse type '%s' as a flavor so unable to find the matching catalog.&quot;, type));</span>
    }

<span class="fc" id="L1505">    DublinCoreMetadataCollection collection = null;</span>
<span class="fc" id="L1506">    EventCatalogUIAdapter adapter = null;</span>
<span class="pc bpc" id="L1507" title="1 of 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="fc" id="L1508">      MetadataList metadataList = new MetadataList();</span>
      // Try the main catalog first as we load it from the index.
<span class="fc" id="L1510">      EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">      if (flavor.get().equals(eventCatalogUIAdapter.getFlavor())) {</span>
<span class="fc" id="L1512">        collection = EventUtils.getEventMetadata(event, eventCatalogUIAdapter);</span>
<span class="fc" id="L1513">        adapter = eventCatalogUIAdapter;</span>
      } else {
<span class="nc" id="L1515">        metadataList.add(eventCatalogUIAdapter, EventUtils.getEventMetadata(event, eventCatalogUIAdapter));</span>
      }

      // Try the other catalogs
<span class="fc" id="L1519">      List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = getEventCatalogUIAdapters();</span>
<span class="fc" id="L1520">      catalogUIAdapters.remove(eventCatalogUIAdapter);</span>
<span class="pc bpc" id="L1521" title="1 of 2 branches missed.">      if (catalogUIAdapters.size() &gt; 0) {</span>
<span class="fc" id="L1522">        MediaPackage mediaPackage = indexService.getEventMediapackage(event);</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">        for (EventCatalogUIAdapter catalogUIAdapter : catalogUIAdapters) {</span>
<span class="pc bpc" id="L1524" title="1 of 2 branches missed.">          if (flavor.get().equals(catalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1525">            collection = catalogUIAdapter.getFields(mediaPackage);</span>
<span class="nc" id="L1526">            adapter = eventCatalogUIAdapter;</span>
          } else {
<span class="fc" id="L1528">            metadataList.add(catalogUIAdapter, catalogUIAdapter.getFields(mediaPackage));</span>
          }
<span class="fc" id="L1530">        }</span>
      }

<span class="pc bpc" id="L1533" title="1 of 2 branches missed.">      if (collection == null) {</span>
<span class="nc" id="L1534">        return ApiResponseBuilder.notFound(&quot;Cannot find a catalog with type '%s' for event with id '%s'.&quot;, type, id);</span>
      }

<span class="fc bfc" id="L1537" title="All 2 branches covered.">      for (String key : updatedFields.keySet()) {</span>
<span class="pc bpc" id="L1538" title="1 of 2 branches missed.">        if (&quot;subjects&quot;.equals(key)) {</span>
<span class="nc" id="L1539">          MetadataField field = collection.getOutputFields().get(DublinCore.PROPERTY_SUBJECT.getLocalName());</span>
<span class="nc" id="L1540">          Opt&lt;Response&gt; error = validateField(field, key, id, type, updatedFields);</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">          if (error.isSome()) {</span>
<span class="nc" id="L1542">            return error.get();</span>
          }
<span class="nc" id="L1544">          collection.removeField(field);</span>
<span class="nc" id="L1545">          JSONArray subjectArray = (JSONArray) parser.parse(updatedFields.get(key));</span>
<span class="nc" id="L1546">          collection.addField(</span>
<span class="nc" id="L1547">                  MetadataJson.copyWithDifferentJsonValue(field, StringUtils.join(subjectArray.iterator(), &quot;,&quot;)));</span>
<span class="pc bfc" id="L1548" title="All 2 branches covered.">        } else if (&quot;startDate&quot;.equals(key)) {</span>
          // Special handling for start date since in API v1 we expect start date and start time to be separate fields.
<span class="fc" id="L1550">          MetadataField field = collection.getOutputFields().get(key);</span>
<span class="fc" id="L1551">          Opt&lt;Response&gt; error = validateField(field, key, id, type, updatedFields);</span>
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">          if (error.isSome()) {</span>
<span class="nc" id="L1553">            return error.get();</span>
          }
<span class="fc" id="L1555">          String apiPattern = field.getPattern();</span>
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">          if (configuredMetadataFields.containsKey(&quot;startDate&quot;)) {</span>
<span class="fc" id="L1557">            final String startDate = configuredMetadataFields.get(&quot;startDate&quot;).getPattern();</span>
<span class="pc bpc" id="L1558" title="1 of 2 branches missed.">            apiPattern = startDate == null ? apiPattern : startDate;</span>
          }
<span class="fc" id="L1560">          SimpleDateFormat apiSdf = MetadataField.getSimpleDateFormatter(apiPattern);</span>
<span class="fc" id="L1561">          SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L1562">          DateTime oldStartDate = new DateTime(sdf.parse((String) field.getValue()), DateTimeZone.UTC);</span>
<span class="fc" id="L1563">          DateTime newStartDate = new DateTime(apiSdf.parse(updatedFields.get(key)), DateTimeZone.UTC);</span>
<span class="fc" id="L1564">          DateTime updatedStartDate = oldStartDate.withDate(newStartDate.year().get(), newStartDate.monthOfYear().get(), newStartDate.dayOfMonth().get());</span>
<span class="fc" id="L1565">          collection.removeField(field);</span>
<span class="fc" id="L1566">          collection.addField(</span>
<span class="fc" id="L1567">                  MetadataJson.copyWithDifferentJsonValue(field, sdf.format(updatedStartDate.toDate())));</span>
<span class="fc bfc" id="L1568" title="All 2 branches covered.">        } else if (&quot;startTime&quot;.equals(key)) {</span>
          // Special handling for start time since in API v1 we expect start date and start time to be separate fields.
<span class="fc" id="L1570">          MetadataField field = collection.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="fc" id="L1571">          Opt&lt;Response&gt; error = validateField(field, &quot;startDate&quot;, id, type, updatedFields);</span>
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">          if (error.isSome()) {</span>
<span class="nc" id="L1573">            return error.get();</span>
          }
<span class="fc" id="L1575">          String apiPattern = &quot;HH:mm&quot;;</span>
<span class="pc bpc" id="L1576" title="1 of 2 branches missed.">          if (configuredMetadataFields.containsKey(&quot;startTime&quot;)) {</span>
<span class="fc" id="L1577">            final String startTime = configuredMetadataFields.get(&quot;startTime&quot;).getPattern();</span>
<span class="pc bpc" id="L1578" title="1 of 2 branches missed.">            apiPattern = startTime == null ? apiPattern : startTime;</span>
          }
<span class="fc" id="L1580">          SimpleDateFormat apiSdf = MetadataField.getSimpleDateFormatter(apiPattern);</span>
<span class="fc" id="L1581">          SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L1582">          DateTime oldStartDate = new DateTime(sdf.parse((String) field.getValue()), DateTimeZone.UTC);</span>
<span class="fc" id="L1583">          DateTime newStartDate = new DateTime(apiSdf.parse(updatedFields.get(key)), DateTimeZone.UTC);</span>
<span class="fc" id="L1584">          DateTime updatedStartDate = oldStartDate.withTime(</span>
<span class="fc" id="L1585">                  newStartDate.hourOfDay().get(),</span>
<span class="fc" id="L1586">                  newStartDate.minuteOfHour().get(),</span>
<span class="fc" id="L1587">                  newStartDate.secondOfMinute().get(),</span>
<span class="fc" id="L1588">                  newStartDate.millisOfSecond().get());</span>
<span class="fc" id="L1589">          collection.removeField(field);</span>
<span class="fc" id="L1590">          collection.addField(</span>
<span class="fc" id="L1591">                  MetadataJson.copyWithDifferentJsonValue(field, sdf.format(updatedStartDate.toDate())));</span>
<span class="fc" id="L1592">        } else {</span>
<span class="fc" id="L1593">          MetadataField field = collection.getOutputFields().get(key);</span>
<span class="fc" id="L1594">          Opt&lt;Response&gt; error = validateField(field, key, id, type, updatedFields);</span>
<span class="pc bpc" id="L1595" title="1 of 2 branches missed.">          if (error.isSome()) {</span>
<span class="nc" id="L1596">            return error.get();</span>
          }
<span class="fc" id="L1598">          collection.removeField(field);</span>
<span class="fc" id="L1599">          collection.addField(</span>
<span class="fc" id="L1600">                  MetadataJson.copyWithDifferentJsonValue(field, updatedFields.get(key)));</span>
        }
<span class="fc" id="L1602">      }</span>

<span class="fc" id="L1604">      metadataList.add(adapter, collection);</span>
<span class="fc" id="L1605">      indexService.updateEventMetadata(id, metadataList, elasticsearchIndex);</span>
<span class="fc" id="L1606">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1608">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  private Opt&lt;Response&gt; validateField(MetadataField field, String key, String id, String type, Map&lt;String, String&gt; updatedFields) {
<span class="pc bpc" id="L1612" title="1 of 2 branches missed.">    if (field == null) {</span>
<span class="nc" id="L1613">      return Opt.some(ApiResponseBuilder.notFound(</span>
              &quot;Cannot find a metadata field with id '%s' from event with id '%s' and the metadata type '%s'.&quot;,
              key, id, type));
<span class="pc bpc" id="L1616" title="1 of 4 branches missed.">    } else if (field.isRequired() &amp;&amp; StringUtils.isBlank(updatedFields.get(key))) {</span>
<span class="nc" id="L1617">      return Opt.some(R.badRequest(String.format(</span>
              &quot;The event metadata field with id '%s' and the metadata type '%s' is required and can not be empty!.&quot;,
              key, type)));
    }
<span class="fc" id="L1621">    return Opt.none();</span>
  }

  @DELETE
  @Path(&quot;{eventId}/metadata&quot;)
  @RestQuery(name = &quot;deleteeventmetadata&quot;, description = &quot;Delete the metadata namespace catalog of the specified event. This will remove all fields and values of the catalog.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = true, description = &quot;The type of metadata to delete&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The metadata of the given namespace has been updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The main metadata catalog dublincore/episode cannot be deleted as it has mandatory fields.&quot;, responseCode = HttpServletResponse.SC_FORBIDDEN),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteEventMetadataByType(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type) throws SearchIndexException {
<span class="nc bnc" id="L1634" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L1635">      Opt&lt;MediaPackageElementFlavor&gt; flavor = getFlavor(type);</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">      if (flavor.isNone()) {</span>
<span class="nc" id="L1637">        return R.badRequest(</span>
<span class="nc" id="L1638">                String.format(&quot;Unable to parse type '%s' as a flavor so unable to find the matching catalog.&quot;, type));</span>
      }
<span class="nc" id="L1640">      EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">      if (flavor.get().equals(eventCatalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1642">        return Response</span>
<span class="nc" id="L1643">                .status(Status.FORBIDDEN).entity(String</span>
<span class="nc" id="L1644">                        .format(&quot;Unable to delete mandatory metadata catalog with type '%s' for event '%s'&quot;, type, id))</span>
<span class="nc" id="L1645">                .build();</span>
      }
      try {
<span class="nc" id="L1648">        indexService.removeCatalogByFlavor(event, flavor.get());</span>
<span class="nc" id="L1649">      } catch (NotFoundException e) {</span>
<span class="nc" id="L1650">        return ApiResponseBuilder.notFound(e.getMessage());</span>
<span class="nc" id="L1651">      } catch (IndexServiceException e) {</span>
<span class="nc" id="L1652">        logger.error(&quot;Unable to remove metadata catalog with type '{}' from event '{}'&quot;, type, id, e);</span>
<span class="nc" id="L1653">        throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L1654">      } catch (IllegalStateException e) {</span>
<span class="nc" id="L1655">        logger.debug(&quot;Unable to remove metadata catalog with type '{}' from event '{}'&quot;, type, id, e);</span>
<span class="nc" id="L1656">        throw new WebApplicationException(e, Status.BAD_REQUEST);</span>
<span class="nc" id="L1657">      } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1658">        return Response.status(Status.UNAUTHORIZED).build();</span>
<span class="nc" id="L1659">      }</span>
<span class="nc" id="L1660">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1662">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @GET
  @Path(&quot;{eventId}/publications&quot;)
  @RestQuery(name = &quot;geteventpublications&quot;, description = &quot;Returns an event's list of publications.&quot;,
             returnDescription = &quot;&quot;,
             pathParameters = {
               @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING)
             },
             restParameters = {
               @RestParameter(name = &quot;sign&quot;, description = &quot;Whether public distribution urls should be signed.&quot;,
                              isRequired = false, type = Type.BOOLEAN),
               @RestParameter(name = &quot;includeInternalPublication&quot;, description = &quot;Whether internal publications should be included.&quot;,
                              isRequired = false, type = Type.BOOLEAN)
             },
             responses = {
                  @RestResponse(description = &quot;The list of publications is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })

    public Response getEventPublications(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;sign&quot;) boolean sign, @QueryParam(&quot;includeInternalPublication&quot;) boolean includeInternalPublication) throws Exception {
    try {
<span class="nc" id="L1685">      final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc" id="L1686">      final Opt&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">      if (event.isSome()) {</span>
<span class="nc" id="L1688">        return ApiResponseBuilder.Json.ok(acceptHeader, arr(getPublications(event.get(), sign, includeInternalPublication, requestedVersion)));</span>
      } else {
<span class="nc" id="L1690">        return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
      }
<span class="nc" id="L1692">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1693">      logger.error(&quot;Unable to get list of publications from event with id '{}'&quot;, id, e);</span>
<span class="nc" id="L1694">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }


  private List&lt;JValue&gt; getPublications(Event event, Boolean withSignedUrls, Boolean includeInternalPublication, ApiVersion requestedVersion) {
<span class="nc" id="L1700">        return event.getPublications().stream()</span>
<span class="nc bnc" id="L1701" title="All 8 branches missed.">        .filter(publication -&gt; ((includeInternalPublication != null &amp;&amp; includeInternalPublication &amp;&amp; !requestedVersion.isSmallerThan(VERSION_1_11_0)) || EventUtils.internalChannelFilter.apply(publication)))</span>
<span class="nc" id="L1702">        .map(p -&gt; getPublication(p, withSignedUrls, requestedVersion))</span>
<span class="nc" id="L1703">        .collect(Collectors.toList());</span>
  }

  public JObject getPublication(Publication publication, Boolean sign, ApiVersion requestedVersion) {
    // signing publication URLs was introduced in 1.7.0
<span class="nc" id="L1708">    URI publicationUrl = publication.getURI();</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">    if (!requestedVersion.isSmallerThan(VERSION_1_7_0)) {</span>
<span class="nc" id="L1710">      publicationUrl = getSignedUrl(publicationUrl, sign);</span>
    }

<span class="nc" id="L1713">    return obj(f(&quot;id&quot;, v(publication.getIdentifier())), f(&quot;channel&quot;, v(publication.getChannel())),</span>
<span class="nc" id="L1714">            f(&quot;mediatype&quot;, v(publication.getMimeType(), BLANK)),</span>
<span class="nc" id="L1715">            f(&quot;url&quot;, v(publicationUrl, BLANK)),</span>
<span class="nc" id="L1716">            f(&quot;media&quot;, arr(getPublicationTracksJson(publication, sign, requestedVersion))),</span>
<span class="nc" id="L1717">            f(&quot;attachments&quot;, arr(getPublicationAttachmentsJson(publication, sign))),</span>
<span class="nc" id="L1718">            f(&quot;metadata&quot;, arr(getPublicationCatalogsJson(publication, sign))));</span>
  }

  private URI getSignedUrl(URI url, boolean sign) {
<span class="nc bnc" id="L1722" title="All 4 branches missed.">    if (url == null || !sign) {</span>
<span class="nc" id="L1723">      return url;</span>
    }

<span class="nc bnc" id="L1726" title="All 2 branches missed.">    if (urlSigningService.accepts(url.toString())) {</span>
      try {
<span class="nc" id="L1728">        return URI.create(urlSigningService.sign(url.toString(), expireSeconds, null, null));</span>
<span class="nc" id="L1729">      } catch (UrlSigningException e) {</span>
<span class="nc" id="L1730">        logger.error(&quot;Unable to sign URI {}&quot;, url, e);</span>
      }
    }
<span class="nc" id="L1733">    return url;</span>
  }

  private List&lt;JValue&gt; getPublicationTracksJson(Publication publication, Boolean sign, ApiVersion requestedVersion) {
<span class="nc" id="L1737">    List&lt;JValue&gt; tracks = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">    for (Track track : publication.getTracks()) {</span>

<span class="nc" id="L1740">      VideoStream[] videoStreams = TrackSupport.byType(track.getStreams(), VideoStream.class);</span>
<span class="nc" id="L1741">      List&lt;Field&gt; trackInfo = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1743" title="All 2 branches missed.">      if (videoStreams.length &gt; 0) {</span>
        // Only supporting one stream, like in many other places...
<span class="nc" id="L1745">        final VideoStream videoStream = videoStreams[0];</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">        if (videoStream.getBitRate() != null)</span>
<span class="nc" id="L1747">          trackInfo.add(f(&quot;bitrate&quot;, v(videoStream.getBitRate())));</span>
<span class="nc bnc" id="L1748" title="All 2 branches missed.">        if (videoStream.getFrameRate() != null)</span>
<span class="nc" id="L1749">          trackInfo.add(f(&quot;framerate&quot;, v(videoStream.getFrameRate())));</span>
<span class="nc bnc" id="L1750" title="All 2 branches missed.">        if (videoStream.getFrameCount() != null)</span>
<span class="nc" id="L1751">          trackInfo.add(f(&quot;framecount&quot;, v(videoStream.getFrameCount())));</span>
<span class="nc bnc" id="L1752" title="All 2 branches missed.">        if (videoStream.getFrameWidth() != null)</span>
<span class="nc" id="L1753">          trackInfo.add(f(&quot;width&quot;, v(videoStream.getFrameWidth())));</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">        if (videoStream.getFrameHeight() != null)</span>
<span class="nc" id="L1755">          trackInfo.add(f(&quot;height&quot;, v(videoStream.getFrameHeight())));</span>
      }

<span class="nc bnc" id="L1758" title="All 2 branches missed.">      if (!requestedVersion.isSmallerThan(VERSION_1_7_0)) {</span>
<span class="nc" id="L1759">        trackInfo.add(f(&quot;is_master_playlist&quot;, v(track.isMaster())));</span>
<span class="nc" id="L1760">        trackInfo.add(f(&quot;is_live&quot;, v(track.isLive())));</span>
      }

<span class="nc" id="L1763">      tracks.add(obj(f(&quot;id&quot;, v(track.getIdentifier(), BLANK)), f(&quot;mediatype&quot;, v(track.getMimeType(), BLANK)),</span>
<span class="nc" id="L1764">              f(&quot;url&quot;, v(getSignedUrl(track.getURI(), sign), BLANK)), f(&quot;flavor&quot;, v(track.getFlavor(), BLANK)),</span>
<span class="nc" id="L1765">              f(&quot;size&quot;, v(track.getSize())), f(&quot;checksum&quot;, v(track.getChecksum(), BLANK)),</span>
<span class="nc" id="L1766">              f(&quot;tags&quot;, arr(track.getTags())), f(&quot;has_audio&quot;, v(track.hasAudio())),</span>
<span class="nc" id="L1767">              f(&quot;has_video&quot;, v(track.hasVideo())), f(&quot;duration&quot;, v(track.getDuration(), NULL)),</span>
<span class="nc" id="L1768">              f(&quot;description&quot;, v(track.getDescription(), BLANK))).merge(trackInfo));</span>
    }
<span class="nc" id="L1770">    return tracks;</span>
  }

  private List&lt;JValue&gt; getPublicationAttachmentsJson(Publication publication, Boolean sign) {
<span class="nc" id="L1774">    List&lt;JValue&gt; attachments = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">    for (Attachment attachment : publication.getAttachments()) {</span>
<span class="nc" id="L1776">      attachments.add(</span>
<span class="nc" id="L1777">              obj(f(&quot;id&quot;, v(attachment.getIdentifier(), BLANK)), f(&quot;mediatype&quot;, v(attachment.getMimeType(), BLANK)),</span>
<span class="nc" id="L1778">                      f(&quot;url&quot;, v(getSignedUrl(attachment.getURI(), sign), BLANK)),</span>
<span class="nc" id="L1779">                      f(&quot;flavor&quot;, v(attachment.getFlavor(), BLANK)), f(&quot;ref&quot;, v(attachment.getReference(), BLANK)),</span>
<span class="nc" id="L1780">                      f(&quot;size&quot;, v(attachment.getSize())), f(&quot;checksum&quot;, v(attachment.getChecksum(), BLANK)),</span>
<span class="nc" id="L1781">                      f(&quot;tags&quot;, arr(attachment.getTags()))));</span>
    }
<span class="nc" id="L1783">    return attachments;</span>
  }

  private List&lt;JValue&gt; getPublicationCatalogsJson(Publication publication, Boolean sign) {
<span class="nc" id="L1787">    List&lt;JValue&gt; catalogs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1788" title="All 2 branches missed.">    for (Catalog catalog : publication.getCatalogs()) {</span>
<span class="nc" id="L1789">      catalogs.add(obj(f(&quot;id&quot;, v(catalog.getIdentifier(), BLANK)), f(&quot;mediatype&quot;, v(catalog.getMimeType(), BLANK)),</span>
<span class="nc" id="L1790">              f(&quot;url&quot;, v(getSignedUrl(catalog.getURI(), sign), BLANK)),</span>
<span class="nc" id="L1791">              f(&quot;flavor&quot;, v(catalog.getFlavor(), BLANK)), f(&quot;size&quot;, v(catalog.getSize())),</span>
<span class="nc" id="L1792">              f(&quot;checksum&quot;, v(catalog.getChecksum(), BLANK)), f(&quot;tags&quot;, arr(catalog.getTags()))));</span>
    }
<span class="nc" id="L1794">    return catalogs;</span>
  }

  @GET
  @Path(&quot;{eventId}/publications/{publicationId}&quot;)
  @RestQuery(name = &quot;geteventpublication&quot;, description = &quot;Returns a single publication.&quot;, returnDescription = &quot;&quot;,
             pathParameters = {
               @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING),
               @RestParameter(name = &quot;publicationId&quot;, description = &quot;The publication id&quot;, isRequired = true, type = STRING)
             },
             restParameters = {
               @RestParameter(name = &quot;sign&quot;, description = &quot;Whether public distribution urls should be signed.&quot;,
                              isRequired = false, type = Type.BOOLEAN)
             },
             responses = {
                  @RestResponse(description = &quot;The track details are returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified event or publication does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })

  public Response getEventPublication(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String eventId,
          @PathParam(&quot;publicationId&quot;) String publicationId, @QueryParam(&quot;sign&quot;) boolean sign) throws Exception {
    try {
<span class="nc" id="L1815">      final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc" id="L1816">      return ApiResponseBuilder.Json.ok(acceptHeader, getPublication(eventId, publicationId, sign, requestedVersion));</span>
<span class="nc" id="L1817">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1818">      return ApiResponseBuilder.notFound(e.getMessage());</span>
<span class="nc" id="L1819">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1820">      logger.error(&quot;Unable to get list of publications from event with id '{}'&quot;, eventId, e);</span>
<span class="nc" id="L1821">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }


  private JObject getPublication(String eventId, String publicationId, Boolean withSignedUrls, ApiVersion requestedVersion)
          throws SearchIndexException, NotFoundException {
<span class="nc bnc" id="L1828" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(eventId, elasticsearchIndex)) {</span>
      List&lt;Publication&gt; publications;
<span class="nc bnc" id="L1830" title="All 4 branches missed.">      publications = event.getPublications().stream().filter(publication -&gt; (!requestedVersion.isSmallerThan(VERSION_1_11_0) || EventUtils.internalChannelFilter.apply(publication))).collect(Collectors.toList());</span>
<span class="nc bnc" id="L1831" title="All 2 branches missed.">      for (Publication publication : publications) {</span>
<span class="nc bnc" id="L1832" title="All 2 branches missed.">        if (publicationId.equals(publication.getIdentifier())) {</span>
<span class="nc" id="L1833">          return getPublication(publication, withSignedUrls, requestedVersion);</span>
        }
<span class="nc" id="L1835">      }</span>
<span class="nc" id="L1836">      throw new NotFoundException(</span>
<span class="nc" id="L1837">              String.format(&quot;Unable to find publication with id '%s' in event with id '%s'&quot;, publicationId, eventId));</span>
    }
<span class="nc" id="L1839">    throw new NotFoundException(String.format(&quot;Unable to find event with id '%s'&quot;, eventId));</span>
  }

  /**
   * Get an {@link AccessControlList} from an {@link Event}.
   *
   * @param event
   *          The {@link Event} to get the ACL from.
   * @return The {@link AccessControlList} stored in the {@link Event}
   */
  protected static AccessControlList getAclFromEvent(Event event) {
<span class="nc" id="L1850">    AccessControlList activeAcl = new AccessControlList();</span>
    try {
<span class="nc bnc" id="L1852" title="All 2 branches missed.">      if (event.getAccessPolicy() != null)</span>
<span class="nc" id="L1853">        activeAcl = AccessControlParser.parseAcl(event.getAccessPolicy());</span>
<span class="nc" id="L1854">    } catch (Exception e) {</span>
<span class="nc" id="L1855">      logger.error(&quot;Unable to parse access policy&quot;, e);</span>
<span class="nc" id="L1856">    }</span>
<span class="nc" id="L1857">    return activeAcl;</span>
  }

  private JValue getJsonStream(Stream stream) {
<span class="nc" id="L1861">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1862" title="All 2 branches missed.">    if (stream instanceof AudioStream) {</span>
<span class="nc" id="L1863">      AudioStream audioStream = (AudioStream) stream;</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">      if (audioStream.getBitDepth() != null)</span>
<span class="nc" id="L1865">        fields.add(f(&quot;bitdepth&quot;, v(audioStream.getBitDepth())));</span>
<span class="nc bnc" id="L1866" title="All 2 branches missed.">      if (audioStream.getBitRate() != null)</span>
<span class="nc" id="L1867">        fields.add(f(&quot;bitrate&quot;, v(audioStream.getBitRate())));</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">      if (audioStream.getCaptureDevice() != null)</span>
<span class="nc" id="L1869">        fields.add(f(&quot;capturedevice&quot;, v(audioStream.getCaptureDevice())));</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">      if (audioStream.getCaptureDeviceVendor() != null)</span>
<span class="nc" id="L1871">        fields.add(f(&quot;capturedevicevendor&quot;, v(audioStream.getCaptureDeviceVendor())));</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">      if (audioStream.getCaptureDeviceVersion() != null)</span>
<span class="nc" id="L1873">        fields.add(f(&quot;capturedeviceversion&quot;, v(audioStream.getCaptureDeviceVersion())));</span>
<span class="nc bnc" id="L1874" title="All 2 branches missed.">      if (audioStream.getChannels() != null)</span>
<span class="nc" id="L1875">        fields.add(f(&quot;channels&quot;, v(audioStream.getChannels())));</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">      if (audioStream.getEncoderLibraryVendor() != null)</span>
<span class="nc" id="L1877">        fields.add(f(&quot;encoderlibraryvendor&quot;, v(audioStream.getEncoderLibraryVendor())));</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">      if (audioStream.getFormat() != null)</span>
<span class="nc" id="L1879">        fields.add(f(&quot;format&quot;, v(audioStream.getFormat())));</span>
<span class="nc bnc" id="L1880" title="All 2 branches missed.">      if (audioStream.getFormatVersion() != null)</span>
<span class="nc" id="L1881">        fields.add(f(&quot;formatversion&quot;, v(audioStream.getFormatVersion())));</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">      if (audioStream.getFrameCount() != null)</span>
<span class="nc" id="L1883">        fields.add(f(&quot;framecount&quot;, v(audioStream.getFrameCount())));</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">      if (audioStream.getIdentifier() != null)</span>
<span class="nc" id="L1885">        fields.add(f(&quot;identifier&quot;, v(audioStream.getIdentifier())));</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">      if (audioStream.getPkLevDb() != null)</span>
<span class="nc" id="L1887">        fields.add(f(&quot;pklevdb&quot;, v(audioStream.getPkLevDb())));</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">      if (audioStream.getRmsLevDb() != null)</span>
<span class="nc" id="L1889">        fields.add(f(&quot;rmslevdb&quot;, v(audioStream.getRmsLevDb())));</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">      if (audioStream.getRmsPkDb() != null)</span>
<span class="nc" id="L1891">        fields.add(f(&quot;rmspkdb&quot;, v(audioStream.getRmsPkDb())));</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">      if (audioStream.getSamplingRate() != null)</span>
<span class="nc" id="L1893">        fields.add(f(&quot;samplingrate&quot;, v(audioStream.getSamplingRate())));</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">    } else if (stream instanceof VideoStream) {</span>
<span class="nc" id="L1895">      VideoStream videoStream = (VideoStream) stream;</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">      if (videoStream.getBitRate() != null)</span>
<span class="nc" id="L1897">        fields.add(f(&quot;bitrate&quot;, v(videoStream.getBitRate())));</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">      if (videoStream.getCaptureDevice() != null)</span>
<span class="nc" id="L1899">        fields.add(f(&quot;capturedevice&quot;, v(videoStream.getCaptureDevice())));</span>
<span class="nc bnc" id="L1900" title="All 2 branches missed.">      if (videoStream.getCaptureDeviceVendor() != null)</span>
<span class="nc" id="L1901">        fields.add(f(&quot;capturedevicevendor&quot;, v(videoStream.getCaptureDeviceVendor())));</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">      if (videoStream.getCaptureDeviceVersion() != null)</span>
<span class="nc" id="L1903">        fields.add(f(&quot;capturedeviceversion&quot;, v(videoStream.getCaptureDeviceVersion())));</span>
<span class="nc bnc" id="L1904" title="All 2 branches missed.">      if (videoStream.getEncoderLibraryVendor() != null)</span>
<span class="nc" id="L1905">        fields.add(f(&quot;encoderlibraryvendor&quot;, v(videoStream.getEncoderLibraryVendor())));</span>
<span class="nc bnc" id="L1906" title="All 2 branches missed.">      if (videoStream.getFormat() != null)</span>
<span class="nc" id="L1907">        fields.add(f(&quot;format&quot;, v(videoStream.getFormat())));</span>
<span class="nc bnc" id="L1908" title="All 2 branches missed.">      if (videoStream.getFormatVersion() != null)</span>
<span class="nc" id="L1909">        fields.add(f(&quot;formatversion&quot;, v(videoStream.getFormatVersion())));</span>
<span class="nc bnc" id="L1910" title="All 2 branches missed.">      if (videoStream.getFrameCount() != null)</span>
<span class="nc" id="L1911">        fields.add(f(&quot;framecount&quot;, v(videoStream.getFrameCount())));</span>
<span class="nc bnc" id="L1912" title="All 2 branches missed.">      if (videoStream.getFrameHeight() != null)</span>
<span class="nc" id="L1913">        fields.add(f(&quot;frameheight&quot;, v(videoStream.getFrameHeight())));</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">      if (videoStream.getFrameRate() != null)</span>
<span class="nc" id="L1915">        fields.add(f(&quot;framerate&quot;, v(videoStream.getFrameRate())));</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">      if (videoStream.getFrameWidth() != null)</span>
<span class="nc" id="L1917">        fields.add(f(&quot;framewidth&quot;, v(videoStream.getFrameWidth())));</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">      if (videoStream.getIdentifier() != null)</span>
<span class="nc" id="L1919">        fields.add(f(&quot;identifier&quot;, v(videoStream.getIdentifier())));</span>
<span class="nc bnc" id="L1920" title="All 2 branches missed.">      if (videoStream.getScanOrder() != null)</span>
<span class="nc" id="L1921">        fields.add(f(&quot;scanorder&quot;, v(videoStream.getScanOrder().toString())));</span>
<span class="nc bnc" id="L1922" title="All 2 branches missed.">      if (videoStream.getScanType() != null)</span>
<span class="nc" id="L1923">        fields.add(f(&quot;scantype&quot;, v(videoStream.getScanType().toString())));</span>
    }
<span class="nc" id="L1925">    return obj(fields);</span>
  }

  private String getEventUrl(String eventId) {
<span class="nc" id="L1929">    return UrlSupport.concat(endpointBaseUrl, eventId);</span>
  }

  @GET
  @Path(&quot;{eventId}/scheduling&quot;)
  @Produces({ ApiMediaType.JSON, ApiMediaType.VERSION_1_1_0, ApiMediaType.VERSION_1_2_0, ApiMediaType.VERSION_1_3_0,
              ApiMediaType.VERSION_1_4_0, ApiMediaType.VERSION_1_5_0, ApiMediaType.VERSION_1_6_0,
              ApiMediaType.VERSION_1_7_0, ApiMediaType.VERSION_1_8_0, ApiMediaType.VERSION_1_9_0,
              ApiMediaType.VERSION_1_10_0, ApiMediaType.VERSION_1_11_0 })
  @RestQuery(name = &quot;geteventscheduling&quot;, description = &quot;Returns an event's scheduling information.&quot;, returnDescription = &quot;&quot;, pathParameters = {
      @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
      @RestResponse(description = &quot;The scheduling information for the specified event is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;The specified event has no scheduling information.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
      @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventScheduling(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
      throws Exception {
    try {
<span class="fc" id="L1946">      final Opt&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>

<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">      if (event.isNone()) {</span>
<span class="nc" id="L1949">        return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
      }

<span class="fc" id="L1952">      final JObject scheduling = SchedulingInfo.of(event.get().getIdentifier(), schedulerService).toJson();</span>
<span class="pc bpc" id="L1953" title="1 of 2 branches missed.">      if (!scheduling.isEmpty()) {</span>
<span class="fc" id="L1954">        return ApiResponseBuilder.Json.ok(acceptHeader, scheduling);</span>
      }
<span class="nc" id="L1956">      return Response.noContent().build();</span>
<span class="nc" id="L1957">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1958">      logger.error(&quot;Unable to get list of publications from event with id '{}'&quot;, id, e);</span>
<span class="nc" id="L1959">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @PUT
  @Path(&quot;{eventId}/scheduling&quot;)
  @Produces({ ApiMediaType.JSON, ApiMediaType.VERSION_1_1_0, ApiMediaType.VERSION_1_2_0, ApiMediaType.VERSION_1_3_0,
              ApiMediaType.VERSION_1_4_0, ApiMediaType.VERSION_1_5_0, ApiMediaType.VERSION_1_6_0,
              ApiMediaType.VERSION_1_7_0, ApiMediaType.VERSION_1_8_0, ApiMediaType.VERSION_1_9_0,
              ApiMediaType.VERSION_1_10_0, ApiMediaType.VERSION_1_11_0 })
  @RestQuery(name = &quot;updateeventscheduling&quot;, description = &quot;Update an event's scheduling information.&quot;, returnDescription = &quot;&quot;, pathParameters = {
      @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = Type.STRING) }, restParameters = {
      @RestParameter(name = &quot;scheduling&quot;, isRequired = true, description = &quot;Scheduling Information&quot;, type = Type.STRING),
      @RestParameter(name = &quot;allowConflict&quot;, description = &quot;Allow conflicts when updating scheduling&quot;, isRequired = false, type = Type.BOOLEAN) }, responses = {
      @RestResponse(description = &quot;The  scheduling information for the specified event is updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
      @RestResponse(description = &quot;The specified event has no scheduling information to update.&quot;, responseCode = HttpServletResponse.SC_NOT_ACCEPTABLE),
      @RestResponse(description = &quot;The scheduling information could not be updated due to a conflict.&quot;, responseCode = HttpServletResponse.SC_CONFLICT),
      @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventScheduling(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
                                 @FormParam(&quot;scheduling&quot;) String scheduling,
                                 @FormParam(&quot;allowConflict&quot;) @DefaultValue(&quot;false&quot;) boolean allowConflict) throws Exception {
<span class="fc" id="L1980">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="fc" id="L1981">    final Opt&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>

<span class="pc bpc" id="L1983" title="1 of 2 branches missed.">    if (requestedVersion.isSmallerThan(ApiVersion.VERSION_1_2_0)) {</span>
<span class="nc" id="L1984">        allowConflict = false;</span>
    }
<span class="pc bpc" id="L1986" title="1 of 2 branches missed.">    if (event.isNone()) {</span>
<span class="nc" id="L1987">      return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
    }
<span class="fc" id="L1989">    final JSONParser parser = new JSONParser();</span>
    JSONObject parsedJson;
    try {
<span class="fc" id="L1992">       parsedJson = (JSONObject) parser.parse(scheduling);</span>
<span class="nc" id="L1993">    } catch (ParseException e) {</span>
<span class="nc" id="L1994">      logger.debug(&quot;Client sent unparsable scheduling information for event {}: {}&quot;, id, scheduling);</span>
<span class="nc" id="L1995">      return RestUtil.R.badRequest(&quot;Unparsable scheduling information&quot;);</span>
<span class="fc" id="L1996">    }</span>
<span class="fc" id="L1997">    Optional&lt;Response&gt; clientError = updateSchedulingInformation(parsedJson, id, requestedVersion, allowConflict);</span>
<span class="fc" id="L1998">    return clientError.orElse(Response.noContent().build());</span>
  }

  private Optional&lt;Response&gt; updateSchedulingInformation(
      JSONObject parsedScheduling,
      String id,
      ApiVersion requestedVersion,
      boolean allowConflict) throws Exception {

    SchedulingInfo schedulingInfo;
    try {
<span class="fc" id="L2009">      schedulingInfo = SchedulingInfo.of(parsedScheduling);</span>
<span class="nc" id="L2010">    } catch (DateTimeParseException e) {</span>
<span class="nc" id="L2011">      logger.debug(&quot;Client sent unparsable start or end date for event {}&quot;, id);</span>
<span class="nc" id="L2012">      return Optional.of(RestUtil.R.badRequest(&quot;Unparsable date in scheduling information&quot;));</span>
<span class="fc" id="L2013">    }</span>
<span class="fc" id="L2014">    final TechnicalMetadata technicalMetadata = schedulerService.getTechnicalMetadata(id);</span>

    // When &quot;inputs&quot; is updated, capture agent configuration needs to be merged
<span class="fc" id="L2017">    Optional&lt;Map&lt;String, String&gt;&gt; caConfig = Optional.empty();</span>
<span class="pc bpc" id="L2018" title="1 of 2 branches missed.">    if (schedulingInfo.getInputs().isSome()) {</span>
<span class="fc" id="L2019">      final Map&lt;String, String&gt; configMap = new HashMap&lt;&gt;(technicalMetadata.getCaptureAgentConfiguration());</span>
<span class="fc" id="L2020">      configMap.put(CaptureParameters.CAPTURE_DEVICE_NAMES, schedulingInfo.getInputs().get());</span>
<span class="fc" id="L2021">      caConfig = Optional.of(configMap);</span>
    }

    try {
<span class="fc" id="L2025">      schedulerService.updateEvent(</span>
          id,
<span class="fc" id="L2027">          Optional.ofNullable(schedulingInfo.getStartDate().orNull()),</span>
<span class="fc" id="L2028">          Optional.ofNullable(schedulingInfo.getEndDate().orNull()),</span>
<span class="fc" id="L2029">          Optional.ofNullable(schedulingInfo.getAgentId().orNull()),</span>
<span class="fc" id="L2030">          Optional.empty(),</span>
<span class="fc" id="L2031">          Optional.empty(),</span>
<span class="fc" id="L2032">          Optional.empty(),</span>
          caConfig,
          allowConflict);
<span class="nc" id="L2035">    } catch (SchedulerConflictException e) {</span>
<span class="nc" id="L2036">      final List&lt;MediaPackage&gt; conflictingEvents = getConflictingEvents(</span>
<span class="nc" id="L2037">          schedulingInfo.merge(technicalMetadata), agentStateService, schedulerService);</span>
<span class="nc" id="L2038">      logger.debug(&quot;Client tried to change scheduling information causing a conflict for event {}.&quot;, id);</span>
<span class="nc" id="L2039">      return Optional.of(ApiResponseBuilder.Json.conflict(requestedVersion,</span>
<span class="nc" id="L2040">          arr(convertConflictingEvents(Optional.of(id), conflictingEvents, indexService, elasticsearchIndex))));</span>
<span class="fc" id="L2041">    }</span>
<span class="fc" id="L2042">    return Optional.empty();</span>
  }

  @POST
  @Path(&quot;{eventId}/track&quot;)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @RestQuery(name = &quot;updateFlavorWithTrack&quot;, description = &quot;Update an events track for a given flavor&quot;, returnDescription = &quot;&quot;,
          pathParameters = {
                  @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) },
          restParameters = {
                  @RestParameter(description = &quot;Flavor to add track to, e.g. captions/source&quot;,
                      isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
                  @RestParameter(description = &quot;Comma separated list of tags for the given track, e.g. archive,publish. &quot;
                      + &quot;If a 'lang:LANG-CODE' tag exists and overwriteExisting=true &quot;
                      + &quot;only tracks with same lang tag and flavor will be replaced. This behavior is used for captions.&quot;,
                      isRequired = false, name = &quot;tags&quot;, type = RestParameter.Type.STRING),
                  @RestParameter(description = &quot;If true, all other tracks in the specified flavor are REMOVED. &quot;
                      + &quot;If tags argument contains a lang:LANG-CODE tag, only elements with same tag would be removed.&quot;,
                      isRequired = true, name = &quot;overwriteExisting&quot;, type = RestParameter.Type.BOOLEAN),
                  @RestParameter(description = &quot;The track file&quot;, isRequired = true, name = &quot;track&quot;, type = RestParameter.Type.FILE),
          },
          responses = {
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND),
                  @RestResponse(description = &quot;The track has been added to the event.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The request is invalid or inconsistent.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          })
  public Response updateFlavorWithTrack(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @Context HttpServletRequest request) {
<span class="fc" id="L2070">    logger.debug(&quot;updateFlavorWithTrack called&quot;);</span>
    try {
<span class="fc" id="L2072">      boolean overwriteExisting = false;</span>
<span class="fc" id="L2073">      MediaPackageElementFlavor tmpFlavor = MediaPackageElementFlavor.parseFlavor(&quot;addTrack/temporary&quot;);</span>
<span class="fc" id="L2074">      MediaPackageElementFlavor newFlavor = null;</span>
      Opt&lt;Event&gt; event;
<span class="fc" id="L2076">      List&lt;String&gt; tags = null;</span>
<span class="fc" id="L2077">      String langTag = null;</span>

      try {
<span class="fc" id="L2080">        event = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc" id="L2081">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L2082">        return RestUtil.R.badRequest(String.format(&quot;Error while searching for event with id %s; %s&quot;, id, e.getMessage()));</span>
<span class="fc" id="L2083">      }</span>

<span class="pc bpc" id="L2085" title="1 of 2 branches missed.">      if (event.isNone()) {</span>
<span class="nc" id="L2086">        return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
      }
<span class="fc" id="L2088">      MediaPackage mp = indexService.getEventMediapackage(event.get());</span>

      try {
<span class="pc bpc" id="L2091" title="1 of 2 branches missed.">        if (workflowService.mediaPackageHasActiveWorkflows(mp.getIdentifier().toString())) {</span>
<span class="nc" id="L2092">          return RestUtil.R.conflict(String.format(&quot;Cannot update while a workflow is running on event '%s'&quot;, id));</span>
        }
<span class="nc" id="L2094">      } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L2095">        return RestUtil.R.serverError();</span>
<span class="fc" id="L2096">      }</span>

<span class="pc bpc" id="L2098" title="1 of 2 branches missed.">      if (!ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L2099">        throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
      }
<span class="fc bfc" id="L2101" title="All 2 branches covered.">      for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="fc" id="L2102">        FileItemStream item = iter.next();</span>
<span class="fc" id="L2103">        String fieldName = item.getFieldName();</span>
<span class="fc bfc" id="L2104" title="All 2 branches covered.">        if (item.isFormField()) {</span>
<span class="fc bfc" id="L2105" title="All 2 branches covered.">          if (&quot;flavor&quot;.equals(fieldName)) {</span>
<span class="fc" id="L2106">            String flavorString = Streams.asString(item.openStream());</span>
            try {
<span class="fc" id="L2108">              newFlavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>
<span class="nc" id="L2109">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L2110">              return RestUtil.R.badRequest(String.format(&quot;Could not parse flavor %s; %s&quot;, flavorString, e.getMessage()));</span>
<span class="fc" id="L2111">            }</span>
<span class="pc bpc" id="L2112" title="1 of 2 branches missed.">          } else if (&quot;tags&quot;.equals(fieldName)) {</span>
<span class="nc" id="L2113">            String tagsString = Streams.asString(item.openStream());</span>
<span class="nc bnc" id="L2114" title="All 2 branches missed.">            if (StringUtils.isNotBlank(tagsString)) {</span>
<span class="nc" id="L2115">              tags = List.of(StringUtils.split(tagsString, ','));</span>
              // find lang tag if exists
<span class="nc bnc" id="L2117" title="All 2 branches missed.">              for (String tag : tags) {</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">                if (StringUtils.startsWith(StringUtils.trimToEmpty(tag), &quot;lang:&quot;)) {</span>
                  // lang tag is set
<span class="nc" id="L2120">                  langTag = StringUtils.trimToEmpty(tag);</span>
<span class="nc" id="L2121">                  break;</span>
                }
<span class="nc" id="L2123">              }</span>
            }
<span class="pc bpc" id="L2125" title="1 of 2 branches missed.">          } else if (&quot;overwriteExisting&quot;.equals(fieldName)) {</span>
<span class="fc" id="L2126">            overwriteExisting = Boolean.parseBoolean(Streams.asString(item.openStream()));</span>
          }
        } else {
          // Add track with temporary flavor
<span class="pc bpc" id="L2130" title="1 of 2 branches missed.">          if (&quot;track&quot;.equals(item.getFieldName())) {</span>
<span class="fc" id="L2131">            mp = ingestService.addTrack(item.openStream(), item.getName(), tmpFlavor, mp);</span>
          }
        }
<span class="fc" id="L2134">      }</span>

<span class="pc bpc" id="L2136" title="1 of 2 branches missed.">      if (overwriteExisting) {</span>
        // remove existing attachments of the new flavor
<span class="fc" id="L2138">        Track[] existing = mp.getTracks(newFlavor);</span>
<span class="pc bpc" id="L2139" title="1 of 2 branches missed.">        for (int i = 0; i &lt; existing.length; i++) {</span>
          // if lang tag is set, remove only matching elements
<span class="nc bnc" id="L2141" title="All 4 branches missed.">          if (null == langTag || existing[i].containsTag(langTag)) {</span>
<span class="nc" id="L2142">            mp.remove(existing[i]);</span>
<span class="nc" id="L2143">            logger.debug(&quot;Overwriting existing asset {} {}&quot;, tmpFlavor, newFlavor);</span>
          }
        }
      }
      // correct the flavor of the new attachment
<span class="fc bfc" id="L2148" title="All 2 branches covered.">      for (Track track : mp.getTracks(tmpFlavor)) {</span>
<span class="fc" id="L2149">        track.setFlavor(newFlavor);</span>
<span class="pc bpc" id="L2150" title="1 of 2 branches missed.">        if (null != tags) {</span>
<span class="nc bnc" id="L2151" title="All 2 branches missed.">          for (String tag : tags) {</span>
<span class="nc" id="L2152">            track.addTag(tag);</span>
<span class="nc" id="L2153">          }</span>
        }
      }
<span class="fc" id="L2156">      logger.debug(&quot;Updated asset {} {}&quot;, tmpFlavor, newFlavor);</span>

      try {
<span class="fc" id="L2159">        assetManager.takeSnapshot(mp);</span>
<span class="nc" id="L2160">      } catch (AssetManagerException e) {</span>
<span class="nc" id="L2161">        logger.error(&quot;Error while adding the updated media package ({}) to the archive&quot;, mp.getIdentifier(), e);</span>
<span class="nc" id="L2162">        return RestUtil.R.badRequest(e.getMessage());</span>
<span class="fc" id="L2163">      }</span>

<span class="fc" id="L2165">      return Response.status(Status.OK).build();</span>
<span class="nc" id="L2166">    } catch (IllegalArgumentException | IOException | FileUploadException | IndexServiceException | IngestException</span>
            | MediaPackageException e) {
<span class="nc" id="L2168">      return RestUtil.R.badRequest(String.format(&quot;Could not add track: %s&quot;, e.getMessage()));</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>