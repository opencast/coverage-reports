<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SearchResult.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-search-service-api</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.search.api</a> &gt; <span class="el_source">SearchResult.java</span></div><h1>SearchResult.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.search.api;

import org.opencastproject.mediapackage.EName;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.MediaPackageParser;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreValue;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.metadata.dublincore.OpencastDctermsDublinCore;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;

import com.google.gson.Gson;

import org.elasticsearch.index.mapper.DateFieldMapper;

import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class SearchResult {

  public static final String TYPE = &quot;type&quot;;
  public static final String MEDIAPACKAGE = &quot;mediapackage&quot;;
  public static final String MEDIAPACKAGE_XML = &quot;mediapackage_xml&quot;;
  public static final String DUBLINCORE = &quot;dc&quot;;
  public static final String ORG = &quot;org&quot;;
  public static final String MODIFIED_DATE = &quot;modified&quot;;
  public static final String DELETED_DATE = &quot;deleted&quot;;
  public static final String INDEX_ACL = &quot;searchable_acl&quot;;
  public static final String REST_ACL = &quot;acl&quot;;

<span class="nc" id="L64">  private static final Gson gson = new Gson();</span>

  private SearchService.IndexEntryType type;

  private MediaPackage mp;

  private DublinCoreCatalog dublinCore;

  private AccessControlList acl;

  private String orgId;

<span class="nc" id="L76">  private String id = null;</span>

<span class="nc" id="L78">  private Instant modified = null;</span>

<span class="nc" id="L80">  private Instant deleted = null;</span>

  public SearchResult(SearchService.IndexEntryType type, DublinCoreCatalog dc, AccessControlList acl,
<span class="nc" id="L83">          String orgId, MediaPackage mp, Instant modified, Instant deleted) {</span>
<span class="nc" id="L84">    this.type = type;</span>
<span class="nc" id="L85">    this.dublinCore = dc;</span>
<span class="nc" id="L86">    this.acl = acl;</span>
<span class="nc" id="L87">    this.orgId = orgId;</span>
<span class="nc" id="L88">    this.mp = mp;</span>
<span class="nc" id="L89">    this.deleted = deleted;</span>
<span class="nc" id="L90">    this.modified = modified;</span>

<span class="nc bnc" id="L92" title="All 2 branches missed.">    if (SearchService.IndexEntryType.Episode.equals(type)) {</span>
<span class="nc" id="L93">      this.id = this.getMediaPackage().getIdentifier().toString();</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">    } else if (SearchService.IndexEntryType.Series.equals(type)) {</span>
<span class="nc" id="L95">      this.id = this.dublinCore.getFirst(DublinCore.PROPERTY_IDENTIFIER);</span>
    }
<span class="nc" id="L97">  }</span>

  public Date getModifiedDate() {
<span class="nc" id="L100">    return new Date(this.modified.toEpochMilli());</span>
  }

  public String getId() {
<span class="nc" id="L104">    return this.id;</span>
  }

  public Date getDeletionDate() {
<span class="nc bnc" id="L108" title="All 2 branches missed.">    return null == this.deleted ? null : new Date(this.deleted.toEpochMilli());</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public static SearchResult rehydrate(Map&lt;String, Object&gt; data) throws SearchException {
    //Our sole parameter here is a map containing a mix of string:string pairs, and String:Map&lt;String, Object&gt; pairs

    try {
      // We're *really* hoping that no one feeds us things that aren't what we expect
      // but ES results come back in json, and get turned into multi-layered Maps
<span class="nc" id="L118">      SearchService.IndexEntryType type = SearchService.IndexEntryType.valueOf((String) data.get(TYPE));</span>
<span class="nc" id="L119">      DublinCoreCatalog dc = rehydrateDC(type, (Map&lt;String, Object&gt;) data.get(DUBLINCORE));</span>
<span class="nc" id="L120">      AccessControlList acl = rehydrateACL((Map&lt;String, Object&gt;) data.get(INDEX_ACL));</span>
<span class="nc" id="L121">      String org = (String) data.get(ORG);</span>

<span class="nc" id="L123">      Instant deleted = null;</span>
<span class="nc bnc" id="L124" title="All 4 branches missed.">      if (data.containsKey(DELETED_DATE) &amp;&amp; null != data.get(DELETED_DATE)) {</span>
<span class="nc" id="L125">        deleted = Instant.parse((String) data.get(DELETED_DATE));</span>
      }

<span class="nc" id="L128">      Instant modified = null;</span>
<span class="nc bnc" id="L129" title="All 4 branches missed.">      if (data.containsKey(MODIFIED_DATE) &amp;&amp; !data.get(MODIFIED_DATE).equals(&quot;null&quot;)) {</span>
<span class="nc" id="L130">        modified = Instant.parse((String) data.get(MODIFIED_DATE));</span>
      }


<span class="nc" id="L134">      MediaPackage mp = null;</span>
      //There had better be a mediapackage with an episode...
<span class="nc bnc" id="L136" title="All 2 branches missed.">      if (SearchService.IndexEntryType.Episode.equals(type)) {</span>
<span class="nc" id="L137">        mp = MediaPackageParser.getFromXml((String) data.get(MEDIAPACKAGE_XML));</span>
      }
<span class="nc" id="L139">      return new SearchResult(type, dc, acl, org, mp, modified, deleted);</span>
<span class="nc" id="L140">    } catch (MediaPackageException e) {</span>
<span class="nc" id="L141">      throw new SearchException(e);</span>
    }
  }

  public static Map&lt;String, List&lt;String&gt;&gt; dehydrateDC(DublinCoreCatalog dublinCoreCatalog) {
<span class="nc" id="L146">    var metadata = new HashMap&lt;String, List&lt;String&gt;&gt;();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    for (var entry : dublinCoreCatalog.getValues().entrySet()) {</span>
<span class="nc" id="L148">      var key = entry.getKey().getLocalName();</span>
<span class="nc" id="L149">      var values = entry.getValue().stream()</span>
<span class="nc" id="L150">              .map(DublinCoreValue::getValue)</span>
<span class="nc" id="L151">              .map(val -&gt; {</span>
                // Normalize `created` field: we want it to be in ISO 8601 format in UTC.
<span class="nc bnc" id="L153" title="All 2 branches missed.">                if (entry.getKey().equals(DublinCore.PROPERTY_CREATED)) {</span>
<span class="nc" id="L154">                  var date = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(val);</span>
<span class="nc" id="L155">                  return DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.withZone(ZoneOffset.UTC).format(date);</span>
                } else {
<span class="nc" id="L157">                  return val;</span>
                }
              })
<span class="nc" id="L160">              .collect(Collectors.toList());</span>
<span class="nc" id="L161">      metadata.put(key, values);</span>
<span class="nc" id="L162">    }</span>

<span class="nc" id="L164">    return metadata;</span>
  }

  /**
   * Simplify ACL structure, so we can easily search by action.
   * @param acl The access control List to restructure
   * @return Restructured ACL
   */
  public static Map&lt;String, Set&lt;String&gt;&gt; dehydrateAclForIndex(AccessControlList acl) {
<span class="nc" id="L173">    var result = new HashMap&lt;String, Set&lt;String&gt;&gt;();</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">    for (var entry : acl.getEntries()) {</span>
<span class="nc" id="L175">      var action = entry.getAction();</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">      if (!result.containsKey(action)) {</span>
<span class="nc" id="L177">        result.put(action, new HashSet&lt;&gt;());</span>
      }
<span class="nc" id="L179">      result.get(action).add(entry.getRole());</span>
<span class="nc" id="L180">    }</span>
<span class="nc" id="L181">    return result;</span>
  }

  public static List&lt;Map&lt;String, ?&gt;&gt; dehydrateAclForREST(AccessControlList acl) {
<span class="nc" id="L185">    return acl.getEntries().stream()</span>
<span class="nc" id="L186">        .map(ace -&gt; Map.of(&quot;action&quot;, ace.getAction(), &quot;role&quot;, ace.getRole(), &quot;allow&quot;, Boolean.TRUE))</span>
<span class="nc" id="L187">        .collect(Collectors.toList());</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public static AccessControlList rehydrateACL(Map&lt;String, Object&gt; map) {
<span class="nc" id="L192">    List&lt;AccessControlEntry&gt; aces = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">    for (var entry : map.entrySet()) {</span>
<span class="nc" id="L194">      String action = entry.getKey();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      for (String rolename : (List&lt;String&gt;)  entry.getValue()) {</span>
<span class="nc" id="L196">        AccessControlEntry ace = new AccessControlEntry(rolename, action, true);</span>
<span class="nc" id="L197">        aces.add(ace);</span>
<span class="nc" id="L198">      }</span>
<span class="nc" id="L199">    }</span>
<span class="nc" id="L200">    return new AccessControlList(aces);</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public static DublinCoreCatalog rehydrateDC(SearchService.IndexEntryType type, Map&lt;String, Object&gt; map)
          throws SearchException {
    OpencastDctermsDublinCore dc;
<span class="nc bnc" id="L207" title="All 2 branches missed.">    if (SearchService.IndexEntryType.Episode.equals(type)) {</span>
<span class="nc" id="L208">      dc = DublinCores.mkOpencastEpisode();</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">    } else if (SearchService.IndexEntryType.Series.equals(type)) {</span>
<span class="nc" id="L210">      dc = DublinCores.mkOpencastSeries();</span>
    } else {
<span class="nc" id="L212">      throw new SearchException(&quot;Unknown DC type!&quot;);</span>
    }
<span class="nc bnc" id="L214" title="All 2 branches missed.">    for (var entry: map.entrySet()) {</span>
<span class="nc" id="L215">      String key = entry.getKey();</span>
      //This is *always* a list, per dehydrateACL
<span class="nc" id="L217">      List&lt;String&gt; value = (List&lt;String&gt;) entry.getValue();</span>
<span class="nc" id="L218">      dc.set(EName.mk(DublinCore.TERMS_NS_URI, key), value);</span>
<span class="nc" id="L219">    }</span>
<span class="nc" id="L220">    return dc.getCatalog();</span>
  }

  public Map&lt;String, Object&gt; dehydrateForIndex() {
<span class="nc" id="L224">    return dehydrate().entrySet().stream()</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        .filter(entry -&gt; !entry.getKey().equals(REST_ACL))</span>
<span class="nc" id="L226">        .collect(HashMap::new, (m,v)-&gt;m.put(v.getKey(), v.getValue()), HashMap::putAll);</span>
  }

  public Map&lt;String, Object&gt; dehydrateForREST() {
<span class="nc" id="L230">    return dehydrate().entrySet().stream()</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        .filter(entry -&gt; !entry.getKey().equals(INDEX_ACL))</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        .filter(entry -&gt; !entry.getKey().equals(MEDIAPACKAGE_XML))</span>
<span class="nc" id="L233">        .collect(HashMap::new, (m,v)-&gt;m.put(v.getKey(), v.getValue()), HashMap::putAll);</span>
  }

  public Map&lt;String, Object&gt; dehydrate() {
<span class="nc bnc" id="L237" title="All 2 branches missed.">    if (SearchService.IndexEntryType.Episode.equals(getType())) {</span>
<span class="nc" id="L238">      return dehydrateEpisode();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">    } else if (SearchService.IndexEntryType.Series.equals(getType())) {</span>
<span class="nc" id="L240">      return dehydrateSeries();</span>
    }
<span class="nc" id="L242">    return null;</span>
  }

  public Map&lt;String, Object&gt; dehydrateEpisode() {

<span class="nc" id="L247">    var ret = new HashMap&lt;&gt;(Map.of(</span>
<span class="nc" id="L248">        MEDIAPACKAGE, gson.fromJson(MediaPackageParser.getAsJSON(this.mp), Map.class).get(MEDIAPACKAGE),</span>
<span class="nc" id="L249">        MEDIAPACKAGE_XML, MediaPackageParser.getAsXml(this.mp),</span>
<span class="nc" id="L250">        INDEX_ACL, SearchResult.dehydrateAclForIndex(acl),</span>
<span class="nc" id="L251">        REST_ACL, SearchResult.dehydrateAclForREST(acl),</span>
<span class="nc" id="L252">        DUBLINCORE, SearchResult.dehydrateDC(this.dublinCore),</span>
        ORG, this.orgId,
<span class="nc" id="L254">        TYPE, this.type.name(),</span>
<span class="nc" id="L255">        MODIFIED_DATE, DateTimeFormatter.ISO_INSTANT.format(this.modified)));</span>

<span class="nc bnc" id="L257" title="All 2 branches missed.">    ret.put(DELETED_DATE, null == this.deleted ? null : DateTimeFormatter.ISO_INSTANT.format(this.deleted));</span>

<span class="nc" id="L259">    return ret;</span>
  }

  public Map&lt;String, Object&gt; dehydrateSeries() {

<span class="nc" id="L264">    var ret = new HashMap&lt;&gt;(Map.of(</span>
<span class="nc" id="L265">        INDEX_ACL, SearchResult.dehydrateAclForIndex(acl),</span>
<span class="nc" id="L266">        REST_ACL, SearchResult.dehydrateAclForREST(acl),</span>
<span class="nc" id="L267">        DUBLINCORE, SearchResult.dehydrateDC(this.dublinCore),</span>
        ORG, this.orgId,
<span class="nc" id="L269">        TYPE, this.type.name(),</span>
<span class="nc" id="L270">        MODIFIED_DATE, DateTimeFormatter.ISO_INSTANT.format(this.modified)));</span>

<span class="nc bnc" id="L272" title="All 2 branches missed.">    ret.put(DELETED_DATE, null == this.deleted ? null : DateTimeFormatter.ISO_INSTANT.format(this.deleted));</span>

<span class="nc" id="L274">    return ret;</span>
  }

  public DublinCoreCatalog getDublinCore() {
<span class="nc" id="L278">    return this.dublinCore;</span>
  }

  public AccessControlList getAcl() {
<span class="nc" id="L282">    return acl;</span>
  }

  public MediaPackage getMediaPackage() {
<span class="nc" id="L286">    return mp;</span>
  }

  public SearchService.IndexEntryType getType() {
<span class="nc" id="L290">    return type;</span>
  }

  public Instant getCreatedDate() {
<span class="nc" id="L294">    var acc = DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(this.dublinCore.getFirst(DublinCore.PROPERTY_CREATED));</span>
<span class="nc" id="L295">    return Instant.from(acc);</span>
  }

  public String getOrgId() {
<span class="nc" id="L299">    return orgId;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>