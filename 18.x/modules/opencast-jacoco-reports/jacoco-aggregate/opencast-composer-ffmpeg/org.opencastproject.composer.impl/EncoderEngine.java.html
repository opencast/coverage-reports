<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EncoderEngine.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-composer-ffmpeg</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.composer.impl</a> &gt; <span class="el_source">EncoderEngine.java</span></div><h1>EncoderEngine.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */


package org.opencastproject.composer.impl;

import org.opencastproject.composer.api.EncoderException;
import org.opencastproject.composer.api.EncodingProfile;
import org.opencastproject.composer.api.VideoClip;
import org.opencastproject.mediapackage.AdaptivePlaylist;
import org.opencastproject.mediapackage.identifier.IdImpl;
import org.opencastproject.util.IoSupport;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.plexus.util.cli.CommandLineUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.activation.MimetypesFileTypeMap;

/**
 * Abstract base class for encoder engines.
 */
public class EncoderEngine implements AutoCloseable {

  /** The ffmpeg commandline suffix */
  static final String CMD_SUFFIX = &quot;ffmpeg.command&quot;;
  static final String ADAPTIVE_TYPE_SUFFIX = &quot;adaptive.type&quot;; // HLS only
  /** The trimming start time property name */
  static final String PROP_TRIMMING_START_TIME = &quot;trim.start&quot;;
  /** The trimming duration property name */
  static final String PROP_TRIMMING_DURATION = &quot;trim.duration&quot;;
  /** If true STDERR and STDOUT of the spawned process will be mixed so that both can be read via STDIN */
  private static final boolean REDIRECT_ERROR_STREAM = true;

<span class="fc" id="L78">  private static Logger logger = LoggerFactory.getLogger(EncoderEngine.class);</span>
  /** the encoder binary */
<span class="fc" id="L80">  private String binary = &quot;ffmpeg&quot;;</span>
  /** Set of processes to clean up */
<span class="fc" id="L82">  private Set&lt;Process&gt; processes = new HashSet&lt;&gt;();</span>

<span class="fc" id="L84">  private final Pattern outputPattern = Pattern.compile(&quot;Output .* (\\S+) to '(.*)':&quot;);</span>
  // ffmpeg4 generates HLS output files and may use a .tmp suffix while writing
<span class="fc" id="L86">  private final Pattern outputPatternHLS = Pattern.compile(&quot;Opening '([^']+)\\.tmp'|([^']+)' for writing&quot;);</span>

  // These are common video options that may be mapped in HLS streams. This will help catch some common mistakes
<span class="fc" id="L89">  private static List&lt;String&gt; mappableOptions = Stream.of(&quot;-bf&quot;, &quot;-b_strategy&quot;, &quot;-bitrate&quot;, &quot;-bufsize&quot;, &quot;-crf&quot;,</span>
         &quot;-f&quot;, &quot;-flags&quot;, &quot;-force_key_frames&quot;, &quot;-g&quot;, &quot;-level&quot;, &quot;-keyint&quot;, &quot;-keyint_min&quot;, &quot;-maxrate&quot;, &quot;-minrate&quot;,
         &quot;-pix_fmt&quot;, &quot;-preset&quot;, &quot;-profile&quot;,
         &quot;-r&quot;, &quot;-refs&quot;, &quot;-s&quot;, &quot;-sc_threshold&quot;, &quot;-tune&quot;, &quot;-x264opts&quot;, &quot;-x264-params&quot;)
<span class="fc" id="L93">         .collect(Collectors.toList());</span>

  /**
   * Creates a new abstract encoder engine with or without support for multiple job submission.
   */
<span class="fc" id="L98">  EncoderEngine(String binary) {</span>
<span class="fc" id="L99">    this.binary = binary;</span>
<span class="fc" id="L100">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see EncoderEngine#encode(File, EncodingProfile, Map)
   */
  File encode(File mediaSource, EncodingProfile format, Map&lt;String, String&gt; properties)
          throws EncoderException {
<span class="fc" id="L109">    List&lt;File&gt; output = process(Collections.singletonMap(&quot;video&quot;, mediaSource), format, properties);</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">    if (output.size() != 1) {</span>
<span class="nc" id="L111">      throw new EncoderException(String.format(&quot;Encode expects one output file (%s found)&quot;, output.size()));</span>
    }
<span class="fc" id="L113">    return output.get(0);</span>
  }

  /**
   * Extract several images from a video file.
   *
   * @param mediaSource
   *          File to extract images from
   * @param format
   *          Encoding profile to use for extraction
   * @param properties
   * @param times
   *          Times at which to extract the images
   * @return  List of image files
   * @throws EncoderException Something went wrong during image extraction
   */
  List&lt;File&gt; extract(File mediaSource, EncodingProfile format, Map&lt;String, String&gt; properties, double... times)
          throws EncoderException {

<span class="fc" id="L132">    List&lt;File&gt; extractedImages = new LinkedList&lt;&gt;();</span>
    try {
      // Extract one image if no times are specified
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">      if (times.length == 0) {</span>
<span class="nc" id="L136">        extractedImages.add(encode(mediaSource, format, properties));</span>
      }
<span class="fc bfc" id="L138" title="All 2 branches covered.">      for (double time : times) {</span>
<span class="fc" id="L139">        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (properties != null) {</span>
<span class="nc" id="L141">          params.putAll(properties);</span>
        }

<span class="fc" id="L144">        DecimalFormatSymbols ffmpegFormat = new DecimalFormatSymbols();</span>
<span class="fc" id="L145">        ffmpegFormat.setDecimalSeparator('.');</span>
<span class="fc" id="L146">        DecimalFormat df = new DecimalFormat(&quot;0.00000&quot;, ffmpegFormat);</span>
<span class="fc" id="L147">        params.put(&quot;time&quot;, df.format(time));</span>

<span class="fc" id="L149">        extractedImages.add(encode(mediaSource, format, params));</span>
      }
<span class="nc" id="L151">    } catch (Exception e) {</span>
<span class="nc" id="L152">      cleanup(extractedImages);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">      if (e instanceof EncoderException) {</span>
<span class="nc" id="L154">        throw (EncoderException) e;</span>
      } else {
<span class="nc" id="L156">        throw new EncoderException(&quot;Image extraction failed&quot;, e);</span>
      }
<span class="fc" id="L158">    }</span>

<span class="fc" id="L160">    return extractedImages;</span>
  }

  /**
   * Executes the command line encoder with the given set of files and properties and using the provided encoding
   * profile.
   *
   * @param source
   *          the source files for encoding
   * @param profile
   *          the profile identifier
   * @param properties
   *          the encoding properties to be interpreted by the actual encoder implementation
   * @return the processed file
   * @throws EncoderException
   *           if processing fails
   */
  List&lt;File&gt; process(Map&lt;String, File&gt; source, EncodingProfile profile, Map&lt;String, String&gt; properties)
          throws EncoderException {
    // Fist, update the parameters
<span class="fc" id="L180">    Map&lt;String, String&gt; params = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">    if (properties != null)</span>
<span class="fc" id="L182">      params.putAll(properties);</span>
    // build command
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">    if (source.isEmpty()) {</span>
<span class="nc" id="L185">      throw new IllegalArgumentException(&quot;At least one track must be specified.&quot;);</span>
    }
    // Set encoding parameters
<span class="fc bfc" id="L188" title="All 2 branches covered.">    for (Map.Entry&lt;String, File&gt; f: source.entrySet()) {</span>
<span class="fc" id="L189">      final String input = FilenameUtils.normalize(f.getValue().getAbsolutePath());</span>
<span class="fc" id="L190">      final String pre = &quot;in.&quot; + f.getKey();</span>
<span class="fc" id="L191">      params.put(pre + &quot;.path&quot;, input);</span>
<span class="fc" id="L192">      params.put(pre + &quot;.name&quot;, FilenameUtils.getBaseName(input));</span>
<span class="fc" id="L193">      params.put(pre + &quot;.suffix&quot;, FilenameUtils.getExtension(input));</span>
<span class="fc" id="L194">      params.put(pre + &quot;.filename&quot;, FilenameUtils.getName(input));</span>
<span class="fc" id="L195">      params.put(pre + &quot;.mimetype&quot;, MimetypesFileTypeMap.getDefaultFileTypeMap().getContentType(input));</span>
<span class="fc" id="L196">    }</span>
<span class="fc" id="L197">    final File parentFile = source.getOrDefault(&quot;video&quot;, source.getOrDefault(&quot;audio&quot;,</span>
<span class="fc" id="L198">        source.values().stream().findFirst().get()));</span>

<span class="fc" id="L200">    final String outDir = parentFile.getAbsoluteFile().getParent();</span>
<span class="fc" id="L201">    final String outFileName = FilenameUtils.getBaseName(parentFile.getName())</span>
<span class="fc" id="L202">            + &quot;_&quot; + UUID.randomUUID().toString();</span>
<span class="fc" id="L203">    params.put(&quot;out.dir&quot;, outDir);</span>
<span class="fc" id="L204">    params.put(&quot;out.name&quot;, outFileName);</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">    if (profile.getSuffix() != null) {</span>
<span class="fc" id="L206">      final String outSuffix = processParameters(profile.getSuffix(), params);</span>
<span class="fc" id="L207">      params.put(&quot;out.suffix&quot;, outSuffix);</span>
    }

<span class="fc bfc" id="L210" title="All 2 branches covered.">    for (String tag : profile.getTags()) {</span>
<span class="fc" id="L211">      final String suffix = processParameters(profile.getSuffix(tag), params);</span>
<span class="fc" id="L212">      params.put(&quot;out.suffix.&quot; + tag, suffix);</span>
<span class="fc" id="L213">    }</span>

    // create encoder process.
<span class="fc" id="L216">    final List&lt;String&gt; command = buildCommand(profile, params);</span>
<span class="fc" id="L217">    logger.info(&quot;Executing encoding command: {}&quot;, command);</span>

<span class="fc" id="L219">    List&lt;File&gt; outFiles = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L220">    BufferedReader in = null;</span>
<span class="fc" id="L221">    Process encoderProcess = null;</span>
    try {
<span class="fc" id="L223">      ProcessBuilder processBuilder = new ProcessBuilder(command);</span>
<span class="fc" id="L224">      processBuilder.redirectErrorStream(REDIRECT_ERROR_STREAM);</span>
<span class="fc" id="L225">      encoderProcess = processBuilder.start();</span>
<span class="fc" id="L226">      processes.add(encoderProcess);</span>

      // tell encoder listeners about output
<span class="fc" id="L229">      in = new BufferedReader(new InputStreamReader(encoderProcess.getInputStream()));</span>
      String line;
<span class="fc bfc" id="L231" title="All 2 branches covered.">      while ((line = in.readLine()) != null) {</span>
<span class="fc" id="L232">        handleEncoderOutput(outFiles, line);</span>
      }

      // wait until the task is finished
<span class="fc" id="L236">      int exitCode = encoderProcess.waitFor();</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">      if (exitCode != 0) {</span>
<span class="nc" id="L238">        throw new EncoderException(&quot;Encoder exited abnormally with status &quot; + exitCode);</span>
      }

<span class="fc" id="L241">      logger.info(&quot;Tracks {} successfully encoded using profile '{}'&quot;, source, profile.getIdentifier());</span>
<span class="fc" id="L242">      return outFiles;</span>
<span class="nc" id="L243">    } catch (Exception e) {</span>
<span class="nc" id="L244">      logger.warn(&quot;Error while encoding {}  using profile '{}'&quot;,</span>
<span class="nc" id="L245">              source, profile.getIdentifier(), e);</span>

      // Ensure temporary data are removed
<span class="nc bnc" id="L248" title="All 2 branches missed.">      for (File outFile : outFiles) {</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (FileUtils.deleteQuietly(outFile)) {</span>
<span class="nc" id="L250">          logger.debug(&quot;Removed output file of failed encoding process: {}&quot;, outFile);</span>
        }
<span class="nc" id="L252">      }</span>
<span class="nc" id="L253">      throw new EncoderException(e);</span>
    } finally {
<span class="fc" id="L255">      IoSupport.closeQuietly(in);</span>
<span class="fc" id="L256">      IoSupport.closeQuietly(encoderProcess);</span>
    }
  }

  /*
   * Runs the raw command string thru the encoder. The string commandopts is ffmpeg specific, it just needs the binary.
   * The calling function is responsible in doing all the appropriate substitutions using the encoding profiles,
   * creating the directory for storage, etc. Encoding profiles and input names are included here for logging and
   * returns
   *
   * @param commandopts - tokenized ffmpeg command
   *
   * @param inputs - input files in the command, used for reporting
   *
   * @param profiles - encoding profiles, used for reporting
   *
   * @return encoded - media as a result of running the command
   *
   * @throws EncoderException if it fails
   */

  protected List&lt;File&gt; process(List&lt;String&gt; commandopts) throws EncoderException {
<span class="fc" id="L278">    logger.trace(&quot;Process raw command -  {}&quot;, commandopts);</span>
    // create encoder process. using working dir of the
    // current java process
<span class="fc" id="L281">    Process encoderProcess = null;</span>
<span class="fc" id="L282">    BufferedReader in = null;</span>
<span class="fc" id="L283">    List&lt;File&gt; outFiles = new ArrayList&lt;&gt;();</span>
    try {
<span class="fc" id="L285">      List&lt;String&gt; command = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L286">      command.add(binary);</span>
<span class="fc" id="L287">      command.addAll(commandopts);</span>
<span class="fc" id="L288">      logger.info(&quot;Executing encoding command: {}&quot;, StringUtils.join(command, &quot; &quot;));</span>

<span class="fc" id="L290">      ProcessBuilder pbuilder = new ProcessBuilder(command);</span>
<span class="fc" id="L291">      pbuilder.redirectErrorStream(REDIRECT_ERROR_STREAM);</span>
<span class="fc" id="L292">      encoderProcess = pbuilder.start();</span>
      // tell encoder listeners about output
<span class="fc" id="L294">      in = new BufferedReader(new InputStreamReader(encoderProcess.getInputStream()));</span>
      String line;
<span class="fc bfc" id="L296" title="All 2 branches covered.">      while ((line = in.readLine()) != null) {</span>
<span class="fc" id="L297">        handleEncoderOutput(outFiles, line); // get names of output files</span>
      }
      // wait until the task is finished
<span class="fc" id="L300">      encoderProcess.waitFor();</span>
<span class="fc" id="L301">      int exitCode = encoderProcess.exitValue();</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">      if (exitCode != 0) {</span>
<span class="fc" id="L303">        throw new EncoderException(&quot;Encoder exited abnormally with status &quot; + exitCode);</span>
      }
<span class="fc" id="L305">      logger.info(&quot;Video track successfully encoded '{}'&quot;,</span>
<span class="fc" id="L306">              new Object[] { StringUtils.join(commandopts, &quot; &quot;) });</span>
<span class="fc" id="L307">      return outFiles; // return output as a list of files</span>
<span class="fc" id="L308">    } catch (Exception e) {</span>
<span class="fc" id="L309">      logger.warn(&quot;Error while encoding video tracks using '{}': {}&quot;,</span>
<span class="fc" id="L310">              new Object[] {  StringUtils.join(commandopts, &quot; &quot;), e.getMessage() });</span>
      // Ensure temporary data are removed
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">      for (File outFile : outFiles) {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (FileUtils.deleteQuietly(outFile)) {</span>
<span class="nc" id="L314">          logger.debug(&quot;Removed output file of failed encoding process: {}&quot;, outFile);</span>
        }
<span class="nc" id="L316">      }</span>
<span class="fc" id="L317">      throw new EncoderException(e);</span>
    } finally {
<span class="fc" id="L319">      IoSupport.closeQuietly(in);</span>
<span class="fc" id="L320">      IoSupport.closeQuietly(encoderProcess);</span>
    }
  }

  /**
   * Deletes all valid files found in a list
   *
   * @param outputFiles
   *          list containing files
   */
  private void cleanup(List&lt;File&gt; outputFiles) {
<span class="nc bnc" id="L331" title="All 2 branches missed.">    for (File file : outputFiles) {</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">      if (file != null &amp;&amp; file.isFile()) {</span>
<span class="nc" id="L333">        String path = file.getAbsolutePath();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (file.delete()) {</span>
<span class="nc" id="L335">          logger.info(&quot;Deleted file {}&quot;, path);</span>
        } else {
<span class="nc" id="L337">          logger.warn(&quot;Could not delete file {}&quot;, path);</span>
        }
      }
<span class="nc" id="L340">    }</span>
<span class="nc" id="L341">  }</span>

  /**
   * Creates the command that is sent to the commandline encoder.
   *
   * @return the commandline
   * @throws EncoderException
   *           in case of any error
   */
  private List&lt;String&gt; buildCommand(final EncodingProfile profile, final Map&lt;String, String&gt; argumentReplacements)
          throws EncoderException {
<span class="fc" id="L352">    List&lt;String&gt; command = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L353">    command.add(binary);</span>
<span class="fc" id="L354">    command.add(&quot;-nostdin&quot;);</span>
<span class="fc" id="L355">    command.add(&quot;-nostats&quot;);</span>

<span class="fc" id="L357">    String commandline = profile.getExtension(CMD_SUFFIX);</span>

    // Handle command line extensions before parsing:
    // Example:
    //   ffmpeg.command = #{concatCmd} -c copy out.mp4
    //   ffmpeg.command.concatCmd = -i ...
<span class="fc bfc" id="L363" title="All 2 branches covered.">    for (String key: argumentReplacements.keySet()) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">      if (key.startsWith(CMD_SUFFIX + '.')) {</span>
<span class="fc" id="L365">        final String shortKey = key.substring(CMD_SUFFIX.length() + 1);</span>
<span class="fc" id="L366">        commandline = commandline.replace(&quot;#{&quot; + shortKey + &quot;}&quot;, argumentReplacements.get(key));</span>
      }
<span class="fc" id="L368">    }</span>

<span class="fc" id="L370">    String processedCommandLine = processParameters(commandline, argumentReplacements);</span>
      try {
<span class="fc" id="L372">        command.addAll(Arrays.asList(CommandLineUtils.translateCommandline(processedCommandLine)));</span>
<span class="nc" id="L373">      } catch (Exception e) {</span>
<span class="nc" id="L374">        throw new EncoderException(&quot;Could not process encoding profile command line&quot;, e);</span>
<span class="fc" id="L375">      }</span>
<span class="fc" id="L376">    return command;</span>
  }

  /**
   * {@inheritDoc}
   *
   * @see EncoderEngine#trim(File,
   *      EncodingProfile, long, long, Map)
   */
  File trim(File mediaSource, EncodingProfile format, long start, long duration, Map&lt;String, String&gt; properties) throws EncoderException {
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">    if (properties == null)</span>
<span class="fc" id="L387">      properties = new HashMap&lt;&gt;();</span>
<span class="fc" id="L388">    double startD = (double) start / 1000;</span>
<span class="fc" id="L389">    double durationD = (double) duration / 1000;</span>
<span class="fc" id="L390">    DecimalFormatSymbols ffmpegFormat = new DecimalFormatSymbols();</span>
<span class="fc" id="L391">    ffmpegFormat.setDecimalSeparator('.');</span>
<span class="fc" id="L392">    DecimalFormat df = new DecimalFormat(&quot;00.00000&quot;, ffmpegFormat);</span>
<span class="fc" id="L393">    properties.put(PROP_TRIMMING_START_TIME, df.format(startD));</span>
<span class="fc" id="L394">    properties.put(PROP_TRIMMING_DURATION, df.format(durationD));</span>
<span class="fc" id="L395">    return encode(mediaSource, format, properties);</span>
  }

  /**
   * Processes the command options by replacing the templates with their actual values.
   *
   * @return the commandline
   */
  private String processParameters(String cmd, final Map&lt;String, String&gt; args) {
    // multi level templates handling
<span class="fc" id="L405">    String cmdBefore = null;</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">    while (!cmd.equals(cmdBefore)) {</span>
<span class="fc" id="L407">      cmdBefore = cmd;</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">      for (Map.Entry&lt;String, String&gt; e : args.entrySet()) {</span>
<span class="fc" id="L409">        cmd = cmd.replace(&quot;#{&quot; + e.getKey() + &quot;}&quot;, e.getValue());</span>
<span class="fc" id="L410">      }</span>
    }

    // Also replace spaces
<span class="fc" id="L414">    cmd = cmd.replace(&quot;#{space}&quot;, &quot; &quot;);</span>

    /* Remove unused commandline parts */
<span class="fc" id="L417">    return cmd.replaceAll(&quot;#\\{.*?\\}&quot;, &quot;&quot;);</span>
  }

  @Override
  public void close() {
<span class="nc bnc" id="L422" title="All 2 branches missed.">    for (Process process: processes) {</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">      if (process.isAlive()) {</span>
<span class="nc" id="L424">        logger.debug(&quot;Destroying encoding process {}&quot;, process);</span>
<span class="nc" id="L425">        process.destroy();</span>
      }
<span class="nc" id="L427">    }</span>
<span class="nc" id="L428">  }</span>

  /**
   * Handles the encoder output by analyzing it first and then firing it off to the registered listeners.
   * Has provisions to deal with HLS outputs which uses templates
   *
   * @param message
   *          the message returned by the encoder
   */
  private void handleEncoderOutput(List&lt;File&gt; output, String message) {
<span class="fc" id="L438">    message = message.trim();</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">    if (&quot;&quot;.equals(message))</span>
<span class="nc" id="L440">      return;</span>

    // Others go to trace logging
<span class="fc bfc" id="L443" title="All 2 branches covered.">    if (StringUtils.startsWithAny(message.toLowerCase(),</span>
          &quot;ffmpeg version&quot;, &quot;configuration&quot;, &quot;lib&quot;, &quot;size=&quot;, &quot;frame=&quot;, &quot;built with&quot;)) {
<span class="fc" id="L445">      logger.trace(message);</span>

    // Handle output files
<span class="fc bfc" id="L448" title="All 2 branches covered.">    } else if (StringUtils.startsWith(message, &quot;Output #&quot;)) {</span>
<span class="fc" id="L449">      logger.debug(message);</span>
<span class="fc" id="L450">      Matcher matcher = outputPattern.matcher(message);</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">      if (matcher.find()) {</span>
<span class="fc" id="L452">        String type = matcher.group(1);</span>
<span class="fc" id="L453">        String outputPath = matcher.group(2);</span>
<span class="pc bpc" id="L454" title="2 of 4 branches missed.">        if (!StringUtils.equals(&quot;NUL&quot;, outputPath) &amp;&amp; !StringUtils.equals(&quot;/dev/null&quot;, outputPath)</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                &amp;&amp; !StringUtils.equals(&quot;/dev/null&quot;, outputPath)</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">                &amp;&amp; !StringUtils.startsWith(&quot;pipe:&quot;, outputPath)) {</span>
<span class="fc" id="L457">          File outputFile = new File(outputPath);</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">          if (!type.startsWith(&quot;hls&quot;)) {</span>
<span class="fc" id="L459">            logger.info(&quot;Identified output file {}&quot;, outputFile);</span>
<span class="fc" id="L460">            output.add(outputFile);</span>
          }
        }
      }
<span class="fc bfc" id="L464" title="All 2 branches covered.">    } else if (StringUtils.startsWith(message, &quot;[hls @ &quot;)) {</span>
<span class="fc" id="L465">      logger.debug(message);</span>
<span class="fc" id="L466">      Matcher matcher = outputPatternHLS.matcher(message);</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">      if (matcher.find()) {</span>
<span class="fc" id="L468">        final String outputPath = Objects.toString(matcher.group(1), matcher.group(2));</span>
<span class="pc bpc" id="L469" title="2 of 4 branches missed.">        if (!StringUtils.equals(&quot;NUL&quot;, outputPath) &amp;&amp; !StringUtils.equals(&quot;/dev/null&quot;, outputPath)</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">                &amp;&amp; !StringUtils.startsWith(&quot;pipe:&quot;, outputPath)) {</span>
<span class="fc" id="L471">          File outputFile = new File(outputPath);</span>
          // HLS generates the filenames based on a template with %v and %d replaced
          // HLS writes into the same manifest file to add each segment
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">          if (!output.contains(outputFile)) {</span>
<span class="fc" id="L475">            logger.info(&quot;Identified HLS output file {}&quot;, outputFile);</span>
<span class="fc" id="L476">            output.add(outputFile);</span>
          }
        }
      }

    // Some to debug
<span class="fc bfc" id="L482" title="All 2 branches covered.">    } else if (StringUtils.startsWithAny(message.toLowerCase(),</span>
          &quot;artist&quot;, &quot;compatible_brands&quot;, &quot;copyright&quot;, &quot;creation_time&quot;, &quot;description&quot;, &quot;composer&quot;, &quot;date&quot;, &quot;duration&quot;,
            &quot;encoder&quot;, &quot;handler_name&quot;, &quot;input #&quot;, &quot;last message repeated&quot;, &quot;major_brand&quot;, &quot;metadata&quot;, &quot;minor_version&quot;,
            &quot;output #&quot;, &quot;program&quot;, &quot;side data:&quot;, &quot;stream #&quot;, &quot;stream mapping&quot;, &quot;title&quot;, &quot;video:&quot;, &quot;[libx264 @ &quot;, &quot;Press [&quot;)) {
<span class="fc" id="L486">      logger.debug(message);</span>

    // And the rest is likely to deserve at least info
    } else {
<span class="fc" id="L490">      logger.info(message);</span>
    }
<span class="fc" id="L492">  }</span>

  /**
   * Splits a line into tokens - mindful of single and double quoted string as single token Apache common and guava do
   * not deal with quotes
   *
   * @param str
   * @return an array of string tokens
   */
  public List&lt;String&gt; commandSplit(String str) {
<span class="fc" id="L502">    ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L503">    final Pattern regex = Pattern.compile(&quot;\&quot;([^\&quot;]*)\&quot;|\'([^\']*)\'|\\S+&quot;);</span>
<span class="fc" id="L504">    Matcher m = regex.matcher(str);</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">    while (m.find()) {</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">      if (m.group(1) != null) {</span>
        // double-quoted string without the quotes
<span class="nc" id="L508">        al.add(m.group(1));</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">      } else if (m.group(2) != null) {</span>
        // single-quoted string without the quotes
<span class="fc" id="L511">        al.add(m.group(2));</span>
      } else {
        // Add unquoted word
<span class="fc" id="L514">        al.add(m.group());</span>
      }
    }
<span class="fc" id="L517">    return (al);</span>
  }

  /**
   * Use a separator to join a string entry only if it is not null or empty
   *
   * @param srlist
   *          -array of string
   * @param separator
   *          - to join the string
   * @return a string
   */
  public String joinNonNullString(String[] srlist, String separator) {
<span class="fc" id="L530">    StringBuffer sb = new StringBuffer();</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">    for (int i = 0; i &lt; srlist.length; i++) {</span>
<span class="pc bpc" id="L532" title="1 of 4 branches missed.">      if (srlist[i] == null || srlist[i].isEmpty())</span>
<span class="nc" id="L533">        continue;</span>
      else {
<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (sb.length() &gt; 0)</span>
<span class="fc" id="L536">          sb.append(separator);</span>
<span class="fc" id="L537">        sb.append(srlist[i]);</span>
      }
    }
<span class="fc" id="L540">    return sb.toString();</span>
  }

  /**
   * Rewrite multiple profiles to ffmpeg complex filter filtergraph chains - inputs are passed in as options, eq: [0aa]
   * and [0vv] Any filters in the encoding profiles are moved into a clause in the complex filter chain for each output
   */
  protected class OutputAggregate {
    private final List&lt;EncodingProfile&gt; pf;
<span class="fc" id="L549">    private final ArrayList&lt;String&gt; outputs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L550">    private final ArrayList&lt;String&gt; outputFiles = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L551">    private final ArrayList&lt;String&gt; outputSuffixes = new ArrayList&lt;&gt;(); // for HLS</span>
<span class="fc" id="L552">    private boolean hasAdaptiveProfile = false;</span>
    private final ArrayList&lt;String&gt; vpads; // output pads for each segment
    private final ArrayList&lt;String&gt; apads;
    private final ArrayList&lt;String&gt; vfilter; // filters for each output format
    private final ArrayList&lt;String&gt; afilter;
<span class="fc" id="L557">    private String vInputPad = &quot;&quot;;</span>
<span class="fc" id="L558">    private String aInputPad = &quot;&quot;;</span>
<span class="fc" id="L559">    private String vsplit = &quot;&quot;;</span>
<span class="fc" id="L560">    private String asplit = &quot;&quot;;</span>
    private final ArrayList&lt;String&gt; vstream; // output video name
    private final ArrayList&lt;String&gt; astream; // output audio name

    public OutputAggregate(List&lt;EncodingProfile&gt; profiles,
<span class="fc" id="L565">            Map&lt;String, String&gt; params, String vInputPad, String aInputPad) throws EncoderException {</span>
<span class="fc" id="L566">      ArrayList&lt;EncodingProfile&gt; deliveryProfiles = new ArrayList&lt;EncodingProfile&gt;(profiles.size());</span>
<span class="fc" id="L567">      EncodingProfile groupProfile = null;</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">      for (EncodingProfile ep: profiles) {</span>
<span class="fc" id="L569">        String adaptiveType = ep.getExtension(ADAPTIVE_TYPE_SUFFIX);</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (adaptiveType == null) {</span>
<span class="fc" id="L571">          deliveryProfiles.add(ep);</span>
        } else {
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">          if (&quot;HLS&quot;.equalsIgnoreCase(adaptiveType)) {</span>
<span class="fc" id="L574">            groupProfile = ep;</span>
<span class="fc" id="L575">            hasAdaptiveProfile = true;</span>
          }
          else
<span class="nc" id="L578">            throw new EncoderException(&quot;Only HLS is supported&quot; + ep.getIdentifier() + &quot; ffmpeg command&quot;);</span>
        }
<span class="fc" id="L580">      }</span>
<span class="fc" id="L581">      this.pf = deliveryProfiles;</span>
<span class="fc" id="L582">      int size = this.pf.size();</span>

<span class="pc bpc" id="L584" title="1 of 4 branches missed.">      if (vInputPad == null &amp;&amp; aInputPad == null)</span>
<span class="nc" id="L585">        throw new EncoderException(&quot;At least one of video or audio input must be specified&quot;);</span>
      // Init
<span class="fc" id="L587">      vfilter = new ArrayList&lt;&gt;(Collections.nCopies(size, null));</span>
<span class="fc" id="L588">      afilter = new ArrayList&lt;&gt;(Collections.nCopies(size, null));</span>
      // name of output pads to map to files
<span class="fc" id="L590">      apads = new ArrayList&lt;&gt;(Collections.nCopies(size, null));</span>
<span class="fc" id="L591">      vpads = new ArrayList&lt;&gt;(Collections.nCopies(size, null));</span>

<span class="fc" id="L593">      vstream = new ArrayList&lt;&gt;(Collections.nCopies(size, null));</span>
<span class="fc" id="L594">      astream = new ArrayList&lt;&gt;(Collections.nCopies(size, null));</span>

<span class="fc bfc" id="L596" title="All 2 branches covered.">      vsplit = (size &gt; 1) ? (vInputPad + &quot;split=&quot; + size) : null; // number of splits</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">      asplit = (size &gt; 1) ? (aInputPad + &quot;asplit=&quot; + size) : null;</span>
<span class="fc" id="L598">      this.vInputPad = vInputPad;</span>
<span class="fc" id="L599">      this.aInputPad = aInputPad;</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">      if (groupProfile != null)</span>
<span class="fc" id="L601">        outputAggregateReal(deliveryProfiles, groupProfile, params, vInputPad, aInputPad);</span>
      else
<span class="fc" id="L603">        outputAggregateReal(deliveryProfiles, params, vInputPad, aInputPad);</span>
<span class="fc" id="L604">    }</span>


    /*
     * set the audio filter if there are any in the profiles or identity
     */
    private void setAudioFilters() {
<span class="fc bfc" id="L611" title="All 2 branches covered.">      if (pf.size() == 1) {</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">        if (afilter.get(0) != null)</span>
<span class="fc" id="L613">          afilter.set(0, aInputPad + afilter.get(0) + apads.get(0)); // Use audio filter on input directly</span>
<span class="fc" id="L614">          astream.set(0, apads.get(0));</span>
      } else
<span class="fc bfc" id="L616" title="All 2 branches covered.">        for (int i = 0; i &lt; pf.size(); i++) {</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">          if (afilter.get(i) != null) {</span>
<span class="fc" id="L618">            afilter.set(i, &quot;[oa0&quot; + i + &quot;]&quot; + afilter.get(i) + apads.get(i)); // Use audio filter on apad</span>
<span class="fc" id="L619">            asplit += &quot;[oa0&quot; + i + &quot;]&quot;;</span>
<span class="fc" id="L620">            astream.set(i, &quot;[oa0&quot; + i + &quot;]&quot;);</span>
          } else {
<span class="fc" id="L622">            asplit += apads.get(i); // straight to output</span>
<span class="fc" id="L623">            astream.set(i, apads.get(i));</span>
          }
        }
<span class="fc" id="L626">      afilter.removeAll(Arrays.asList((String) null));</span>
<span class="fc" id="L627">    }</span>

    /*
     * set the video filter if there are any in the profiles
     */
    private void setVideoFilters() {
<span class="fc bfc" id="L633" title="All 2 branches covered.">      if (pf.size() == 1) {</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">        if (vfilter.get(0) != null)</span>
<span class="fc" id="L635">          vfilter.set(0, vInputPad + vfilter.get(0) + vpads.get(0)); // send to filter first</span>
<span class="fc" id="L636">          vstream.set(0, vpads.get(0));</span>
      } else
<span class="fc bfc" id="L638" title="All 2 branches covered.">        for (int i = 0; i &lt; pf.size(); i++) {</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">          if (vfilter.get(i) != null) {</span>
<span class="fc" id="L640">            vfilter.set(i, &quot;[ov0&quot; + i + &quot;]&quot; + vfilter.get(i) + vpads.get(i)); // send to filter first</span>
<span class="fc" id="L641">            vsplit += &quot;[ov0&quot; + i + &quot;]&quot;;</span>
<span class="fc" id="L642">            vstream.set(i, &quot;[ov0&quot; + i + &quot;]&quot;);</span>
          } else {
<span class="fc" id="L644">            vsplit += vpads.get(i);// straight to output</span>
<span class="fc" id="L645">            vstream.set(i, vpads.get(i));</span>
          }
        }

<span class="fc" id="L649">      vfilter.removeAll(Arrays.asList((String) null));</span>
<span class="fc" id="L650">    }</span>

    public List&lt;String&gt; getOutFiles() {
<span class="nc" id="L653">      return outputFiles;</span>
    }

    /**
     *
     * @return output pads - the &quot;-map xyz&quot; clauses
     */
    public List&lt;String&gt; getOutput() {
<span class="fc" id="L661">      return outputs;</span>
    }

    /**
     * Get the profile suffixes with source file string interpolation done
     *
     * @return the suffixes iff adaptive, otherwise empty
     */
    public List&lt;String&gt; getSegmentOutputSuffixes() {
<span class="fc" id="L670">      return outputSuffixes;</span>
    }

    /**
     * Check for adaptive playlist output - output may need remapping
     *
     * @return if true
     */
    public boolean hasAdaptivePlaylist() {
<span class="fc" id="L679">      return hasAdaptiveProfile;</span>
    }

    /**
     *
     * @return filter split clause for ffmpeg
     */
    public String getVsplit() {
<span class="fc" id="L687">      return vsplit;</span>
    }

    public String getAsplit() {
<span class="fc" id="L691">      return asplit;</span>
    }

    public String getVideoFilter() {
<span class="fc bfc" id="L695" title="All 2 branches covered.">      if (vfilter.isEmpty())</span>
<span class="fc" id="L696">        return null;</span>
<span class="fc" id="L697">      return StringUtils.join(vfilter, &quot;;&quot;);</span>
    }

    public String getAudioFilter() {
<span class="fc bfc" id="L701" title="All 2 branches covered.">      if (afilter.isEmpty())</span>
<span class="fc" id="L702">        return null;</span>
<span class="fc" id="L703">      return StringUtils.join(afilter, &quot;;&quot;);</span>
    }

    /**
     * If this is a raw mapping not used with complex filter, strip the square brackets if there are any
     *
     * @param pad
     *          - such as 0:a, [0:v], [1:1],[0:12],[main],[overlay]
     * @return adjusted pad
     */
    public String adjustForNoComplexFilter(String pad) {
<span class="fc" id="L714">      final Pattern outpad = Pattern.compile(&quot;\\[(\\d+:[av\\d{1,2}])\\]&quot;);</span>
      try {
<span class="fc" id="L716">        Matcher matcher = outpad.matcher(pad); // throws exception if pad is null</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">        if (matcher.matches()) {</span>
<span class="fc" id="L718">          return matcher.group(1);</span>
        }
<span class="fc" id="L720">      } catch (Exception e) {</span>
<span class="fc" id="L721">      }</span>
<span class="fc" id="L722">      return pad;</span>
    }

    /**
     * Replace all the templates with real values for each profile
     *
     * @param cmd
     *          from profile
     * @param params
     *          from input
     * @return command
     */
    protected String processParameters(String cmd, Map&lt;String, String&gt; params) {
<span class="fc" id="L735">      String r = cmd;</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">      for (Map.Entry&lt;String, String&gt; e : params.entrySet()) {</span>
<span class="fc" id="L737">        r = r.replace(&quot;#{&quot; + e.getKey() + &quot;}&quot;, e.getValue());</span>
<span class="fc" id="L738">      }</span>
<span class="fc" id="L739">      return r;</span>
    }

    /**
     * Translate the profiles to work with complex filter clauses in ffmpeg, it splits one output into multiple, one for
     * each encoding profile. This also generates the manifests for HLS using the group profile (HLS only). Each
     * encoding profile must have a bitrate or one will be generated for all the profiles.
     * This requires ffmpeg version later than 4.1
     *
     * @param profiles
     *          - list of encoding profiles
     * @param groupProfile
     *          - encoding profile that applies to all output and has precedence, currently only HLS options
     * @param params
     *          - values for substitution
     * @param vInputPad
     *          - name of video pad as input, eg: [0v] null if no video
     * @param aInputPad
     *          - name of audio pad as input, eg [0a], null if no audio
     * @throws EncoderException
     *           - if it fails
     */
    public void outputAggregateReal(List&lt;EncodingProfile&gt; profiles, EncodingProfile groupProfile,
            Map&lt;String, String&gt; params, String vInputPad, String aInputPad) throws EncoderException {
<span class="fc" id="L763">      int size = profiles.size();</span>

      // substitute the output file suffix for group
      try {
<span class="fc" id="L767">        String outSuffix = processParameters(groupProfile.getSuffix(), params);</span>
<span class="fc" id="L768">        params.put(&quot;out.suffix&quot;, outSuffix); // Add profile suffix</span>
<span class="nc" id="L769">      } catch (Exception e) {</span>
<span class="nc" id="L770">        throw new EncoderException(&quot;Missing Encoding Profiles&quot;);</span>
<span class="fc" id="L771">      }</span>
<span class="fc" id="L772">      String ffmpgGCmd = groupProfile.getExtension(CMD_SUFFIX); // Get ffmpeg command from profile</span>

<span class="pc bpc" id="L774" title="1 of 2 branches missed.">      if (ffmpgGCmd == null)</span>
<span class="nc" id="L775">        throw new EncoderException(&quot;Missing ffmpeg Encoding Profile &quot; + groupProfile.getIdentifier() + &quot; ffmpeg command&quot;);</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">      for (Map.Entry&lt;String, String&gt; e : params.entrySet()) { // replace output filenames</span>
<span class="fc" id="L777">        ffmpgGCmd = ffmpgGCmd.replace(&quot;#{&quot; + e.getKey() + &quot;}&quot;, e.getValue());</span>
<span class="fc" id="L778">      }</span>
<span class="fc" id="L779">      ffmpgGCmd = ffmpgGCmd.replace(&quot;#{space}&quot;, &quot; &quot;);</span>
<span class="fc" id="L780">      int indx = 0; // individual quality profiles - names are not needed anymore</span>
      // Only quality(bitrate/resolution/etc) and position matters
<span class="fc bfc" id="L782" title="All 2 branches covered.">      for (EncodingProfile profile : profiles) {</span>
<span class="fc" id="L783">        String cmd = &quot;&quot;;</span>
        // substitute the output file name
<span class="fc" id="L785">        outputSuffixes.add(processParameters(profile.getSuffix(), params)); // preferred suffixes</span>
<span class="fc" id="L786">        String ffmpgCmd = profile.getExtension(CMD_SUFFIX); // Get ffmpeg command from profile</span>
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">        if (ffmpgCmd == null)</span>
<span class="nc" id="L788">          throw new EncoderException(&quot;Missing Encoding Profile &quot; + profile.getIdentifier() + &quot; ffmpeg command&quot;);</span>
        // Leave this so they will be removed
<span class="fc" id="L790">        params.remove(&quot;out.dir&quot;);</span>
<span class="fc" id="L791">        params.remove(&quot;out.name&quot;);</span>
<span class="fc" id="L792">        params.remove(&quot;out.suffix&quot;);</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">        for (Map.Entry&lt;String, String&gt; e : params.entrySet()) { // replace output filenames</span>
<span class="fc" id="L794">          ffmpgCmd = ffmpgCmd.replace(&quot;#{&quot; + e.getKey() + &quot;}&quot;, e.getValue());</span>
<span class="fc" id="L795">        }</span>
<span class="fc" id="L796">        ffmpgCmd = ffmpgCmd.replace(&quot;#{space}&quot;, &quot; &quot;);</span>
        List&lt;String&gt; cmdToken;
        try {
<span class="fc" id="L799">          cmdToken = commandSplit(ffmpgCmd);</span>
<span class="nc" id="L800">        } catch (Exception e) {</span>
<span class="nc" id="L801">          throw new EncoderException(&quot;Could not parse encoding profile command line&quot;, e);</span>
<span class="fc" id="L802">        }</span>
        //List&lt;String&gt; cmdToken = Arrays.asList(arguments);
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">        for (int i = 0; i &lt; cmdToken.size(); i++) {</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">          if (cmdToken.get(i).contains(&quot;#{out.name}&quot;)) {</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">            if (i == cmdToken.size() - 1) { // last item, most likely</span>
<span class="fc" id="L807">              cmdToken = cmdToken.subList(0, i);</span>
<span class="fc" id="L808">              break;</span>
            } else { // in the middle of the list
<span class="nc" id="L810">              List&lt;String&gt; copy = cmdToken.subList(0, i - 1);</span>
<span class="nc" id="L811">              copy.addAll(cmdToken.subList(i + 1, cmdToken.size() - 1));</span>
<span class="nc" id="L812">              cmdToken = copy;</span>
            }
          }
        }
        // Find and remove input and filters from ffmpeg command from the profile
<span class="fc" id="L817">        int i = 0;</span>
<span class="fc" id="L818">        String maxrate = null;</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">        while (i &lt; cmdToken.size()) {</span>
<span class="fc" id="L820">          String opt = cmdToken.get(i);</span>
<span class="fc bfc" id="L821" title="All 4 branches covered.">          if (opt.startsWith(&quot;-vf&quot;) || opt.startsWith(&quot;-filter:v&quot;)) { // video filters</span>
<span class="fc" id="L822">            vfilter.set(indx, cmdToken.get(i + 1).replace(&quot;\&quot;&quot;, &quot;&quot;)); // store without quotes</span>
<span class="fc" id="L823">            i++;</span>
<span class="pc bpc" id="L824" title="2 of 4 branches missed.">          } else if (opt.startsWith(&quot;-filter_complex&quot;) || opt.startsWith(&quot;-lavfi&quot;)) { // safer to quit now than to</span>
            // baffle users with strange errors later
<span class="nc" id="L826">            i++;</span>
<span class="nc" id="L827">            logger.error(&quot;Command does not support complex filters - only simple -af or -vf filters are supported&quot;);</span>
<span class="nc" id="L828">            throw new EncoderException(</span>
<span class="nc" id="L829">                    &quot;Cannot parse complex filters in&quot; + profile.getIdentifier() + &quot; for this operation&quot;);</span>
<span class="pc bpc" id="L830" title="1 of 4 branches missed.">          } else if (opt.startsWith(&quot;-af&quot;) || opt.startsWith(&quot;-filter:a&quot;)) { // audio filter</span>
<span class="fc" id="L831">            afilter.set(indx, cmdToken.get(i + 1).replace(&quot;\&quot;&quot;, &quot;&quot;)); // store without quotes</span>
<span class="fc" id="L832">            i++;</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">          } else if (&quot;-i&quot;.equals(opt)) {</span>
<span class="fc" id="L834">            i++; // inputs are now mapped, remove from command</span>
<span class="fc bfc" id="L835" title="All 6 branches covered.">          } else if (opt.startsWith(&quot;-c:&quot;) || opt.startsWith(&quot;-codec:&quot;) || opt.contains(&quot;-vcodec&quot;)</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">                  || opt.contains(&quot;-acodec&quot;)) { // cannot copy codec in complex filter</span>
<span class="fc" id="L837">            String str = cmdToken.get(i + 1);</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">            if (str.contains(&quot;copy&quot;)) // c</span>
<span class="fc" id="L839">              i++;</span>
<span class="fc bfc" id="L840" title="All 4 branches covered.">            else if (opt.startsWith(&quot;-codec:&quot;) || opt.contains(&quot;-vcodec&quot;)) { // becomes -c:v</span>
<span class="fc" id="L841">              cmd = cmd + &quot; &quot; + adjustABRVMaps(&quot;-c:v&quot;, indx);</span>
            }
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">            else if (opt.startsWith(&quot;-acodec:&quot;))</span>
<span class="nc" id="L844">              cmd = cmd + &quot; &quot; + adjustABRVMaps(&quot;-c:a&quot;, indx);</span>
            else
<span class="fc" id="L846">              cmd = cmd + &quot; &quot; + adjustABRVMaps(opt, indx);</span>
<span class="fc" id="L847">          } else { // keep the rest</span>
<span class="fc" id="L848">            cmd = cmd + &quot; &quot; + adjustABRVMaps(opt, indx);</span>
          }
<span class="fc" id="L850">          i++;</span>
<span class="fc" id="L851">        }</span>

        /* Remove unused commandline parts */
<span class="fc" id="L854">        cmd = cmd.replaceAll(&quot;#\\{.*?\\}&quot;, &quot;&quot;);</span>
        // Find the output map based on splits and filters
<span class="fc bfc" id="L856" title="All 2 branches covered.">        if (size == 1) { // no split</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">          if (afilter.get(indx) == null)</span>
<span class="fc" id="L858">            apads.set(indx, adjustForNoComplexFilter(aInputPad));</span>
          else
<span class="fc" id="L860">            apads.set(indx, &quot;[oa&quot; + indx + &quot;]&quot;);</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">          if (vfilter.get(indx) == null)</span>
<span class="fc" id="L862">            vpads.set(indx, adjustForNoComplexFilter(vInputPad)); // No split, no filter - straight from input</span>
          else
<span class="nc" id="L864">            vpads.set(indx, &quot;[ov&quot; + indx + &quot;]&quot;);</span>

        } else { // split
<span class="fc" id="L867">          vpads.set(indx, &quot;[ov&quot; + indx + &quot;]&quot;); // name the output pads from split -&gt; input to final format</span>
<span class="fc" id="L868">          apads.set(indx, &quot;[oa&quot; + indx + &quot;]&quot;); // name the output audio pads</span>
        }
<span class="fc" id="L870">        cmd = StringUtils.trimToNull(cmd); // remove all leading/trailing white spaces</span>
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">        if (cmd != null) {</span>
          // No direct output from encoding profile
          // outputFiles.add(cmdToken.get(cmdToken.size() - 1));
<span class="fc bfc" id="L874" title="All 2 branches covered.">          if (vInputPad != null) {</span>
<span class="fc" id="L875">            outputs.add(&quot;-map &quot; + vpads.get(indx));</span>
          }
<span class="fc bfc" id="L877" title="All 2 branches covered.">          if (aInputPad != null) {</span>
<span class="fc" id="L878">            outputs.add(&quot;-map &quot; + apads.get(indx)); // map video and audio input</span>
          }
<span class="fc" id="L880">          outputs.add(cmd); // profiles appended in order, they are numbered 0,1,2,3...</span>
<span class="fc" id="L881">          indx++; // indx for this profile</span>
        }
<span class="fc" id="L883">      }</span>
<span class="fc" id="L884">      setVideoFilters();</span>
<span class="fc" id="L885">      setAudioFilters();</span>
<span class="fc bfc" id="L886" title="All 4 branches covered.">      setHLSVarStreamMap(ffmpgGCmd, vInputPad != null, aInputPad != null); // Only HLS is supported so far</span>
<span class="fc" id="L887">    }</span>

    /**
     * Sets the mapping of outputs to HLS streams.
     *
     * @param ffmpgCmd
     *          - ffmpeg command with substitution from the encoding profile
     * @param hasVideo
     *          - use video stream
     * @param hasAudio
     *          - use audio stream
     */
    private void setHLSVarStreamMap(String ffmpgCmd, boolean hasVideo, boolean hasAudio) {
<span class="fc" id="L900">      StringBuilder varStreamMap = new StringBuilder();</span>
<span class="fc" id="L901">      varStreamMap.append(&quot; -var_stream_map '&quot;);</span>

<span class="fc bfc" id="L903" title="All 2 branches covered.">      for (int i = 0; i &lt; pf.size(); i++) {</span>
<span class="fc" id="L904">        int j = 0;</span>
<span class="fc" id="L905">        String[] maps = new String[2];</span>
<span class="pc bpc" id="L906" title="1 of 4 branches missed.">        if (hasVideo &amp;&amp; vstream.get(i) != null) { // Has video</span>
<span class="fc" id="L907">          maps[j] = &quot;v:&quot; + i;</span>
<span class="fc" id="L908">          ++j;</span>
        }
<span class="pc bpc" id="L910" title="1 of 4 branches missed.">        if (hasAudio &amp;&amp; astream.get(i) != null) { // Has audio</span>
<span class="fc" id="L911">          maps[j] = &quot;a:&quot; + i;</span>
        }
        // each target delivery is v:i,a:i
<span class="fc" id="L914">        varStreamMap.append(joinNonNullString(maps, &quot;,&quot;));</span>
<span class="fc" id="L915">        varStreamMap.append(&quot; &quot;);</span>
      }

<span class="fc" id="L918">      varStreamMap.append(&quot;' &quot;);</span>
<span class="fc" id="L919">      varStreamMap.append(ffmpgCmd);</span>
<span class="fc" id="L920">      varStreamMap.append(&quot; &quot;);</span>
<span class="fc" id="L921">      outputs.add(varStreamMap.toString()); // treat as another output</span>
<span class="fc" id="L922">    }</span>

    /**
     * When the inputs are routed to ABR, some options need to have a v:int suffix for video and a:0 for audio Any
     * options ending with &quot;:v&quot; will get a number, otherwise try and guess use option:(v or a) notables (eg: b:v, c:v),
     * options such as ab or vb will not work
     *
     * @param option
     *          - ffmpeg option
     * @param position
     *          - position in the command
     */
    public String adjustABRVMaps(String option, int position) {
<span class="fc bfc" id="L935" title="All 4 branches covered.">      if (option.endsWith(&quot;:v&quot;) || option.endsWith(&quot;:a&quot;)) {</span>
<span class="fc" id="L936">        return option + &quot;:&quot; + Integer.toString(position);</span>
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">      } else if (mappableOptions.contains(option)) {</span>
<span class="nc" id="L938">        return option + &quot;:v:&quot; + Integer.toString(position);</span>
      } else
<span class="fc" id="L940">        return option;</span>
    }


    /**
     * Translate the profiles to work with complex filter clauses in ffmpeg, it splits one output into multiple, one for
     * each encoding profile
     *
     * @param profiles
     *          - list of encoding profiles
     * @param params
     *          - values for substitution
     * @param vInputPad
     *          - name of video pad as input, eg: [0v] null if no video
     * @param aInputPad
     *          - name of audio pad as input, eg [0a], null if no audio
     * @throws EncoderException
     *           - if it fails
     */
    public void outputAggregateReal(List&lt;EncodingProfile&gt; profiles, Map&lt;String, String&gt; params,
              String vInputPad, String aInputPad) throws EncoderException {

<span class="fc" id="L962">      int size = profiles.size();</span>
<span class="fc" id="L963">      int indx = 0; // profiles</span>
<span class="fc bfc" id="L964" title="All 2 branches covered.">      for (EncodingProfile profile : profiles) {</span>
<span class="fc" id="L965">        String cmd = &quot;&quot;;</span>
        String outSuffix;
        // generate random name as we only have one base name
<span class="fc" id="L968">        String outFileName = params.get(&quot;out.name.base&quot;) + &quot;_&quot; + IdImpl.fromUUID().toString();</span>
<span class="fc" id="L969">        params.put(&quot;out.name&quot;, outFileName); // Output file name for this profile</span>
        try {
<span class="fc" id="L971">          outSuffix = processParameters(profile.getSuffix(), params);</span>
<span class="fc" id="L972">          params.put(&quot;out.suffix&quot;, outSuffix); // Add profile suffix</span>
<span class="nc" id="L973">        } catch (Exception e) {</span>
<span class="nc" id="L974">          throw new EncoderException(&quot;Missing Encoding Profiles&quot;);</span>
<span class="fc" id="L975">        }</span>
        // substitute the output file name
<span class="fc" id="L977">        String ffmpgCmd = profile.getExtension(CMD_SUFFIX); // Get ffmpeg command from profile</span>
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">        if (ffmpgCmd == null)</span>
<span class="nc" id="L979">          throw new EncoderException(&quot;Missing Encoding Profile &quot; + profile.getIdentifier() + &quot; ffmpeg command&quot;);</span>
<span class="fc bfc" id="L980" title="All 2 branches covered.">        for (Map.Entry&lt;String, String&gt; e : params.entrySet()) { // replace output filenames</span>
<span class="fc" id="L981">          ffmpgCmd = ffmpgCmd.replace(&quot;#{&quot; + e.getKey() + &quot;}&quot;, e.getValue());</span>
<span class="fc" id="L982">        }</span>
<span class="fc" id="L983">        ffmpgCmd = ffmpgCmd.replace(&quot;#{space}&quot;, &quot; &quot;);</span>
        String[] arguments;
        try {
<span class="fc" id="L986">          arguments = CommandLineUtils.translateCommandline(ffmpgCmd);</span>
<span class="nc" id="L987">        } catch (Exception e) {</span>
<span class="nc" id="L988">          throw new EncoderException(&quot;Could not parse encoding profile command line&quot;, e);</span>
<span class="fc" id="L989">        }</span>
<span class="fc" id="L990">        List&lt;String&gt; cmdToken = Arrays.asList(arguments);</span>
        // Find and remove input and filters from ffmpeg command from the profile
<span class="fc" id="L992">        int i = 0;</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">        while (i &lt; cmdToken.size()) {</span>
<span class="fc" id="L994">          String opt = cmdToken.get(i);</span>
<span class="fc bfc" id="L995" title="All 4 branches covered.">          if (opt.startsWith(&quot;-vf&quot;) || opt.startsWith(&quot;-filter:v&quot;)) { // video filters</span>
<span class="fc" id="L996">            vfilter.set(indx, cmdToken.get(i + 1).replace(&quot;\&quot;&quot;, &quot;&quot;)); // store without quotes</span>
<span class="fc" id="L997">            i++;</span>
<span class="pc bpc" id="L998" title="2 of 4 branches missed.">          } else if (opt.startsWith(&quot;-filter_complex&quot;) || opt.startsWith(&quot;-lavfi&quot;)) { // safer to quit now than to</span>
            // baffle users with strange errors later
<span class="nc" id="L1000">            i++;</span>
<span class="nc" id="L1001">            logger.error(&quot;Command does not support complex filters - only simple -af or -vf filters are supported&quot;);</span>
<span class="nc" id="L1002">            throw new EncoderException(</span>
<span class="nc" id="L1003">                    &quot;Cannot parse complex filters in&quot; + profile.getIdentifier() + &quot; for this operation&quot;);</span>
<span class="pc bpc" id="L1004" title="1 of 4 branches missed.">          } else if (opt.startsWith(&quot;-af&quot;) || opt.startsWith(&quot;-filter:a&quot;)) { // audio filter</span>
<span class="fc" id="L1005">            afilter.set(indx, cmdToken.get(i + 1).replace(&quot;\&quot;&quot;, &quot;&quot;)); // store without quotes</span>
<span class="fc" id="L1006">            i++;</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">          } else if (&quot;-i&quot;.equals(opt)) {</span>
<span class="fc" id="L1008">            i++; // inputs are now mapped, remove from command</span>
<span class="fc bfc" id="L1009" title="All 6 branches covered.">          } else if (opt.startsWith(&quot;-c:&quot;) || opt.startsWith(&quot;-codec:&quot;) || opt.contains(&quot;-vcodec&quot;)</span>
<span class="fc bfc" id="L1010" title="All 2 branches covered.">                  || opt.contains(&quot;-acodec&quot;)) { // cannot copy codec in complex filter</span>
<span class="fc" id="L1011">            String str = cmdToken.get(i + 1);</span>
<span class="fc bfc" id="L1012" title="All 2 branches covered.">            if (str.contains(&quot;copy&quot;)) // c</span>
<span class="fc" id="L1013">              i++;</span>
            else
<span class="fc" id="L1015">              cmd = cmd + &quot; &quot; + opt;</span>
<span class="fc" id="L1016">          } else { // keep the rest</span>
<span class="fc" id="L1017">            cmd = cmd + &quot; &quot; + opt;</span>
          }
<span class="fc" id="L1019">          i++;</span>
<span class="fc" id="L1020">        }</span>
        /* Remove unused commandline parts */
<span class="fc" id="L1022">        cmd = cmd.replaceAll(&quot;#\\{.*?\\}&quot;, &quot;&quot;);</span>
        // Find the output map based on splits and filters
<span class="fc bfc" id="L1024" title="All 2 branches covered.">        if (size == 1) { // no split</span>
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">          if (afilter.get(indx) == null)</span>
<span class="fc" id="L1026">            apads.set(indx, adjustForNoComplexFilter(aInputPad));</span>
          else
<span class="nc" id="L1028">            apads.set(indx, &quot;[oa&quot; + indx + &quot;]&quot;);</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">          if (vfilter.get(indx) == null)</span>
<span class="fc" id="L1030">            vpads.set(indx, adjustForNoComplexFilter(vInputPad)); // No split, no filter - straight from input</span>
          else
<span class="fc" id="L1032">            vpads.set(indx, &quot;[ov&quot; + indx + &quot;]&quot;);</span>

        } else { // split
<span class="fc" id="L1035">          vpads.set(indx, &quot;[ov&quot; + indx + &quot;]&quot;); // name the output pads from split -&gt; input to final format</span>
<span class="fc" id="L1036">          apads.set(indx, &quot;[oa&quot; + indx + &quot;]&quot;); // name the output audio pads</span>
        }
<span class="fc" id="L1038">        cmd = StringUtils.trimToNull(cmd); // remove all leading/trailing white spaces</span>
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">        if (cmd != null) {</span>
<span class="fc" id="L1040">          outputFiles.add(cmdToken.get(cmdToken.size() - 1));</span>
<span class="fc bfc" id="L1041" title="All 2 branches covered.">          if (vInputPad != null) {</span>
<span class="fc" id="L1042">            outputs.add(&quot;-map &quot; + vpads.get(indx));</span>
          }
<span class="fc bfc" id="L1044" title="All 2 branches covered.">          if (aInputPad != null) {</span>
<span class="fc" id="L1045">            outputs.add(&quot;-map &quot; + apads.get(indx)); // map video and audio input</span>
          }
<span class="fc" id="L1047">          outputs.add(cmd); // profiles appended in order, they are numbered 0,1,2,3...</span>
<span class="fc" id="L1048">          indx++; // indx for this profile</span>
        }
<span class="fc" id="L1050">      }</span>
<span class="fc" id="L1051">      setVideoFilters();</span>
<span class="fc" id="L1052">      setAudioFilters();</span>
<span class="fc" id="L1053">    }</span>
  }

  /**
   * Clean up the edit points, make sure the gap between consecutive segments are larger than the transition Otherwise
   * it can be very slow to run and output will be ugly because the fades will extend the clip
   *
   * @param edits
   *          - clips to be stitched together
   * @param gap
   *          = transitionDuration / 1000; default gap size - same as fade
   * @return a list of sanitized video clips
   */
  private static List&lt;VideoClip&gt; sortSegments(List&lt;VideoClip&gt; edits, double gap) {
<span class="fc" id="L1067">    LinkedList&lt;VideoClip&gt; ll = new LinkedList&lt;VideoClip&gt;();</span>
<span class="fc" id="L1068">    Iterator&lt;VideoClip&gt; it = edits.iterator();</span>
    VideoClip clip;
    VideoClip nextclip;
<span class="fc" id="L1071">    int lastSrc = -1;</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">    while (it.hasNext()) { // Skip sort if there are multiple sources</span>
<span class="fc" id="L1073">      clip = it.next();</span>
<span class="fc bfc" id="L1074" title="All 2 branches covered.">      if (lastSrc &lt; 0) {</span>
<span class="fc" id="L1075">        lastSrc = clip.getSrc();</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">      } else if (lastSrc != clip.getSrc()) {</span>
<span class="fc" id="L1077">        return edits;</span>
      }
    }
<span class="fc" id="L1080">    Collections.sort(edits); // Sort clips if all clips are from the same src</span>
<span class="fc" id="L1081">    List&lt;VideoClip&gt; clips = new ArrayList&lt;VideoClip&gt;();</span>
<span class="fc" id="L1082">    it = edits.iterator();</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">    while (it.hasNext()) { // Check for legal durations</span>
<span class="fc" id="L1084">      clip = it.next();</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">      if (clip.getDuration() &gt; gap) { // Keep segments at least as long as transition fade</span>
<span class="fc" id="L1086">        ll.add(clip);</span>
      }
    }
<span class="fc" id="L1089">    clip = ll.pop(); // initialize</span>
    // Clean up segments so that the cut out is at least as long as the transition gap (default is fade out-fade in)
<span class="fc bfc" id="L1091" title="All 2 branches covered.">    while (!ll.isEmpty()) { // Check that 2 consecutive segments from same src are at least GAP secs apart</span>
<span class="pc bpc" id="L1092" title="1 of 2 branches missed.">      if (ll.peek() != null) {</span>
<span class="fc" id="L1093">        nextclip = ll.pop(); // check next consecutive segment</span>
<span class="pc bpc" id="L1094" title="1 of 4 branches missed.">        if ((nextclip.getSrc() == clip.getSrc()) &amp;&amp; (nextclip.getStart() - clip.getEnd()) &lt; gap) { // collapse two</span>
          // segments into one
<span class="fc" id="L1096">          clip.setEnd(nextclip.getEnd()); // by using inpt of seg 1 and outpoint of seg 2</span>
        } else {
<span class="fc" id="L1098">          clips.add(clip); // keep last segment</span>
<span class="fc" id="L1099">          clip = nextclip; // check next segment</span>
        }
      }
    }
<span class="fc" id="L1103">    clips.add(clip); // add last segment</span>
<span class="fc" id="L1104">    return clips;</span>
  }

  /**
   * Create the trim part of the complex filter and return the clauses for the complex filter. The transition is fade to
   * black then fade from black. The outputs are mapped to [ov] and [oa]
   *
   * @param clips
   *          - video segments as indices into the media files by time
   * @param transitionDuration
   *          - length of transition in MS between each segment
   * @param hasVideo
   *          - has video, from inspection
   * @param hasAudio
   *          - has audio
   * @return complex filter clauses to do editing for ffmpeg
   * @throws Exception
   *           - if it fails
   */
  private List&lt;String&gt; makeEdits(List&lt;VideoClip&gt; clips, int transitionDuration, Boolean hasVideo,
          Boolean hasAudio) throws Exception {
<span class="fc" id="L1125">    double vfade = transitionDuration / 1000; // video and audio have the same transition duration</span>
<span class="fc" id="L1126">    double afade = vfade;</span>
<span class="fc" id="L1127">    DecimalFormatSymbols ffmpegFormat = new DecimalFormatSymbols();</span>
<span class="fc" id="L1128">    ffmpegFormat.setDecimalSeparator('.');</span>
<span class="fc" id="L1129">    DecimalFormat f = new DecimalFormat(&quot;0.00&quot;, ffmpegFormat);</span>
<span class="fc" id="L1130">    List&lt;String&gt; vpads = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1131">    List&lt;String&gt; apads = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1132">    List&lt;String&gt; clauses = new ArrayList&lt;&gt;(); // The clauses are ordered</span>
<span class="fc" id="L1133">    int n = 0;</span>
<span class="fc bfc" id="L1134" title="All 2 branches covered.">    if (clips != null)</span>
<span class="fc" id="L1135">      n = clips.size();</span>
<span class="fc" id="L1136">    String outmap = &quot;o&quot;;</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">    if (n &gt; 1) { // Create the input pads if we have multiple segments</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">      for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1139">        vpads.add(&quot;[v&quot; + i + &quot;]&quot;); // post filter</span>
<span class="fc" id="L1140">        apads.add(&quot;[a&quot; + i + &quot;]&quot;);</span>
      }
<span class="fc" id="L1142">      outmap = &quot;&quot;;</span>
      // Create the trims
<span class="fc bfc" id="L1144" title="All 2 branches covered.">      for (int i = 0; i &lt; n; i++) { // Each clip</span>
        // get clip and add fades to each clip
<span class="fc" id="L1146">        VideoClip vclip = clips.get(i);</span>
<span class="fc" id="L1147">        int fileindx = vclip.getSrc(); // get source file by index</span>
<span class="fc" id="L1148">        double inpt = vclip.getStart(); // get in points</span>
<span class="fc" id="L1149">        double duration = vclip.getDuration();</span>
<span class="fc" id="L1150">        double vend = Math.max(duration - vfade, 0);</span>
<span class="fc" id="L1151">        double aend = Math.max(duration - afade, 0);</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">        if (hasVideo) {</span>
          String vvclip;
<span class="fc" id="L1154">          vvclip = &quot;[&quot; + fileindx + &quot;:v]trim=&quot; + f.format(inpt) + &quot;:duration=&quot; + f.format(duration)</span>
                  + &quot;,setpts=PTS-STARTPTS&quot;
<span class="fc bfc" id="L1156" title="All 2 branches covered.">                  + ((vfade &gt; 0) ? &quot;,fade=t=in:st=0:d=&quot; + vfade + &quot;,fade=t=out:st=&quot; + f.format(vend) + &quot;:d=&quot; + vfade</span>
<span class="fc" id="L1157">                          : &quot;&quot;)</span>
                  + &quot;[&quot; + outmap + &quot;v&quot; + i + &quot;]&quot;;
<span class="fc" id="L1159">          clauses.add(vvclip);</span>
        }
<span class="fc bfc" id="L1161" title="All 2 branches covered.">        if (hasAudio) {</span>
          String aclip;
<span class="fc" id="L1163">          aclip = &quot;[&quot; + fileindx + &quot;:a]atrim=&quot; + f.format(inpt) + &quot;:duration=&quot; + f.format(duration)</span>
                  + &quot;,asetpts=PTS-STARTPTS&quot;
<span class="fc bfc" id="L1165" title="All 2 branches covered.">                  + ((afade &gt; 0)</span>
<span class="fc" id="L1166">                          ? &quot;,afade=t=in:st=0:d=&quot; + afade + &quot;,afade=t=out:st=&quot; + f.format(aend) + &quot;:d=&quot; + afade</span>
<span class="fc" id="L1167">                          : &quot;&quot;)</span>
                  + &quot;[&quot; + outmap + &quot;a&quot; + i + &quot;]&quot;;
<span class="fc" id="L1169">          clauses.add(aclip);</span>
        }
      }
      // use unsafe because different files may have different SAR/framerate
<span class="fc bfc" id="L1173" title="All 2 branches covered.">      if (hasVideo)</span>
<span class="fc" id="L1174">        clauses.add(StringUtils.join(vpads, &quot;&quot;) + &quot;concat=n=&quot; + n + &quot;:unsafe=1[ov]&quot;); // concat video clips</span>
<span class="fc bfc" id="L1175" title="All 2 branches covered.">      if (hasAudio)</span>
<span class="fc" id="L1176">        clauses.add(StringUtils.join(apads, &quot;&quot;) + &quot;concat=n=&quot; + n + &quot;:v=0:a=1[oa]&quot;); // concat audio clips in stream 0,</span>
<span class="fc bfc" id="L1177" title="All 2 branches covered.">    } else if (n == 1) { // single segment</span>
<span class="fc" id="L1178">      VideoClip vclip = clips.get(0);</span>
<span class="fc" id="L1179">      int fileindx = vclip.getSrc(); // get source file by index</span>
<span class="fc" id="L1180">      double inpt = vclip.getStart(); // get in points</span>
<span class="fc" id="L1181">      double duration = vclip.getDuration();</span>
<span class="fc" id="L1182">      double vend = Math.max(duration - vfade, 0);</span>
<span class="fc" id="L1183">      double aend = Math.max(duration - afade, 0);</span>

<span class="fc bfc" id="L1185" title="All 2 branches covered.">      if (hasVideo) {</span>
        String vvclip;

<span class="fc" id="L1188">        vvclip = &quot;[&quot; + fileindx + &quot;:v]trim=&quot; + f.format(inpt) + &quot;:duration=&quot; + f.format(duration)</span>
                + &quot;,setpts=PTS-STARTPTS&quot;
<span class="fc bfc" id="L1190" title="All 2 branches covered.">                + ((vfade &gt; 0) ? &quot;,fade=t=in:st=0:d=&quot; + vfade + &quot;,fade=t=out:st=&quot; + f.format(vend) + &quot;:d=&quot; + vfade : &quot;&quot;)</span>
                + &quot;[ov]&quot;;

<span class="fc" id="L1193">        clauses.add(vvclip);</span>
      }
<span class="fc bfc" id="L1195" title="All 2 branches covered.">      if (hasAudio) {</span>
        String aclip;
<span class="fc" id="L1197">        aclip = &quot;[&quot; + fileindx + &quot;:a]atrim=&quot; + f.format(inpt) + &quot;:duration=&quot; + f.format(duration)</span>
                + &quot;,asetpts=PTS-STARTPTS&quot;
<span class="fc bfc" id="L1199" title="All 2 branches covered.">                + ((afade &gt; 0) ? &quot;,afade=t=in:st=0:d=&quot; + afade + &quot;,afade=t=out:st=&quot; + f.format(aend) + &quot;:d=&quot; + afade</span>
<span class="fc" id="L1200">                        : &quot;&quot;)</span>
                + &quot;[oa]&quot;;

<span class="fc" id="L1203">        clauses.add(aclip);</span>
      }
    }
<span class="fc" id="L1206">    return clauses; // if no edits, there are no clauses</span>
  }

  private Map&lt;String, String&gt; getParamsFromFile(File parentFile) {
<span class="fc" id="L1210">    Map&lt;String, String&gt; params = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1211">    String videoInput = FilenameUtils.normalize(parentFile.getAbsolutePath());</span>
<span class="fc" id="L1212">    params.put(&quot;in.video.path&quot;, videoInput);</span>
<span class="fc" id="L1213">    params.put(&quot;in.video.name&quot;, FilenameUtils.getBaseName(videoInput));</span>
<span class="fc" id="L1214">    params.put(&quot;in.name&quot;, FilenameUtils.getBaseName(videoInput)); // One of the names</span>
<span class="fc" id="L1215">    params.put(&quot;in.video.suffix&quot;, FilenameUtils.getExtension(videoInput));</span>
<span class="fc" id="L1216">    params.put(&quot;in.video.filename&quot;, FilenameUtils.getName(videoInput));</span>
<span class="fc" id="L1217">    params.put(&quot;in.video.mimetype&quot;, MimetypesFileTypeMap.getDefaultFileTypeMap().getContentType(videoInput));</span>
<span class="fc" id="L1218">    String outDir = parentFile.getAbsoluteFile().getParent(); // Use first file dir</span>
<span class="fc" id="L1219">    params.put(&quot;out.dir&quot;, outDir);</span>
<span class="fc" id="L1220">    String outFileName = FilenameUtils.getBaseName(parentFile.getName());</span>
<span class="fc" id="L1221">    params.put(&quot;out.name.base&quot;, outFileName); // Base file name used</span>
<span class="fc" id="L1222">    params.put(&quot;out.name&quot;, outFileName); // file name used - may be replaced</span>
<span class="fc" id="L1223">    return params;</span>
  }

  /**
   * Concatenate segments of one or more input tracks specified by trim points into the track the edits are passed in as
   * double so that it is generic. The tracks are assumed to have the same resolution.
   *
   * @param inputs
   *          - input tracks as a list of files
   * @param edits
   *          - edits are a flat list of triplets, each triplet represent one clip: index (int) into input tracks, trim in point(long)
   *          in milliseconds and trim out point (long) in milliseconds for each segment
   * @param profiles
   *          - encoding profiles for each delivery target - [optional] one adaptive profile to apply to the outputs to
   *          generate manifests/playlists
   * @param transitionDuration
   *          in ms, transition time between each edited segment
   * @throws EncoderException
   *           - if it fails
   */
  public List&lt;File&gt; multiTrimConcat(List&lt;File&gt; inputs, List&lt;Long&gt; edits, List&lt;EncodingProfile&gt; profiles,
          int transitionDuration) throws EncoderException {
<span class="fc" id="L1245">    return multiTrimConcat(inputs, edits, profiles, transitionDuration, true, true);</span>

  }

  public List&lt;File&gt; multiTrimConcat(List&lt;File&gt; inputs, List&lt;Long&gt; edits, List&lt;EncodingProfile&gt; profiles,
          int transitionDuration, boolean hasVideo, boolean hasAudio)
          throws EncoderException, IllegalArgumentException {
<span class="pc bpc" id="L1252" title="2 of 4 branches missed.">    if (inputs == null || inputs.size() &lt; 1) {</span>
<span class="nc" id="L1253">      throw new IllegalArgumentException(&quot;At least one track must be specified.&quot;);</span>
    }
<span class="pc bpc" id="L1255" title="1 of 4 branches missed.">    if (edits == null &amp;&amp; inputs.size() &gt; 1) {</span>
<span class="nc" id="L1256">      throw new IllegalArgumentException(&quot;If there is no editing, only one track can be specified.&quot;);</span>
    }
<span class="fc" id="L1258">    List&lt;VideoClip&gt; clips = null;</span>
<span class="fc bfc" id="L1259" title="All 2 branches covered.">    if (edits != null) {</span>
<span class="fc" id="L1260">      clips = new ArrayList&lt;VideoClip&gt;(edits.size() / 3);</span>
<span class="fc" id="L1261">      int adjust = 0;</span>
      // When the first clip starts at 0, and there is a fade, lip sync can be off,
      // this adjustment will mitigate the problem
<span class="fc bfc" id="L1264" title="All 2 branches covered.">      for (int i = 0; i &lt; edits.size(); i += 3) {</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">        if (edits.get(i + 1) &lt; transitionDuration) // If taken from the beginning of video</span>
<span class="fc" id="L1266">          adjust = transitionDuration / 2000; // add half the fade duration in seconds</span>
        else
<span class="fc" id="L1268">          adjust = 0;</span>
<span class="fc" id="L1269">        clips.add(new VideoClip(edits.get(i).intValue(), (double) edits.get(i + 1) / 1000 + adjust,</span>
<span class="fc" id="L1270">              (double) edits.get(i + 2) / 1000));</span>
      }
      try {
<span class="fc" id="L1273">        clips = sortSegments(clips, transitionDuration / 1000); // remove bad edit points</span>
<span class="nc" id="L1274">      } catch (Exception e) {</span>
<span class="nc" id="L1275">        logger.error(&quot;Illegal edits, cannot sort segment&quot;, e);</span>
<span class="nc" id="L1276">      throw new EncoderException(&quot;Cannot understand the edit points&quot;, e);</span>
<span class="fc" id="L1277">      }</span>
    }
    // Set encoding parameters
<span class="fc" id="L1280">    Map&lt;String, String&gt; params = null;</span>
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">    if (inputs.size() &gt; 0) { // Shared parameters - the rest are profile specific</span>
<span class="fc" id="L1282">      params = getParamsFromFile(inputs.get(0));</span>
    }
<span class="pc bpc" id="L1284" title="2 of 4 branches missed.">    if (profiles == null || profiles.size() == 0) {</span>
<span class="nc" id="L1285">      logger.error(&quot;Missing encoding profiles&quot;);</span>
<span class="nc" id="L1286">      throw new EncoderException(&quot;Missing encoding profile(s)&quot;);</span>
    }
    try {
<span class="fc" id="L1289">      List&lt;String&gt; command = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1290">      List&lt;String&gt; clauses = makeEdits(clips, transitionDuration, hasVideo, hasAudio); // map inputs into [ov]</span>
                                                                                               // and [oa]
      // Entry point for multiencode here, if edits is empty, then use raw channels instead of output from edits
<span class="fc bfc" id="L1293" title="All 2 branches covered.">      String videoOut = (clips == null) ? &quot;[0:v]&quot; : &quot;[ov]&quot;;</span>
<span class="fc bfc" id="L1294" title="All 2 branches covered.">      String audioOut = (clips == null) ? &quot;[0:a]&quot; : &quot;[oa]&quot;;</span>
<span class="fc bfc" id="L1295" title="All 2 branches covered.">      OutputAggregate outmaps = new OutputAggregate(profiles, params, (hasVideo ? videoOut : null),</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">              (hasAudio ? audioOut : null)); // map outputs from ov and oa</span>
<span class="fc bfc" id="L1297" title="All 2 branches covered.">      if (hasAudio) {</span>
<span class="fc" id="L1298">        clauses.add(outmaps.getAsplit());</span>
<span class="fc" id="L1299">        clauses.add(outmaps.getAudioFilter());</span>
      }
<span class="fc bfc" id="L1301" title="All 2 branches covered.">      if (hasVideo) {</span>
<span class="fc" id="L1302">        clauses.add(outmaps.getVsplit());</span>
<span class="fc" id="L1303">        clauses.add(outmaps.getVideoFilter());</span>
      }
<span class="fc" id="L1305">      clauses.removeIf(Objects::isNull); // remove all empty filters</span>
<span class="fc" id="L1306">      command.add(&quot;-nostats&quot;); // no progress report</span>
<span class="fc" id="L1307">      command.add(&quot;-hide_banner&quot;); // no configuration/library info</span>
<span class="fc bfc" id="L1308" title="All 2 branches covered.">      for (File o : inputs) {</span>
<span class="fc" id="L1309">        command.add(&quot;-i&quot;); // Add inputfile in the order of entry</span>
<span class="fc" id="L1310">        command.add(o.getCanonicalPath());</span>
<span class="fc" id="L1311">      }</span>
<span class="fc bfc" id="L1312" title="All 2 branches covered.">      if (!clauses.isEmpty()) {</span>
<span class="fc" id="L1313">        command.add(&quot;-filter_complex&quot;);</span>
<span class="fc" id="L1314">        command.add(StringUtils.join(clauses, &quot;;&quot;));</span>
      }
<span class="fc bfc" id="L1316" title="All 2 branches covered.">      for (String outpad : outmaps.getOutput()) {</span>
<span class="fc" id="L1317">        command.addAll(commandSplit(outpad)); // split by space</span>
<span class="fc" id="L1318">      }</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">      if (outmaps.hasAdaptivePlaylist()) {</span>
<span class="fc" id="L1320">        List&lt;File&gt; results = process(command); // Run the ffmpeg command</span>
        // Sort list of segmented mp4s because the output segments are numbered
<span class="fc" id="L1322">        List&lt;File&gt; segments = results.stream().filter(AdaptivePlaylist.isHLSFilePred.negate())</span>
<span class="fc" id="L1323">                .collect(Collectors.toList());</span>
<span class="fc" id="L1324">        segments.sort((File f1, File f2) -&gt; f1.getName().compareTo(f2.getName()));</span>
<span class="fc" id="L1325">        List&lt;String&gt; suffixes = outmaps.getSegmentOutputSuffixes();</span>
<span class="fc" id="L1326">        HashMap&lt;File, File&gt; renames = new HashMap&lt;File, File&gt;();</span>
<span class="fc" id="L1327">        results.forEach((f) -&gt; {</span>
<span class="fc" id="L1328">          renames.put(f, f); // init</span>
<span class="fc" id="L1329">        });</span>
<span class="fc bfc" id="L1330" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.size(); i++) {</span>
<span class="fc" id="L1331">          File file = segments.get(i);</span>
          // Construct a new name with old name (unique within this group) and profile suffix
<span class="fc" id="L1333">          String newname = FilenameUtils.concat(file.getParent(),</span>
<span class="fc" id="L1334">                  FilenameUtils.getBaseName(file.getName()) + suffixes.get(i));</span>
<span class="fc" id="L1335">          renames.put(file, new File(newname)); // only segments change names</span>
        }
        // Adjust the playlists to use new names
<span class="fc" id="L1338">        return AdaptivePlaylist.hlsRenameAllFiles(results, renames);</span>
      }
<span class="fc" id="L1340">      return process(command); // Run the ffmpeg command and return outputs</span>
<span class="fc" id="L1341">    } catch (Exception e) {</span>
<span class="fc" id="L1342">      logger.error(&quot;MultiTrimConcat failed to run command {} &quot;, e.getMessage());</span>
<span class="fc" id="L1343">      throw new EncoderException(&quot;Cannot encode the inputs&quot;,e);</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>