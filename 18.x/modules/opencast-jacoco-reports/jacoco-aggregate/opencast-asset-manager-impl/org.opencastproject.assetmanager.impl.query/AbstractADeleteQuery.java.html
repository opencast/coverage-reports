<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractADeleteQuery.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-asset-manager-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.assetmanager.impl.query</a> &gt; <span class="el_source">AbstractADeleteQuery.java</span></div><h1>AbstractADeleteQuery.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.assetmanager.impl.query;

import static com.entwinemedia.fn.Stream.$;
import static java.lang.String.format;

import org.opencastproject.assetmanager.api.query.ADeleteQuery;
import org.opencastproject.assetmanager.api.query.Predicate;
import org.opencastproject.assetmanager.api.storage.AssetStore;
import org.opencastproject.assetmanager.api.storage.DeletionSelector;
import org.opencastproject.assetmanager.impl.AssetManagerImpl;
import org.opencastproject.assetmanager.impl.RuntimeTypes;
import org.opencastproject.assetmanager.impl.VersionImpl;
import org.opencastproject.assetmanager.impl.persistence.Conversions;
import org.opencastproject.assetmanager.impl.persistence.EntityPaths;
import org.opencastproject.assetmanager.impl.persistence.QPropertyDto;
import org.opencastproject.assetmanager.impl.persistence.QSnapshotDto;
import org.opencastproject.util.data.Function;

import com.entwinemedia.fn.Fn;
import com.entwinemedia.fn.data.SetB;
import com.mysema.query.Tuple;
import com.mysema.query.jpa.JPASubQuery;
import com.mysema.query.jpa.impl.JPADeleteClause;
import com.mysema.query.jpa.impl.JPAQueryFactory;
import com.mysema.query.support.Expressions;
import com.mysema.query.types.EntityPath;
import com.mysema.query.types.expr.BooleanExpression;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collections;
import java.util.List;
import java.util.Set;

public abstract class AbstractADeleteQuery implements ADeleteQuery, DeleteQueryContributor, EntityPaths {
<span class="fc" id="L57">  private static final Logger logger = LoggerFactory.getLogger(AbstractADeleteQuery.class);</span>

  private AssetManagerImpl am;
  private String owner;

<span class="fc" id="L62">  public AbstractADeleteQuery(AssetManagerImpl am, String owner) {</span>
<span class="fc" id="L63">    this.am = am;</span>
<span class="fc" id="L64">    this.owner = owner;</span>
<span class="fc" id="L65">  }</span>

  @Override public ADeleteQuery name(final String queryName) {
<span class="fc" id="L68">    return new AbstractADeleteQuery(am, owner) {</span>
      @Override public DeleteQueryContribution contributeDelete(String owner) {
<span class="fc" id="L70">        final DeleteQueryContribution cParent = AbstractADeleteQuery.this.contributeDelete(owner);</span>
<span class="fc" id="L71">        return DeleteQueryContribution.mk(cParent).name(queryName);</span>
      }
    };
  }

  @Override public ADeleteQuery where(final Predicate predicate) {
<span class="fc" id="L77">    return new AbstractADeleteQuery(am, owner) {</span>
      @Override public DeleteQueryContribution contributeDelete(String owner) {
<span class="fc" id="L79">        final DeleteQueryContribution cParent = AbstractADeleteQuery.this.contributeDelete(owner);</span>
<span class="fc" id="L80">        final DeleteQueryContribution cPredicate = RuntimeTypes.convert(predicate).contributeDelete(owner);</span>
<span class="fc" id="L81">        return DeleteQueryContribution.mk()</span>
<span class="fc" id="L82">                .from(cParent.from.append(cPredicate.from))</span>
<span class="fc" id="L83">                .targetPredicate(cParent.targetPredicate)</span>
<span class="fc" id="L84">                .where(JpaFns.allOf(cParent.where, cPredicate.where));</span>
      }

      @Override public String toString() {
<span class="nc" id="L88">        return &quot;where &quot; + predicate;</span>
      }
    };
  }

  public long run(DeleteEpisodeHandler deleteEpisodeHandler) {
    // run query and map the result to records
<span class="fc" id="L95">    final long startTime = System.nanoTime();</span>
    // resolve AST
<span class="fc" id="L97">    final DeleteQueryContribution c = contributeDelete(owner);</span>
    // run all queries in a single transaction
<span class="fc" id="L99">    final DeletionResult deletion = am.getDatabase().run(new Function&lt;JPAQueryFactory, DeletionResult&gt;() {</span>
      @Override public DeletionResult apply(final JPAQueryFactory jpa) {
<span class="fc" id="L101">        return runQueries(jpa, c);</span>
      }
    });
<span class="fc" id="L104">    logger.debug(&quot;Pure query ms &quot; + (System.nanoTime() - startTime) / 1000000);</span>
    // delete from store
<span class="fc bfc" id="L106" title="All 2 branches covered.">    for (Tuple t : deletion.deletedSnapshots) {</span>
      // all three t.get(..) calls won't return null since the database fields are not null.
<span class="fc" id="L108">      final String orgId = t.get(Q_SNAPSHOT.organizationId);</span>
<span class="fc" id="L109">      final String mpId = t.get(Q_SNAPSHOT.mediaPackageId);</span>
<span class="fc" id="L110">      final VersionImpl version = Conversions.toVersion(t.get(Q_SNAPSHOT.version));</span>
<span class="fc" id="L111">      final DeletionSelector deletionSelector = DeletionSelector.delete(orgId, mpId, version);</span>
<span class="fc" id="L112">      am.getLocalAssetStore().delete(deletionSelector);</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">      for (AssetStore as : am.getRemoteAssetStores()) {</span>
<span class="fc" id="L114">        as.delete(deletionSelector);</span>
<span class="fc" id="L115">      }</span>
<span class="fc" id="L116">    }</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">    for (String mpId : deletion.deletedEpisodes) {</span>
<span class="fc" id="L118">      deleteEpisodeHandler.handleDeletedEpisode(mpId);</span>
<span class="fc" id="L119">    }</span>
<span class="fc" id="L120">    final long searchTime = (System.nanoTime() - startTime) / 1000000;</span>
<span class="fc" id="L121">    logger.debug(&quot;Complete query ms &quot; + searchTime);</span>
<span class="fc" id="L122">    return deletion.deletedItemsCount;</span>
  }

  /** Run this in a transaction. */
  private DeletionResult runQueries(JPAQueryFactory jpa, DeleteQueryContribution c) {
    // # create Querydsl delete clause
    // # from
    // put into a set to remove duplicates
    final EntityPath&lt;?&gt; from;
    {
<span class="fc" id="L132">      final Set&lt;EntityPath&lt;?&gt;&gt; f = c.from.toSet(SetB.MH);</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">      if (f.size() == 1) {</span>
<span class="fc" id="L134">        from = $(f).head2();</span>
      } else {
<span class="nc" id="L136">        throw new RuntimeException(&quot;Only one entity is allowed in the from clause&quot;);</span>
      }
    }
    //
<span class="fc bfc" id="L140" title="All 2 branches covered.">    if (from instanceof QSnapshotDto) {</span>
      // from Snapshot
      //
<span class="fc" id="L143">      final BooleanExpression where = Expressions.allOf(</span>
<span class="fc" id="L144">              c.targetPredicate.orNull(),</span>
<span class="fc" id="L145">              c.where.apply(Q_SNAPSHOT));</span>
      // get snapshots to delete
      // TODO ATTENTION: this query has the potential to yield a massive amount of elements
      // return the list of snapshots to delete them outside the transaction since
      // it may take a while.
<span class="fc" id="L150">      final List&lt;Tuple&gt; deletedSnapshots = jpa.query()</span>
<span class="fc" id="L151">              .from(Q_SNAPSHOT)</span>
<span class="fc" id="L152">              .where(where)</span>
<span class="fc" id="L153">              .list(Q_SNAPSHOT.organizationId, Q_SNAPSHOT.mediaPackageId, Q_SNAPSHOT.version);</span>
// &lt;BLOCK&gt;
// TODO database only approach to determine deleted episodes
// TODO does not run with H2 so unit tests break
      /*
SELECT
  e.mediapackage_id,
  count(*) AS v
FROM oc_assets_snapshot e
GROUP BY e.mediapackage_id
HAVING v = (SELECT count(*)
            FROM oc_assets_snapshot e2
            WHERE e.mediapackage_id = e2.mediapackage_id
                  AND
                  -- delete where clause
                  (e2.version = 2 OR e2.mediapackage_id = '24ec925e-ea57-43a5-a7bb-58dc5aae54dd')
            GROUP BY mediapackage_id);
       */
//      final QSnapshotDto e2 = new QSnapshotDto(&quot;eee&quot;);
//      final List&lt;String&gt; deletedSnapshots = jpa.query()
//              .from(e2)
//              .groupBy(e2.mediaPackageId)
//              .having(e2.count().eq(
//                      jpa.subQuery()
//                              .from(Q_SNAPSHOT)
//                              .where(Q_SNAPSHOT.mediaPackageId.eq(e2.mediaPackageId).and(where))
//                              .groupBy(Q_SNAPSHOT.mediaPackageId)
//                              .count()))
//              .list(e2.mediaPackageId);
// &lt;/BLOCK&gt;
      // main delete query
<span class="fc" id="L184">      final JPADeleteClause qMain = jpa.delete(Q_SNAPSHOT).where(where);</span>
<span class="fc" id="L185">      am.getDatabase().logDelete(formatQueryName(c.name, &quot;main&quot;), qMain);</span>
<span class="fc" id="L186">      final long deletedItems = qMain.execute();</span>
      // &lt;BLOCK&gt;
      // TODO Bad solution. Yields all media package IDs which can easily be thousands
      // TODO The above SQL solution does not work with H2 so I suspect the query is not 100% clean
      // TODO Rework the query and replace this code.
      // calculate deleted episodes, i.e. where all snapshots have been deleted
      final Set&lt;String&gt; deletedEpisodes;
      {
<span class="fc" id="L194">        final List&lt;String&gt; remainingSnapshots = jpa.query()</span>
<span class="fc" id="L195">                .from(Q_SNAPSHOT)</span>
<span class="fc" id="L196">                .distinct()</span>
<span class="fc" id="L197">                .list(Q_SNAPSHOT.mediaPackageId);</span>
<span class="fc" id="L198">        final Set&lt;String&gt; d = $(deletedSnapshots).map(new Fn&lt;Tuple, String&gt;() {</span>
          @Override public String apply(Tuple tuple) {
<span class="fc" id="L200">            return tuple.get(Q_SNAPSHOT.mediaPackageId);</span>
          }
<span class="fc" id="L202">        }).toSet(SetB.MH);</span>
<span class="fc" id="L203">        d.removeAll(remainingSnapshots);</span>
<span class="fc" id="L204">        deletedEpisodes = Collections.unmodifiableSet(d);</span>
      }
      // &lt;/BLOCK&gt;
<span class="fc" id="L207">      return new DeletionResult(deletedItems, deletedSnapshots, deletedEpisodes);</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">    } else if (from instanceof QPropertyDto) {</span>
      // from Property
      //
      final BooleanExpression where;
      {
<span class="fc" id="L213">        final BooleanExpression w = c.where.apply(Q_PROPERTY);</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (w != null) {</span>
          /* The original sub query used an &quot;ON&quot; clause to filter the join by mediapackage id [1].
             Unfortunately Eclipse link drops this clause completely when transforming the query
             into SQL. It creates a cross join instead of the inner join, which is perfectly legal
             if the &quot;ON&quot; clause would be moved to the &quot;WHERE&quot; clause.
             The example [2] shows that neither an &quot;ON&quot; clause nor an additional &quot;WHERE&quot; predicate is generated.

             [1]
             new JPASubQuery()
                .from(Q_PROPERTY)
                .join(Q_SNAPSHOT) &lt;- inner join
                .on(Q_PROPERTY.mediaPackageId.eq(Q_SNAPSHOT.mediaPackageId)) &lt;- dropped by Eclipse link
                .where(Q_PROPERTY.mediaPackageId.eq(Q_SNAPSHOT.mediaPackageId).and(w))
                .distinct()
                .list(Q_PROPERTY.mediaPackageId)

             [2]
             SELECT DISTINCT t1.mediapackage_id FROM oc_assets_snapshot t2, oc_assets_properties t1
                 WHERE (t2.organization_id = ?)
           */
<span class="fc" id="L234">          where = Q_PROPERTY.mediaPackageId.in(</span>
              new JPASubQuery()
<span class="fc" id="L236">                  .from(Q_PROPERTY)</span>
<span class="fc" id="L237">                  .join(Q_SNAPSHOT)</span>
                  // move the join condition from the &quot;ON&quot; clause (mediapackage_id) to the
                  // where clause. Find an explanation above.
<span class="fc" id="L240">                  .where(Q_PROPERTY.mediaPackageId.eq(Q_SNAPSHOT.mediaPackageId).and(w))</span>
<span class="fc" id="L241">                  .distinct()</span>
<span class="fc" id="L242">                  .list(Q_PROPERTY.mediaPackageId));</span>
        } else {
<span class="fc" id="L244">          where = null;</span>
        }
      }
<span class="fc" id="L247">      final JPADeleteClause qProperties = jpa.delete(from).where(Expressions.allOf(c.targetPredicate.orNull(), where));</span>
<span class="fc" id="L248">      am.getDatabase().logDelete(formatQueryName(c.name, &quot;main&quot;), qProperties);</span>
<span class="fc" id="L249">      final long deletedItems = qProperties.execute();</span>
<span class="fc" id="L250">      return new DeletionResult(deletedItems, Collections.&lt;Tuple&gt;emptyList(), Collections.&lt;String&gt;emptySet());</span>
    } else {
      // from contains an unsupported entity
<span class="nc" id="L253">      throw new RuntimeException(&quot;[Bug]&quot;);</span>
    }
  }

  @Override public long run() {
<span class="nc" id="L258">    return run(DELETE_EPISODE_HANDLER);</span>
  }

  private static String formatQueryName(String name, String subQueryName) {
<span class="fc" id="L262">    return format(&quot;[%s] [%s]&quot;, name, subQueryName);</span>
  }

  /**
   * Call {@link #run(DeleteEpisodeHandler)} with a deletion handler to get notified about deletions.
   */
  public interface DeleteEpisodeHandler {

    void handleDeletedEpisode(String mpId);
  }

<span class="fc" id="L273">  public static final DeleteEpisodeHandler DELETE_EPISODE_HANDLER = new DeleteEpisodeHandler() {</span>

    @Override public void handleDeletedEpisode(String mpId) {
<span class="nc" id="L276">    }</span>
  };

  public final class DeletionResult {
    // CHECKSTYLE:OFF
    public final long deletedItemsCount;
    public final List&lt;Tuple&gt; deletedSnapshots;
    public final Set&lt;String&gt; deletedEpisodes;
    // CHECKSTYLE:ON

    public DeletionResult(
<span class="fc" id="L287">            long deletedItemsCount, List&lt;Tuple&gt; deletedSnapshots, Set&lt;String&gt; deletedEpisodes) {</span>
<span class="fc" id="L288">      this.deletedItemsCount = deletedItemsCount;</span>
<span class="fc" id="L289">      this.deletedSnapshots = deletedSnapshots;</span>
<span class="fc" id="L290">      this.deletedEpisodes = deletedEpisodes;</span>
<span class="fc" id="L291">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>