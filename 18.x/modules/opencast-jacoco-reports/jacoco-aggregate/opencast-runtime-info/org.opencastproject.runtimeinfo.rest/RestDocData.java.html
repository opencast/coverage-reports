<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RestDocData.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-runtime-info</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.runtimeinfo.rest</a> &gt; <span class="el_source">RestDocData.java</span></div><h1>RestDocData.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.runtimeinfo.rest;

import static org.apache.commons.lang3.StringUtils.isBlank;

import org.opencastproject.util.doc.DocData;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.ws.rs.Path;
import javax.ws.rs.Produces;

/**
 * This is the document model class which holds the data about a set of rest endpoints.
 */
public class RestDocData extends DocData {

  /**
   * The name to identify the endpoint holder for read endpoints (get/head).
   */
  private static final String READ_ENDPOINT_HOLDER_NAME = &quot;READ&quot;;

  /**
   * The name to identify the endpoint holder for write endpoints (delete,post,put).
   */
  private static final String WRITE_ENDPOINT_HOLDER_NAME = &quot;WRITE&quot;;

  /**
   * Regular expression used to count the number of path parameters in a path.
   */
  public static final String PATH_PARAM_COUNTING_REGEX = &quot;\\{(.+?)\\}&quot;;

  /**
   * List of RestEndpointHolderData which each stores a group of endpoints. Currently there are 2 groups, READ group and
   * WRITE group.
   */
  protected List&lt;RestEndpointHolderData&gt; holders;

  /**
   * Create the base data object for creating REST documentation.
   *
   * @param name
   *          the name of the set of rest endpoints (must be alphanumeric (includes _) and no spaces or special chars)
   * @param title
   *          [OPTIONAL] the title of the documentation
   * @param url
   *          this is the absolute base URL for this endpoint, do not include the trailing slash (e.g. /workflow)
   * @param notes
   *          [OPTIONAL] an array of notes to add into the end of the documentation
   * @throws IllegalArgumentException
   *           if the url is null or empty
   */
  public RestDocData(String name, String title, String url, String[] notes) throws IllegalArgumentException {
<span class="fc" id="L83">    super(name, title, notes);</span>
<span class="pc bpc" id="L84" title="2 of 4 branches missed.">    if (url == null || &quot;&quot;.equals(url)) {</span>
<span class="nc" id="L85">      throw new IllegalArgumentException(&quot;URL cannot be blank.&quot;);</span>
    }
<span class="fc" id="L87">    meta.put(&quot;url&quot;, url);</span>
    // create the endpoint holders
<span class="fc" id="L89">    holders = new Vector&lt;RestEndpointHolderData&gt;(2);</span>
<span class="fc" id="L90">    holders.add(new RestEndpointHolderData(READ_ENDPOINT_HOLDER_NAME, &quot;Read&quot;));</span>
<span class="fc" id="L91">    holders.add(new RestEndpointHolderData(WRITE_ENDPOINT_HOLDER_NAME, &quot;Write&quot;));</span>
<span class="fc" id="L92">  }</span>

  /**
   * Verify the integrity of this object. If its data is verified to be okay, it return a map representation of this
   * RestDocData object.
   *
   * @return a map representation of this RestDocData object if this object passes the verification
   *
   * @throws IllegalStateException
   *           if any path parameter is not present in the endpoint's path
   */
  @Override
  public Map&lt;String, Object&gt; toMap() throws IllegalStateException {
<span class="nc" id="L105">    LinkedHashMap&lt;String, Object&gt; m = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L106">    m.put(&quot;meta&quot;, meta);</span>
<span class="nc" id="L107">    m.put(&quot;notes&quot;, notes);</span>
    // only pass through the holders with things in them
<span class="nc" id="L109">    ArrayList&lt;RestEndpointHolderData&gt; holdersList = new ArrayList&lt;RestEndpointHolderData&gt;();</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">    for (RestEndpointHolderData holder : holders) {</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">      if (!holder.getEndpoints().isEmpty()) {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">        for (RestEndpointData endpoint : holder.getEndpoints()) {</span>
          // Validate the endpoint path matches the specified path parameters.
          // First, it makes sure that every path parameter is present in the endpoint's path.
<span class="nc bnc" id="L115" title="All 2 branches missed.">          if (!endpoint.getPathParams().isEmpty()) {</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            for (RestParamData param : endpoint.getPathParams()) {</span>
              // Some endpoints allow for arbitrary characters, including slashes, in their path parameters, so we
              // must check for both {param} and {param:.*}.
<span class="nc bnc" id="L119" title="All 2 branches missed.">              if (!endpoint.getPath().contains(&quot;{&quot; + param.getName() + &quot;}&quot;)</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                      &amp;&amp; !endpoint.getPath().contains(&quot;{&quot; + param.getName() + &quot;:&quot;)) {</span>
<span class="nc" id="L121">                throw new IllegalStateException(&quot;Path (&quot; + endpoint.getPath() + &quot;) does not match path parameter (&quot;</span>
<span class="nc" id="L122">                        + param.getName() + &quot;) for endpoint (&quot; + endpoint.getName()</span>
                        + &quot;), the path must contain all path parameter names.&quot;);
              }
<span class="nc" id="L125">            }</span>
          }
          // Then, it makes sure that the number of path parameter patterns in the path is the same as the number of
          // path parameters in the endpoint.
          // The following part uses a regular expression to find patterns like {something}.
<span class="nc" id="L130">          Pattern pattern = Pattern.compile(PATH_PARAM_COUNTING_REGEX);</span>
<span class="nc" id="L131">          Matcher matcher = pattern.matcher(endpoint.getPath());</span>

<span class="nc" id="L133">          int count = 0;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">          while (matcher.find()) {</span>
<span class="nc" id="L135">            count++;</span>
          }
<span class="nc bnc" id="L137" title="All 2 branches missed.">          if (count != endpoint.getPathParams().size()) {</span>
<span class="nc" id="L138">            throw new IllegalStateException(&quot;Path (&quot; + endpoint.getPath() + &quot;) does not match path parameters (&quot;</span>
<span class="nc" id="L139">                    + endpoint.getPathParams() + &quot;) for endpoint (&quot; + endpoint.getName()</span>
                    + &quot;), the path must contain the same number of path parameters (&quot; + count
<span class="nc" id="L141">                    + &quot;) as the pathParams list (&quot; + endpoint.getPathParams().size() + &quot;).&quot;);</span>
          }
<span class="nc" id="L143">        }</span>
<span class="nc" id="L144">        holdersList.add(holder);</span>
      }
<span class="nc" id="L146">    }</span>
<span class="nc" id="L147">    m.put(&quot;endpointHolders&quot;, holdersList);</span>
<span class="nc" id="L148">    return m;</span>
  }

  /**
   * Gets the path to the default template (a .xhtml file).
   *
   * @return the path to the default template file
   */
  @Override
  public String getDefaultTemplatePath() {
<span class="nc" id="L158">    return TEMPLATE_DEFAULT;</span>
  }

  /**
   * Returns a string representation of this object.
   *
   * @return a string representation of this object
   */
  @Override
  public String toString() {
<span class="nc" id="L168">    return &quot;DOC:meta=&quot; + meta + &quot;, notes=&quot; + notes + &quot;, &quot; + holders;</span>
  }

  /**
   * Add an endpoint to this documentation using and assign it to the correct type group (read/write).
   *
   * @param type
   *          the type of this endpoint (RestEndpointData.Type.READ or RestEndpointData.Type.WRITE)
   * @param endpoint
   *          the endpoint to be added
   * @throws IllegalStateException
   *           if the endpoint cannot be assigned to a group
   */
  private void addEndpoint(String type, RestEndpointData endpoint) throws IllegalStateException {
<span class="nc" id="L182">    RestEndpointHolderData currentHolder = null;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">    for (RestEndpointHolderData holder : holders) {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">      if (type.equalsIgnoreCase(holder.getName())) {</span>
<span class="nc" id="L185">        currentHolder = holder;</span>
<span class="nc" id="L186">        break;</span>
      }
<span class="nc" id="L188">    }</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">    if (currentHolder == null) {</span>
<span class="nc" id="L190">      throw new IllegalStateException(&quot;Could not find holder of type: &quot; + type + &quot;.&quot;);</span>
    }
<span class="nc" id="L192">    currentHolder.addEndPoint(endpoint);</span>
<span class="nc" id="L193">  }</span>

  /**
   * Creates an abstract section which is displayed at the top of the documentation page.
   *
   * @param abstractText
   *          any text to place at the top of the document, can be html markup but must be valid
   */
  public void setAbstract(String abstractText) {
<span class="nc bnc" id="L202" title="All 2 branches missed.">    if (isBlank(abstractText)) {</span>
<span class="nc" id="L203">      meta.remove(&quot;abstract&quot;);</span>
    } else {
<span class="nc" id="L205">      meta.put(&quot;abstract&quot;, abstractText);</span>
    }
<span class="nc" id="L207">  }</span>

  /**
   * Validates paths: VALID: /sample , /sample/{thing} , /{my}/{path}.xml , /my/fancy_path/is/{awesome}.{FORMAT}
   * INVALID: sample, /sample/, /sa#$%mple/path
   *
   * @param path
   *          the path value to check
   * @return true if this path is valid, false otherwise
   */
  public static boolean isValidPath(String path) {
<span class="pc bpc" id="L218" title="2 of 4 branches missed.">    return path != null &amp;&amp; path.matches(&quot;^/$|^/[\\w/{}|:.*+]*[\\w}.]$&quot;);</span>
  }

  /**
   * Add an endpoint to the Rest documentation.
   *
   * @param restQuery
   *          the RestQuery annotation type storing information of an endpoint
   * @param returnType
   *          the return type for this endpoint. If this is {@link javax.xml.bind.annotation.XmlRootElement} or
   *          {@link javax.xml.bind.annotation.XmlRootElement}, the XML schema for the class will be made available to
   *          clients
   * @param produces
   *          the return type(s) of this endpoint, values should be constants from &lt;a
   *          href=&quot;http://jackson.codehaus.org/javadoc/jax-rs/1.0/javax/ws/rs/core/MediaType.html&quot;
   *          &gt;javax.ws.rs.core.MediaType&lt;/a&gt; or ExtendedMediaType
   *          (org.opencastproject.util.doc.rest.ExtendedMediaType).
   * @param httpMethodString
   *          the HTTP method of this endpoint (e.g. GET, POST)
   * @param path
   *          the path of this endpoint
   */
  public void addEndpoint(RestQuery restQuery, Class&lt;?&gt; returnType, Produces produces, String httpMethodString,
          Path path) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">    String pathValue = path.value().startsWith(&quot;/&quot;) ? path.value() : &quot;/&quot; + path.value();</span>
<span class="nc" id="L243">    RestEndpointData endpoint = new RestEndpointData(returnType, restQuery.name(), httpMethodString, pathValue,</span>
<span class="nc" id="L244">            restQuery.description());</span>
    // Add return description if needed
<span class="nc bnc" id="L246" title="All 2 branches missed.">    if (!restQuery.returnDescription().isEmpty()) {</span>
<span class="nc" id="L247">      endpoint.addNote(&quot;Return value description: &quot; + restQuery.returnDescription());</span>
    }

    // Add formats
<span class="nc bnc" id="L251" title="All 2 branches missed.">    if (produces != null) {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">      for (String format : produces.value()) {</span>
<span class="nc" id="L253">        endpoint.addFormat(new RestFormatData(format));</span>
      }
    }

    // Add responses
<span class="nc bnc" id="L258" title="All 2 branches missed.">    for (RestResponse restResp : restQuery.responses()) {</span>
<span class="nc" id="L259">      endpoint.addStatus(restResp);</span>
    }

    // Add body parameter
<span class="nc bnc" id="L263" title="All 2 branches missed.">    if (restQuery.bodyParameter().type() != RestParameter.Type.NO_PARAMETER) {</span>
<span class="nc" id="L264">      endpoint.addBodyParam(restQuery.bodyParameter());</span>
    }

    // Add path parameter
<span class="nc bnc" id="L268" title="All 2 branches missed.">    for (RestParameter pathParam : restQuery.pathParameters()) {</span>
<span class="nc" id="L269">      endpoint.addPathParam(new RestParamData(pathParam));</span>
    }

    // Add query parameter (required and optional)
<span class="nc bnc" id="L273" title="All 2 branches missed.">    for (RestParameter restParam : restQuery.restParameters()) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">      if (restParam.isRequired()) {</span>
<span class="nc" id="L275">        endpoint.addRequiredParam(new RestParamData(restParam));</span>
      } else {
<span class="nc" id="L277">        endpoint.addOptionalParam(new RestParamData(restParam));</span>
      }
    }

    // Set the test form after all parameters are added.
<span class="nc" id="L282">    endpoint.setTestForm(new RestFormData(endpoint));</span>

    // Add the endpoint to the corresponding group based on its HTTP method
<span class="nc bnc" id="L285" title="All 4 branches missed.">    if (&quot;GET&quot;.equalsIgnoreCase(httpMethodString) || &quot;HEAD&quot;.equalsIgnoreCase(httpMethodString)) {</span>
<span class="nc" id="L286">      addEndpoint(READ_ENDPOINT_HOLDER_NAME, endpoint);</span>
<span class="nc bnc" id="L287" title="All 4 branches missed.">    } else if (&quot;DELETE&quot;.equalsIgnoreCase(httpMethodString) || &quot;POST&quot;.equalsIgnoreCase(httpMethodString)</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            || &quot;PUT&quot;.equalsIgnoreCase(httpMethodString)) {</span>
<span class="nc" id="L289">      addEndpoint(WRITE_ENDPOINT_HOLDER_NAME, endpoint);</span>
    }
<span class="nc" id="L291">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>