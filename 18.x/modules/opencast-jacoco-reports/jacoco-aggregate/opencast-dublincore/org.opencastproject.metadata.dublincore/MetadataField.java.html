<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MetadataField.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-dublincore</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.metadata.dublincore</a> &gt; <span class="el_source">MetadataField.java</span></div><h1>MetadataField.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.metadata.dublincore;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Map;
import java.util.TimeZone;

/**
 * This is a generic and very abstract view of a certain field/property in a metadata catalog. The main purpose of this
 * class is to have a generic access to the variety of information stored in metadata catalogs.
 */
public class MetadataField {

<span class="fc" id="L39">  private static final Logger logger = LoggerFactory.getLogger(MetadataField.class);</span>

  /** Keys for the different values in the configuration file */
  public static final String CONFIG_COLLECTION_ID_KEY = &quot;collectionID&quot;;
  private static final String CONFIG_PATTERN_KEY = &quot;pattern&quot;;
  private static final String CONFIG_DELIMITER_KEY = &quot;delimiter&quot;;
  public static final String CONFIG_INPUT_ID_KEY = &quot;inputID&quot;;
  public static final String CONFIG_LABEL_KEY = &quot;label&quot;;
  public static final String CONFIG_LIST_PROVIDER_KEY = &quot;listprovider&quot;;
  private static final String CONFIG_NAMESPACE_KEY = &quot;namespace&quot;;
  private static final String CONFIG_ORDER_KEY = &quot;order&quot;;
  private static final String CONFIG_OUTPUT_ID_KEY = &quot;outputID&quot;;
  public static final String CONFIG_PROPERTY_PREFIX = &quot;property&quot;;
  public static final String CONFIG_READ_ONLY_KEY = &quot;readOnly&quot;;
  public static final String CONFIG_REQUIRED_KEY = &quot;required&quot;;
  public static final String CONFIG_TYPE_KEY = &quot;type&quot;;

  /**
   * Possible types for the metadata field. The types are used in the frontend and backend to know how the metadata
   * fields should be formatted (if needed).
   */
<span class="fc" id="L60">  public enum Type {</span>
<span class="fc" id="L61">    BOOLEAN, DATE, DURATION, ITERABLE_TEXT, MIXED_TEXT, ORDERED_TEXT, LONG, START_DATE, START_TIME, TEXT, TEXT_LONG</span>
  }

  /** The id of a collection to validate values against. */
  private String collectionID;
  /** The format to use for temporal date properties. */
  private String pattern;
  /** The delimiter used to display and parse list values. */
  private String delimiter;
  /** The id of the field used to identify it in the dublin core. */
  private final String inputID;
  /** The i18n id for the label to show the property. */
  private final String label;
  /** The provider to populate the property with. */
  private final String listprovider;
  /** The optional namespace of the field used if a field can be found in more than one namespace */
  private final String namespace;
  /**
   * In the order of properties where this property should be oriented in the UI i.e. 0 means the property should come
   * first, 1 means it should come second etc.
   */
  private final Integer order;
  /** The optional id of the field used to output for the ui, if not present will assume the same as the inputID. */
  private final String outputID;
  /** Whether the property should not be edited. */
  private boolean readOnly;
  /** Whether the property is required to update the metadata. */
  private final boolean required;
  /** The type of the metadata for example text, date etc. */
  private Type type;

  private Object value;
  private Boolean translatable;
<span class="fc" id="L94">  private boolean updated = false;</span>
  private Map&lt;String, String&gt; collection;

  // this can only be true if the metadata field is representing multiple events with different values
<span class="fc" id="L98">  private Boolean hasDifferentValues = null;</span>

  /**
   * Copy constructor
   *
   * @param other
   *          Other metadata field
   */
<span class="fc" id="L106">  public MetadataField(final MetadataField other) {</span>
<span class="fc" id="L107">    this.inputID = other.inputID;</span>
<span class="fc" id="L108">    this.outputID = other.outputID;</span>
<span class="fc" id="L109">    this.label = other.label;</span>
<span class="fc" id="L110">    this.readOnly = other.readOnly;</span>
<span class="fc" id="L111">    this.required = other.required;</span>
<span class="fc" id="L112">    this.value = other.value;</span>
<span class="fc" id="L113">    this.translatable = other.translatable;</span>
<span class="fc" id="L114">    this.hasDifferentValues = other.hasDifferentValues;</span>
<span class="fc" id="L115">    this.type = other.type;</span>
<span class="fc" id="L116">    this.collection = other.collection;</span>
<span class="fc" id="L117">    this.collectionID = other.collectionID;</span>
<span class="fc" id="L118">    this.order = other.order;</span>
<span class="fc" id="L119">    this.namespace = other.namespace;</span>
<span class="fc" id="L120">    this.updated = other.updated;</span>
<span class="fc" id="L121">    this.pattern = other.pattern;</span>
<span class="fc" id="L122">    this.delimiter = other.delimiter;</span>
<span class="fc" id="L123">    this.listprovider = other.listprovider;</span>
<span class="fc" id="L124">  }</span>

  /**
   * Metadata field constructor
   *
   * @param inputID
   *          The identifier of the new metadata field
   * @param label
   *          the label of the field. The string displayed next to the field value on the frontend. This is usually be a
   *          translation key
   * @param readOnly
   *          Define if the new metadata field can be or not edited
   * @param required
   *          Define if the new metadata field is or not required
   * @param value
   *          The metadata field value
   * @param type
   *          The metadata field type @ EventMetadata.Type}
   * @param collection
   *          If the field has a limited list of possible value, the option should contain this one. Otherwise it should
   *          be none. This is also possible to use the collectionId parameter for that.
   * @param collectionID
   *          The id of the limit list of possible value that should be get through the resource endpoint.
   * @param listprovider An optional list provider ID
   * @param pattern Pattern for time/date fields
   * @param delimiter Delimiter
   * @throws IllegalArgumentException
   *           if the id, label, type parameters is/are null
   */
  public MetadataField(
          final String inputID,
          final String outputID,
          final String label,
          final boolean readOnly,
          final boolean required,
          final Object value,
          final Boolean translatable,
          final Type type,
          final Map&lt;String, String&gt; collection,
          final String collectionID,
          final Integer order,
          final String namespace,
          final String listprovider,
          final String pattern,
<span class="fc" id="L168">          final String delimiter) throws IllegalArgumentException {</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">    if (StringUtils.isBlank(inputID))</span>
<span class="nc" id="L170">      throw new IllegalArgumentException(&quot;The metadata input id must not be null.&quot;);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">    if (StringUtils.isBlank(label))</span>
<span class="nc" id="L172">      throw new IllegalArgumentException(&quot;The metadata label must not be null.&quot;);</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">    if (type == null)</span>
<span class="nc" id="L174">      throw new IllegalArgumentException(&quot;The metadata type must not be null.&quot;);</span>
<span class="fc" id="L175">    this.inputID = inputID;</span>
<span class="fc" id="L176">    this.outputID = outputID;</span>
<span class="fc" id="L177">    this.label = label;</span>
<span class="fc" id="L178">    this.readOnly = readOnly;</span>
<span class="fc" id="L179">    this.required = required;</span>
<span class="fc" id="L180">    this.value = value;</span>
<span class="fc" id="L181">    this.translatable = translatable;</span>
<span class="fc" id="L182">    this.type = type;</span>
<span class="fc" id="L183">    this.collection = collection;</span>
<span class="fc" id="L184">    this.collectionID = collectionID;</span>
<span class="fc" id="L185">    this.order = order;</span>
<span class="fc" id="L186">    this.namespace = namespace;</span>
<span class="fc" id="L187">    this.listprovider = listprovider;</span>
<span class="fc" id="L188">    this.pattern = pattern;</span>
<span class="fc" id="L189">    this.delimiter = delimiter;</span>
<span class="fc" id="L190">  }</span>

  /**
   * Set the option of a limited list of possible values.
   *
   * @param collection
   *          The option of a limited list of possible values
   */
  public void setCollection(final Map&lt;String, String&gt; collection) {
<span class="fc" id="L199">    this.collection = collection;</span>
<span class="fc" id="L200">  }</span>

  public Map&lt;String, String&gt; getCollection() {
<span class="fc" id="L203">    return collection;</span>
  }

  public Object getValue() {
<span class="fc" id="L207">    return value;</span>
  }

  public Boolean isTranslatable() {
<span class="fc" id="L211">    return translatable;</span>
  }

  public boolean isUpdated() {
<span class="fc" id="L215">    return updated;</span>
  }

  public void setValue(final Object value) {
<span class="fc" id="L219">    setValue(value, true);</span>
<span class="fc" id="L220">  }</span>

  public void setValue(final Object value, final boolean setUpdated) {
<span class="fc" id="L223">    this.value = value;</span>

<span class="fc bfc" id="L225" title="All 2 branches covered.">    if (setUpdated) {</span>
<span class="fc" id="L226">      this.updated = true;</span>
    }
<span class="fc" id="L228">  }</span>

  public void setIsTranslatable(final Boolean translatable) {
<span class="fc" id="L231">    this.translatable = translatable;</span>
<span class="fc" id="L232">  }</span>

  public static SimpleDateFormat getSimpleDateFormatter(final String pattern) {
    final SimpleDateFormat dateFormat;
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">    if (StringUtils.isNotBlank(pattern)) {</span>
<span class="fc" id="L237">      dateFormat = new SimpleDateFormat(pattern);</span>
    } else {
<span class="nc" id="L239">      dateFormat = new SimpleDateFormat();</span>
    }
<span class="fc" id="L241">    dateFormat.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
<span class="fc" id="L242">    return dateFormat;</span>
  }

  public static MetadataField createMetadataField(final Map&lt;String,String&gt; configuration) {
<span class="fc" id="L246">    final String inputID = configuration.get(CONFIG_INPUT_ID_KEY);</span>
<span class="fc" id="L247">    final String label = configuration.get(CONFIG_LABEL_KEY);</span>

<span class="fc" id="L249">    final String collectionID = configuration.get(CONFIG_COLLECTION_ID_KEY);</span>
<span class="fc" id="L250">    final String delimiter = configuration.get(CONFIG_DELIMITER_KEY);</span>
<span class="fc" id="L251">    final String outputID = configuration.get(CONFIG_OUTPUT_ID_KEY);</span>
<span class="fc" id="L252">    final String listprovider = configuration.get(CONFIG_LIST_PROVIDER_KEY);</span>
<span class="fc" id="L253">    final String namespace = configuration.get(CONFIG_NAMESPACE_KEY);</span>

<span class="pc bpc" id="L255" title="1 of 2 branches missed.">    final Type type = configuration.containsKey(CONFIG_TYPE_KEY)</span>
<span class="pc" id="L256">            ? Type.valueOf(configuration.get(CONFIG_TYPE_KEY).toUpperCase()) : null;</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">    final boolean required = configuration.containsKey(CONFIG_REQUIRED_KEY) &amp;&amp; Boolean</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            .parseBoolean(configuration.get(CONFIG_REQUIRED_KEY).toUpperCase());</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">    final boolean readOnly = configuration.containsKey(CONFIG_READ_ONLY_KEY) &amp;&amp; Boolean</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            .parseBoolean(configuration.get(CONFIG_READ_ONLY_KEY).toUpperCase());</span>

<span class="fc" id="L262">    final String pattern = configuration.getOrDefault(CONFIG_PATTERN_KEY, &quot;yyyy-MM-dd'T'HH:mm:ss.SSS'Z'&quot;);</span>

<span class="fc" id="L264">    Integer order = null;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">    if (configuration.containsKey(CONFIG_ORDER_KEY)) {</span>
      try {
<span class="fc" id="L267">        order = Integer.parseInt(configuration.get(CONFIG_ORDER_KEY));</span>
<span class="nc" id="L268">      } catch (final NumberFormatException e) {</span>
<span class="nc" id="L269">        logger.warn(&quot;Unable to parse order value {} of metadata field {}&quot;, configuration.get(CONFIG_ORDER_KEY),</span>
                inputID, e);
<span class="fc" id="L271">      }</span>
    }

<span class="pc bpc" id="L274" title="1 of 2 branches missed.">    if (type == null)</span>
<span class="nc" id="L275">      throw new IllegalArgumentException(&quot;type is null&quot;);</span>

<span class="pc bpc" id="L277" title="3 of 7 branches missed.">    switch (type) {</span>
      case BOOLEAN:
<span class="nc" id="L279">        return new MetadataField(</span>
                inputID,
                outputID,
                label,
                readOnly,
                required,
                null,
                null,
                type,
                null,
                null,
                order,
                namespace,
                listprovider,
                null,
                null);
      case DATE:
<span class="fc" id="L296">        return new MetadataField(</span>
                inputID,
                outputID,
                label,
                readOnly,
                required,
                null,
                null,
                type,
                null,
                null,
                order,
                namespace,
                listprovider,
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">                StringUtils.isNotBlank(pattern) ? pattern : null,</span>
                null);
      case DURATION:
      case TEXT:
      case ORDERED_TEXT:
      case TEXT_LONG:
<span class="fc" id="L316">        return new MetadataField(</span>
                inputID,
                outputID,
                label,
                readOnly,
                required,
                &quot;&quot;,
                null,
                type,
                null,
                collectionID,
                order,
                namespace,
                listprovider,
                null,
                null);
      case ITERABLE_TEXT:
      case MIXED_TEXT:
<span class="fc" id="L334">        return new MetadataField(</span>
                inputID,
                outputID,
                label,
                readOnly,
                required,
                new ArrayList&lt;&gt;(),
                null,
                type,
                null,
                collectionID,
                order,
                namespace,
                listprovider,
                null,
                delimiter);
      case LONG:
<span class="nc" id="L351">        return new MetadataField(</span>
                inputID,
                outputID,
                label,
                readOnly,
                required,
<span class="nc" id="L357">                0L,</span>
                null,
                Type.LONG,
                null,
                collectionID,
                order,
                namespace,
                listprovider,
                null, null);
      case START_DATE:
      case START_TIME:
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (StringUtils.isBlank(pattern)) {</span>
<span class="nc" id="L369">          throw new IllegalArgumentException(</span>
                  &quot;For temporal metadata field &quot; + inputID + &quot; of type &quot; + type + &quot; there needs to be a pattern.&quot;);
        }

<span class="fc" id="L373">        return new MetadataField(</span>
                inputID,
                outputID,
                label,
                readOnly,
                required,
                null,
                null,
                type,
                null,
                null,
                order,
                namespace,
                listprovider,
                pattern,
                null);
      default:
<span class="nc" id="L390">        throw new IllegalArgumentException(&quot;Unknown metadata type! &quot; + type);</span>
    }
  }

  public String getCollectionID() {
<span class="fc" id="L395">    return collectionID;</span>
  }

  public void setCollectionID(final String collectionID) {
<span class="fc" id="L399">    this.collectionID = collectionID;</span>
<span class="fc" id="L400">  }</span>

  public String getInputID() {
<span class="fc" id="L403">    return inputID;</span>
  }

  public String getLabel() {
<span class="fc" id="L407">    return label;</span>
  }

  public String getListprovider() {
<span class="fc" id="L411">    return listprovider;</span>
  }

  public String getNamespace() {
<span class="fc" id="L415">    return namespace;</span>
  }

  public Integer getOrder() {
<span class="fc" id="L419">    return order;</span>
  }

  /**
   * @return The outputID if available, inputID if it is missing.
   */
  public String getOutputID() {
<span class="fc bfc" id="L426" title="All 2 branches covered.">    if (outputID != null) {</span>
<span class="fc" id="L427">      return outputID;</span>
    }
<span class="fc" id="L429">    return inputID;</span>
  }

  public String getPattern() {
<span class="fc" id="L433">    return pattern;</span>
  }

  public void setPattern(final String pattern) {
<span class="fc" id="L437">    this.pattern = pattern;</span>
<span class="fc" id="L438">  }</span>

  public String getDelimiter() {
<span class="fc" id="L441">    return delimiter;</span>
  }

  public void setDelimiter(final String delimiter) {
<span class="nc" id="L445">    this.delimiter = delimiter;</span>
<span class="nc" id="L446">  }</span>

  public void setReadOnly(final boolean readOnly) {
<span class="fc" id="L449">    this.readOnly = readOnly;</span>
<span class="fc" id="L450">  }</span>

  public boolean isReadOnly() {
<span class="fc" id="L453">    return readOnly;</span>
  }

  public boolean isRequired() {
<span class="fc" id="L457">    return required;</span>
  }

  public void setUpdated(final boolean updated) {
<span class="fc" id="L461">    this.updated = updated;</span>
<span class="fc" id="L462">  }</span>

  public Type getType() {
<span class="fc" id="L465">    return type;</span>
  }

  public void setType(final Type type) {
<span class="nc" id="L469">    this.type = type;</span>
<span class="nc" id="L470">  }</span>

  public void setDifferentValues() {
<span class="fc" id="L473">    value = null;</span>
<span class="fc" id="L474">    hasDifferentValues = true;</span>
<span class="fc" id="L475">  }</span>

  public Boolean hasDifferentValues() {
<span class="fc" id="L478">    return hasDifferentValues;</span>
  }

  public MetadataField readOnlyCopy() {
<span class="fc" id="L482">    final MetadataField metadataField = new MetadataField(this);</span>
<span class="fc" id="L483">    metadataField.setReadOnly(true);</span>
<span class="fc" id="L484">    return metadataField;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>