<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EncodingSchemeUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-dublincore</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.metadata.dublincore</a> &gt; <span class="el_source">EncodingSchemeUtils.java</span></div><h1>EncodingSchemeUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */


package org.opencastproject.metadata.dublincore;

import com.entwinemedia.fn.data.Opt;

import org.joda.time.Duration;
import org.joda.time.format.ISODateTimeFormat;
import org.joda.time.format.ISOPeriodFormat;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.TimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utility class to facilitate the work with DCMI encoding schemes.
 */
public final class EncodingSchemeUtils {

<span class="fc" id="L44">  private static final Map&lt;Precision, String&gt; formats = new HashMap&lt;Precision, String&gt;();</span>

  static {
<span class="fc" id="L47">    formats.put(Precision.Year, &quot;yyyy&quot;);</span>
<span class="fc" id="L48">    formats.put(Precision.Month, &quot;yyyy-MM&quot;);</span>
<span class="fc" id="L49">    formats.put(Precision.Day, &quot;yyyy-MM-dd&quot;);</span>
<span class="fc" id="L50">    formats.put(Precision.Minute, &quot;yyyy-MM-dd'T'HH:mm'Z'&quot;);</span>
<span class="fc" id="L51">    formats.put(Precision.Second, &quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;);</span>
<span class="fc" id="L52">    formats.put(Precision.Fraction, &quot;yyyy-MM-dd'T'HH:mm:ss.SSS'Z'&quot;);</span>
  }

  /** Disable construction of this utility class */
  private EncodingSchemeUtils() {
  }

  /**
   * Encode a date with the given precision into a Dublin Core string value, using the recommended W3C-DTF scheme. The
   * UTC timezone is used for all precisions from {@link Precision#Minute} to {@link Precision#Fraction}. For years,
   * months and days the local timezone is used instead to ensure that the given date enters the DublinCore as is. If
   * UTC was used it may happen that you get the previous or next day, month or year respectively
   * &lt;p&gt;
   * The language of the returned value is {@link DublinCore#LANGUAGE_UNDEFINED}.
   * &lt;p&gt;
   * See &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;http://www.w3.org/TR/NOTE-datetime&lt;/a&gt; for more information about
   * W3C-DTF.
   *
   * @param date
   *          the date to encode
   * @param precision
   *          the precision to use
   */
  public static DublinCoreValue encodeDate(Date date, Precision precision) {
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">    if (date == null)</span>
<span class="nc" id="L77">      throw new IllegalArgumentException(&quot;The date must not be null&quot;);</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">    if (precision == null)</span>
<span class="nc" id="L79">      throw new IllegalArgumentException(&quot;The precision must not be null&quot;);</span>

<span class="fc" id="L81">    return DublinCoreValue.mk(formatDate(date, precision), DublinCore.LANGUAGE_UNDEFINED, Opt.some(DublinCore.ENC_SCHEME_W3CDTF));</span>
  }

  public static String formatDate(Date date, Precision precision) {
<span class="fc" id="L85">    SimpleDateFormat f = new SimpleDateFormat(formats.get(precision));</span>
<span class="fc bfc" id="L86" title="All 6 branches covered.">    if (precision == Precision.Minute || precision == Precision.Second || precision == Precision.Fraction)</span>
<span class="fc" id="L87">      f.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
<span class="fc" id="L88">    return f.format(date);</span>
  }

  /**
   * Encode a period with the given precision into a Dublin Core string value using the recommended DCMI Period scheme.
   * For the usage of the UTC timezone please refer to {@link #encodeDate(Date, Precision)} for further information.
   * &lt;p&gt;
   * One of the dates may be null to create an open interval.
   * &lt;p&gt;
   * The language of the returned value is {@link DublinCore#LANGUAGE_UNDEFINED}.
   * &lt;p&gt;
   * See &lt;a href=&quot;http://dublincore.org/documents/dcmi-period/&quot;&gt;http://dublincore.org/documents/dcmi-period/&lt;/a&gt; for
   * more information about DCMI Period.
   *
   * @param period
   *          the period
   * @param precision
   *          the precision
   */
  public static DublinCoreValue encodePeriod(DCMIPeriod period, Precision precision) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">    if (period == null)</span>
<span class="fc" id="L109">      throw new IllegalArgumentException(&quot;The period must not be null&quot;);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    if (precision == null)</span>
<span class="fc" id="L111">      throw new IllegalArgumentException(&quot;The precision must not be null&quot;);</span>

<span class="fc" id="L113">    StringBuilder b = new StringBuilder();</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">    if (period.hasStart()) {</span>
<span class="fc" id="L115">      b.append(&quot;start=&quot;).append(formatDate(period.getStart(), precision)).append(&quot;;&quot;);</span>
    }
<span class="fc bfc" id="L117" title="All 2 branches covered.">    if (period.hasEnd()) {</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">      if (b.length() &gt; 0)</span>
<span class="fc" id="L119">        b.append(&quot; &quot;);</span>
<span class="fc" id="L120">      b.append(&quot;end=&quot;).append(formatDate(period.getEnd(), precision)).append(&quot;;&quot;);</span>
    }
<span class="fc bfc" id="L122" title="All 2 branches covered.">    if (period.hasName()) {</span>
<span class="fc" id="L123">      b.append(&quot; &quot;).append(&quot;name=&quot;).append(period.getName().replace(&quot;;&quot;, &quot;&quot;)).append(&quot;;&quot;);</span>
    }
<span class="fc" id="L125">    b.append(&quot; &quot;).append(&quot;scheme=W3C-DTF;&quot;);</span>
<span class="fc" id="L126">    return DublinCoreValue.mk(b.toString(), DublinCore.LANGUAGE_UNDEFINED, Opt.some(DublinCore.ENC_SCHEME_PERIOD));</span>
  }

  /**
   * Encode a duration measured in milliseconds into a Dublin Core string using the
   * {@link DublinCore#ENC_SCHEME_ISO8601} encoding scheme &lt;code&gt;PTnHnMnS&lt;/code&gt;.
   * &lt;p&gt;
   * The language of the returned value is {@link DublinCore#LANGUAGE_UNDEFINED}.
   * &lt;p&gt;
   * See &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt; ISO8601 Durations&lt;/a&gt; for details.
   *
   * @param duration
   *          the duration in milliseconds
   */
  public static DublinCoreValue encodeDuration(long duration) {
<span class="fc" id="L141">    return DublinCoreValue.mk(ISOPeriodFormat.standard().print(new Duration(duration).toPeriod()),</span>
<span class="fc" id="L142">            DublinCore.LANGUAGE_UNDEFINED, Opt.some(DublinCore.ENC_SCHEME_ISO8601));</span>
  }

  /**
   * Decode a string encoded in the ISO8601 encoding scheme.
   * &lt;p&gt;
   * Also supports the REPLAY legacy format &lt;code&gt;hh:mm:ss&lt;/code&gt;.
   * &lt;p&gt;
   * See &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt; ISO8601 Durations&lt;/a&gt; for details.
   *
   * @param value
   *          the ISO encoded string
   * @return the duration in milliseconds or null, if the value cannot be parsed
   */
  public static Long decodeDuration(String value) {
    try {
<span class="fc" id="L158">      return ISOPeriodFormat.standard().parsePeriod(value).toStandardDuration().getMillis();</span>
<span class="fc" id="L159">    } catch (IllegalArgumentException ignore) {</span>
    }
    // also support the legacy format hh:mm:ss
<span class="fc" id="L162">    String[] parts = value.split(&quot;:&quot;);</span>
    try {
<span class="fc bfc" id="L164" title="All 2 branches covered.">      if (parts.length == 1)</span>
<span class="nc" id="L165">        return Long.parseLong(parts[0]) * 1000;</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">      if (parts.length == 2)</span>
<span class="nc" id="L167">        return Long.parseLong(parts[0]) * 1000 * 60 + Long.parseLong(parts[1]) * 1000;</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">      if (parts.length == 3)</span>
<span class="fc" id="L169">        return Long.parseLong(parts[0]) * 1000 * 60 * 60 + Long.parseLong(parts[1]) * 1000 * 60</span>
<span class="fc" id="L170">                + Long.parseLong(parts[2]) * 1000;</span>
<span class="fc" id="L171">    } catch (NumberFormatException ignore) {</span>
<span class="nc" id="L172">    }</span>
<span class="fc" id="L173">    return null;</span>
  }

  /**
   * Decode a string encoded in the ISO8601 encoding scheme.
   *
   * @param value
   *          the Dublin Core value
   * @return the duration in milliseconds or null, if the value cannot be parsed or is in a different encoding scheme
   */
  public static Long decodeDuration(DublinCoreValue value) {
<span class="pc bpc" id="L184" title="1 of 4 branches missed.">    if (!value.hasEncodingScheme() || value.getEncodingScheme().get().equals(DublinCore.ENC_SCHEME_ISO8601)) {</span>
<span class="fc" id="L185">      return decodeDuration(value.getValue());</span>
    }
<span class="fc" id="L187">    return null;</span>
  }

  public static Long decodeMandatoryDuration(String value) {
<span class="nc" id="L191">    Long l = decodeDuration(value);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">    if (l == null)</span>
<span class="nc" id="L193">      throw new IllegalArgumentException(&quot;Cannot decode duration: &quot; + value);</span>
<span class="nc" id="L194">    return l;</span>
  }

  /**
   * Tries to decode the given value as a W3C-DTF encoded date. If decoding fails, null is returned.
   *
   * @return the date or null if decoding fails
   */
  public static Date decodeDate(DublinCoreValue value) {
<span class="pc bpc" id="L203" title="1 of 4 branches missed.">    if (!value.hasEncodingScheme() || value.getEncodingScheme().get().equals(DublinCore.ENC_SCHEME_W3CDTF)) {</span>
      try {
<span class="fc" id="L205">        return parseW3CDTF(value.getValue());</span>
<span class="fc" id="L206">      } catch (IllegalArgumentException ignore) {</span>
      }
    }

    // Try unixtime in milliseconds (backwards-compatibility with older mediapackages)
    try {
<span class="fc" id="L212">      long timestamp = Long.parseLong(value.getValue());</span>
<span class="fc" id="L213">      Date decoded = new java.util.Date(timestamp);</span>
<span class="fc" id="L214">      return decoded;</span>
<span class="fc" id="L215">    } catch (NumberFormatException nfe) {</span>
    }

<span class="fc" id="L218">    return null;</span>
  }

  /**
   * Tries to decode the given value as a W3C-DTF encoded date. If decoding fails, null is returned.
   *
   * @return the date or null if decoding fails
   */
  public static Date decodeDate(String value) {
    try {
<span class="fc" id="L228">      return parseW3CDTF(value);</span>
<span class="fc" id="L229">    } catch (IllegalArgumentException ignore) {</span>
    }

    // Try unixtime in milliseconds (backwards-compatibility with older mediapackages)
    try {
<span class="fc" id="L234">      long timestamp = Long.parseLong(value);</span>
<span class="fc" id="L235">      Date decoded = new java.util.Date(timestamp);</span>
<span class="fc" id="L236">      return decoded;</span>
<span class="nc" id="L237">    } catch (NumberFormatException nfe) {</span>
    }

<span class="nc" id="L240">    return null;</span>
  }

  /**
   * Like {@link #decodeDate(String)}, but throws an {@link IllegalArgumentException} if the value cannot be decoded.
   *
   * @param value
   *          the value
   * @return the date
   * @throws IllegalArgumentException
   *           if the value cannot be decoded
   */
  public static Date decodeMandatoryDate(DublinCoreValue value) {
<span class="nc" id="L253">    Date date = decodeDate(value);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">    if (date == null)</span>
<span class="nc" id="L255">      throw new IllegalArgumentException(&quot;Cannot decode to Date: &quot; + value);</span>
<span class="nc" id="L256">    return date;</span>
  }

  /**
   * Like {@link #decodeDate(String)}, but throws an {@link IllegalArgumentException} if the value cannot be decoded.
   *
   * @return the date
   * @throws IllegalArgumentException
   *           if the value cannot be decoded
   */
  public static Date decodeMandatoryDate(String value) {
<span class="nc" id="L267">    Date date = decodeDate(value);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">    if (date == null)</span>
<span class="nc" id="L269">      throw new IllegalArgumentException(&quot;Cannot decode to Date: &quot; + value);</span>
<span class="nc" id="L270">    return date;</span>
  }

<span class="fc" id="L273">  private static final Pattern DCMI_PERIOD = Pattern.compile(&quot;(start|end|name)\\s*=\\s*(.*?)(?:;|\\s*$)&quot;);</span>
<span class="fc" id="L274">  private static final Pattern DCMI_PERIOD_SCHEME = Pattern.compile(&quot;scheme\\s*=\\s*(.*?)(?:;|\\s*$)&quot;);</span>

  /**
   * Tries to decode a string in the DCMI period format, using W3C-DTF for the encoding of the individual dates. If
   * parsing fails at any point, null will be returned.
   *
   * @return the period or null if decoding fails
   */
  public static DCMIPeriod decodePeriod(DublinCoreValue value) {
<span class="fc" id="L283">    return decodePeriod(value.getValue());</span>
  }

  /**
   * Tries to decode a string in the DCMI period format, using W3C-DTF for the encoding of the individual dates. If
   * parsing fails at any point, null will be returned.
   *
   * @return the period or null if decoding fails
   */
  public static DCMIPeriod decodePeriod(String value) {
    // Parse value
<span class="fc" id="L294">    Matcher schemeMatcher = DCMI_PERIOD_SCHEME.matcher(value);</span>
<span class="fc" id="L295">    boolean mayBeW3CDTFEncoded = true;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">    if (schemeMatcher.find()) {</span>
<span class="fc" id="L297">      String schemeString = schemeMatcher.group(1);</span>
<span class="pc bpc" id="L298" title="1 of 4 branches missed.">      if (!&quot;W3C-DTF&quot;.equalsIgnoreCase(schemeString) &amp;&amp; !&quot;W3CDTF&quot;.equalsIgnoreCase(schemeString)) {</span>
<span class="fc" id="L299">        mayBeW3CDTFEncoded = false;</span>
      }
    }
    try {
<span class="fc bfc" id="L303" title="All 2 branches covered.">      if (mayBeW3CDTFEncoded) {</span>
        // Declare fields
<span class="fc" id="L305">        Date start = null;</span>
<span class="fc" id="L306">        Date end = null;</span>
<span class="fc" id="L307">        String name = null;</span>
        // Parse
<span class="fc" id="L309">        Matcher m = DCMI_PERIOD.matcher(value);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        while (m.find()) {</span>
<span class="fc" id="L311">          String field = m.group(1);</span>
<span class="fc" id="L312">          String fieldValue = m.group(2);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">          if (&quot;start&quot;.equals(field)) {</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">            if (start != null)</span>
<span class="nc" id="L315">              return null;</span>
<span class="fc" id="L316">            start = parseW3CDTF(fieldValue);</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">          } else if (&quot;end&quot;.equals(field)) {</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">            if (end != null)</span>
<span class="nc" id="L319">              return null;</span>
<span class="fc" id="L320">            end = parseW3CDTF(fieldValue);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">          } else if (&quot;name&quot;.equals(field)) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (name != null)</span>
<span class="nc" id="L323">              return null;</span>
<span class="nc" id="L324">            name = fieldValue;</span>
          }
<span class="fc" id="L326">        }</span>
<span class="pc bpc" id="L327" title="1 of 4 branches missed.">        if (start == null &amp;&amp; end == null)</span>
<span class="fc" id="L328">          return null;</span>
<span class="fc" id="L329">        return new DCMIPeriod(start, end, name);</span>
      }
<span class="fc" id="L331">    } catch (IllegalArgumentException ignore) {</span>
      // Parse error
<span class="fc" id="L333">    }</span>
<span class="fc" id="L334">    return null;</span>
  }

  /**
   * Like {@link #decodePeriod(String)}, but throws an {@link IllegalArgumentException} if the value cannot be decoded.
   *
   * @return the period
   * @throws IllegalArgumentException
   *           if the value cannot be decoded
   */
  public static DCMIPeriod decodeMandatoryPeriod(DublinCoreValue value) {
<span class="nc" id="L345">    return decodeMandatoryPeriod(value.getValue());</span>
  }

  /**
   * Like {@link #decodePeriod(DublinCoreValue)}, but throws an {@link IllegalArgumentException} if the value cannot be
   * decoded.
   *
   * @return the period
   * @throws IllegalArgumentException
   *           if the value cannot be decoded
   */
  public static DCMIPeriod decodeMandatoryPeriod(String value) {
<span class="fc" id="L357">    DCMIPeriod period = decodePeriod(value);</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">    if (period == null)</span>
<span class="nc" id="L359">      throw new IllegalArgumentException(&quot;Cannot decode to DCMIPeriod: &quot; + value);</span>

<span class="fc" id="L361">    return period;</span>
  }

  /**
   * Tries to decode the value to a temporal object. For now, supported types are {@link java.util.Date},
   * {@link DCMIPeriod} and Long for a duration.
   *
   * @param value
   *          the value to decode
   * @return a temporal object of the said types or null if decoding fails
   */
  public static Temporal decodeTemporal(DublinCoreValue value) {
    // First try Date
<span class="fc" id="L374">    Date instant = decodeDate(value);</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">    if (instant != null)</span>
<span class="fc" id="L376">      return Temporal.instant(instant);</span>
<span class="fc" id="L377">    DCMIPeriod period = decodePeriod(value);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">    if (period != null)</span>
<span class="fc" id="L379">      return Temporal.period(period);</span>
<span class="fc" id="L380">    Long duration = decodeDuration(value);</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">    if (duration != null)</span>
<span class="fc" id="L382">      return Temporal.duration(duration);</span>
<span class="nc" id="L383">    return null;</span>
  }

  /**
   * Like {@link #decodeTemporal(DublinCoreValue)}, but throws an {@link IllegalArgumentException} if the value cannot
   * be decoded.
   *
   * @return the temporal object of type {@link java.util.Date} or {@link DCMIPeriod}
   * @throws IllegalArgumentException
   *           if the value cannot be decoded
   */
  public static Temporal decodeMandatoryTemporal(DublinCoreValue value) {
<span class="nc" id="L395">    Temporal temporal = decodeTemporal(value);</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">    if (value == null)</span>
<span class="nc" id="L397">      throw new IllegalArgumentException(&quot;Cannot decode to either Date or DCMIPeriod: &quot; + value);</span>

<span class="nc" id="L399">    return temporal;</span>
  }

  /**
   * @throws IllegalArgumentException
   *           if the value cannot be parsed
   */
  private static Date parseW3CDTF(String value) {
<span class="fc" id="L407">    return ISODateTimeFormat.dateTimeParser().parseDateTime(value).toDate();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>