<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MetadataJson.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-dublincore</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.metadata.dublincore</a> &gt; <span class="el_source">MetadataJson.java</span></div><h1>MetadataJson.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.metadata.dublincore;

import static com.entwinemedia.fn.data.json.Jsons.arr;
import static com.entwinemedia.fn.data.json.Jsons.f;
import static com.entwinemedia.fn.data.json.Jsons.obj;
import static com.entwinemedia.fn.data.json.Jsons.v;
import static org.apache.commons.lang3.exception.ExceptionUtils.getMessage;

import org.opencastproject.mediapackage.MediaPackageElementFlavor;

import com.entwinemedia.fn.data.json.Field;
import com.entwinemedia.fn.data.json.JObject;
import com.entwinemedia.fn.data.json.JValue;
import com.entwinemedia.fn.data.json.Jsons;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.DurationFormatUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.TimeZone;
import java.util.stream.Collectors;

public final class MetadataJson {
<span class="fc" id="L58">  private static final Logger logger = LoggerFactory.getLogger(MetadataJson.class);</span>

  /* Keys for the different properties of the metadata JSON Object */
  private static final String JSON_KEY_ID = &quot;id&quot;;
  private static final String JSON_KEY_LABEL = &quot;label&quot;;
  private static final String JSON_KEY_READONLY = &quot;readOnly&quot;;
  private static final String JSON_KEY_REQUIRED = &quot;required&quot;;
  private static final String JSON_KEY_TYPE = &quot;type&quot;;
  private static final String JSON_KEY_VALUE = &quot;value&quot;;
  private static final String JSON_KEY_COLLECTION = &quot;collection&quot;;
  private static final String JSON_KEY_TRANSLATABLE = &quot;translatable&quot;;
  private static final String JSON_KEY_DELIMITER = &quot;delimiter&quot;;
  private static final String JSON_KEY_DIFFERENT_VALUES = &quot;differentValues&quot;;
  private static final String KEY_METADATA_TITLE = &quot;title&quot;;
  private static final String KEY_METADATA_FLAVOR = &quot;flavor&quot;;
  private static final String KEY_METADATA_FIELDS = &quot;fields&quot;;
  private static final String KEY_METADATA_LOCKED = &quot;locked&quot;;

  /* Keys for the different properties of the metadata JSON Object */
  private static final String KEY_METADATA_ID = &quot;id&quot;;
  private static final String KEY_METADATA_VALUE = &quot;value&quot;;

  private static final String PATTERN_DURATION = &quot;HH:mm:ss&quot;;

  /**
   * Turn a map into a {@link JObject} object
   *
   * @param map the source map
   * @return a new {@link JObject} generated with the map values
   */
  private static JObject mapToJson(final Map&lt;String, String&gt; map) {
<span class="fc" id="L89">    Objects.requireNonNull(map);</span>
<span class="fc" id="L90">    final List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">    for (final Map.Entry&lt;String, String&gt; item : map.entrySet()) {</span>
<span class="fc" id="L92">      fields.add(f(item.getKey(), v(item.getValue(), Jsons.BLANK)));</span>
<span class="fc" id="L93">    }</span>
<span class="fc" id="L94">    return obj(fields);</span>
  }

<span class="fc" id="L97">  public enum JsonType {</span>
<span class="fc" id="L98">    BOOLEAN, DATE, NUMBER, TEXT, MIXED_TEXT, ORDERED_TEXT, TEXT_LONG, TIME</span>
  }

  private MetadataJson() {
  }

  private static SimpleDateFormat getSimpleDateFormatter(final String pattern) {
    final SimpleDateFormat dateFormat;
<span class="fc bfc" id="L106" title="All 2 branches covered.">    if (StringUtils.isNotBlank(pattern)) {</span>
<span class="fc" id="L107">      dateFormat = new SimpleDateFormat(pattern);</span>
    } else {
<span class="fc" id="L109">      dateFormat = new SimpleDateFormat();</span>
    }
<span class="fc" id="L111">    dateFormat.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
<span class="fc" id="L112">    return dateFormat;</span>
  }

  private static &lt;T&gt; JValue valueToJson(final T rawValue, final MetadataField.Type type, final String pattern) {
<span class="pc bpc" id="L116" title="3 of 9 branches missed.">    switch (type) {</span>
      case BOOLEAN:
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (rawValue == null)</span>
<span class="nc" id="L119">          return Jsons.BLANK;</span>
<span class="nc" id="L120">        return v(rawValue, Jsons.BLANK);</span>
      case DATE: {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (rawValue == null)</span>
<span class="fc" id="L123">          return Jsons.BLANK;</span>
<span class="fc" id="L124">        final SimpleDateFormat dateFormat = getSimpleDateFormatter(pattern);</span>
<span class="fc" id="L125">        return v(dateFormat.format((Date) rawValue), Jsons.BLANK);</span>
      }
      case DURATION: {
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (rawValue == null)</span>
<span class="nc" id="L129">          return Jsons.BLANK;</span>
<span class="fc" id="L130">        long returnValue = 0L;</span>
<span class="fc" id="L131">        final String value = (String) rawValue;</span>
<span class="fc" id="L132">        final DCMIPeriod period = EncodingSchemeUtils.decodePeriod(value);</span>
<span class="pc bpc" id="L133" title="5 of 6 branches missed.">        if (period != null &amp;&amp; period.hasStart() &amp;&amp; period.hasEnd()) {</span>
<span class="nc" id="L134">          returnValue = period.getEnd().getTime() - period.getStart().getTime();</span>
        } else {
          try {
<span class="fc" id="L137">            returnValue = Long.parseLong(value);</span>
<span class="fc" id="L138">          } catch (final NumberFormatException e) {</span>
<span class="fc" id="L139">            logger.debug(&quot;Unable to parse duration '{}' as either period or millisecond duration.&quot;, value);</span>
<span class="fc" id="L140">          }</span>
        }
<span class="fc" id="L142">        return v(DurationFormatUtils.formatDuration(returnValue, PATTERN_DURATION));</span>
      }
      case ITERABLE_TEXT:
      case MIXED_TEXT: {
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (rawValue == null)</span>
<span class="fc" id="L147">          return arr();</span>

<span class="fc" id="L149">        final List&lt;JValue&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (rawValue instanceof String) {</span>
          // The value is a string so we need to split it.
<span class="fc" id="L152">          final String stringVal = (String) rawValue;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">          for (final String entry : stringVal.split(&quot;,&quot;)) {</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">            if (StringUtils.isNotBlank(entry))</span>
<span class="fc" id="L155">              list.add(v(entry, Jsons.BLANK));</span>
          }
<span class="fc" id="L157">        } else {</span>
          // The current value is just an iterable string.
<span class="fc bfc" id="L159" title="All 2 branches covered.">          for (final Object v : (Iterable&lt;String&gt;)rawValue) {</span>
<span class="fc" id="L160">            list.add(v(v, Jsons.BLANK));</span>
<span class="fc" id="L161">          }</span>
        }

<span class="fc" id="L164">        return arr(list);</span>
      }
      case ORDERED_TEXT:
      case TEXT_LONG:
      case TEXT:
<span class="fc bfc" id="L169" title="All 2 branches covered.">        return v(rawValue == null ? &quot;&quot; : (String)rawValue);</span>
      case LONG:
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (rawValue == null)</span>
<span class="nc" id="L172">          return Jsons.BLANK;</span>
<span class="nc" id="L173">        return v(rawValue.toString());</span>
      case START_DATE: {
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (rawValue == null)</span>
<span class="fc" id="L176">          return Jsons.BLANK;</span>

<span class="fc" id="L178">        final String value = (String) rawValue;</span>

<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (StringUtils.isBlank(value))</span>
<span class="nc" id="L181">          return Jsons.BLANK;</span>

        // Try to parse the metadata as DCIM metadata.
<span class="fc" id="L184">        final DCMIPeriod p = EncodingSchemeUtils.decodePeriod(value);</span>
<span class="fc" id="L185">        final SimpleDateFormat dateFormat = getSimpleDateFormatter(pattern);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (p != null)</span>
<span class="fc" id="L187">          return v(dateFormat.format(p.getStart()), Jsons.BLANK);</span>

        // Not DCIM metadata so it might already be formatted (given from the front and is being returned there
        try {
<span class="fc" id="L191">          dateFormat.parse(value);</span>
<span class="fc" id="L192">          return v(value, Jsons.BLANK);</span>
<span class="nc" id="L193">        } catch (final Exception e) {</span>
<span class="nc" id="L194">          logger.error(</span>
                  &quot;Unable to parse temporal metadata '{}' as either DCIM data or a formatted date using pattern {} because:&quot;,
                  value,
                  pattern,
                  e);
<span class="nc" id="L199">          throw new IllegalArgumentException(e);</span>
        }
      }
      case START_TIME: {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (rawValue == null)</span>
<span class="nc" id="L204">          return Jsons.BLANK;</span>

<span class="fc" id="L206">        final String value = (String) rawValue;</span>

<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (StringUtils.isBlank(value))</span>
<span class="nc" id="L209">          return Jsons.BLANK;</span>

        // Try to parse the metadata as DCIM metadata.
<span class="fc" id="L212">        final DCMIPeriod p = EncodingSchemeUtils.decodePeriod(value);</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (p != null) {</span>
<span class="nc" id="L214">          final SimpleDateFormat dateFormat = getSimpleDateFormatter(pattern);</span>
<span class="nc" id="L215">          return v(dateFormat.format(p.getStart()), Jsons.BLANK);</span>
        }

        // Not DCIM metadata so it might already be formatted (given from the front and is being returned there
        try {
<span class="fc" id="L220">          final SimpleDateFormat dateFormat = getSimpleDateFormatter(pattern);</span>
<span class="fc" id="L221">          dateFormat.parse(value);</span>
<span class="fc" id="L222">          return v(value, Jsons.BLANK);</span>
<span class="nc" id="L223">        } catch (final Exception e) {</span>
<span class="nc" id="L224">          logger.error(</span>
                  &quot;Unable to parse temporal metadata '{}' as either DCIM data or a formatted date using pattern {} because:&quot;,
                  value,
                  pattern,
                  e);
<span class="nc" id="L229">          throw new IllegalArgumentException(e);</span>
        }
      }
      default:
<span class="nc" id="L233">        throw new IllegalArgumentException(&quot;invalid metadata field of type '&quot; + type + &quot;'&quot;);</span>
    }
  }

  private static JsonType jsonType(final MetadataField f, final boolean withOrderedText) {
<span class="pc bpc" id="L238" title="4 of 9 branches missed.">    switch (f.getType()) {</span>
      case BOOLEAN:
<span class="nc" id="L240">        return JsonType.BOOLEAN;</span>
      case DATE:
      case START_DATE:
<span class="fc" id="L243">        return JsonType.DATE;</span>
      case DURATION:
      case ITERABLE_TEXT:
      case TEXT:
<span class="fc" id="L247">        return JsonType.TEXT;</span>
      case MIXED_TEXT:
<span class="fc" id="L249">        return JsonType.MIXED_TEXT;</span>
      case ORDERED_TEXT:
<span class="nc bnc" id="L251" title="All 2 branches missed.">        return withOrderedText ? JsonType.ORDERED_TEXT : JsonType.TEXT;</span>
      case LONG:
<span class="nc" id="L253">        return JsonType.NUMBER;</span>
      case START_TIME:
<span class="fc" id="L255">        return JsonType.TIME;</span>
      case TEXT_LONG:
<span class="fc" id="L257">        return JsonType.TEXT_LONG;</span>
      default:
<span class="nc" id="L259">        throw new IllegalArgumentException(&quot;invalid field type '&quot; + f.getType() + &quot;'&quot;);</span>
    }
  }

  private static Object valueFromJson(final Object value, final MetadataField field) {
<span class="pc bpc" id="L264" title="7 of 9 branches missed.">    switch (field.getType()) {</span>
      case BOOLEAN: {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (value instanceof Boolean)</span>
<span class="nc" id="L267">          return value;</span>
<span class="nc" id="L268">        final String stringValue = value.toString();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (StringUtils.isBlank(stringValue))</span>
<span class="nc" id="L270">          return null;</span>
<span class="nc" id="L271">        return Boolean.parseBoolean(stringValue);</span>
      }
      case DATE: {
<span class="nc" id="L274">        final SimpleDateFormat dateFormat = getSimpleDateFormatter(field.getPattern());</span>
        try {
<span class="nc" id="L276">          final String date = (String) value;</span>

<span class="nc bnc" id="L278" title="All 2 branches missed.">          if (StringUtils.isBlank(date))</span>
<span class="nc" id="L279">            return null;</span>

<span class="nc" id="L281">          return dateFormat.parse(date);</span>
<span class="nc" id="L282">        } catch (final java.text.ParseException e) {</span>
<span class="nc" id="L283">          logger.error(&quot;Not able to parse date {}: {}&quot;, value, e.getMessage());</span>
<span class="nc" id="L284">          return null;</span>
        }
      }
      case DURATION: {
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (!(value instanceof String)) {</span>
<span class="nc" id="L289">          logger.warn(&quot;The given value for duration can not be parsed.&quot;);</span>
<span class="nc" id="L290">          return &quot;&quot;;</span>
        }

<span class="nc" id="L293">        final String duration = (String) value;</span>
<span class="nc" id="L294">        final String[] durationParts = duration.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (durationParts.length &lt; 3)</span>
<span class="nc" id="L296">          return null;</span>
<span class="nc" id="L297">        final long hours = Long.parseLong(durationParts[0]);</span>
<span class="nc" id="L298">        final long minutes = Long.parseLong(durationParts[1]);</span>
<span class="nc" id="L299">        final long seconds = Long.parseLong(durationParts[2]);</span>

<span class="nc" id="L301">        final long returnValue = ((hours * 60 + minutes) * 60 + seconds) * 1000;</span>

<span class="nc" id="L303">        return Long.toString(returnValue);</span>
      }
      case ITERABLE_TEXT: {
<span class="nc" id="L306">        final JSONArray array = (JSONArray) value;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (array == null)</span>
<span class="nc" id="L308">          return null;</span>
<span class="nc" id="L309">        final String[] arrayOut = new String[array.size()];</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        for (int i = 0; i &lt; array.size(); i++)</span>
<span class="nc" id="L311">          arrayOut[i] = (String) array.get(i);</span>
<span class="nc" id="L312">        return Arrays.asList(arrayOut);</span>
      }
      case MIXED_TEXT: {
<span class="nc" id="L315">        final JSONParser parser = new JSONParser();</span>
        final JSONArray array;
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (value instanceof String) {</span>
          try {
<span class="nc" id="L319">            array = (JSONArray) parser.parse((String) value);</span>
<span class="nc" id="L320">          } catch (final ParseException e) {</span>
<span class="nc" id="L321">            throw new IllegalArgumentException(&quot;Unable to parse Mixed Iterable value into a JSONArray:&quot;, e);</span>
<span class="nc" id="L322">          }</span>
        } else {
<span class="nc" id="L324">          array = (JSONArray) value;</span>
        }

<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (array == null)</span>
<span class="nc" id="L328">          return new ArrayList&lt;&gt;();</span>
<span class="nc" id="L329">        final String[] arrayOut = new String[array.size()];</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        for (int i = 0; i &lt; array.size(); i++)</span>
<span class="nc" id="L331">          arrayOut[i] = (String) array.get(i);</span>
<span class="nc" id="L332">        return Arrays.asList(arrayOut);</span>
      }
      case TEXT:
      case TEXT_LONG:
      case ORDERED_TEXT: {
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (value == null)</span>
<span class="nc" id="L338">          return &quot;&quot;;</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        if (!(value instanceof String)) {</span>
<span class="nc" id="L340">          logger.warn(&quot;Value cannot be parsed as String. Expecting type 'String', but received type '{}'.&quot;, value.getClass().getName());</span>
<span class="nc" id="L341">          return null;</span>
        }
<span class="fc" id="L343">        return value;</span>
      }
      case LONG: {
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (!(value instanceof String)) {</span>
<span class="nc" id="L347">          logger.warn(&quot;The given value for Long can not be parsed.&quot;);</span>
<span class="nc" id="L348">          return 0L;</span>
        }
<span class="nc" id="L350">        final String longString = (String) value;</span>
<span class="nc" id="L351">        return Long.parseLong(longString);</span>
      }
      case START_DATE:
      case START_TIME:
      {
<span class="fc" id="L356">        final String date = (String) value;</span>

<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (StringUtils.isBlank(date))</span>
<span class="nc" id="L359">          return &quot;&quot;;</span>

        try {
<span class="fc" id="L362">          final SimpleDateFormat dateFormat = getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L363">          dateFormat.parse(date);</span>
<span class="nc" id="L364">        } catch (final java.text.ParseException e) {</span>
<span class="nc" id="L365">          logger.error(&quot;Not able to parse date string {}: {}&quot;, value, getMessage(e));</span>
<span class="nc" id="L366">          return null;</span>
<span class="fc" id="L367">        }</span>

<span class="fc" id="L369">        return date;</span>
      }
      default:
<span class="nc" id="L372">        throw new IllegalArgumentException(&quot;invalid field type '&quot; + field.getType() + &quot;'&quot;);</span>
    }
  }

  public static JObject fieldToJson(final MetadataField f, final boolean withOrderedText) {
<span class="fc" id="L377">    Objects.requireNonNull(f);</span>
<span class="fc" id="L378">    final Map&lt;String, Field&gt; values = new HashMap&lt;&gt;();</span>
<span class="fc" id="L379">    values.put(JSON_KEY_ID, f(JSON_KEY_ID, v(f.getOutputID(), Jsons.BLANK)));</span>
<span class="fc" id="L380">    values.put(JSON_KEY_LABEL, f(JSON_KEY_LABEL, v(f.getLabel(), Jsons.BLANK)));</span>
<span class="fc" id="L381">    values.put(JSON_KEY_VALUE, f(JSON_KEY_VALUE, valueToJson(f.getValue(), f.getType(), f.getPattern())));</span>
<span class="fc" id="L382">    values.put(JSON_KEY_TYPE, f(JSON_KEY_TYPE, v(jsonType(f, withOrderedText).toString().toLowerCase(), Jsons.BLANK)));</span>
<span class="fc" id="L383">    values.put(JSON_KEY_READONLY, f(JSON_KEY_READONLY, v(f.isReadOnly())));</span>
<span class="fc" id="L384">    values.put(JSON_KEY_REQUIRED, f(JSON_KEY_REQUIRED, v(f.isRequired())));</span>

<span class="fc bfc" id="L386" title="All 2 branches covered.">    if (f.getCollection() != null)</span>
<span class="fc" id="L387">      values.put(JSON_KEY_COLLECTION, f(JSON_KEY_COLLECTION, mapToJson(f.getCollection())));</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">    else if (f.getCollectionID() != null)</span>
<span class="fc" id="L389">      values.put(JSON_KEY_COLLECTION, f(JSON_KEY_COLLECTION, v(f.getCollectionID())));</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">    if (f.isTranslatable() != null)</span>
<span class="fc" id="L391">      values.put(JSON_KEY_TRANSLATABLE, f(JSON_KEY_TRANSLATABLE, v(f.isTranslatable())));</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">    if (f.getDelimiter() != null)</span>
<span class="nc" id="L393">      values.put(JSON_KEY_DELIMITER, f(JSON_KEY_DELIMITER, v(f.getDelimiter())));</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">    if (f.hasDifferentValues() != null)</span>
<span class="fc" id="L395">      values.put(JSON_KEY_DIFFERENT_VALUES, f(JSON_KEY_DIFFERENT_VALUES, v(f.hasDifferentValues())));</span>
<span class="fc" id="L396">    return obj(values);</span>
  }

  public static MetadataField copyWithDifferentJsonValue(final MetadataField t, final String v) {
<span class="fc" id="L400">    final MetadataField copy = new MetadataField(t);</span>
<span class="fc" id="L401">    copy.setValue(valueFromJson(v, copy));</span>
<span class="fc" id="L402">    return copy;</span>
  }

  public static JValue collectionToJson(final DublinCoreMetadataCollection collection, final boolean withOrderedText) {
<span class="fc" id="L406">    return arr(collection.getFields().stream().map(field -&gt; fieldToJson(field, withOrderedText))</span>
<span class="fc" id="L407">            .collect(Collectors.toList()));</span>
  }

  public static JSONArray extractSingleCollectionfromListJson(JSONArray json) {
<span class="nc bnc" id="L411" title="All 4 branches missed.">    if (json == null || json.size() != 1) {</span>
<span class="nc" id="L412">      throw new IllegalArgumentException(&quot;Input has to be a JSONArray with one entry&quot;);</span>
    }

<span class="nc" id="L415">    return (JSONArray) ((JSONObject) json.get(0)).get(KEY_METADATA_FIELDS);</span>
  }

  public static void fillCollectionFromJson(final DublinCoreMetadataCollection collection, final Object json) {
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">    if (!(json instanceof  JSONArray))</span>
<span class="nc" id="L420">      throw new IllegalArgumentException(&quot;couldn't fill metadata collection, didn't get an array&quot;);</span>

<span class="fc" id="L422">    final JSONArray metadataJson = (JSONArray) json;</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">    for (final JSONObject item : (Iterable&lt;JSONObject&gt;) metadataJson) {</span>
<span class="fc" id="L424">      final String fieldId = (String) item.get(KEY_METADATA_ID);</span>

<span class="pc bpc" id="L426" title="1 of 2 branches missed.">      if (fieldId == null)</span>
<span class="nc" id="L427">        continue;</span>
<span class="fc" id="L428">      final Object value = item.get(KEY_METADATA_VALUE);</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">      if (value == null)</span>
<span class="nc" id="L430">        continue;</span>

<span class="fc" id="L432">      final MetadataField target = collection.getOutputFields().get(fieldId);</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">      if (target == null)</span>
<span class="fc" id="L434">        continue;</span>

<span class="fc" id="L436">      final Object o = valueFromJson(value, target);</span>
<span class="fc" id="L437">      target.setValue(o);</span>
<span class="fc" id="L438">    }</span>
<span class="fc" id="L439">  }</span>

  public static void fillListFromJson(final MetadataList metadataList, final JSONArray json) {
<span class="fc bfc" id="L442" title="All 2 branches covered.">    for (final JSONObject item : (Iterable&lt;JSONObject&gt;) json) {</span>
<span class="fc" id="L443">      final MediaPackageElementFlavor flavor = MediaPackageElementFlavor</span>
<span class="fc" id="L444">              .parseFlavor((String) item.get(KEY_METADATA_FLAVOR));</span>
<span class="fc" id="L445">      final String title = (String) item.get(KEY_METADATA_TITLE);</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">      if (title == null)</span>
<span class="nc" id="L447">        continue;</span>

<span class="fc" id="L449">      final JSONArray value = (JSONArray) item.get(KEY_METADATA_FIELDS);</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">      if (value == null)</span>
<span class="nc" id="L451">        continue;</span>

<span class="fc" id="L453">      final DublinCoreMetadataCollection collection = metadataList.getMetadataByFlavor(flavor.toString());</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">      if (collection == null)</span>
<span class="fc" id="L455">        continue;</span>
<span class="fc" id="L456">      MetadataJson.fillCollectionFromJson(collection, value);</span>
<span class="fc" id="L457">    }</span>
<span class="fc" id="L458">  }</span>

  public static JValue listToJson(final MetadataList metadataList, final boolean withOrderedText) {
<span class="fc" id="L461">    final List&lt;JValue&gt; catalogs = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">    for (final Map.Entry&lt;String, MetadataList.TitledMetadataCollection&gt; metadata : metadataList.getMetadataList().entrySet()) {</span>
<span class="fc" id="L463">      final List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L465">      DublinCoreMetadataCollection metadataCollection = metadata.getValue().getCollection();</span>

<span class="fc bfc" id="L467" title="All 2 branches covered.">      if (!MetadataList.Locked.NONE.equals(metadataList.getLocked())) {</span>
<span class="fc" id="L468">        fields.add(f(KEY_METADATA_LOCKED, v(metadataList.getLocked().getValue())));</span>
<span class="fc" id="L469">        metadataCollection = metadataCollection.readOnlyCopy();</span>
      }

<span class="fc" id="L472">      fields.add(f(KEY_METADATA_FLAVOR, v(metadata.getKey())));</span>
<span class="fc" id="L473">      fields.add(f(KEY_METADATA_TITLE, v(metadata.getValue().getTitle())));</span>
<span class="fc" id="L474">      fields.add(f(KEY_METADATA_FIELDS, MetadataJson.collectionToJson(metadataCollection, withOrderedText)));</span>

<span class="fc" id="L476">      catalogs.add(obj(fields));</span>
<span class="fc" id="L477">    }</span>
<span class="fc" id="L478">    return arr(catalogs);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>