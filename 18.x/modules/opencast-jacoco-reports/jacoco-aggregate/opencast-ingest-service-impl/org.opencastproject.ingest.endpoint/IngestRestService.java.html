<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IngestRestService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-ingest-service-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.ingest.endpoint</a> &gt; <span class="el_source">IngestRestService.java</span></div><h1>IngestRestService.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.ingest.endpoint;

import static org.apache.commons.lang3.StringUtils.trimToNull;
import static org.opencastproject.mediapackage.MediaPackageElements.XACML_POLICY_EPISODE;

import org.opencastproject.authorization.xacml.XACMLUtils;
import org.opencastproject.capture.CaptureParameters;
import org.opencastproject.ingest.api.IngestException;
import org.opencastproject.ingest.api.IngestService;
import org.opencastproject.ingest.impl.IngestServiceImpl;
import org.opencastproject.job.api.JobProducer;
import org.opencastproject.mediapackage.EName;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageBuilderFactory;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.MediaPackageParser;
import org.opencastproject.mediapackage.MediaPackageSupport;
import org.opencastproject.mediapackage.identifier.IdImpl;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreCatalogService;
import org.opencastproject.metadata.dublincore.DublinCoreXmlFormat;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.rest.AbstractJobProducerEndpoint;
import org.opencastproject.scheduler.api.SchedulerConflictException;
import org.opencastproject.scheduler.api.SchedulerException;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.AccessControlParsingException;
import org.opencastproject.security.api.TrustedHttpClient;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.data.Function0.X;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.workflow.api.JaxbWorkflowInstance;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.XmlWorkflowParser;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.Consumes;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedHashMap;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

/**
 * Creates and augments Opencast MediaPackages using the api. Stores media into the Working File Repository.
 */
@Path(&quot;/ingest&quot;)
@RestService(name = &quot;ingestservice&quot;, title = &quot;Ingest Service&quot;, abstractText = &quot;This service creates and augments Opencast media packages that include media tracks, metadata &quot;
        + &quot;catalogs and attachments.&quot;, notes = {
        &quot;All paths above are relative to the REST endpoint base (something like http://your.server/files)&quot;,
        &quot;If the service is down or not working it will return a status 503, this means the the underlying service is &quot;
                + &quot;not working and is either restarting or has failed&quot;,
        &quot;A status code 500 means a general failure has occurred which is not recoverable and was not anticipated. In &quot;
                + &quot;other words, there is a bug! You should file an error report with your server logs from the time when the &quot;
                + &quot;error occurred: &lt;a href=\&quot;https://github.com/opencast/opencast/issues\&quot;&gt;Opencast Issue Tracker&lt;/a&gt;&quot; })
@Component(
  immediate = true,
  service = IngestRestService.class,
  property = {
    &quot;service.description=Ingest REST Endpoint&quot;,
    &quot;opencast.service.type=org.opencastproject.ingest&quot;,
    &quot;opencast.service.path=/ingest&quot;,
    &quot;opencast.service.jobproducer=true&quot;
  }
)
@JaxrsResource
<span class="fc" id="L145">public class IngestRestService extends AbstractJobProducerEndpoint {</span>

<span class="fc" id="L147">  private static final Logger logger = LoggerFactory.getLogger(IngestRestService.class);</span>

  /** Key for the default workflow definition in config.properties */
  protected static final String DEFAULT_WORKFLOW_DEFINITION = &quot;org.opencastproject.workflow.default.definition&quot;;

  /** Key for the default maximum number of ingests in config.properties */
  protected static final String MAX_INGESTS_KEY = &quot;org.opencastproject.ingest.max.concurrent&quot;;

  /** The http request parameter used to provide the workflow instance id */
  protected static final String WORKFLOW_INSTANCE_ID_PARAM = &quot;workflowInstanceId&quot;;

  /** The http request parameter used to provide the workflow definition id */
  protected static final String WORKFLOW_DEFINITION_ID_PARAM = &quot;workflowDefinitionId&quot;;

  /** The default workflow definition */
<span class="fc" id="L162">  private String defaultWorkflowDefinitionId = null;</span>

  /** The http client */
  private TrustedHttpClient httpClient;

  /** Dublin Core Terms: http://purl.org/dc/terms/ */
<span class="fc" id="L168">  private static final List&lt;String&gt; dcterms = Arrays.asList(&quot;abstract&quot;, &quot;accessRights&quot;, &quot;accrualMethod&quot;,</span>
          &quot;accrualPeriodicity&quot;, &quot;accrualPolicy&quot;, &quot;alternative&quot;, &quot;audience&quot;, &quot;available&quot;, &quot;bibliographicCitation&quot;,
          &quot;conformsTo&quot;, &quot;contributor&quot;, &quot;coverage&quot;, &quot;created&quot;, &quot;creator&quot;, &quot;date&quot;, &quot;dateAccepted&quot;, &quot;dateCopyrighted&quot;,
          &quot;dateSubmitted&quot;, &quot;description&quot;, &quot;educationLevel&quot;, &quot;extent&quot;, &quot;format&quot;, &quot;hasFormat&quot;, &quot;hasPart&quot;, &quot;hasVersion&quot;,
          &quot;identifier&quot;, &quot;instructionalMethod&quot;, &quot;isFormatOf&quot;, &quot;isPartOf&quot;, &quot;isReferencedBy&quot;, &quot;isReplacedBy&quot;,
          &quot;isRequiredBy&quot;, &quot;issued&quot;, &quot;isVersionOf&quot;, &quot;language&quot;, &quot;license&quot;, &quot;mediator&quot;, &quot;medium&quot;, &quot;modified&quot;,
          &quot;provenance&quot;, &quot;publisher&quot;, &quot;references&quot;, &quot;relation&quot;, &quot;replaces&quot;, &quot;requires&quot;, &quot;rights&quot;, &quot;rightsHolder&quot;,
          &quot;source&quot;, &quot;spatial&quot;, &quot;subject&quot;, &quot;tableOfContents&quot;, &quot;temporal&quot;, &quot;title&quot;, &quot;type&quot;, &quot;valid&quot;);

  /** Formatter to for the date into a string */
<span class="fc" id="L178">  private static final DateFormat DATE_FORMAT = new SimpleDateFormat(IngestService.UTC_DATE_FORMAT);</span>

  /** Media package builder factory */
<span class="fc" id="L181">  private static final MediaPackageBuilderFactory MP_FACTORY = MediaPackageBuilderFactory.newInstance();</span>

<span class="fc" id="L183">  private IngestService ingestService = null;</span>
<span class="fc" id="L184">  private ServiceRegistry serviceRegistry = null;</span>
  private DublinCoreCatalogService dublinCoreService;
  // The number of ingests this service can handle concurrently.
<span class="fc" id="L187">  private int ingestLimit = -1;</span>
  /* Stores a map workflow ID and date to update the ingest start times post-hoc */
<span class="fc" id="L189">  private final Cache&lt;String, Date&gt; startCache = CacheBuilder.newBuilder().expireAfterAccess(1, TimeUnit.DAYS).build();</span>

  /**
   * Returns the maximum number of concurrent ingest operations or &lt;code&gt;-1&lt;/code&gt; if no limit is enforced.
   *
   * @return the maximum number of concurrent ingest operations
   * @see #isIngestLimitEnabled()
   */
  protected synchronized int getIngestLimit() {
<span class="fc" id="L198">    return ingestLimit;</span>
  }

  /**
   * Sets the maximum number of concurrent ingest operations. Use &lt;code&gt;-1&lt;/code&gt; to indicate no limit.
   *
   * @param ingestLimit
   *          the limit
   */
  private synchronized void setIngestLimit(int ingestLimit) {
<span class="fc" id="L208">    this.ingestLimit = ingestLimit;</span>
<span class="fc" id="L209">  }</span>

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if a maximum number of concurrent ingest operations has been defined.
   *
   * @return &lt;code&gt;true&lt;/code&gt; if there is a maximum number of concurrent ingests
   */
  protected synchronized boolean isIngestLimitEnabled() {
<span class="fc bfc" id="L217" title="All 2 branches covered.">    return ingestLimit &gt;= 0;</span>
  }

  /**
   * Callback for activation of this component.
   */
  @Activate
  public void activate(ComponentContext cc) {
<span class="fc bfc" id="L225" title="All 2 branches covered.">    if (cc != null) {</span>
<span class="fc" id="L226">      defaultWorkflowDefinitionId = trimToNull(cc.getBundleContext().getProperty(DEFAULT_WORKFLOW_DEFINITION));</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">      if (defaultWorkflowDefinitionId == null) {</span>
<span class="nc" id="L228">        defaultWorkflowDefinitionId = &quot;schedule-and-upload&quot;;</span>
      }
<span class="fc bfc" id="L230" title="All 2 branches covered.">      if (cc.getBundleContext().getProperty(MAX_INGESTS_KEY) != null) {</span>
        try {
<span class="fc" id="L232">          ingestLimit = Integer.parseInt(trimToNull(cc.getBundleContext().getProperty(MAX_INGESTS_KEY)));</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">          if (ingestLimit == 0) {</span>
<span class="fc" id="L234">            ingestLimit = -1;</span>
          }
<span class="fc" id="L236">        } catch (NumberFormatException e) {</span>
<span class="fc" id="L237">          logger.warn(&quot;Max ingest property with key &quot; + MAX_INGESTS_KEY</span>
                  + &quot; isn't defined so no ingest limit will be used.&quot;);
<span class="fc" id="L239">          ingestLimit = -1;</span>
<span class="fc" id="L240">        }</span>
      }
    }
<span class="fc" id="L243">  }</span>

  @PUT
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;createMediaPackageWithID/{id}&quot;)
  @RestQuery(name = &quot;createMediaPackageWithID&quot;, description = &quot;Create an empty media package with ID /n Overrides Existing Mediapackage &quot;, pathParameters = {
          @RestParameter(description = &quot;The Id for the new Mediapackage&quot;, isRequired = true, name = &quot;id&quot;, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Returns media package&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response createMediaPackage(@PathParam(&quot;id&quot;) String mediaPackageId) {
    MediaPackage mp;
    try {
<span class="fc" id="L255">      mp = ingestService.createMediaPackage(mediaPackageId);</span>

<span class="fc" id="L257">      startCache.put(mp.getIdentifier().toString(), new Date());</span>
<span class="fc" id="L258">      return Response.ok(mp).build();</span>
<span class="nc" id="L259">    } catch (Exception e) {</span>
<span class="nc" id="L260">      logger.warn(&quot;Unable to create mediapackage&quot;, e);</span>
<span class="nc" id="L261">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @GET
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;createMediaPackage&quot;)
  @RestQuery(name = &quot;createMediaPackage&quot;, description = &quot;Create an empty media package&quot;, restParameters = {
         }, responses = {
          @RestResponse(description = &quot;Returns media package&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response createMediaPackage() {
    MediaPackage mp;
    try {
<span class="fc" id="L275">      mp = ingestService.createMediaPackage();</span>
<span class="fc" id="L276">      startCache.put(mp.getIdentifier().toString(), new Date());</span>
<span class="fc" id="L277">      return Response.ok(mp).build();</span>
<span class="nc" id="L278">    } catch (Exception e) {</span>
<span class="nc" id="L279">      logger.warn(&quot;Unable to create empty mediapackage&quot;, e);</span>
<span class="nc" id="L280">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @POST
  @Path(&quot;discardMediaPackage&quot;)
  @RestQuery(name = &quot;discardMediaPackage&quot;, description = &quot;Discard a media package&quot;, restParameters = { @RestParameter(description = &quot;Given media package to be destroyed&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) }, responses = {
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response discardMediaPackage(@FormParam(&quot;mediaPackage&quot;) String mpx) {
<span class="nc" id="L290">    logger.debug(&quot;discardMediaPackage(MediaPackage): {}&quot;, mpx);</span>
    try {
<span class="nc" id="L292">      MediaPackage mp = MP_FACTORY.newMediaPackageBuilder().loadFromXml(mpx);</span>
<span class="nc" id="L293">      ingestService.discardMediaPackage(mp);</span>
<span class="nc" id="L294">      return Response.ok().build();</span>
<span class="nc" id="L295">    } catch (Exception e) {</span>
<span class="nc" id="L296">      logger.warn(&quot;Unable to discard mediapackage {}&quot;, mpx, e);</span>
<span class="nc" id="L297">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;addTrack&quot;)
  @RestQuery(name = &quot;addTrackURL&quot;, description = &quot;Add a media track to a given media package using an URL&quot;, restParameters = {
          @RestParameter(description = &quot;The location of the media&quot;, isRequired = true, name = &quot;url&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The kind of media&quot;, isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The tags of the  media track&quot;, isRequired = false, name = &quot;tags&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The media package as XML&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) }, responses = {
          @RestResponse(description = &quot;Returns augmented media package&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response addMediaPackageTrack(@FormParam(&quot;url&quot;) String url, @FormParam(&quot;flavor&quot;) String flavor,  @FormParam(&quot;tags&quot;)  String tags,
          @FormParam(&quot;mediaPackage&quot;) String mpx) {
<span class="fc" id="L314">    logger.trace(&quot;add media package from url: {} flavor: {} tags: {} mediaPackage: {}&quot;, url, flavor, tags, mpx);</span>
    try {
<span class="fc" id="L316">      MediaPackage mp = MP_FACTORY.newMediaPackageBuilder().loadFromXml(mpx);</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">      if (MediaPackageSupport.sanityCheck(mp).isSome())</span>
<span class="nc" id="L318">        return Response.serverError().status(Status.BAD_REQUEST).build();</span>
<span class="fc" id="L319">      String[] tagsArray = null;</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">      if (tags != null) {</span>
<span class="fc" id="L321">        tagsArray = tags.split(&quot;,&quot;);</span>
      }
<span class="fc" id="L323">      mp = ingestService.addTrack(new URI(url), MediaPackageElementFlavor.parseFlavor(flavor), tagsArray, mp);</span>
<span class="fc" id="L324">      return Response.ok(mp).build();</span>
<span class="nc" id="L325">    } catch (Exception e) {</span>
<span class="nc" id="L326">      logger.warn(&quot;Unable to add mediapackage track&quot;, e);</span>
<span class="nc" id="L327">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @Path(&quot;addTrack&quot;)
  @RestQuery(
    name = &quot;addTrackInputStream&quot;,
    description = &quot;Add a media track to a given media package using an input stream&quot;,
    restParameters = {
      @RestParameter(description = &quot;The kind of media track&quot;, isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
      @RestParameter(description = &quot;The tags of the media track&quot;, isRequired = false, name = &quot;tags&quot;, type = RestParameter.Type.STRING),
      @RestParameter(description = &quot;The media package as XML&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) },
    bodyParameter = @RestParameter(description = &quot;The media track file&quot;, isRequired = true, name = &quot;BODY&quot;, type = RestParameter.Type.FILE),
    responses = {
      @RestResponse(description = &quot;Returns augmented media package&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
      @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) },
    returnDescription = &quot;&quot;)
  public Response addMediaPackageTrack(@Context HttpServletRequest request) {
<span class="fc" id="L349">    logger.trace(&quot;add track as multipart-form-data&quot;);</span>
<span class="fc" id="L350">    return addMediaPackageElement(request, MediaPackageElement.Type.Track);</span>
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;addPartialTrack&quot;)
  @RestQuery(name = &quot;addPartialTrackURL&quot;, description = &quot;Add a partial media track to a given media package using an URL&quot;, restParameters = {
          @RestParameter(description = &quot;The location of the media&quot;, isRequired = true, name = &quot;url&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The kind of media&quot;, isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The start time in milliseconds&quot;, isRequired = true, name = &quot;startTime&quot;, type = RestParameter.Type.INTEGER),
          @RestParameter(description = &quot;The media package as XML&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) }, responses = {
          @RestResponse(description = &quot;Returns augmented media package&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response addMediaPackagePartialTrack(@FormParam(&quot;url&quot;) String url, @FormParam(&quot;flavor&quot;) String flavor,
          @FormParam(&quot;startTime&quot;) Long startTime, @FormParam(&quot;mediaPackage&quot;) String mpx) {
<span class="fc" id="L366">    logger.trace(&quot;add partial track with url: {} flavor: {} startTime: {} mediaPackage: {}&quot;,</span>
            url, flavor, startTime, mpx);
    try {
<span class="fc" id="L369">      MediaPackage mp = MP_FACTORY.newMediaPackageBuilder().loadFromXml(mpx);</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">      if (MediaPackageSupport.sanityCheck(mp).isSome())</span>
<span class="nc" id="L371">        return Response.serverError().status(Status.BAD_REQUEST).build();</span>

<span class="fc" id="L373">      mp = ingestService.addPartialTrack(new URI(url), MediaPackageElementFlavor.parseFlavor(flavor), startTime, mp);</span>
<span class="fc" id="L374">      return Response.ok(mp).build();</span>
<span class="nc" id="L375">    } catch (Exception e) {</span>
<span class="nc" id="L376">      logger.warn(&quot;Unable to add partial track&quot;, e);</span>
<span class="nc" id="L377">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @Path(&quot;addPartialTrack&quot;)
  @RestQuery(name = &quot;addPartialTrackInputStream&quot;, description = &quot;Add a partial media track to a given media package using an input stream&quot;, restParameters = {
          @RestParameter(description = &quot;The kind of media track&quot;, isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The start time in milliseconds&quot;, isRequired = true, name = &quot;startTime&quot;, type = RestParameter.Type.INTEGER),
          @RestParameter(description = &quot;The media package as XML&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) }, bodyParameter = @RestParameter(description = &quot;The media track file&quot;, isRequired = true, name = &quot;BODY&quot;, type = RestParameter.Type.FILE), responses = {
          @RestResponse(description = &quot;Returns augmented media package&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response addMediaPackagePartialTrack(@Context HttpServletRequest request) {
<span class="fc" id="L393">    logger.trace(&quot;add partial track as multipart-form-data&quot;);</span>
<span class="fc" id="L394">    return addMediaPackageElement(request, MediaPackageElement.Type.Track);</span>
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;addCatalog&quot;)
  @RestQuery(name = &quot;addCatalogURL&quot;, description = &quot;Add a metadata catalog to a given media package using an URL&quot;, restParameters = {
          @RestParameter(description = &quot;The location of the catalog&quot;, isRequired = true, name = &quot;url&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The kind of catalog&quot;, isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The tags of the catalog&quot;, isRequired = false, name = &quot;tags&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The media package as XML&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) }, responses = {
          @RestResponse(description = &quot;Returns augmented media package&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response addMediaPackageCatalog(@FormParam(&quot;url&quot;) String url, @FormParam(&quot;flavor&quot;) String flavor,
      @FormParam(&quot;tags&quot;) String tags, @FormParam(&quot;mediaPackage&quot;) String mpx) {
<span class="fc" id="L410">    logger.trace(&quot;add catalog with url: {} flavor: {} tags: {} mediaPackage: {}&quot;, url, flavor, tags, mpx);</span>
    try {
<span class="fc" id="L412">      MediaPackage mp = MP_FACTORY.newMediaPackageBuilder().loadFromXml(mpx);</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">      if (MediaPackageSupport.sanityCheck(mp).isSome())</span>
<span class="nc" id="L414">        return Response.serverError().status(Status.BAD_REQUEST).build();</span>
<span class="fc" id="L415">      String[] tagsArray = null;</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">      if (tags != null) {</span>
<span class="nc" id="L417">        tagsArray = tags.split(&quot;,&quot;);</span>
      }
<span class="fc" id="L419">      MediaPackage resultingMediaPackage = ingestService.addCatalog(new URI(url),</span>
<span class="fc" id="L420">              MediaPackageElementFlavor.parseFlavor(flavor), tagsArray, mp);</span>
<span class="fc" id="L421">      return Response.ok(resultingMediaPackage).build();</span>
<span class="nc" id="L422">    } catch (Exception e) {</span>
<span class="nc" id="L423">      logger.warn(&quot;Unable to add catalog&quot;, e);</span>
<span class="nc" id="L424">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @Path(&quot;addCatalog&quot;)
  @RestQuery(name = &quot;addCatalogInputStream&quot;, description = &quot;Add a metadata catalog to a given media package using an input stream&quot;, restParameters = {
          @RestParameter(description = &quot;The kind of media catalog&quot;, isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The tags of the attachment&quot;, isRequired = false, name = &quot;tags&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The media package as XML&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) }, bodyParameter = @RestParameter(description = &quot;The metadata catalog file&quot;, isRequired = true, name = &quot;BODY&quot;, type = RestParameter.Type.FILE), responses = {
          @RestResponse(description = &quot;Returns augmented media package&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response addMediaPackageCatalog(@Context HttpServletRequest request) {
<span class="fc" id="L440">    logger.trace(&quot;add catalog as multipart-form-data&quot;);</span>
<span class="fc" id="L441">    return addMediaPackageElement(request, MediaPackageElement.Type.Catalog);</span>
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;addAttachment&quot;)
  @RestQuery(name = &quot;addAttachmentURL&quot;, description = &quot;Add an attachment to a given media package using an URL&quot;, restParameters = {
          @RestParameter(description = &quot;The location of the attachment&quot;, isRequired = true, name = &quot;url&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The kind of attachment&quot;, isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The tags of the attachment&quot;, isRequired = false, name = &quot;tags&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The media package as XML&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) }, responses = {
          @RestResponse(description = &quot;Returns augmented media package&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response addMediaPackageAttachment(@FormParam(&quot;url&quot;) String url, @FormParam(&quot;flavor&quot;) String flavor,
      @FormParam(&quot;tags&quot;) String tags, @FormParam(&quot;mediaPackage&quot;) String mpx) {
<span class="fc" id="L457">    logger.trace(&quot;add attachment with url: {} flavor: {} mediaPackage: {}&quot;, url, flavor, mpx);</span>
    try {
<span class="fc" id="L459">      MediaPackage mp = MP_FACTORY.newMediaPackageBuilder().loadFromXml(mpx);</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">      if (MediaPackageSupport.sanityCheck(mp).isSome())</span>
<span class="nc" id="L461">        return Response.serverError().status(Status.BAD_REQUEST).build();</span>
<span class="fc" id="L462">      String[] tagsArray = null;</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">      if (tags != null) {</span>
<span class="nc" id="L464">        tagsArray = tags.split(&quot;,&quot;);</span>
      }
<span class="fc" id="L466">      mp = ingestService.addAttachment(new URI(url), MediaPackageElementFlavor.parseFlavor(flavor), tagsArray, mp);</span>
<span class="fc" id="L467">      return Response.ok(mp).build();</span>
<span class="nc" id="L468">    } catch (Exception e) {</span>
<span class="nc" id="L469">      logger.warn(&quot;Unable to add attachment&quot;, e);</span>
<span class="nc" id="L470">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @Path(&quot;addAttachment&quot;)
  @RestQuery(name = &quot;addAttachmentInputStream&quot;, description = &quot;Add an attachment to a given media package using an input stream&quot;, restParameters = {
          @RestParameter(description = &quot;The kind of attachment&quot;, isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The tags of the attachment&quot;, isRequired = false, name = &quot;tags&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The media package as XML&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) }, bodyParameter = @RestParameter(description = &quot;The attachment file&quot;, isRequired = true, name = &quot;BODY&quot;, type = RestParameter.Type.FILE), responses = {
          @RestResponse(description = &quot;Returns augmented media package&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response addMediaPackageAttachment(@Context HttpServletRequest request) {
<span class="fc" id="L486">    logger.trace(&quot;add attachment as multipart-form-data&quot;);</span>
<span class="fc" id="L487">    return addMediaPackageElement(request, MediaPackageElement.Type.Attachment);</span>
  }

  protected Response addMediaPackageElement(HttpServletRequest request, MediaPackageElement.Type type) {
<span class="fc" id="L491">    MediaPackageElementFlavor flavor = null;</span>
<span class="fc" id="L492">    InputStream in = null;</span>
    try {
<span class="fc" id="L494">      String fileName = null;</span>
<span class="fc" id="L495">      MediaPackage mp = null;</span>
<span class="fc" id="L496">      Long startTime = null;</span>
<span class="fc" id="L497">      String[] tags = null;</span>
      /* Only accept multipart/form-data */
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">      if (!ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L500">        logger.trace(&quot;request isn't multipart-form-data&quot;);</span>
<span class="nc" id="L501">        return Response.serverError().status(Status.BAD_REQUEST).build();</span>
      }
<span class="fc" id="L503">      boolean isDone = false;</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">      for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="fc" id="L505">        FileItemStream item = iter.next();</span>
<span class="fc" id="L506">        String fieldName = item.getFieldName();</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">        if (item.isFormField()) {</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">          if (&quot;flavor&quot;.equals(fieldName)) {</span>
<span class="fc" id="L509">            String flavorString = Streams.asString(item.openStream(), &quot;UTF-8&quot;);</span>
<span class="fc" id="L510">            logger.trace(&quot;flavor: {}&quot;, flavorString);</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">            if (flavorString != null) {</span>
              try {
<span class="fc" id="L513">                flavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>
<span class="nc" id="L514">              } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L515">                String error = String.format(&quot;Could not parse flavor '%s'&quot;, flavorString);</span>
<span class="nc" id="L516">                logger.debug(error, e);</span>
<span class="nc" id="L517">                return Response.status(Status.BAD_REQUEST).entity(error).build();</span>
<span class="fc" id="L518">              }</span>
            }
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">          } else if (&quot;tags&quot;.equals(fieldName)) {</span>
<span class="nc" id="L521">            String tagsString = Streams.asString(item.openStream(), &quot;UTF-8&quot;);</span>
<span class="nc" id="L522">            logger.trace(&quot;tags: {}&quot;, tagsString);</span>
<span class="nc" id="L523">            tags = tagsString.split(&quot;,&quot;);</span>
<span class="pc bfc" id="L524" title="All 2 branches covered.">          } else if (&quot;mediaPackage&quot;.equals(fieldName)) {</span>
            try {
<span class="fc" id="L526">              String mediaPackageString = Streams.asString(item.openStream(), &quot;UTF-8&quot;);</span>
<span class="fc" id="L527">              logger.trace(&quot;mediaPackage: {}&quot;, mediaPackageString);</span>
<span class="fc" id="L528">              mp = MP_FACTORY.newMediaPackageBuilder().loadFromXml(mediaPackageString);</span>
<span class="nc" id="L529">            } catch (MediaPackageException e) {</span>
<span class="nc" id="L530">              logger.debug(&quot;Unable to parse the 'mediaPackage' parameter: {}&quot;, ExceptionUtils.getMessage(e));</span>
<span class="nc" id="L531">              return Response.serverError().status(Status.BAD_REQUEST).build();</span>
<span class="fc" id="L532">            }</span>
<span class="pc bpc" id="L533" title="1 of 4 branches missed.">          } else if (&quot;startTime&quot;.equals(fieldName) &amp;&amp; &quot;/ingest/addPartialTrack&quot;.equals(request.getPathInfo())) {</span>
<span class="fc" id="L534">            String startTimeString = Streams.asString(item.openStream(), &quot;UTF-8&quot;);</span>
<span class="fc" id="L535">            logger.trace(&quot;startTime: {}&quot;, startTime);</span>
            try {
<span class="fc" id="L537">              startTime = Long.parseLong(startTimeString);</span>
<span class="nc" id="L538">            } catch (Exception e) {</span>
<span class="nc" id="L539">              logger.debug(&quot;Unable to parse the 'startTime' parameter: {}&quot;, ExceptionUtils.getMessage(e));</span>
<span class="nc" id="L540">              return Response.serverError().status(Status.BAD_REQUEST).build();</span>
<span class="fc" id="L541">            }</span>
<span class="fc" id="L542">          }</span>
        } else {
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">          if (flavor == null) {</span>
            /* A flavor has to be specified in the request prior the video file */
<span class="nc" id="L546">            logger.debug(&quot;A flavor has to be specified in the request prior to the content BODY&quot;);</span>
<span class="nc" id="L547">            return Response.serverError().status(Status.BAD_REQUEST).build();</span>
          }
<span class="fc" id="L549">          fileName = item.getName();</span>
<span class="fc" id="L550">          in = item.openStream();</span>
<span class="fc" id="L551">          isDone = true;</span>
        }
<span class="fc bfc" id="L553" title="All 2 branches covered.">        if (isDone) {</span>
<span class="fc" id="L554">          break;</span>
        }
<span class="fc" id="L556">      }</span>
      /*
       * Check if we actually got a valid request including a message body and a valid mediapackage to attach the
       * element to
       */
<span class="pc bpc" id="L561" title="3 of 6 branches missed.">      if (in == null || mp == null || MediaPackageSupport.sanityCheck(mp).isSome()) {</span>
<span class="nc" id="L562">        return Response.serverError().status(Status.BAD_REQUEST).build();</span>
      }
<span class="pc bpc" id="L564" title="1 of 4 branches missed.">      switch (type) {</span>
        case Attachment:
<span class="fc" id="L566">          mp = ingestService.addAttachment(in, fileName, flavor, tags, mp);</span>
<span class="fc" id="L567">          break;</span>
        case Catalog:
          try {
<span class="fc" id="L570">            mp = ingestService.addCatalog(in, fileName, flavor, tags, mp);</span>
<span class="nc" id="L571">          } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L572">            logger.debug(&quot;Invalid catalog data&quot;, e);</span>
<span class="nc" id="L573">            return Response.serverError().status(Status.BAD_REQUEST).build();</span>
<span class="fc" id="L574">          }</span>
          break;
        case Track:
<span class="fc bfc" id="L577" title="All 2 branches covered.">          if (startTime == null) {</span>
<span class="fc" id="L578">            mp = ingestService.addTrack(in, fileName, flavor, tags, mp);</span>
          } else {
<span class="fc" id="L580">            mp = ingestService.addPartialTrack(in, fileName, flavor, startTime, mp);</span>
          }
<span class="fc" id="L582">          break;</span>
        default:
<span class="nc" id="L584">          throw new IllegalStateException(&quot;Type must be one of track, catalog, or attachment&quot;);</span>
      }
<span class="fc" id="L586">      return Response.ok(MediaPackageParser.getAsXml(mp)).build();</span>
<span class="nc" id="L587">    } catch (Exception e) {</span>
<span class="nc" id="L588">      logger.warn(&quot;Unable to add mediapackage element&quot;, e);</span>
<span class="nc" id="L589">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    } finally {
<span class="fc" id="L591">      IOUtils.closeQuietly(in);</span>
    }
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @Path(&quot;addMediaPackage&quot;)
  @RestQuery(name = &quot;addMediaPackage&quot;,
      description = &quot;&lt;p&gt;Create and ingest media package from media tracks with additional Dublin Core metadata. It is &quot;
        + &quot;mandatory to set a title for the recording. This can be done with the 'title' form field or by supplying a DC &quot;
        + &quot;catalog with a title included.  The identifier of the newly created media package will be taken from the &quot;
        + &quot;&lt;em&gt;identifier&lt;/em&gt; field or the episode DublinCore catalog (deprecated&lt;sup&gt;*&lt;/sup&gt;). If no identifier is &quot;
        + &quot;set, a new random UUIDv4 will be generated. This endpoint is not meant to be used by capture agents for &quot;
        + &quot;scheduled recordings. Its primary use is for manual ingests with command line tools like cURL.&lt;/p&gt; &quot;
        + &quot;&lt;p&gt;Multiple tracks can be ingested by using multiple form fields. It is important to always set the &quot;
        + &quot;flavor of the next media file &lt;em&gt;before&lt;/em&gt; sending the media file itself.&lt;/p&gt;&quot;
        + &quot;&lt;b&gt;(*)&lt;/b&gt; The special treatment of the identifier field is deprecated and may be removed in future versions &quot;
        + &quot;without further notice in favor of a random UUID generation to ensure uniqueness of identifiers. &quot;
        + &quot;&lt;h3&gt;Example cURL command:&lt;/h3&gt;&quot;
        + &quot;&lt;p&gt;Ingest one video file:&lt;/p&gt;&quot;
        + &quot;&lt;p&gt;&lt;pre&gt;\n&quot;
        + &quot;curl -i -u admin:opencast http://localhost:8080/ingest/addMediaPackage \\\n&quot;
        + &quot;    -F creator='John Doe' -F title='Test Recording' \\\n&quot;
        + &quot;    -F 'flavor=presentation/source' -F 'BODY=@test-recording.mp4' \n&quot;
        + &quot;&lt;/pre&gt;&lt;/p&gt;&quot;
        + &quot;&lt;p&gt;Ingest two video files:&lt;/p&gt;&quot;
        + &quot;&lt;p&gt;&lt;pre&gt;\n&quot;
        + &quot;curl -i -u admin:opencast http://localhost:8080/ingest/addMediaPackage \\\n&quot;
        + &quot;    -F creator='John Doe' -F title='Test Recording' \\\n&quot;
        + &quot;    -F 'flavor=presentation/source' -F 'BODY=@test-recording-vga.mp4' \\\n&quot;
        + &quot;    -F 'flavor=presenter/source' -F 'BODY=@test-recording-camera.mp4' \n&quot;
        + &quot;&lt;/pre&gt;&lt;/p&gt;&quot;,
      restParameters = {
          @RestParameter(description = &quot;The kind of media track. This has to be specified prior to each media track&quot;, isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;abstract&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;accessRights&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;available&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;contributor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;coverage&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;created&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;creator&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;date&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;description&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;extent&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;format&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;identifier&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;isPartOf&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;isReferencedBy&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;isReplacedBy&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;language&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;license&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;publisher&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;relation&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;replaces&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;rights&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;rightsHolder&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;source&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;spatial&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;subject&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;temporal&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;title&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;type&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;URL of episode DublinCore Catalog&quot;, isRequired = false, name = &quot;episodeDCCatalogUri&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode DublinCore Catalog&quot;, isRequired = false, name = &quot;episodeDCCatalog&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;URL of series DublinCore Catalog&quot;, isRequired = false, name = &quot;seriesDCCatalogUri&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Series DublinCore Catalog&quot;, isRequired = false, name = &quot;seriesDCCatalog&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Access control list in XACML or JSON form&quot;, isRequired = false, name = &quot;acl&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Tag of the next media file&quot;, isRequired = false, name = &quot;tag&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;URL of a media track file&quot;, isRequired = false, name = &quot;mediaUri&quot;, type = RestParameter.Type.STRING) },
      bodyParameter = @RestParameter(description = &quot;The media track file&quot;, isRequired = true, name = &quot;BODY&quot;, type = RestParameter.Type.FILE),
      responses = {
          @RestResponse(description = &quot;Ingest successful. Returns workflow instance as xml&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;Ingest failed due to invalid requests.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;Ingest failed. Something went wrong internally. Please have a look at the log files&quot;,
              responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) },
      returnDescription = &quot;&quot;)
  public Response addMediaPackage(@Context HttpServletRequest request) {
<span class="nc" id="L669">    logger.trace(&quot;add mediapackage as multipart-form-data&quot;);</span>
<span class="nc" id="L670">    return addMediaPackage(request, null);</span>
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @Path(&quot;addMediaPackage/{wdID}&quot;)
  @RestQuery(name = &quot;addMediaPackage&quot;,
      description = &quot;&lt;p&gt;Create and ingest media package from media tracks with additional Dublin Core metadata. It is &quot;
        + &quot;mandatory to set a title for the recording. This can be done with the 'title' form field or by supplying a DC &quot;
        + &quot;catalog with a title included.  The identifier of the newly created media package will be taken from the &quot;
        + &quot;&lt;em&gt;identifier&lt;/em&gt; field or the episode DublinCore catalog (deprecated&lt;sup&gt;*&lt;/sup&gt;). If no identifier is &quot;
        + &quot;set, a newa randumm UUIDv4 will be generated. This endpoint is not meant to be used by capture agents for &quot;
        + &quot;scheduled recordings. It's primary use is for manual ingests with command line tools like cURL.&lt;/p&gt; &quot;
        + &quot;&lt;p&gt;Multiple tracks can be ingested by using multiple form fields. It's important, however, to always set the &quot;
        + &quot;flavor of the next media file &lt;em&gt;before&lt;/em&gt; sending the media file itself.&lt;/p&gt;&quot;
        + &quot;&lt;b&gt;(*)&lt;/b&gt; The special treatment of the identifier field is deprecated any may be removed in future versions &quot;
        + &quot;without further notice in favor of a random UUID generation to ensure uniqueness of identifiers. &quot;
        + &quot;&lt;h3&gt;Example cURL command:&lt;/h3&gt;&quot;
        + &quot;&lt;p&gt;Ingest one video file:&lt;/p&gt;&quot;
        + &quot;&lt;p&gt;&lt;pre&gt;\n&quot;
        + &quot;curl -i -u admin:opencast http://localhost:8080/ingest/addMediaPackage/fast \\\n&quot;
        + &quot;    -F creator='John Doe' -F title='Test Recording' \\\n&quot;
        + &quot;    -F 'flavor=presentation/source' -F 'BODY=@test-recording.mp4' \n&quot;
        + &quot;&lt;/pre&gt;&lt;/p&gt;&quot;
        + &quot;&lt;p&gt;Ingest two video files:&lt;/p&gt;&quot;
        + &quot;&lt;p&gt;&lt;pre&gt;\n&quot;
        + &quot;curl -i -u admin:opencast http://localhost:8080/ingest/addMediaPackage/fast \\\n&quot;
        + &quot;    -F creator='John Doe' -F title='Test Recording' \\\n&quot;
        + &quot;    -F 'flavor=presentation/source' -F 'BODY=@test-recording-vga.mp4' \\\n&quot;
        + &quot;    -F 'flavor=presenter/source' -F 'BODY=@test-recording-camera.mp4' \n&quot;
        + &quot;&lt;/pre&gt;&lt;/p&gt;&quot;,
      pathParameters = {
          @RestParameter(description = &quot;Workflow definition id&quot;, isRequired = true, name = &quot;wdID&quot;, type = RestParameter.Type.STRING) },
      restParameters = {
          @RestParameter(description = &quot;The kind of media track. This has to be specified prior to each media track&quot;, isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;abstract&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;accessRights&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;available&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;contributor&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;coverage&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;created&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;creator&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;date&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;description&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;extent&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;format&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;identifier&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;isPartOf&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;isReferencedBy&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;isReplacedBy&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;language&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;license&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;publisher&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;relation&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;replaces&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;rights&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;rightsHolder&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;source&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;spatial&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;subject&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;temporal&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;title&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode metadata value&quot;, isRequired = false, name = &quot;type&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;URL of episode DublinCore Catalog&quot;, isRequired = false, name = &quot;episodeDCCatalogUri&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Episode DublinCore Catalog&quot;, isRequired = false, name = &quot;episodeDCCatalog&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;URL of series DublinCore Catalog&quot;, isRequired = false, name = &quot;seriesDCCatalogUri&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Series DublinCore Catalog&quot;, isRequired = false, name = &quot;seriesDCCatalog&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Access control list in XACML or JSON form&quot;, isRequired = false, name = &quot;acl&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;Tag of the next media file&quot;, isRequired = false, name = &quot;tag&quot;, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;URL of a media track file&quot;, isRequired = false, name = &quot;mediaUri&quot;, type = RestParameter.Type.STRING) },
      bodyParameter = @RestParameter(description = &quot;The media track file&quot;, isRequired = true, name = &quot;BODY&quot;, type = RestParameter.Type.FILE),
      responses = {
          @RestResponse(description = &quot;Ingest successful. Returns workflow instance as XML&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;Ingest failed due to invalid requests.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;Ingest failed. A workflow is currently active on the media package&quot;, responseCode = HttpServletResponse.SC_CONFLICT),
          @RestResponse(description = &quot;Ingest failed. Something went wrong internally. Please have a look at the log files&quot;,
              responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) },
      returnDescription = &quot;&quot;)
  public Response addMediaPackage(@Context HttpServletRequest request, @PathParam(&quot;wdID&quot;) String wdID) {
<span class="nc" id="L750">    logger.trace(&quot;add mediapackage as multipart-form-data with workflow definition id: {}&quot;, wdID);</span>
    // For compatibility, we will support re-use of flavors for now but will print a warning.
    // If there are no major complaints, we will remove this with Opencast 11 or 12
<span class="nc" id="L753">    boolean flavorAlreadyUsed = false;</span>
<span class="nc" id="L754">    MediaPackageElementFlavor flavor = null;</span>
<span class="nc" id="L755">    List&lt;String&gt; tags = new ArrayList&lt;&gt;();</span>
    try {
<span class="nc" id="L757">      MediaPackage mp = ingestService.createMediaPackage();</span>
<span class="nc" id="L758">      DublinCoreCatalog dcc = null;</span>
<span class="nc" id="L759">      Map&lt;String, String&gt; workflowProperties = new HashMap&lt;&gt;();</span>
<span class="nc" id="L760">      int seriesDCCatalogNumber = 0;</span>
<span class="nc" id="L761">      int episodeDCCatalogNumber = 0;</span>
<span class="nc" id="L762">      boolean hasMedia = false;</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">      if (ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L765">          FileItemStream item = iter.next();</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">          if (item.isFormField()) {</span>
<span class="nc" id="L767">            String fieldName = item.getFieldName();</span>
<span class="nc" id="L768">            String value = Streams.asString(item.openStream(), &quot;UTF-8&quot;);</span>
<span class="nc" id="L769">            logger.trace(&quot;form field {}: {}&quot;, fieldName, value);</span>
            /* Ignore empty fields */
<span class="nc bnc" id="L771" title="All 2 branches missed.">            if (&quot;&quot;.equals(value)) {</span>
<span class="nc" id="L772">              continue;</span>
            }

            /* “Remember” the flavor for the next media. */
<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (&quot;flavor&quot;.equals(fieldName)) {</span>
              try {
<span class="nc" id="L778">                flavor = MediaPackageElementFlavor.parseFlavor(value);</span>
<span class="nc" id="L779">                flavorAlreadyUsed = false;</span>
<span class="nc" id="L780">              } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L781">                return badRequest(String.format(&quot;Could not parse flavor '%s'&quot;, value), e);</span>
<span class="nc" id="L782">              }</span>
              /* “Remember” the tags for the next media. */
<span class="nc bnc" id="L784" title="All 2 branches missed.">            } else if (&quot;tag&quot;.equals(fieldName)) {</span>
<span class="nc" id="L785">              tags.add(value);</span>
              /* Fields for DC catalog */
<span class="nc bnc" id="L787" title="All 2 branches missed.">            } else if (dcterms.contains(fieldName)) {</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">              if (&quot;identifier&quot;.equals(fieldName)) {</span>
                /* Use the identifier for the mediapackage */
<span class="nc" id="L790">                mp.setIdentifier(new IdImpl(value));</span>
              }
<span class="nc bnc" id="L792" title="All 2 branches missed.">              if (dcc == null) {</span>
<span class="nc" id="L793">                dcc = dublinCoreService.newInstance();</span>
              }
<span class="nc" id="L795">              dcc.add(new EName(DublinCore.TERMS_NS_URI, fieldName), value);</span>

              /* Episode metadata by URL */
<span class="nc bnc" id="L798" title="All 2 branches missed.">            } else if (&quot;episodeDCCatalogUri&quot;.equals(fieldName)) {</span>
              try {
<span class="nc" id="L800">                URI dcUrl = new URI(value);</span>
<span class="nc" id="L801">                ingestService.addCatalog(dcUrl, MediaPackageElements.EPISODE, null, mp);</span>
<span class="nc" id="L802">                updateMediaPackageID(mp, dcUrl);</span>
<span class="nc" id="L803">                episodeDCCatalogNumber += 1;</span>
<span class="nc" id="L804">              } catch (java.net.URISyntaxException e) {</span>
<span class="nc" id="L805">                return badRequest(String.format(&quot;Invalid URI %s for episodeDCCatalogUri&quot;, value), e);</span>
<span class="nc" id="L806">              } catch (Exception e) {</span>
<span class="nc" id="L807">                return badRequest(&quot;Could not parse XML Dublin Core catalog&quot;, e);</span>
<span class="nc" id="L808">              }</span>

              /* Episode metadata DC catalog (XML) as string */
<span class="nc bnc" id="L811" title="All 2 branches missed.">            } else if (&quot;episodeDCCatalog&quot;.equals(fieldName)) {</span>
<span class="nc" id="L812">              try (InputStream is = new ByteArrayInputStream(value.getBytes(StandardCharsets.UTF_8))) {</span>
<span class="nc" id="L813">                final String fileName = &quot;episode-&quot; + episodeDCCatalogNumber + &quot;.xml&quot;;</span>
<span class="nc" id="L814">                ingestService.addCatalog(is, fileName, MediaPackageElements.EPISODE, mp);</span>
<span class="nc" id="L815">                episodeDCCatalogNumber += 1;</span>
<span class="nc" id="L816">                is.reset();</span>
<span class="nc" id="L817">                updateMediaPackageID(mp, is);</span>
<span class="nc" id="L818">              } catch (Exception e) {</span>
<span class="nc" id="L819">                return badRequest(&quot;Could not parse XML Dublin Core catalog&quot;, e);</span>
<span class="nc" id="L820">              }</span>

              /* Series by URL */
<span class="nc bnc" id="L823" title="All 2 branches missed.">            } else if (&quot;seriesDCCatalogUri&quot;.equals(fieldName)) {</span>
              try {
<span class="nc" id="L825">                URI dcUrl = new URI(value);</span>
<span class="nc" id="L826">                ingestService.addCatalog(dcUrl, MediaPackageElements.SERIES, null, mp);</span>
<span class="nc" id="L827">              } catch (java.net.URISyntaxException e) {</span>
<span class="nc" id="L828">                return badRequest(String.format(&quot;Invalid URI %s for episodeDCCatalogUri&quot;, value), e);</span>
<span class="nc" id="L829">              } catch (Exception e) {</span>
<span class="nc" id="L830">                return badRequest(&quot;Could not parse XML Dublin Core catalog&quot;, e);</span>
<span class="nc" id="L831">              }</span>

              /* Series DC catalog (XML) as string */
<span class="nc bnc" id="L834" title="All 2 branches missed.">            } else if (&quot;seriesDCCatalog&quot;.equals(fieldName)) {</span>
<span class="nc" id="L835">              final String fileName = &quot;series-&quot; + seriesDCCatalogNumber + &quot;.xml&quot;;</span>
<span class="nc" id="L836">              seriesDCCatalogNumber += 1;</span>
<span class="nc" id="L837">              try (InputStream is = new ByteArrayInputStream(value.getBytes(StandardCharsets.UTF_8))) {</span>
<span class="nc" id="L838">                ingestService.addCatalog(is, fileName, MediaPackageElements.SERIES, mp);</span>
<span class="nc" id="L839">              } catch (Exception e) {</span>
<span class="nc" id="L840">                return badRequest(&quot;Could not parse XML Dublin Core catalog&quot;, e);</span>
<span class="nc" id="L841">              }</span>

              // Add ACL in JSON, XML or XACML format
<span class="nc bnc" id="L844" title="All 2 branches missed.">            } else if (&quot;acl&quot;.equals(fieldName)) {</span>
<span class="nc" id="L845">              InputStream inputStream = new ByteArrayInputStream(value.getBytes(StandardCharsets.UTF_8));</span>
              AccessControlList acl;
              try {
<span class="nc" id="L848">                acl = AccessControlParser.parseAcl(inputStream);</span>
<span class="nc" id="L849">                inputStream = new ByteArrayInputStream(XACMLUtils.getXacml(mp, acl).getBytes(StandardCharsets.UTF_8));</span>
<span class="nc" id="L850">              } catch (AccessControlParsingException e) {</span>
                // Couldn't parse this → already XACML. Why again are we using three different formats?
<span class="nc" id="L852">                logger.debug(&quot;Unable to parse ACL, guessing that this is already XACML&quot;);</span>
<span class="nc" id="L853">                inputStream.reset();</span>
<span class="nc" id="L854">              }</span>
<span class="nc" id="L855">              ingestService.addAttachment(inputStream, &quot;episode-security.xml&quot;, XACML_POLICY_EPISODE, mp);</span>

              /* Add media files by URL */
<span class="nc bnc" id="L858" title="All 2 branches missed.">            } else if (&quot;mediaUri&quot;.equals(fieldName)) {</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">              if (flavor == null) {</span>
<span class="nc" id="L860">                return badRequest(&quot;A flavor has to be specified in the request prior to the media file&quot;, null);</span>
              }
              URI mediaUrl;
              try {
<span class="nc" id="L864">                mediaUrl = new URI(value);</span>
<span class="nc" id="L865">              } catch (java.net.URISyntaxException e) {</span>
<span class="nc" id="L866">                return badRequest(String.format(&quot;Invalid URI %s for media&quot;, value), e);</span>
<span class="nc" id="L867">              }</span>
<span class="nc" id="L868">              warnIfFlavorAlreadyUsed(flavorAlreadyUsed);</span>
<span class="nc" id="L869">              ingestService.addTrack(mediaUrl, flavor, tags.toArray(new String[0]), mp);</span>
<span class="nc" id="L870">              flavorAlreadyUsed = true;</span>
<span class="nc" id="L871">              tags.clear();</span>
<span class="nc" id="L872">              hasMedia = true;</span>

<span class="nc" id="L874">            } else {</span>
              /* Tread everything else as workflow properties */
<span class="nc" id="L876">              workflowProperties.put(fieldName, value);</span>
            }

            /* Media files as request parameter */
<span class="nc" id="L880">          } else {</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">            if (flavor == null) {</span>
              /* A flavor has to be specified in the request prior the video file */
<span class="nc" id="L883">              return badRequest(&quot;A flavor has to be specified in the request prior to the content BODY&quot;, null);</span>
            }
<span class="nc" id="L885">            warnIfFlavorAlreadyUsed(flavorAlreadyUsed);</span>
<span class="nc" id="L886">            ingestService.addTrack(item.openStream(), item.getName(), flavor, tags.toArray(new String[0]), mp);</span>
<span class="nc" id="L887">            flavorAlreadyUsed = true;</span>
<span class="nc" id="L888">            tags.clear();</span>
<span class="nc" id="L889">            hasMedia = true;</span>
          }
<span class="nc" id="L891">        }</span>

        /* Check if we got any media. Fail if not. */
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (!hasMedia) {</span>
<span class="nc" id="L895">          return badRequest(&quot;Rejected ingest without actual media.&quot;, null);</span>
        }

        /* Add episode mediapackage if metadata were send separately */
<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (dcc != null) {</span>
<span class="nc" id="L900">          ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
          try {
<span class="nc" id="L902">            dcc.toXml(out, true);</span>
<span class="nc" id="L903">            try (InputStream in = new ByteArrayInputStream(out.toByteArray())) {</span>
<span class="nc" id="L904">              ingestService.addCatalog(in, &quot;dublincore.xml&quot;, MediaPackageElements.EPISODE, mp);</span>
            }
<span class="nc" id="L906">          } catch (Exception e) {</span>
<span class="nc" id="L907">            return badRequest(&quot;Could not create XML from ingested metadata&quot;, e);</span>
<span class="nc" id="L908">          }</span>

          /* Check if we have metadata for the episode */
<span class="nc bnc" id="L911" title="All 2 branches missed.">        } else if (episodeDCCatalogNumber == 0) {</span>
<span class="nc" id="L912">          return badRequest(&quot;Rejected ingest without episode metadata. At least provide a title.&quot;, null);</span>
        }

<span class="nc bnc" id="L915" title="All 2 branches missed.">        WorkflowInstance workflow = (wdID == null)</span>
<span class="nc" id="L916">            ? ingestService.ingest(mp)</span>
<span class="nc" id="L917">            : ingestService.ingest(mp, wdID, workflowProperties);</span>
<span class="nc" id="L918">        return Response.ok(new JaxbWorkflowInstance(workflow)).build();</span>
      }
<span class="nc" id="L920">      return Response.serverError().status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L921">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L922">      return badRequest(e.getMessage(), e);</span>
<span class="nc" id="L923">    } catch (IllegalStateException e) {</span>
<span class="nc" id="L924">      return Response.status(Status.CONFLICT).entity(e.getMessage()).build();</span>
<span class="nc" id="L925">    } catch (Exception e) {</span>
<span class="nc" id="L926">      logger.warn(&quot;Unable to add mediapackage&quot;, e);</span>
<span class="nc" id="L927">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @Deprecated
  private void warnIfFlavorAlreadyUsed(final boolean used) {
<span class="nc bnc" id="L933" title="All 2 branches missed.">    if (used) {</span>
<span class="nc" id="L934">      logger.warn(&quot;\n&quot;</span>
          + &quot;********************************************\n&quot;
          + &quot;* Warning: Re-use of flavors during ingest *\n&quot;
          + &quot;*          is deprecated and will be       *\n&quot;
          + &quot;*          removed soon! Declare a flavor  *\n&quot;
          + &quot;*          for each media file or create   *\n&quot;
          + &quot;*          an issue if you need this.      *\n&quot;
          + &quot;********************************************&quot;
      );
    }
<span class="nc" id="L944">  }</span>

  /**
   * Try updating the identifier of a mediapackage with the identifier from a episode DublinCore catalog.
   *
   * @param mp
   *          MediaPackage to modify
   * @param is
   *          InputStream containing the episode DublinCore catalog
   */
  private void updateMediaPackageID(MediaPackage mp, InputStream is) throws IOException {
<span class="nc" id="L955">    DublinCoreCatalog dc = DublinCores.read(is);</span>
<span class="nc" id="L956">    EName en = new EName(DublinCore.TERMS_NS_URI, &quot;identifier&quot;);</span>
<span class="nc" id="L957">    String id = dc.getFirst(en);</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">    if (id != null) {</span>
<span class="nc" id="L959">      mp.setIdentifier(new IdImpl(id));</span>
    }
<span class="nc" id="L961">  }</span>

  /**
   * Try updating the identifier of a mediapackage with the identifier from a episode DublinCore catalog.
   *
   * @param mp
   *          MediaPackage to modify
   * @param uri
   *          URI to get the episode DublinCore catalog from
   */
  private void updateMediaPackageID(MediaPackage mp, URI uri) throws IOException {
<span class="nc" id="L972">    InputStream in = null;</span>
<span class="nc" id="L973">    HttpResponse response = null;</span>
    try {
<span class="nc bnc" id="L975" title="All 2 branches missed.">      if (uri.toString().startsWith(&quot;http&quot;)) {</span>
<span class="nc" id="L976">        HttpGet get = new HttpGet(uri);</span>
<span class="nc" id="L977">        response = httpClient.execute(get);</span>
<span class="nc" id="L978">        int httpStatusCode = response.getStatusLine().getStatusCode();</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">        if (httpStatusCode != 200) {</span>
<span class="nc" id="L980">          throw new IOException(uri + &quot; returns http &quot; + httpStatusCode);</span>
        }
<span class="nc" id="L982">        in = response.getEntity().getContent();</span>
<span class="nc" id="L983">      } else {</span>
<span class="nc" id="L984">        in = uri.toURL().openStream();</span>
      }
<span class="nc" id="L986">      updateMediaPackageID(mp, in);</span>
<span class="nc" id="L987">      in.close();</span>
    } finally {
<span class="nc" id="L989">      IOUtils.closeQuietly(in);</span>
<span class="nc" id="L990">      httpClient.close(response);</span>
    }
<span class="nc" id="L992">  }</span>

  @POST
  @Path(&quot;addZippedMediaPackage/{workflowDefinitionId}&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;addZippedMediaPackage&quot;, description = &quot;Create media package from a compressed file containing a manifest.xml document and all media tracks, metadata catalogs and attachments&quot;, pathParameters = { @RestParameter(description = &quot;Workflow definition id&quot;, isRequired = true, name = WORKFLOW_DEFINITION_ID_PARAM, type = RestParameter.Type.STRING) }, restParameters = { @RestParameter(description = &quot;The workflow instance ID to associate with this zipped mediapackage&quot;, isRequired = false, name = WORKFLOW_INSTANCE_ID_PARAM, type = RestParameter.Type.STRING) }, bodyParameter = @RestParameter(description = &quot;The compressed (application/zip) media package file&quot;, isRequired = true, name = &quot;BODY&quot;, type = RestParameter.Type.FILE), responses = {
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE) }, returnDescription = &quot;&quot;)
  public Response addZippedMediaPackage(@Context HttpServletRequest request,
          @PathParam(&quot;workflowDefinitionId&quot;) String wdID, @QueryParam(&quot;id&quot;) String wiID) {
<span class="fc" id="L1004">    logger.trace(&quot;add zipped media package with workflow definition id: {} and workflow instance id: {}&quot;, wdID, wiID);</span>
<span class="pc bpc" id="L1005" title="3 of 4 branches missed.">    if (!isIngestLimitEnabled() || getIngestLimit() &gt; 0) {</span>
<span class="fc" id="L1006">      return ingestZippedMediaPackage(request, wdID, wiID);</span>
    } else {
<span class="nc" id="L1008">      logger.warn(&quot;Delaying ingest because we have exceeded the maximum number of ingests this server is setup to do concurrently.&quot;);</span>
<span class="nc" id="L1009">      return Response.status(Status.SERVICE_UNAVAILABLE).build();</span>
    }
  }

  @POST
  @Path(&quot;addZippedMediaPackage&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;addZippedMediaPackage&quot;, description = &quot;Create media package from a compressed file containing a manifest.xml document and all media tracks, metadata catalogs and attachments&quot;, restParameters = {
          @RestParameter(description = &quot;The workflow definition ID to run on this mediapackage. &quot;
                  + &quot;This parameter has to be set in the request prior to the zipped mediapackage &quot;
                  + &quot;(This parameter is deprecated. Please use /addZippedMediaPackage/{workflowDefinitionId} instead)&quot;, isRequired = false, name = WORKFLOW_DEFINITION_ID_PARAM, type = RestParameter.Type.STRING),
          @RestParameter(description = &quot;The workflow instance ID to associate with this zipped mediapackage. &quot;
                  + &quot;This parameter has to be set in the request prior to the zipped mediapackage &quot;
                  + &quot;(This parameter is deprecated. Please use /addZippedMediaPackage/{workflowDefinitionId} with a path parameter instead)&quot;, isRequired = false, name = WORKFLOW_INSTANCE_ID_PARAM, type = RestParameter.Type.STRING) }, bodyParameter = @RestParameter(description = &quot;The compressed (application/zip) media package file&quot;, isRequired = true, name = &quot;BODY&quot;, type = RestParameter.Type.FILE), responses = {
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE) }, returnDescription = &quot;&quot;)
  public Response addZippedMediaPackage(@Context HttpServletRequest request) {
<span class="fc" id="L1028">    logger.trace(&quot;add zipped media package&quot;);</span>
<span class="fc bfc" id="L1029" title="All 4 branches covered.">    if (!isIngestLimitEnabled() || getIngestLimit() &gt; 0) {</span>
<span class="fc" id="L1030">      return ingestZippedMediaPackage(request, null, null);</span>
    } else {
<span class="fc" id="L1032">      logger.warn(&quot;Delaying ingest because we have exceeded the maximum number of ingests this server is setup to do concurrently.&quot;);</span>
<span class="fc" id="L1033">      return Response.status(Status.SERVICE_UNAVAILABLE).build();</span>
    }
  }

  private Response ingestZippedMediaPackage(HttpServletRequest request, String wdID, String wiID) {
<span class="fc bfc" id="L1038" title="All 2 branches covered.">    if (isIngestLimitEnabled()) {</span>
<span class="fc" id="L1039">      setIngestLimit(getIngestLimit() - 1);</span>
<span class="fc" id="L1040">      logger.debug(&quot;An ingest has started so remaining ingest limit is &quot; + getIngestLimit());</span>
    }
<span class="fc" id="L1042">    InputStream in = null;</span>
<span class="fc" id="L1043">    Date started = new Date();</span>

<span class="fc" id="L1045">    logger.info(&quot;Received new request from {} to ingest a zipped mediapackage&quot;, request.getRemoteHost());</span>

    try {
<span class="fc" id="L1048">      String workflowDefinitionId = wdID;</span>
<span class="fc" id="L1049">      String workflowIdAsString = wiID;</span>
<span class="fc" id="L1050">      Long workflowInstanceIdAsLong = null;</span>
<span class="fc" id="L1051">      Map&lt;String, String&gt; workflowConfig = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L1052" title="1 of 2 branches missed.">      if (ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L1053">        boolean isDone = false;</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L1055">          FileItemStream item = iter.next();</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">          if (item.isFormField()) {</span>
<span class="nc" id="L1057">            String fieldName = item.getFieldName();</span>
<span class="nc" id="L1058">            String value = Streams.asString(item.openStream(), &quot;UTF-8&quot;);</span>
<span class="nc" id="L1059">            logger.trace(&quot;{}: {}&quot;, fieldName, value);</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">            if (WORKFLOW_INSTANCE_ID_PARAM.equals(fieldName)) {</span>
<span class="nc" id="L1061">              workflowIdAsString = value;</span>
<span class="nc" id="L1062">              continue;</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">            } else if (WORKFLOW_DEFINITION_ID_PARAM.equals(fieldName)) {</span>
<span class="nc" id="L1064">              workflowDefinitionId = value;</span>
<span class="nc" id="L1065">              continue;</span>
            } else {
<span class="nc" id="L1067">              logger.debug(&quot;Processing form field: &quot; + fieldName);</span>
<span class="nc" id="L1068">              workflowConfig.put(fieldName, value);</span>
            }
<span class="nc" id="L1070">          } else {</span>
<span class="nc" id="L1071">            logger.debug(&quot;Processing file item&quot;);</span>
            // once the body gets read iter.hasNext must not be invoked or the stream can not be read
            // MH-9579
<span class="nc" id="L1074">            in = item.openStream();</span>
<span class="nc" id="L1075">            isDone = true;</span>
          }
<span class="nc bnc" id="L1077" title="All 2 branches missed.">          if (isDone)</span>
<span class="nc" id="L1078">            break;</span>
<span class="nc" id="L1079">        }</span>
<span class="nc" id="L1080">      } else {</span>
<span class="fc" id="L1081">        logger.debug(&quot;Processing file item&quot;);</span>
<span class="fc" id="L1082">        in = request.getInputStream();</span>
      }

      // Adding ingest start time to workflow configuration
<span class="fc" id="L1086">      DateFormat formatter = new SimpleDateFormat(IngestService.UTC_DATE_FORMAT);</span>
<span class="fc" id="L1087">      workflowConfig.put(IngestService.START_DATE_KEY, formatter.format(started));</span>

      /* Legacy support: Try to convert the workflowId to integer */
<span class="fc bfc" id="L1090" title="All 2 branches covered.">      if (!StringUtils.isBlank(workflowIdAsString)) {</span>
        try {
<span class="nc" id="L1092">          workflowInstanceIdAsLong = Long.parseLong(workflowIdAsString);</span>
<span class="fc" id="L1093">        } catch (NumberFormatException e) {</span>
          // The workflowId is not a long value and might be the media package identifier
<span class="fc" id="L1095">          workflowConfig.put(IngestServiceImpl.LEGACY_MEDIAPACKAGE_ID_KEY, workflowIdAsString);</span>
<span class="nc" id="L1096">        }</span>
      }
<span class="fc bfc" id="L1098" title="All 2 branches covered.">      if (StringUtils.isBlank(workflowDefinitionId)) {</span>
<span class="fc" id="L1099">        workflowDefinitionId = defaultWorkflowDefinitionId;</span>
      }

      WorkflowInstance workflow;
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">      if (workflowInstanceIdAsLong != null) {</span>
<span class="nc" id="L1104">        workflow = ingestService.addZippedMediaPackage(in, workflowDefinitionId, workflowConfig,</span>
                workflowInstanceIdAsLong);
      } else {
<span class="fc" id="L1107">        workflow = ingestService.addZippedMediaPackage(in, workflowDefinitionId, workflowConfig);</span>
      }
<span class="fc" id="L1109">      return Response.ok(XmlWorkflowParser.toXml(workflow)).build();</span>
<span class="nc" id="L1110">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1111">      logger.info(&quot;Not found: {}&quot;, e.getMessage());</span>
<span class="nc" id="L1112">      return Response.status(Status.NOT_FOUND).build();</span>
<span class="nc" id="L1113">    } catch (MediaPackageException e) {</span>
<span class="nc" id="L1114">      logger.warn(&quot;Unable to ingest mediapackage: {}&quot;, e.getMessage());</span>
<span class="nc" id="L1115">      return Response.serverError().status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L1116">    } catch (Exception e) {</span>
<span class="nc" id="L1117">      logger.warn(&quot;Unable to ingest mediapackage&quot;, e);</span>
<span class="nc" id="L1118">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    } finally {
<span class="fc" id="L1120">      IOUtils.closeQuietly(in);</span>
<span class="fc bfc" id="L1121" title="All 2 branches covered.">      if (isIngestLimitEnabled()) {</span>
<span class="fc" id="L1122">        setIngestLimit(getIngestLimit() + 1);</span>
<span class="fc" id="L1123">        logger.debug(&quot;An ingest has finished so increased ingest limit to &quot; + getIngestLimit());</span>
      }
    }
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;ingest/{wdID}&quot;)
  @RestQuery(name = &quot;ingest&quot;,
             description = &quot;&lt;p&gt;Ingest the completed media package into the system and start a specified workflow.&lt;/p&gt;&quot;
             + &quot;&lt;p&gt;In addition to the documented form parameters, workflow parameters are accepted as well.&lt;/p&gt;&quot;,
    pathParameters = {
      @RestParameter(description = &quot;Workflow definition id&quot;, isRequired = true, name = &quot;wdID&quot;, type = RestParameter.Type.STRING) },
    restParameters = {
      @RestParameter(description = &quot;The media package as XML&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) },
    responses = {
      @RestResponse(description = &quot;Returns the workflow instance&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) },
    returnDescription = &quot;&quot;)
  public Response ingest(@Context HttpServletRequest request, @PathParam(&quot;wdID&quot;) String wdID) {
<span class="nc" id="L1143">    logger.trace(&quot;ingest media package with workflow definition id: {}&quot;, wdID);</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">    if (StringUtils.isBlank(wdID)) {</span>
<span class="nc" id="L1145">      return Response.status(Response.Status.BAD_REQUEST).build();</span>
    }
<span class="nc" id="L1147">    return ingest(wdID, request);</span>
  }

  @POST
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;ingest&quot;)
  @RestQuery(name = &quot;ingest&quot;,
             description = &quot;&lt;p&gt;Ingest the completed media package into the system&lt;/p&gt;&quot;
             + &quot;&lt;p&gt;In addition to the documented form parameters, workflow parameters are accepted as well.&lt;/p&gt;&quot;,
    restParameters = {
      @RestParameter(description = &quot;The media package&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT),
      @RestParameter(description = &quot;Workflow definition id&quot;, isRequired = false, name = WORKFLOW_DEFINITION_ID_PARAM, type = RestParameter.Type.STRING),
      @RestParameter(description = &quot;The workflow instance ID to associate this ingest with scheduled events.&quot;, isRequired = false, name = WORKFLOW_INSTANCE_ID_PARAM, type = RestParameter.Type.STRING) },
    responses = {
      @RestResponse(description = &quot;Returns the workflow instance&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) },
    returnDescription = &quot;&quot;)
  public Response ingest(@Context HttpServletRequest request) {
<span class="fc" id="L1165">    return ingest(null, request);</span>
  }

  private Map&lt;String, String&gt; getWorkflowConfig(MultivaluedMap&lt;String, String&gt; formData) {
<span class="fc" id="L1169">    Map&lt;String, String&gt; wfConfig = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1170" title="All 2 branches covered.">    for (String key : formData.keySet()) {</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">      if (!&quot;mediaPackage&quot;.equals(key)) {</span>
<span class="fc" id="L1172">        wfConfig.put(key, formData.getFirst(key));</span>
      }
<span class="fc" id="L1174">    }</span>
<span class="fc" id="L1175">    return wfConfig;</span>
  }

  private Response ingest(final String wdID, final HttpServletRequest request) {
    /* Note: We use a MultivaluedMap here to ensure that we can get any arbitrary form parameters. This is required to
     * enable things like holding for trim or distributing to YouTube. */
<span class="fc" id="L1181">    final MultivaluedMap&lt;String, String&gt; formData = new MultivaluedHashMap&lt;&gt;();</span>
<span class="pc bpc" id="L1182" title="1 of 2 branches missed.">    if (ServletFileUpload.isMultipartContent(request)) {</span>
      // parse form fields
      try {
<span class="nc bnc" id="L1185" title="All 2 branches missed.">        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L1186">          FileItemStream item = iter.next();</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">          if (item.isFormField()) {</span>
<span class="nc" id="L1188">            final String value = Streams.asString(item.openStream(), &quot;UTF-8&quot;);</span>
<span class="nc" id="L1189">            formData.putSingle(item.getFieldName(), value);</span>
          }
<span class="nc" id="L1191">        }</span>
<span class="nc" id="L1192">      } catch (FileUploadException | IOException e) {</span>
<span class="nc" id="L1193">        return Response.status(Response.Status.BAD_REQUEST).build();</span>
<span class="nc" id="L1194">      }</span>
    } else {
<span class="fc" id="L1196">      request.getParameterMap().forEach((key, value) -&gt; formData.put(key, Arrays.asList(value)));</span>
    }

<span class="fc" id="L1199">    final Map&lt;String, String&gt; wfConfig = getWorkflowConfig(formData);</span>
<span class="pc bpc" id="L1200" title="1 of 2 branches missed.">    if (StringUtils.isNotBlank(wdID))</span>
<span class="nc" id="L1201">      wfConfig.put(WORKFLOW_DEFINITION_ID_PARAM, wdID);</span>

    final MediaPackage mp;
    try {
<span class="fc" id="L1205">      mp = MP_FACTORY.newMediaPackageBuilder().loadFromXml(formData.getFirst(&quot;mediaPackage&quot;));</span>
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">      if (MediaPackageSupport.sanityCheck(mp).isSome()) {</span>
<span class="nc" id="L1207">        logger.warn(&quot;Rejected ingest with invalid mediapackage {}&quot;, mp);</span>
<span class="nc" id="L1208">        return Response.status(Status.BAD_REQUEST).build();</span>
      }
<span class="nc" id="L1210">    } catch (Exception e) {</span>
<span class="nc" id="L1211">      logger.warn(&quot;Rejected ingest without mediapackage&quot;);</span>
<span class="nc" id="L1212">      return Response.status(Status.BAD_REQUEST).build();</span>
<span class="fc" id="L1213">    }</span>

<span class="fc" id="L1215">    final String workflowInstance = wfConfig.get(WORKFLOW_INSTANCE_ID_PARAM);</span>
<span class="fc" id="L1216">    final String workflowDefinition = wfConfig.get(WORKFLOW_DEFINITION_ID_PARAM);</span>

    // Adding ingest start time to workflow configuration
<span class="fc" id="L1219">    final Date ingestDate = startCache.getIfPresent(mp.getIdentifier().toString());</span>
<span class="pc bpc" id="L1220" title="1 of 2 branches missed.">    wfConfig.put(IngestService.START_DATE_KEY, DATE_FORMAT.format(ingestDate != null ? ingestDate : new Date()));</span>

<span class="fc" id="L1222">    final X&lt;WorkflowInstance&gt; ingest = new X&lt;WorkflowInstance&gt;() {</span>
      @Override
      public WorkflowInstance xapply() throws Exception {
        /* Legacy support: Try to convert the workflowInstance to integer */
<span class="fc" id="L1226">        Long workflowInstanceId = null;</span>
<span class="pc bpc" id="L1227" title="1 of 2 branches missed.">        if (StringUtils.isNotBlank(workflowInstance)) {</span>
          try {
<span class="nc" id="L1229">            workflowInstanceId = Long.parseLong(workflowInstance);</span>
<span class="fc" id="L1230">          } catch (NumberFormatException e) {</span>
            // The workflowId is not a long value and might be the media package identifier
<span class="fc" id="L1232">            wfConfig.put(IngestServiceImpl.LEGACY_MEDIAPACKAGE_ID_KEY, workflowInstance);</span>
<span class="nc" id="L1233">          }</span>
        }

<span class="pc bpc" id="L1236" title="1 of 2 branches missed.">        if (workflowInstanceId != null) {</span>
<span class="nc" id="L1237">          return ingestService.ingest(mp, trimToNull(workflowDefinition), wfConfig, workflowInstanceId);</span>
        } else {
<span class="fc" id="L1239">          return ingestService.ingest(mp, trimToNull(workflowDefinition), wfConfig);</span>
        }
      }
    };

    try {
<span class="fc" id="L1245">      WorkflowInstance workflow = ingest.apply();</span>
<span class="fc" id="L1246">      startCache.asMap().remove(mp.getIdentifier().toString());</span>
<span class="fc" id="L1247">      return Response.ok(XmlWorkflowParser.toXml(workflow)).build();</span>
<span class="nc" id="L1248">    } catch (Exception e) {</span>
<span class="nc" id="L1249">      Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">      if (cause instanceof NotFoundException) {</span>
<span class="nc" id="L1251">        return badRequest(&quot;Could not retrieve all media package elements&quot;, e);</span>
      }
<span class="nc" id="L1253">      logger.warn(&quot;Unable to ingest mediapackage&quot;, e);</span>
<span class="nc" id="L1254">      return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @POST
  @Path(&quot;schedule&quot;)
  @RestQuery(name = &quot;schedule&quot;, description = &quot;Schedule an event based on the given media package&quot;,
          restParameters = {
                  @RestParameter(description = &quot;The media package&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) },
          responses = {
                  @RestResponse(description = &quot;Event scheduled&quot;, responseCode = HttpServletResponse.SC_CREATED),
                  @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) },
          returnDescription = &quot;&quot;)
  public Response schedule(MultivaluedMap&lt;String, String&gt; formData) {
<span class="nc" id="L1268">    logger.trace(&quot;pass schedule with default workflow definition id {}&quot;, defaultWorkflowDefinitionId);</span>
<span class="nc" id="L1269">    return this.schedule(defaultWorkflowDefinitionId, formData);</span>
  }

  @POST
  @Path(&quot;schedule/{wdID}&quot;)
  @RestQuery(name = &quot;schedule&quot;, description = &quot;Schedule an event based on the given media package&quot;,
          pathParameters = {
          @RestParameter(description = &quot;Workflow definition id&quot;, isRequired = true, name = &quot;wdID&quot;, type = RestParameter.Type.STRING) },
          restParameters = {
          @RestParameter(description = &quot;The media package&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT) },
          responses = {
          @RestResponse(description = &quot;Event scheduled&quot;, responseCode = HttpServletResponse.SC_CREATED),
          @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) },
          returnDescription = &quot;&quot;)
  public Response schedule(@PathParam(&quot;wdID&quot;) String wdID, MultivaluedMap&lt;String, String&gt; formData) {
<span class="nc bnc" id="L1284" title="All 2 branches missed.">    if (StringUtils.isBlank(wdID)) {</span>
<span class="nc" id="L1285">      logger.trace(&quot;workflow definition id is not specified&quot;);</span>
<span class="nc" id="L1286">      return Response.status(Response.Status.BAD_REQUEST).build();</span>
    }

<span class="nc" id="L1289">    Map&lt;String, String&gt; wfConfig = getWorkflowConfig(formData);</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">    if (StringUtils.isNotBlank(wdID)) {</span>
<span class="nc" id="L1291">      wfConfig.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, wdID);</span>
    }
<span class="nc" id="L1293">    logger.debug(&quot;Schedule with workflow definition '{}'&quot;, wfConfig.get(WORKFLOW_DEFINITION_ID_PARAM));</span>

<span class="nc" id="L1295">    String mediaPackageXml = formData.getFirst(&quot;mediaPackage&quot;);</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">    if (StringUtils.isBlank(mediaPackageXml)) {</span>
<span class="nc" id="L1297">      logger.debug(&quot;Rejected schedule without media package&quot;);</span>
<span class="nc" id="L1298">      return Response.status(Status.BAD_REQUEST).build();</span>
    }

<span class="nc" id="L1301">    MediaPackage mp = null;</span>
    try {
<span class="nc" id="L1303">      mp = MP_FACTORY.newMediaPackageBuilder().loadFromXml(mediaPackageXml);</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">      if (MediaPackageSupport.sanityCheck(mp).isSome()) {</span>
<span class="nc" id="L1305">        throw new MediaPackageException(&quot;Insane media package&quot;);</span>
      }
<span class="nc" id="L1307">    } catch (MediaPackageException e) {</span>
<span class="nc" id="L1308">      logger.debug(&quot;Rejected ingest with invalid media package {}&quot;, mp);</span>
<span class="nc" id="L1309">      return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L1310">    }</span>

<span class="nc" id="L1312">    MediaPackageElement[] mediaPackageElements = mp.getElementsByFlavor(MediaPackageElements.EPISODE);</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">    if (mediaPackageElements.length != 1) {</span>
<span class="nc" id="L1314">      logger.debug(&quot;There can be only one (and exactly one) episode dublin core catalog: https://youtu.be/_J3VeogFUOs&quot;);</span>
<span class="nc" id="L1315">      return Response.status(Status.BAD_REQUEST).build();</span>
    }

    try {
<span class="nc" id="L1319">      ingestService.schedule(mp, wdID, wfConfig);</span>
<span class="nc" id="L1320">      return Response.status(Status.CREATED).build();</span>
<span class="nc" id="L1321">    } catch (IngestException e) {</span>
<span class="nc" id="L1322">      return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();</span>
<span class="nc" id="L1323">    } catch (SchedulerConflictException e) {</span>
<span class="nc" id="L1324">      return Response.status(Status.CONFLICT).entity(e.getMessage()).build();</span>
<span class="nc" id="L1325">    } catch (NotFoundException | UnauthorizedException | SchedulerException e) {</span>
<span class="nc" id="L1326">      return Response.serverError().build();</span>
    }
  }

  /**
   * Adds a dublinCore metadata catalog to the MediaPackage and returns the grown mediaPackage. JQuery Ajax functions
   * doesn't support multipart/form-data encoding.
   *
   * @param mp
   *          MediaPackage
   * @param dc
   *          DublinCoreCatalog
   * @return grown MediaPackage XML
   */
  @POST
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;addDCCatalog&quot;)
  @RestQuery(name = &quot;addDCCatalog&quot;, description = &quot;Add a dublincore episode catalog to a given media package using an url&quot;, restParameters = {
          @RestParameter(description = &quot;The media package as XML&quot;, isRequired = true, name = &quot;mediaPackage&quot;, type = RestParameter.Type.TEXT),
          @RestParameter(description = &quot;DublinCore catalog as XML&quot;, isRequired = true, name = &quot;dublinCore&quot;, type = RestParameter.Type.TEXT),
          @RestParameter(defaultValue = &quot;dublincore/episode&quot;, description = &quot;DublinCore Flavor&quot;, isRequired = false, name = &quot;flavor&quot;, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Returns augmented media package&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;Media package not valid&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;&quot;, responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR) }, returnDescription = &quot;&quot;)
  public Response addDCCatalog(@FormParam(&quot;mediaPackage&quot;) String mp, @FormParam(&quot;dublinCore&quot;) String dc,
          @FormParam(&quot;flavor&quot;) String flavor) {
<span class="nc" id="L1352">    logger.trace(&quot;add DC catalog: {} with flavor: {} to media package: {}&quot;, dc, flavor, mp);</span>
<span class="nc" id="L1353">    MediaPackageElementFlavor dcFlavor = MediaPackageElements.EPISODE;</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">    if (flavor != null) {</span>
      try {
<span class="nc" id="L1356">        dcFlavor = MediaPackageElementFlavor.parseFlavor(flavor);</span>
<span class="nc" id="L1357">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1358">        return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();</span>
<span class="nc" id="L1359">      }</span>
    }
    MediaPackage mediaPackage;
    /* Check if we got a proper mediapackage and try to parse it */
    try {
<span class="nc" id="L1364">      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder().loadFromXml(mp);</span>
<span class="nc" id="L1365">    } catch (MediaPackageException e) {</span>
<span class="nc" id="L1366">      return Response.serverError().status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L1367">    }</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">    if (MediaPackageSupport.sanityCheck(mediaPackage).isSome()) {</span>
<span class="nc" id="L1369">      return Response.status(Status.BAD_REQUEST).build();</span>
    }

    /* Check if we got a proper catalog */
    try {
<span class="nc" id="L1374">      DublinCoreXmlFormat.read(dc);</span>
<span class="nc" id="L1375">    } catch (Exception e) {</span>
<span class="nc" id="L1376">      return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();</span>
<span class="nc" id="L1377">    }</span>

<span class="nc" id="L1379">    try (InputStream in = IOUtils.toInputStream(dc, &quot;UTF-8&quot;)) {</span>
<span class="nc" id="L1380">      mediaPackage = ingestService.addCatalog(in, &quot;dublincore.xml&quot;, dcFlavor, mediaPackage);</span>
<span class="nc" id="L1381">    } catch (MediaPackageException e) {</span>
<span class="nc" id="L1382">      return Response.serverError().status(Status.BAD_REQUEST).entity(e.getMessage()).build();</span>
<span class="nc" id="L1383">    } catch (IOException e) {</span>
<span class="nc" id="L1384">      logger.error(&quot;Could not write catalog to disk&quot;, e);</span>
<span class="nc" id="L1385">      return Response.serverError().build();</span>
<span class="nc" id="L1386">    } catch (Exception e) {</span>
<span class="nc" id="L1387">      logger.error(&quot;Unable to add catalog&quot;, e);</span>
<span class="nc" id="L1388">      return Response.serverError().build();</span>
<span class="nc" id="L1389">    }</span>
<span class="nc" id="L1390">    return Response.ok(mediaPackage).build();</span>
  }

  /**
   * Return a bad request response but log additional details in debug mode.
   *
   * @param message
   *          Message to send
   * @param e
   *          Exception to log. If &lt;pre&gt;null&lt;/pre&gt;, a new exception is created to log a stack trace.
   * @return 400 BAD REQUEST HTTP response
   */
  private Response badRequest(final String message, final Exception e) {
<span class="nc bnc" id="L1403" title="All 4 branches missed.">    logger.debug(message, e == null &amp;&amp; logger.isDebugEnabled() ? new IngestException(message) : e);</span>
<span class="nc" id="L1404">    return Response.status(Status.BAD_REQUEST)</span>
<span class="nc" id="L1405">        .entity(message)</span>
<span class="nc" id="L1406">        .build();</span>
  }

  @Override
  public JobProducer getService() {
<span class="nc" id="L1411">    return ingestService;</span>
  }

  @Override
  public ServiceRegistry getServiceRegistry() {
<span class="nc" id="L1416">    return serviceRegistry;</span>
  }

  /**
   * OSGi Declarative Services callback to set the reference to the ingest service.
   *
   * @param ingestService
   *          the ingest service
   */
  @Reference
  void setIngestService(IngestService ingestService) {
<span class="fc" id="L1427">    this.ingestService = ingestService;</span>
<span class="fc" id="L1428">  }</span>

  /**
   * OSGi Declarative Services callback to set the reference to the service registry.
   *
   * @param serviceRegistry
   *          the service registry
   */
  @Reference
  void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="nc" id="L1438">    this.serviceRegistry = serviceRegistry;</span>
<span class="nc" id="L1439">  }</span>

  /**
   * OSGi Declarative Services callback to set the reference to the dublin core service.
   *
   * @param dcService
   *          the dublin core service
   */
  @Reference
  void setDublinCoreService(DublinCoreCatalogService dcService) {
<span class="nc" id="L1449">    this.dublinCoreService = dcService;</span>
<span class="nc" id="L1450">  }</span>

  /**
   * Sets the trusted http client
   *
   * @param httpClient
   *          the http client
   */
  @Reference
  public void setHttpClient(TrustedHttpClient httpClient) {
<span class="nc" id="L1460">    this.httpClient = httpClient;</span>
<span class="nc" id="L1461">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>