<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IBMWatsonTranscriptionService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-transcription-service-ibm-watson-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.transcription.ibmwatson</a> &gt; <span class="el_source">IBMWatsonTranscriptionService.java</span></div><h1>IBMWatsonTranscriptionService.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.transcription.ibmwatson;

import static org.opencastproject.systems.OpencastConstants.ADMIN_EMAIL_PROPERTY;

import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.fn.Enrichments;
import org.opencastproject.assetmanager.api.query.AQueryBuilder;
import org.opencastproject.assetmanager.api.query.AResult;
import org.opencastproject.assetmanager.util.Workflows;
import org.opencastproject.job.api.AbstractJobProducer;
import org.opencastproject.job.api.Job;
import org.opencastproject.kernel.mail.SmtpService;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementBuilder;
import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.security.api.DefaultOrganization;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.transcription.api.TranscriptionService;
import org.opencastproject.transcription.api.TranscriptionServiceException;
import org.opencastproject.transcription.persistence.TranscriptionDatabase;
import org.opencastproject.transcription.persistence.TranscriptionDatabaseException;
import org.opencastproject.transcription.persistence.TranscriptionJobControl;
import org.opencastproject.transcription.persistence.TranscriptionProviderControl;
import org.opencastproject.util.LoadUtil;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.OsgiUtil;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.data.Option;
import org.opencastproject.workflow.api.ConfiguredWorkflow;
import org.opencastproject.workflow.api.WorkflowDatabaseException;
import org.opencastproject.workflow.api.WorkflowDefinition;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowService;
import org.opencastproject.workingfilerepository.api.WorkingFileRepository;
import org.opencastproject.workspace.api.Workspace;

import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHeaders;
import org.apache.http.HttpHost;
import org.apache.http.HttpStatus;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.AuthCache;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.protocol.HttpClientContext;
import org.apache.http.entity.FileEntity;
import org.apache.http.impl.auth.BasicScheme;
import org.apache.http.impl.client.BasicAuthCache;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Component(
    immediate = true,
    service = { TranscriptionService.class,IBMWatsonTranscriptionService.class },
    property = {
        &quot;service.description=IBM Watson Transcription Service&quot;,
        &quot;provider=ibm.watson&quot;
    }
)
public class IBMWatsonTranscriptionService extends AbstractJobProducer implements TranscriptionService {

  /** The logger */
<span class="fc" id="L126">  private static final Logger logger = LoggerFactory.getLogger(IBMWatsonTranscriptionService.class);</span>

  private static final String PROVIDER = &quot;IBM Watson&quot;;

  private static final String JOB_TYPE = &quot;org.opencastproject.transcription.ibmwatson&quot;;

  static final String TRANSCRIPT_COLLECTION = &quot;transcripts&quot;;
  static final String APIKEY = &quot;apikey&quot;;
  private static final int CONNECTION_TIMEOUT = 60000; // ms, 1 minute
  private static final int SOCKET_TIMEOUT = 60000; // ms, 1 minute
  // Default wf to attach transcription results to mp
  public static final String DEFAULT_WF_DEF = &quot;attach-watson-transcripts&quot;;
  private static final long DEFAULT_COMPLETION_BUFFER = 600; // in seconds, default is 10 minutes
  private static final long DEFAULT_DISPATCH_INTERVAL = 60; // in seconds, default is 1 minute
  private static final long DEFAULT_MAX_PROCESSING_TIME = 2 * 60 * 60; // in seconds, default is 2 hours
  private static final String DEFAULT_LANGUAGE = &quot;en&quot;;
  // Cleans up results files that are older than 7 days (which is how long the IBM watson
  // speech-to-text-service keeps the jobs by default)
  private static final int DEFAULT_CLEANUP_RESULTS_DAYS = 7;

  // Global configuration (custom.properties)
  public static final String ADMIN_URL_PROPERTY = &quot;org.opencastproject.admin.ui.url&quot;;
  private static final String DIGEST_USER_PROPERTY = &quot;org.opencastproject.security.digest.user&quot;;

  // Cluster name
  private static final String CLUSTER_NAME_PROPERTY = &quot;org.opencastproject.environment.name&quot;;
<span class="fc" id="L152">  private String clusterName = &quot;&quot;;</span>

  /** The load introduced on the system by creating a transcription job */
  public static final float DEFAULT_START_TRANSCRIPTION_JOB_LOAD = 0.1f;

  /** The key to look for in the service configuration file to override the default h=job load */
  public static final String START_TRANSCRIPTION_JOB_LOAD_KEY = &quot;job.load.start.transcription&quot;;

  /** The load introduced on the system by creating a caption job */
<span class="fc" id="L161">  private float jobLoad = DEFAULT_START_TRANSCRIPTION_JOB_LOAD;</span>

  // The events we are interested in receiving notifications
  public interface JobEvent {
    String COMPLETED_WITH_RESULTS = &quot;recognitions.completed_with_results&quot;;
    String FAILED = &quot;recognitions.failed&quot;;
  }

  public interface RecognitionJobStatus {
    String COMPLETED = &quot;completed&quot;;
    String FAILED = &quot;failed&quot;;
    String PROCESSING = &quot;processing&quot;;
    String WAITING = &quot;waiting&quot;;
  }

  /** Service dependencies */
  private ServiceRegistry serviceRegistry;
  private SecurityService securityService;
  private UserDirectoryService userDirectoryService;
  private OrganizationDirectoryService organizationDirectoryService;
  private Workspace workspace;
  private TranscriptionDatabase database;
  private AssetManager assetManager;
  private WorkflowService workflowService;
  private WorkingFileRepository wfr;
  private SmtpService smtpService;

  // Only used by unit tests!
  private Workflows wfUtil;

<span class="nc" id="L191">  private enum Operation {</span>
<span class="nc" id="L192">    StartTranscription</span>
  }

  private static final String IBM_WATSON_SERVICE_URL = &quot;https://stream.watsonplatform.net/speech-to-text/api&quot;;
  private static final String API_VERSION = &quot;v1&quot;;
  private static final String REGISTER_CALLBACK = &quot;register_callback&quot;;
  private static final String RECOGNITIONS = &quot;recognitions&quot;;
  private static final String CALLBACK_PATH = &quot;/transcripts/watson/results&quot;;

  /** Service configuration options */
  public static final String ENABLED_CONFIG = &quot;enabled&quot;;
  public static final String IBM_WATSON_SERVICE_URL_CONFIG = &quot;ibm.watson.service.url&quot;;
  public static final String IBM_WATSON_USER_CONFIG = &quot;ibm.watson.user&quot;;
  public static final String IBM_WATSON_PSW_CONFIG = &quot;ibm.watson.password&quot;;
  public static final String IBM_WATSON_API_KEY_CONFIG = &quot;ibm.watson.api.key&quot;;
  public static final String IBM_WATSON_MODEL_CONFIG = &quot;ibm.watson.model&quot;;
  public static final String WORKFLOW_CONFIG = &quot;workflow&quot;;
  public static final String DISPATCH_WORKFLOW_INTERVAL_CONFIG = &quot;workflow.dispatch.interval&quot;;
  public static final String COMPLETION_CHECK_BUFFER_CONFIG = &quot;completion.check.buffer&quot;;
  public static final String MAX_PROCESSING_TIME_CONFIG = &quot;max.processing.time&quot;;
  public static final String NOTIFICATION_EMAIL_CONFIG = &quot;notification.email&quot;;
  public static final String CLEANUP_RESULTS_DAYS_CONFIG = &quot;cleanup.results.days&quot;;
  public static final String MAX_ATTEMPTS_CONFIG = &quot;max.attempts&quot;;
  public static final String RETRY_WORKLFOW_CONFIG = &quot;retry.workflow&quot;;

  /** Service configuration values */
<span class="fc" id="L218">  private boolean enabled = false; // Disabled by default</span>
<span class="fc" id="L219">  private String watsonServiceUrl = UrlSupport.concat(IBM_WATSON_SERVICE_URL, API_VERSION);</span>
  private String model;
<span class="fc" id="L221">  private String workflowDefinitionId = DEFAULT_WF_DEF;</span>
<span class="fc" id="L222">  private long workflowDispatchInterval = DEFAULT_DISPATCH_INTERVAL;</span>
<span class="fc" id="L223">  private long completionCheckBuffer = DEFAULT_COMPLETION_BUFFER;</span>
<span class="fc" id="L224">  private long maxProcessingSeconds = DEFAULT_MAX_PROCESSING_TIME;</span>
  private String toEmailAddress;
<span class="fc" id="L226">  private int cleanupResultDays = DEFAULT_CLEANUP_RESULTS_DAYS;</span>
<span class="fc" id="L227">  private String language = DEFAULT_LANGUAGE;</span>
<span class="fc" id="L228">  private int maxAttempts = 1;</span>
<span class="fc" id="L229">  private String retryWfDefId = null;</span>

  private String systemAccount;
  private String serverUrl;
  private String callbackUrl;
<span class="fc" id="L234">  private boolean callbackAlreadyRegistered = false;</span>
<span class="fc" id="L235">  private ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(2);</span>
  // For preemptive basic authentication
  private AuthCache authCache;
  private CredentialsProvider credentialsProvider;

  public IBMWatsonTranscriptionService() {
<span class="fc" id="L241">    super(JOB_TYPE);</span>
<span class="fc" id="L242">  }</span>

  @Override
  @Activate
  public void activate(ComponentContext cc) {
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">    if (cc != null) {</span>
      // Has this service been enabled?
<span class="fc" id="L249">      enabled = OsgiUtil.getOptCfgAsBoolean(cc.getProperties(), ENABLED_CONFIG).get();</span>

<span class="pc bpc" id="L251" title="1 of 2 branches missed.">      if (enabled) {</span>
        // Service url (optional)
<span class="fc" id="L253">        Option&lt;String&gt; urlOpt = OsgiUtil.getOptCfg(cc.getProperties(), IBM_WATSON_SERVICE_URL_CONFIG);</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (urlOpt.isSome()) {</span>
<span class="fc" id="L255">          watsonServiceUrl = UrlSupport.concat(urlOpt.get(), API_VERSION);</span>
        }

        // Api key is checked first. If not entered, user and password are mandatory (to
        // support older instances of the STT service)
        String user; // user name or 'apikey'
        String psw; // user password or api key
<span class="fc" id="L262">        Option&lt;String&gt; keyOpt = OsgiUtil.getOptCfg(cc.getProperties(), IBM_WATSON_API_KEY_CONFIG);</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (keyOpt.isSome()) {</span>
<span class="fc" id="L264">          user = APIKEY;</span>
<span class="fc" id="L265">          psw = keyOpt.get();</span>
<span class="fc" id="L266">          logger.info(&quot;Using transcription service at {} with api key&quot;, watsonServiceUrl);</span>
        } else {
          // User name (mandatory if api key is empty)
<span class="nc" id="L269">          user = OsgiUtil.getComponentContextProperty(cc, IBM_WATSON_USER_CONFIG);</span>
          // Password (mandatory if api key is empty)
<span class="nc" id="L271">          psw = OsgiUtil.getComponentContextProperty(cc, IBM_WATSON_PSW_CONFIG);</span>
<span class="nc" id="L272">          logger.info(&quot;Using transcription service at {} with username {}&quot;, watsonServiceUrl, user);</span>
        }
        // We will use preemptive basic auth
        try {
<span class="fc" id="L276">          URI uri = new URI(watsonServiceUrl);</span>
<span class="fc" id="L277">          HttpHost targetHost = new HttpHost(uri.getHost(), uri.getPort(), uri.getScheme());</span>
<span class="fc" id="L278">          credentialsProvider = new BasicCredentialsProvider();</span>
<span class="fc" id="L279">          credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(user, psw));</span>
<span class="fc" id="L280">          authCache = new BasicAuthCache();</span>
<span class="fc" id="L281">          authCache.put(targetHost, new BasicScheme());</span>
<span class="nc" id="L282">        } catch (URISyntaxException e) {</span>
<span class="nc" id="L283">          throw new RuntimeException(&quot;Watson STT service url is not valid: &quot; + watsonServiceUrl, e);</span>
<span class="fc" id="L284">        }</span>

        // Language model to be used (optional)
<span class="fc" id="L287">        Option&lt;String&gt; modelOpt = OsgiUtil.getOptCfg(cc.getProperties(), IBM_WATSON_MODEL_CONFIG);</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (modelOpt.isSome()) {</span>
<span class="nc" id="L289">          model = modelOpt.get();</span>
<span class="nc" id="L290">          language = StringUtils.substringBefore(model, &quot;-&quot;);</span>
<span class="nc" id="L291">          logger.info(&quot;Model is {}&quot;, model);</span>
        } else {
<span class="fc" id="L293">          logger.info(&quot;Default model will be used&quot;);</span>
        }

        // Workflow to execute when getting callback (optional, with default)
<span class="fc" id="L297">        Option&lt;String&gt; wfOpt = OsgiUtil.getOptCfg(cc.getProperties(), WORKFLOW_CONFIG);</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (wfOpt.isSome()) {</span>
<span class="nc" id="L299">          workflowDefinitionId = wfOpt.get();</span>
        }
<span class="fc" id="L301">        logger.info(&quot;Workflow definition is {}&quot;, workflowDefinitionId);</span>
        // Interval to check for completed transcription jobs and start workflows to attach transcripts
<span class="fc" id="L303">        Option&lt;String&gt; intervalOpt = OsgiUtil.getOptCfg(cc.getProperties(), DISPATCH_WORKFLOW_INTERVAL_CONFIG);</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        if (intervalOpt.isSome()) {</span>
          try {
<span class="nc" id="L306">            workflowDispatchInterval = Long.parseLong(intervalOpt.get());</span>
<span class="nc" id="L307">          } catch (NumberFormatException e) {</span>
            // Use default
<span class="nc" id="L309">          }</span>
        }
<span class="fc" id="L311">        logger.info(&quot;Workflow dispatch interval is {} seconds&quot;, workflowDispatchInterval);</span>
        // How long to wait after a transcription is supposed to finish before starting checking
<span class="fc" id="L313">        Option&lt;String&gt; bufferOpt = OsgiUtil.getOptCfg(cc.getProperties(), COMPLETION_CHECK_BUFFER_CONFIG);</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        if (bufferOpt.isSome()) {</span>
          try {
<span class="fc" id="L316">            completionCheckBuffer = Long.parseLong(bufferOpt.get());</span>
<span class="nc" id="L317">          } catch (NumberFormatException e) {</span>
            // Use default
<span class="nc" id="L319">            logger.warn(&quot;Invalid configuration for {} : {}. Default used instead: {}&quot;,</span>
<span class="nc" id="L320">                    COMPLETION_CHECK_BUFFER_CONFIG, bufferOpt.get(), completionCheckBuffer);</span>
<span class="fc" id="L321">          }</span>
        }
<span class="fc" id="L323">        logger.info(&quot;Completion check buffer is {} seconds&quot;, completionCheckBuffer);</span>
        // How long to wait after a transcription is supposed to finish before marking the job as canceled in the db
<span class="fc" id="L325">        Option&lt;String&gt; maxProcessingOpt = OsgiUtil.getOptCfg(cc.getProperties(), MAX_PROCESSING_TIME_CONFIG);</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (maxProcessingOpt.isSome()) {</span>
          try {
<span class="fc" id="L328">            maxProcessingSeconds = Long.parseLong(maxProcessingOpt.get());</span>
<span class="nc" id="L329">          } catch (NumberFormatException e) {</span>
            // Use default
<span class="fc" id="L331">          }</span>
        }
<span class="fc" id="L333">        logger.info(&quot;Maximum time a job is checked after it should have ended is {} seconds&quot;, maxProcessingSeconds);</span>
        // How long to keep result files in the working file repository
<span class="fc" id="L335">        Option&lt;String&gt; cleaupOpt = OsgiUtil.getOptCfg(cc.getProperties(), CLEANUP_RESULTS_DAYS_CONFIG);</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        if (cleaupOpt.isSome()) {</span>
          try {
<span class="nc" id="L338">            cleanupResultDays = Integer.parseInt(cleaupOpt.get());</span>
<span class="nc" id="L339">          } catch (NumberFormatException e) {</span>
            // Use default
<span class="nc" id="L341">          }</span>
        }
<span class="fc" id="L343">        logger.info(&quot;Cleanup result files after {} days&quot;, cleanupResultDays);</span>

        // Maximum number of retries if error (optional)
<span class="fc" id="L346">        Option&lt;String&gt; maxAttemptsOpt = OsgiUtil.getOptCfg(cc.getProperties(), MAX_ATTEMPTS_CONFIG);</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (maxAttemptsOpt.isSome()) {</span>
          try {
<span class="fc" id="L349">            maxAttempts = Integer.parseInt(maxAttemptsOpt.get());</span>
<span class="fc" id="L350">            retryWfDefId = OsgiUtil.getComponentContextProperty(cc, RETRY_WORKLFOW_CONFIG);</span>
<span class="nc" id="L351">          } catch (NumberFormatException e) {</span>
            // Use default
<span class="nc" id="L353">            logger.warn(&quot;Invalid configuration for {} : {}. Default used instead: no retries&quot;, MAX_ATTEMPTS_CONFIG,</span>
<span class="nc" id="L354">                    maxAttemptsOpt.get());</span>
<span class="pc" id="L355">          }</span>
        } else {
<span class="fc" id="L357">          logger.info(&quot;No retries in case of errors&quot;);</span>
        }

<span class="fc" id="L360">        serverUrl = OsgiUtil.getContextProperty(cc, OpencastConstants.SERVER_URL_PROPERTY);</span>
<span class="fc" id="L361">        systemAccount = OsgiUtil.getContextProperty(cc, DIGEST_USER_PROPERTY);</span>

<span class="fc" id="L363">        jobLoad = LoadUtil.getConfiguredLoadValue(cc.getProperties(), START_TRANSCRIPTION_JOB_LOAD_KEY,</span>
<span class="fc" id="L364">                DEFAULT_START_TRANSCRIPTION_JOB_LOAD, serviceRegistry);</span>

        // Schedule the workflow dispatching, starting in 2 minutes
<span class="fc" id="L367">        scheduledExecutor.scheduleWithFixedDelay(new WorkflowDispatcher(), 120, workflowDispatchInterval,</span>
                TimeUnit.SECONDS);

        // Schedule the cleanup of old results jobs from the collection in the wfr once a day
<span class="fc" id="L371">        scheduledExecutor.scheduleWithFixedDelay(new ResultsFileCleanup(), 1, 1, TimeUnit.DAYS);</span>

        // Notification email passed in this service configuration?
<span class="fc" id="L374">        Option&lt;String&gt; optTo = OsgiUtil.getOptCfg(cc.getProperties(), NOTIFICATION_EMAIL_CONFIG);</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        if (optTo.isSome()) {</span>
<span class="fc" id="L376">          toEmailAddress = optTo.get();</span>
        } else {
          // Use admin email informed in custom.properties
<span class="nc" id="L379">          optTo = OsgiUtil.getOptContextProperty(cc, ADMIN_EMAIL_PROPERTY);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">          if (optTo.isSome()) {</span>
<span class="nc" id="L381">            toEmailAddress = optTo.get();</span>
          }
        }
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (toEmailAddress != null) {</span>
<span class="fc" id="L385">          logger.info(&quot;Notification email set to {}&quot;, toEmailAddress);</span>
        } else {
<span class="nc" id="L387">          logger.warn(&quot;Email notification disabled&quot;);</span>
        }

<span class="fc" id="L390">        Option&lt;String&gt; optCluster = OsgiUtil.getOptContextProperty(cc, CLUSTER_NAME_PROPERTY);</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (optCluster.isSome()) {</span>
<span class="nc" id="L392">          clusterName = optCluster.get();</span>
        }
<span class="fc" id="L394">        logger.info(&quot;Environment name is {}&quot;, clusterName);</span>

<span class="fc" id="L396">        logger.info(&quot;Activated!&quot;);</span>
        // Cannot call registerCallback here because of the REST service dependency on this service
<span class="fc" id="L398">      } else {</span>
<span class="nc" id="L399">        logger.info(&quot;Service disabled. If you want to enable it, please update the service configuration.&quot;);</span>
      }
    } else {
<span class="nc" id="L402">      throw new IllegalArgumentException(&quot;Missing component context&quot;);</span>
    }
<span class="fc" id="L404">  }</span>

  @Override
  public Job startTranscription(String mpId, Track track) throws TranscriptionServiceException {
<span class="nc bnc" id="L408" title="All 2 branches missed.">    if (!enabled) {</span>
<span class="nc" id="L409">      throw new TranscriptionServiceException(</span>
              &quot;This service is disabled. If you want to enable it, please update the service configuration.&quot;);
    }

    try {
<span class="nc" id="L414">      return serviceRegistry.createJob(JOB_TYPE, Operation.StartTranscription.name(),</span>
<span class="nc" id="L415">              Arrays.asList(mpId, MediaPackageElementParser.getAsXml(track)), jobLoad);</span>
<span class="nc" id="L416">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L417">      throw new TranscriptionServiceException(&quot;Unable to create a job&quot;, e);</span>
<span class="nc" id="L418">    } catch (MediaPackageException e) {</span>
<span class="nc" id="L419">      throw new TranscriptionServiceException(&quot;Invalid track &quot; + track.toString(), e);</span>
    }
  }

  @Override
  public Job startTranscription(String mpId, Track track, String... args) {
<span class="nc" id="L425">    throw new UnsupportedOperationException(&quot;Not supported.&quot;);</span>
  }

  @Override
  public void transcriptionDone(String mpId, Object obj) throws TranscriptionServiceException {
<span class="fc" id="L430">    JSONObject jsonObj = null;</span>
<span class="fc" id="L431">    String jobId = null;</span>
    try {
<span class="fc" id="L433">      jsonObj = (JSONObject) obj;</span>
<span class="fc" id="L434">      jobId = (String) jsonObj.get(&quot;id&quot;);</span>

      // Check for errors inside the results object. Sometimes we get a status completed, but
      // the transcription failed e.g.
      // curl --header &quot;Content-Type: application/json&quot; --request POST --data
      // '{&quot;id&quot;:&quot;ebeeb546-2e1a-11e9-941d-f349af2d6273&quot;,
      // &quot;results&quot;:[{&quot;error&quot;:&quot;failed when posting audio to the STT service&quot;}],
      // &quot;event&quot;:&quot;recognitions.completed_with_results&quot;,
      // &quot;user_token&quot;:&quot;66c6c9b0-b6a2-4c9a-92c8-55f953ab3d38&quot;,
      // &quot;created&quot;:&quot;2019-02-11T05:04:29.283Z&quot;}' http://ADMIN/transcripts/watson/results
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">      if (jsonObj.get(&quot;results&quot;) instanceof JSONArray) {</span>
<span class="fc" id="L445">        JSONArray resultsArray = (JSONArray) jsonObj.get(&quot;results&quot;);</span>
<span class="pc bpc" id="L446" title="2 of 4 branches missed.">        if (resultsArray != null &amp;&amp; resultsArray.size() &gt; 0) {</span>
<span class="fc" id="L447">          String error = (String) ((JSONObject) resultsArray.get(0)).get(&quot;error&quot;);</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">          if (!StringUtils.isEmpty(error)) {</span>
<span class="fc" id="L449">            retryOrError(jobId, mpId,</span>
<span class="fc" id="L450">                String.format(&quot;Transcription completed with error for mpId %s, jobId %s: %s&quot;, mpId, jobId, error));</span>
<span class="fc" id="L451">            return;</span>
          }
        }
      }

<span class="fc" id="L456">      logger.info(&quot;Transcription done for mpId {}, jobId {}&quot;, mpId, jobId);</span>

      // Update state in database
      // If there's an optimistic lock exception here, it's ok because the workflow dispatcher
      // may be doing the same thing
<span class="fc" id="L461">      database.updateJobControl(jobId, TranscriptionJobControl.Status.TranscriptionComplete.name());</span>

      // Save results in file system if there
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">      if (jsonObj.get(&quot;results&quot;) != null) {</span>
<span class="fc" id="L465">        saveResults(jobId, jsonObj);</span>
      }
<span class="nc" id="L467">    } catch (IOException e) {</span>
<span class="nc" id="L468">      logger.warn(&quot;Could not save transcription results file for mpId {}, jobId {}: {}&quot;,</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">              mpId, jobId, jsonObj == null ? &quot;null&quot; : jsonObj.toJSONString());</span>
<span class="nc" id="L470">      throw new TranscriptionServiceException(&quot;Could not save transcription results file&quot;, e);</span>
<span class="nc" id="L471">    } catch (TranscriptionDatabaseException e) {</span>
<span class="nc" id="L472">      logger.warn(&quot;Error when updating state in database for mpId {}, jobId {}&quot;, mpId, jobId);</span>
<span class="nc" id="L473">      throw new TranscriptionServiceException(&quot;Could not update transcription job control db&quot;, e);</span>
<span class="fc" id="L474">    }</span>
<span class="fc" id="L475">  }</span>

  @Override
  public void transcriptionError(String mpId, Object obj) throws TranscriptionServiceException {
<span class="fc" id="L479">    JSONObject jsonObj = (JSONObject) obj;</span>
<span class="fc" id="L480">    String jobId = (String) jsonObj.get(&quot;id&quot;);</span>
    try {
<span class="fc" id="L482">      retryOrError(jobId, mpId, String.format(&quot;Transcription error for media package %s, job id %s&quot;, mpId, jobId));</span>
<span class="nc" id="L483">    } catch (TranscriptionDatabaseException e) {</span>
<span class="nc" id="L484">      throw new TranscriptionServiceException(&quot;Error when updating job state.&quot;, e);</span>
<span class="fc" id="L485">    }</span>
<span class="fc" id="L486">  }</span>

  @Override
  public String getLanguage() {
<span class="nc" id="L490">    return language;</span>
  }

  @Override
  public Map&lt;String, Object&gt; getReturnValues(String mpId, String jobId) throws TranscriptionServiceException {
<span class="nc" id="L495">    throw new TranscriptionServiceException(&quot;Method not implemented&quot;);</span>
  }

  @Override
  protected String process(Job job) throws Exception {
<span class="nc" id="L500">    Operation op = null;</span>
<span class="nc" id="L501">    String operation = job.getOperation();</span>
<span class="nc" id="L502">    List&lt;String&gt; arguments = job.getArguments();</span>
<span class="nc" id="L503">    String result = &quot;&quot;;</span>

<span class="nc" id="L505">    op = Operation.valueOf(operation);</span>

<span class="nc bnc" id="L507" title="All 2 branches missed.">    switch (op) {</span>
      case StartTranscription:
<span class="nc" id="L509">        String mpId = arguments.get(0);</span>
<span class="nc" id="L510">        Track track = (Track) MediaPackageElementParser.getFromXml(arguments.get(1));</span>
<span class="nc" id="L511">        createRecognitionsJob(mpId, track);</span>
<span class="nc" id="L512">        break;</span>
      default:
<span class="nc" id="L514">        throw new IllegalStateException(&quot;Don't know how to handle operation '&quot; + operation + &quot;'&quot;);</span>
    }

<span class="nc" id="L517">    return result;</span>
  }

  // Example URL is too long but needs to stay like this
  // CHECKSTYLE:OFF
  /**
   * Register the callback url with the Speech-to-text service. From:
   * https://cloud.ibm.com/apidocs/speech-to-text#register-a-callback
   *
   * curl -X POST -u &quot;apikey:{apikey}&quot;
   * &quot;https://stream.watsonplatform.net/speech-to-text/api/v1/register_callback?callback_url=http://{user_callback_path}/job_results&amp;user_secret=ThisIsMySecret&quot;
   * Response looks like: { &quot;status&quot;: &quot;created&quot;, &quot;url&quot;: &quot;http://{user_callback_path}/results&quot; }
   */
  // CHECKSTYLE:ON
  void registerCallback() throws TranscriptionServiceException {
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">    if (callbackAlreadyRegistered) {</span>
<span class="nc" id="L533">      return;</span>
    }

<span class="fc" id="L536">    Organization org = securityService.getOrganization();</span>
<span class="fc" id="L537">    String adminUrl = StringUtils.trimToNull(org.getProperties().get(ADMIN_URL_PROPERTY));</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">    if (adminUrl != null) {</span>
<span class="fc" id="L539">      callbackUrl = adminUrl + CALLBACK_PATH;</span>
    } else {
<span class="nc" id="L541">      callbackUrl = serverUrl + CALLBACK_PATH;</span>
    }
<span class="fc" id="L543">    logger.info(&quot;Callback url is {}&quot;, callbackUrl);</span>

<span class="fc" id="L545">    CloseableHttpClient httpClient = makeHttpClient();</span>
<span class="fc" id="L546">    HttpPost httpPost = new HttpPost(</span>
<span class="fc" id="L547">            UrlSupport.concat(watsonServiceUrl, REGISTER_CALLBACK) + String.format(&quot;?callback_url=%s&quot;, callbackUrl));</span>
    // Add AuthCache to the execution context for preemptive auth
<span class="fc" id="L549">    HttpClientContext context = HttpClientContext.create();</span>
<span class="fc" id="L550">    context.setCredentialsProvider(credentialsProvider);</span>
<span class="fc" id="L551">    context.setAuthCache(authCache);</span>
<span class="fc" id="L552">    CloseableHttpResponse response = null;</span>

    try {
<span class="fc" id="L555">      response = httpClient.execute(httpPost, context);</span>
<span class="fc" id="L556">      int code = response.getStatusLine().getStatusCode();</span>

<span class="pc bpc" id="L558" title="2 of 5 branches missed.">      switch (code) {</span>
        case HttpStatus.SC_OK: // 200
<span class="fc" id="L560">          logger.info(&quot;Callback url: {} had already already been registered&quot;, callbackUrl);</span>
<span class="fc" id="L561">          callbackAlreadyRegistered = true;</span>
<span class="fc" id="L562">          EntityUtils.consume(response.getEntity());</span>
<span class="fc" id="L563">          break;</span>
        case HttpStatus.SC_CREATED: // 201
<span class="fc" id="L565">          logger.info(&quot;Callback url: {} has been successfully registered&quot;, callbackUrl);</span>
<span class="fc" id="L566">          callbackAlreadyRegistered = true;</span>
<span class="fc" id="L567">          EntityUtils.consume(response.getEntity());</span>
<span class="fc" id="L568">          break;</span>
        case HttpStatus.SC_BAD_REQUEST: // 400
<span class="fc" id="L570">          logger.warn(&quot;Callback url {} could not be verified, status: {}&quot;, callbackUrl, code);</span>
<span class="fc" id="L571">          break;</span>
        case HttpStatus.SC_SERVICE_UNAVAILABLE: // 503
<span class="nc" id="L573">          logger.warn(&quot;Service unavailable when registering callback url {} status: {}&quot;, callbackUrl, code);</span>
<span class="nc" id="L574">          break;</span>
        default:
<span class="nc" id="L576">          logger.warn(&quot;Unknown status when registering callback url {}, status: {}&quot;, callbackUrl, code);</span>
          break;
      }
<span class="nc" id="L579">    } catch (Exception e) {</span>
<span class="nc" id="L580">      logger.warn(&quot;Exception when calling the the register callback endpoint&quot;, e);</span>
    } finally {
      try {
<span class="fc" id="L583">        httpClient.close();</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        if (response != null) {</span>
<span class="fc" id="L585">          response.close();</span>
        }
<span class="nc" id="L587">      } catch (IOException e) {</span>
<span class="fc" id="L588">      }</span>
    }
<span class="fc" id="L590">  }</span>

  // Example URL is too long but needs to stay like this
  // CHECKSTYLE:OFF
  /**
   * From: https://cloud.ibm.com/apidocs/speech-to-text#create-a-job:
   *
   * curl -X POST -u &quot;apikey:{apikey}&quot; --header &quot;Content-Type: audio/flac&quot; --data-binary @audio-file.flac
   * &quot;https://stream.watsonplatform.net/speech-to-text/api/v1/recognitions?callback_url=http://{user_callback_path}/job_results&amp;user_token=job25&amp;timestamps=true&quot;
   *
   * Response: { &quot;id&quot;: &quot;4bd734c0-e575-21f3-de03-f932aa0468a0&quot;, &quot;status&quot;: &quot;waiting&quot;, &quot;url&quot;:
   * &quot;http://stream.watsonplatform.net/speech-to-text/api/v1/recognitions/4bd734c0-e575-21f3-de03-f932aa0468a0&quot; }
   */
  // CHECKSTYLE:ON
  void createRecognitionsJob(String mpId, Track track) throws TranscriptionServiceException {
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">    if (!callbackAlreadyRegistered) {</span>
<span class="fc" id="L606">      registerCallback();</span>
    }

    // Get audio track file
<span class="fc" id="L610">    File audioFile = null;</span>
    try {
<span class="fc" id="L612">      audioFile = workspace.get(track.getURI());</span>
<span class="nc" id="L613">    } catch (Exception e) {</span>
<span class="nc" id="L614">      throw new TranscriptionServiceException(&quot;Error reading audio track&quot;, e);</span>
<span class="fc" id="L615">    }</span>

<span class="fc" id="L617">    CloseableHttpClient httpClient = makeHttpClient();</span>
<span class="fc" id="L618">    String additionalParms = &quot;&quot;;</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">    if (callbackAlreadyRegistered) {</span>
<span class="fc" id="L620">      additionalParms = String.format(&quot;&amp;user_token=%s&amp;callback_url=%s&amp;events=%s,%s&quot;, mpId, callbackUrl,</span>
              JobEvent.COMPLETED_WITH_RESULTS, JobEvent.FAILED);
    }
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">    if (!StringUtils.isEmpty(model)) {</span>
<span class="nc" id="L624">      additionalParms += String.format(&quot;&amp;model=%s&quot;, model);</span>
    }
    // Add AuthCache to the execution context for preemptive auth
<span class="fc" id="L627">    HttpClientContext context = HttpClientContext.create();</span>
<span class="fc" id="L628">    context.setCredentialsProvider(credentialsProvider);</span>
<span class="fc" id="L629">    context.setAuthCache(authCache);</span>
<span class="fc" id="L630">    CloseableHttpResponse response = null;</span>
    try {
<span class="fc" id="L632">      HttpPost httpPost = new HttpPost(UrlSupport.concat(watsonServiceUrl, RECOGNITIONS)</span>
<span class="fc" id="L633">              + String.format(</span>
                      &quot;?inactivity_timeout=-1&amp;timestamps=true&amp;smart_formatting=true%s&quot;, additionalParms));
<span class="fc" id="L635">      logger.debug(&quot;Url to invoke ibm watson service: {}&quot;, httpPost.getURI().toString());</span>
<span class="fc" id="L636">      httpPost.setHeader(HttpHeaders.CONTENT_TYPE, track.getMimeType().toString());</span>
<span class="fc" id="L637">      FileEntity fileEntity = new FileEntity(audioFile);</span>
<span class="fc" id="L638">      fileEntity.setChunked(true);</span>
<span class="fc" id="L639">      httpPost.setEntity(fileEntity);</span>
<span class="fc" id="L640">      response = httpClient.execute(httpPost, context);</span>
<span class="fc" id="L641">      int code = response.getStatusLine().getStatusCode();</span>

<span class="pc bpc" id="L643" title="2 of 4 branches missed.">      switch (code) {</span>
        case HttpStatus.SC_CREATED: // 201
<span class="fc" id="L645">          logger.info(&quot;Recognitions job has been successfully created&quot;);</span>

<span class="fc" id="L647">          HttpEntity entity = response.getEntity();</span>
          // Response returned is a json object:
          // {
          // &quot;id&quot;: &quot;4bd734c0-e575-21f3-de03-f932aa0468a0&quot;,
          // &quot;status&quot;: &quot;waiting&quot;,
          // &quot;url&quot;:
          // &quot;http://stream.watsonplatform.net/speech-to-text/api/v1/recognitions/4bd734c0-e575-21f3-de03-f932aa0468a0&quot;
          // }
<span class="fc" id="L655">          String jsonString = EntityUtils.toString(response.getEntity());</span>
<span class="fc" id="L656">          JSONParser jsonParser = new JSONParser();</span>
<span class="fc" id="L657">          JSONObject jsonObject = (JSONObject) jsonParser.parse(jsonString);</span>
<span class="fc" id="L658">          String jobId = (String) jsonObject.get(&quot;id&quot;);</span>
<span class="fc" id="L659">          String jobStatus = (String) jsonObject.get(&quot;status&quot;);</span>
<span class="fc" id="L660">          String jobUrl = (String) jsonObject.get(&quot;url&quot;);</span>
<span class="fc" id="L661">          logger.info(&quot;Transcription for mp {} has been submitted. Job id: {}, job status: {}, job url: {}&quot;, mpId,</span>
                  jobId, jobStatus, jobUrl);

<span class="fc" id="L664">          database.storeJobControl(mpId, track.getIdentifier(), jobId, TranscriptionJobControl.Status.InProgress.name(),</span>
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">                  track.getDuration() == null ? 0 : track.getDuration().longValue(), null, PROVIDER);</span>
<span class="fc" id="L666">          EntityUtils.consume(entity);</span>
<span class="fc" id="L667">          return;</span>
        case HttpStatus.SC_BAD_REQUEST: // 400
<span class="nc" id="L669">          logger.info(&quot;Invalid argument returned, status: {}&quot;, code);</span>
<span class="nc" id="L670">          break;</span>
        case HttpStatus.SC_SERVICE_UNAVAILABLE: // 503
<span class="fc" id="L672">          logger.info(&quot;Service unavailable returned, status: {}&quot;, code);</span>
<span class="fc" id="L673">          break;</span>
        default:
<span class="nc" id="L675">          logger.info(&quot;Unknown return status: {}.&quot;, code);</span>
          break;
      }
<span class="fc" id="L678">      throw new TranscriptionServiceException(&quot;Could not create recognition job. Status returned: &quot; + code);</span>
<span class="fc" id="L679">    } catch (Exception e) {</span>
<span class="fc" id="L680">      logger.warn(&quot;Exception when calling the recognitions endpoint&quot;, e);</span>
<span class="fc" id="L681">      throw new TranscriptionServiceException(&quot;Exception when calling the recognitions endpoint&quot;, e);</span>
    } finally {
      try {
<span class="fc" id="L684">        httpClient.close();</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">        if (response != null) {</span>
<span class="fc" id="L686">          response.close();</span>
        }
<span class="nc" id="L688">      } catch (IOException e) {</span>
<span class="fc" id="L689">      }</span>
    }
  }

  /**
   * From: https://cloud.ibm.com/apidocs/speech-to-text#check-a-job:
   *
   * curl -X GET -u &quot;apikey:{apikey}&quot; &quot;https://stream.watsonplatform.net/speech-to-text/api/v1/recognitions/{id}&quot;
   *
   * Response: { &quot;results&quot;: [ { &quot;result_index&quot;: 0, &quot;results&quot;: [ { &quot;final&quot;: true, &quot;alternatives&quot;: [ { &quot;transcript&quot;:
   * &quot;several tornadoes touch down as a line of severe thunderstorms swept through Colorado on Sunday &quot;, &quot;timestamps&quot;: [
   * [ &quot;several&quot;, 1, 1.52 ], [ &quot;tornadoes&quot;, 1.52, 2.15 ], . . . [ &quot;Sunday&quot;, 5.74, 6.33 ] ], &quot;confidence&quot;: 0.885 } ] } ]
   * } ], &quot;created&quot;: &quot;2016-08-17T19:11:04.298Z&quot;, &quot;updated&quot;: &quot;2016-08-17T19:11:16.003Z&quot;, &quot;status&quot;: &quot;completed&quot; }
   */
  String getAndSaveJobResults(String jobId) throws TranscriptionServiceException {
<span class="fc" id="L704">    CloseableHttpClient httpClient = makeHttpClient();</span>
    // Add AuthCache to the execution context for preemptive auth
<span class="fc" id="L706">    HttpClientContext context = HttpClientContext.create();</span>
<span class="fc" id="L707">    context.setCredentialsProvider(credentialsProvider);</span>
<span class="fc" id="L708">    context.setAuthCache(authCache);</span>
<span class="fc" id="L709">    CloseableHttpResponse response = null;</span>
<span class="fc" id="L710">    String mpId = &quot;unknown&quot;;</span>
    try {
<span class="fc" id="L712">      HttpGet httpGet = new HttpGet(UrlSupport.concat(watsonServiceUrl, RECOGNITIONS, jobId));</span>
<span class="fc" id="L713">      response = httpClient.execute(httpGet, context);</span>
<span class="fc" id="L714">      int code = response.getStatusLine().getStatusCode();</span>

<span class="pc bpc" id="L716" title="1 of 4 branches missed.">      switch (code) {</span>
        case HttpStatus.SC_OK: // 200
<span class="fc" id="L718">          HttpEntity entity = response.getEntity();</span>

          // Response returned is a json object described above
<span class="fc" id="L721">          String jsonString = EntityUtils.toString(entity);</span>
<span class="fc" id="L722">          JSONParser jsonParser = new JSONParser();</span>
<span class="fc" id="L723">          JSONObject jsonObject = (JSONObject) jsonParser.parse(jsonString);</span>
<span class="fc" id="L724">          String jobStatus = (String) jsonObject.get(&quot;status&quot;);</span>
<span class="fc" id="L725">          mpId = (String) jsonObject.get(&quot;user_token&quot;);</span>
          // user_token doesn't come back if this is not in the context of a callback so get the mpId from the db
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">          if (mpId == null) {</span>
<span class="fc" id="L728">            TranscriptionJobControl jc = database.findByJob(jobId);</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">            if (jc != null) {</span>
<span class="fc" id="L730">              mpId = jc.getMediaPackageId();</span>
            }
          }
<span class="fc" id="L733">          logger.info(&quot;Recognitions job {} has been found, status {}&quot;, jobId, jobStatus);</span>
<span class="fc" id="L734">          EntityUtils.consume(entity);</span>

<span class="pc bpc" id="L736" title="1 of 4 branches missed.">          if (jobStatus.indexOf(RecognitionJobStatus.COMPLETED) &gt; -1 &amp;&amp; jsonObject.get(&quot;results&quot;) != null) {</span>
<span class="fc" id="L737">            transcriptionDone(mpId, jsonObject);</span>
          }
<span class="fc" id="L739">          return jobStatus;</span>
        case HttpStatus.SC_NOT_FOUND: // 404
<span class="fc" id="L741">          logger.info(&quot;Job not found: {}&quot;, jobId);</span>
<span class="fc" id="L742">          break;</span>
        case HttpStatus.SC_SERVICE_UNAVAILABLE: // 503
<span class="fc" id="L744">          logger.info(&quot;Service unavailable returned, status: {}&quot;, code);</span>
<span class="fc" id="L745">          break;</span>
        default:
<span class="nc" id="L747">          logger.info(&quot;Unknown return status: {}.&quot;, code);</span>
          break;
      }
<span class="fc" id="L750">      throw new TranscriptionServiceException(</span>
<span class="fc" id="L751">              String.format(&quot;Could not check recognition job for media package %s, job id %s. Status returned: %d&quot;,</span>
<span class="fc" id="L752">                      mpId, jobId, code),</span>
              code);
<span class="fc" id="L754">    } catch (TranscriptionServiceException e) {</span>
<span class="fc" id="L755">      throw e;</span>
<span class="nc" id="L756">    } catch (Exception e) {</span>
<span class="nc" id="L757">      logger.warn(&quot;Exception when calling the recognitions endpoint for media package {}, job id {}&quot;,</span>
              mpId, jobId, e);
<span class="nc" id="L759">      throw new TranscriptionServiceException(String.format(</span>
              &quot;Exception when calling the recognitions endpoint for media package %s, job id %s&quot;, mpId, jobId), e);
    } finally {
      try {
<span class="fc" id="L763">        httpClient.close();</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">        if (response != null) {</span>
<span class="fc" id="L765">          response.close();</span>
        }
<span class="nc" id="L767">      } catch (IOException e) {</span>
<span class="fc" id="L768">      }</span>
    }
  }

  private void saveResults(String jobId, JSONObject jsonObj) throws IOException {
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">    if (jsonObj.get(&quot;results&quot;) != null) {</span>
      // Save the results into a collection
<span class="fc" id="L775">      workspace.putInCollection(TRANSCRIPT_COLLECTION, jobId + &quot;.json&quot;,</span>
<span class="fc" id="L776">              new ByteArrayInputStream(jsonObj.toJSONString().getBytes()));</span>
    }
<span class="fc" id="L778">  }</span>

  @Override
  public MediaPackageElement getGeneratedTranscription(String mpId, String jobId, MediaPackageElement.Type type)
          throws TranscriptionServiceException {
    try {
      // If jobId is unknown, look for all jobs associated to that mpId
<span class="pc bpc" id="L785" title="1 of 4 branches missed.">      if (jobId == null || &quot;null&quot;.equals(jobId)) {</span>
<span class="fc" id="L786">        jobId = null;</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">        for (TranscriptionJobControl jc : database.findByMediaPackage(mpId)) {</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">          if (TranscriptionJobControl.Status.Closed.name().equals(jc.getStatus())</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">                  || TranscriptionJobControl.Status.TranscriptionComplete.name().equals(jc.getStatus())) {</span>
<span class="fc" id="L790">            jobId = jc.getTranscriptionJobId();</span>
          }
<span class="fc" id="L792">        }</span>
      }

<span class="pc bpc" id="L795" title="1 of 2 branches missed.">      if (jobId == null) {</span>
<span class="nc" id="L796">        throw new TranscriptionServiceException(</span>
                &quot;No completed or closed transcription job found in database for media package &quot; + mpId);
      }

      // Results already saved?
<span class="fc" id="L801">      URI uri = workspace.getCollectionURI(TRANSCRIPT_COLLECTION, jobId + &quot;.json&quot;);</span>
      try {
<span class="fc" id="L803">        workspace.get(uri);</span>
<span class="fc" id="L804">      } catch (Exception e) {</span>
        // Not saved yet so call the ibm watson service to get the results
<span class="fc" id="L806">        getAndSaveJobResults(jobId);</span>
<span class="fc" id="L807">      }</span>
<span class="fc" id="L808">      MediaPackageElementBuilder builder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();</span>
<span class="fc" id="L809">      return builder.elementFromURI(uri, type, new MediaPackageElementFlavor(&quot;captions&quot;, &quot;ibm-watson-json&quot;));</span>
<span class="nc" id="L810">    } catch (TranscriptionDatabaseException e) {</span>
<span class="nc" id="L811">      throw new TranscriptionServiceException(&quot;Job id not informed and could not find transcription&quot;, e);</span>
    }
  }

  protected CloseableHttpClient makeHttpClient() {
<span class="nc" id="L816">    RequestConfig reqConfig = RequestConfig.custom().setConnectTimeout(CONNECTION_TIMEOUT)</span>
<span class="nc" id="L817">            .setSocketTimeout(SOCKET_TIMEOUT).setConnectionRequestTimeout(CONNECTION_TIMEOUT).build();</span>
<span class="nc" id="L818">    return HttpClients.custom().setDefaultRequestConfig(reqConfig)</span>
<span class="nc" id="L819">            .setRetryHandler(new DefaultHttpRequestRetryHandler(3, true)).build();</span>
  }

  protected void retryOrError(String jobId, String mpId, String errorMsg) throws TranscriptionDatabaseException {
<span class="fc" id="L823">    logger.warn(errorMsg);</span>

    // TranscriptionJobControl.Status status
<span class="fc" id="L826">    TranscriptionJobControl jc = database.findByJob(jobId);</span>
<span class="fc" id="L827">    String trackId = jc.getTrackId();</span>
    // Current job is still in progress state
<span class="fc" id="L829">    int attempts = database</span>
<span class="fc" id="L830">            .findByMediaPackageTrackAndStatus(mpId, trackId, TranscriptionJobControl.Status.Error.name(),</span>
<span class="fc" id="L831">                    TranscriptionJobControl.Status.InProgress.name(), TranscriptionJobControl.Status.Canceled.name())</span>
<span class="fc" id="L832">            .size();</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">    if (attempts &lt; maxAttempts) {</span>
      // Update state in database to retry
<span class="fc" id="L835">      database.updateJobControl(jobId, TranscriptionJobControl.Status.Retry.name());</span>
<span class="fc" id="L836">      logger.info(&quot;Will retry transcription for media package {}, track {}&quot;, mpId, trackId);</span>
    } else {
      // Update state in database to error
<span class="fc" id="L839">      database.updateJobControl(jobId, TranscriptionJobControl.Status.Error.name());</span>
      // Send error notification email
<span class="fc" id="L841">      logger.error(&quot;{} transcription attempts exceeded maximum of {} for media package {}, track {}.&quot;, attempts,</span>
<span class="fc" id="L842">              maxAttempts, mpId, trackId);</span>
<span class="fc" id="L843">      sendEmail(&quot;Transcription ERROR&quot;, String.format(errorMsg, mpId, jobId));</span>
    }
<span class="fc" id="L845">  }</span>

  private void sendEmail(String subject, String body) {
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">    if (toEmailAddress == null) {</span>
<span class="nc" id="L849">      logger.info(&quot;Skipping sending email notification. Message is {}.&quot;, body);</span>
<span class="nc" id="L850">      return;</span>
    }
    try {
<span class="fc" id="L853">      logger.debug(&quot;Sending e-mail notification to {}&quot;, toEmailAddress);</span>
<span class="fc" id="L854">      smtpService.send(toEmailAddress, String.format(&quot;%s (%s)&quot;, subject, clusterName), body);</span>
<span class="fc" id="L855">      logger.info(&quot;Sent e-mail notification to {}&quot;, toEmailAddress);</span>
<span class="nc" id="L856">    } catch (Exception e) {</span>
<span class="nc" id="L857">      logger.error(&quot;Could not send email: {}\n{}&quot;, subject, body, e);</span>
<span class="fc" id="L858">    }</span>
<span class="fc" id="L859">  }</span>

  public boolean isCallbackAlreadyRegistered() {
<span class="fc" id="L862">    return callbackAlreadyRegistered;</span>
  }

  @Reference
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L867">    this.serviceRegistry = serviceRegistry;</span>
<span class="fc" id="L868">  }</span>

  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L872">    this.securityService = securityService;</span>
<span class="fc" id="L873">  }</span>

  @Reference
  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {
<span class="fc" id="L877">    this.userDirectoryService = userDirectoryService;</span>
<span class="fc" id="L878">  }</span>

  @Reference
  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectoryService) {
<span class="fc" id="L882">    this.organizationDirectoryService = organizationDirectoryService;</span>
<span class="fc" id="L883">  }</span>

  @Reference
  public void setSmtpService(SmtpService service) {
<span class="fc" id="L887">    this.smtpService = service;</span>
<span class="fc" id="L888">  }</span>

  @Reference
  public void setWorkspace(Workspace ws) {
<span class="fc" id="L892">    this.workspace = ws;</span>
<span class="fc" id="L893">  }</span>

  @Reference
  public void setWorkingFileRepository(WorkingFileRepository wfr) {
<span class="nc" id="L897">    this.wfr = wfr;</span>
<span class="nc" id="L898">  }</span>

  @Reference
  public void setDatabase(TranscriptionDatabase service) {
<span class="fc" id="L902">    this.database = service;</span>
<span class="fc" id="L903">  }</span>

  @Reference
  public void setAssetManager(AssetManager service) {
<span class="fc" id="L907">    this.assetManager = service;</span>
<span class="fc" id="L908">  }</span>

  @Reference
  public void setWorkflowService(WorkflowService service) {
<span class="fc" id="L912">    this.workflowService = service;</span>
<span class="fc" id="L913">  }</span>

  @Override
  protected ServiceRegistry getServiceRegistry() {
<span class="nc" id="L917">    return serviceRegistry;</span>
  }

  @Override
  protected SecurityService getSecurityService() {
<span class="nc" id="L922">    return securityService;</span>
  }

  @Override
  protected UserDirectoryService getUserDirectoryService() {
<span class="nc" id="L927">    return userDirectoryService;</span>
  }

  @Override
  protected OrganizationDirectoryService getOrganizationDirectoryService() {
<span class="nc" id="L932">    return organizationDirectoryService;</span>
  }

  // Only used by unit tests!
  void setWfUtil(Workflows wfUtil) {
<span class="fc" id="L937">    this.wfUtil = wfUtil;</span>
<span class="fc" id="L938">  }</span>

<span class="fc" id="L940">  class WorkflowDispatcher implements Runnable {</span>

    /**
     * {@inheritDoc}
     *
     * @see java.lang.Thread#run()
     */
    @Override
    public void run() {
<span class="fc" id="L949">      logger.debug(&quot;WorkflowDispatcher waking up...&quot;);</span>

      try {
        // Find jobs that are in progress and jobs that had transcription complete i.e. got the callback

        long providerId;
<span class="fc" id="L955">        TranscriptionProviderControl providerInfo = database.findIdByProvider(PROVIDER);</span>
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">        if (providerInfo != null) {</span>
<span class="fc" id="L957">          providerId = providerInfo.getId();</span>
        } else {
<span class="nc" id="L959">          logger.warn(&quot;No provider entry for {}&quot;, PROVIDER);</span>
<span class="nc" id="L960">          return;</span>
        }

<span class="fc" id="L963">        List&lt;TranscriptionJobControl&gt; jobs = database.findByStatus(TranscriptionJobControl.Status.InProgress.name(),</span>
<span class="fc" id="L964">                TranscriptionJobControl.Status.TranscriptionComplete.name());</span>

<span class="fc bfc" id="L966" title="All 2 branches covered.">        for (TranscriptionJobControl j : jobs) {</span>

          // Don't process jobs for other services
<span class="pc bpc" id="L969" title="1 of 2 branches missed.">          if (j.getProviderId() != providerId) {</span>
<span class="nc" id="L970">            continue;</span>
          }

<span class="fc" id="L973">          String mpId = j.getMediaPackageId();</span>
<span class="fc" id="L974">          String jobId = j.getTranscriptionJobId();</span>

          // If the job in progress, check if it should already have finished and we didn't get the callback for some
          // reason. This can happen if the admin server was offline when the callback came.
<span class="fc bfc" id="L978" title="All 2 branches covered.">          if (TranscriptionJobControl.Status.InProgress.name().equals(j.getStatus())) {</span>
            // If job should already have been completed, try to get the results. Consider a buffer factor so that we
            // don't try it too early.
<span class="fc" id="L981">            if (j.getDateCreated().getTime() + j.getTrackDuration() + completionCheckBuffer * 1000 &lt; System</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">                    .currentTimeMillis()) {</span>
              try {
<span class="fc" id="L984">                String jobStatus = getAndSaveJobResults(jobId);</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">                if (RecognitionJobStatus.FAILED.equals(jobStatus)) {</span>
<span class="fc" id="L986">                  retryOrError(jobId, mpId,</span>
<span class="fc" id="L987">                          String.format(&quot;Transcription job failed for mpId %s, jobId %s&quot;, mpId, jobId));</span>
<span class="fc" id="L988">                  continue;</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">                } else if (RecognitionJobStatus.PROCESSING.equals(jobStatus)</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">                        || RecognitionJobStatus.WAITING.equals(jobStatus)) {</span>
                  // Job still waiting/running so check if it should have finished more than N seconds ago
<span class="fc" id="L992">                  if (j.getDateCreated().getTime() + j.getTrackDuration()</span>
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">                          + (completionCheckBuffer + maxProcessingSeconds) * 1000 &lt; System.currentTimeMillis()) {</span>
                    // Processing for too long, mark job as error or retry and don't check anymore
<span class="fc" id="L995">                    retryOrError(jobId, mpId, String.format(</span>
                            &quot;Transcription job was in waiting or processing state for too long &quot;
                                + &quot;(media package %s, job id %s)&quot;, mpId, jobId));
                  }
                  // else job still running, not finished
<span class="fc" id="L1000">                  continue;</span>
                }
<span class="fc" id="L1002">              } catch (TranscriptionServiceException e) {</span>
<span class="pc bpc" id="L1003" title="1 of 2 branches missed.">                if (e.getCode() == 404) {</span>
                  // Job not found there, update job state to canceled
<span class="fc" id="L1005">                  database.updateJobControl(jobId, TranscriptionJobControl.Status.Canceled.name());</span>
                  // Send notification email
<span class="fc" id="L1007">                  sendEmail(&quot;Transcription ERROR&quot;,</span>
<span class="fc" id="L1008">                          String.format(&quot;Transcription job was not found (media package %s, job id %s).&quot;, mpId, jobId));</span>
                }
<span class="fc" id="L1010">                continue; // Skip this one, exception was already logged</span>
<span class="fc" id="L1011">              }</span>
            } else {
              continue; // Not time to check yet
            }
          }

          // Jobs that get here have state TranscriptionCompleted.
          try {
            // Apply workflow to attach transcripts
<span class="fc" id="L1020">            Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L1021">            params.put(&quot;transcriptionJobId&quot;, jobId);</span>
<span class="fc" id="L1022">            String wfId = startWorkflow(mpId, workflowDefinitionId, params);</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">            if (wfId == null) {</span>
<span class="nc" id="L1024">              logger.warn(&quot;Attach transcription workflow could NOT be scheduled for mp {}, watson job {}&quot;, mpId, jobId);</span>
<span class="nc" id="L1025">              continue;</span>
            }
            // Update state in the database
<span class="fc" id="L1028">            database.updateJobControl(jobId, TranscriptionJobControl.Status.Closed.name());</span>
<span class="fc" id="L1029">            logger.info(&quot;Attach transcription workflow {} scheduled for mp {}, watson job {}&quot;,</span>
                    wfId, mpId, jobId);
<span class="nc" id="L1031">          } catch (Exception e) {</span>
<span class="nc" id="L1032">            logger.warn(</span>
                &quot;Attach transcription workflow could NOT be scheduled for media package {}, watson job {}, {}: {}&quot;,
<span class="nc" id="L1034">                mpId, jobId, e.getClass().getName(), e.getMessage()</span>
            );
<span class="fc" id="L1036">          }</span>
<span class="fc" id="L1037">        }</span>

<span class="fc bfc" id="L1039" title="All 2 branches covered.">        if (maxAttempts &gt; 1) {</span>
          // Find jobs that need to be re-submitted
<span class="fc" id="L1041">          jobs = database.findByStatus(TranscriptionJobControl.Status.Retry.name());</span>
<span class="fc" id="L1042">          HashMap&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">          for (TranscriptionJobControl j : jobs) {</span>
<span class="fc" id="L1044">            String mpId = j.getMediaPackageId();</span>
<span class="fc" id="L1045">            String wfId = startWorkflow(mpId, retryWfDefId, params);</span>
<span class="fc" id="L1046">            String jobId = j.getTranscriptionJobId();</span>
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">            if (wfId == null) {</span>
<span class="nc" id="L1048">              logger.warn(</span>
                  &quot;Retry transcription workflow could NOT be scheduled for mp {}, watson job {}. &quot;
                      + &quot;Will try again next time.&quot;,
                  mpId, jobId);
              // Will try again next time
<span class="nc" id="L1053">              continue;</span>
            }
<span class="fc" id="L1055">            logger.info(&quot;Retry transcription workflow {} scheduled for mp {}.&quot;, wfId, mpId);</span>
            // Retry was submitted, update previously failed job state to error
<span class="fc" id="L1057">            database.updateJobControl(jobId, TranscriptionJobControl.Status.Error.name());</span>
<span class="fc" id="L1058">          }</span>
        }
<span class="nc" id="L1060">      } catch (TranscriptionDatabaseException e) {</span>
<span class="nc" id="L1061">        logger.warn(&quot;Could not read/update transcription job control database.&quot;, e);</span>
<span class="fc" id="L1062">      }</span>
<span class="fc" id="L1063">    }</span>
  }

  private String startWorkflow(String mpId, String wfDefId, Map&lt;String, String&gt; params) {
<span class="fc" id="L1067">    DefaultOrganization defaultOrg = new DefaultOrganization();</span>
<span class="fc" id="L1068">    securityService.setOrganization(defaultOrg);</span>
<span class="fc" id="L1069">    securityService.setUser(SecurityUtil.createSystemUser(systemAccount, defaultOrg));</span>

    // Find the episode
<span class="fc" id="L1072">    final AQueryBuilder q = assetManager.createQuery();</span>
<span class="fc" id="L1073">    final AResult r = q.select(q.snapshot()).where(q.mediaPackageId(mpId).and(q.version().isLatest())).run();</span>
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">    if (r.getSize() == 0) {</span>
      // Media package not archived yet.
<span class="nc" id="L1076">      logger.warn(&quot;Media package {} has not been archived yet.&quot;, mpId);</span>
<span class="nc" id="L1077">      return null;</span>
    }

<span class="fc" id="L1080">    String org = Enrichments.enrich(r).getSnapshots().stream().findFirst().get().getOrganizationId();</span>
<span class="fc" id="L1081">    Organization organization = null;</span>
    try {
<span class="fc" id="L1083">      organization = organizationDirectoryService.getOrganization(org);</span>
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">      if (organization == null) {</span>
<span class="nc" id="L1085">        logger.warn(&quot;Media package {} has an unknown organization {}.&quot;, mpId, org);</span>
<span class="nc" id="L1086">        return null;</span>
      }
<span class="nc" id="L1088">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1089">      logger.warn(&quot;Organization {} not found for media package {}.&quot;, org, mpId);</span>
<span class="nc" id="L1090">      return null;</span>
<span class="fc" id="L1091">    }</span>
<span class="fc" id="L1092">    securityService.setOrganization(organization);</span>

    try {
<span class="fc" id="L1095">      WorkflowDefinition wfDef = workflowService.getWorkflowDefinitionById(wfDefId);</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">      Workflows workflows = wfUtil != null ? wfUtil : new Workflows(assetManager, workflowService);</span>
<span class="fc" id="L1097">      Set&lt;String&gt; mpIds = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L1098">      mpIds.add(mpId);</span>
<span class="fc" id="L1099">      List&lt;WorkflowInstance&gt; wfList = workflows</span>
<span class="fc" id="L1100">              .applyWorkflowToLatestVersion(mpIds, ConfiguredWorkflow.workflow(wfDef, params));</span>
<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">      return wfList.size() &gt; 0 ? Long.toString(wfList.get(0).getId()) : null;</span>
<span class="nc" id="L1102">    } catch (NotFoundException | WorkflowDatabaseException e) {</span>
<span class="nc" id="L1103">      logger.warn(&quot;Could not get workflow definition: {}&quot;, wfDefId);</span>
    }

<span class="nc" id="L1106">    return null;</span>
  }

  /**
   * Allow transcription service to be disabled via config Utility to verify service is active
   *
   * @return true if service is enabled, false if service should be skipped
   */
  public boolean isEnabled() {
<span class="nc" id="L1115">    return enabled;</span>
  }

<span class="fc" id="L1118">  class ResultsFileCleanup implements Runnable {</span>
    @Override
    public void run() {
<span class="nc" id="L1121">      logger.info(&quot;ResultsFileCleanup waking up...&quot;);</span>
      try {
        // Cleans up results files older than CLEANUP_RESULT_FILES_DAYS days
<span class="nc" id="L1124">        wfr.cleanupOldFilesFromCollection(TRANSCRIPT_COLLECTION, cleanupResultDays);</span>
<span class="nc" id="L1125">      } catch (IOException e) {</span>
<span class="nc" id="L1126">        logger.warn(&quot;Could not cleanup old transcript results files&quot;, e);</span>
<span class="nc" id="L1127">      }</span>
<span class="nc" id="L1128">    }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>