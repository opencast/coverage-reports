<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PlaylistDatabaseServiceImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-playlists</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.playlists.persistence</a> &gt; <span class="el_source">PlaylistDatabaseServiceImpl.java</span></div><h1>PlaylistDatabaseServiceImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.playlists.persistence;

import static org.opencastproject.db.Queries.namedQuery;

import org.opencastproject.db.DBSession;
import org.opencastproject.db.DBSessionFactory;
import org.opencastproject.playlists.Playlist;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.requests.SortCriterion;

import org.apache.commons.lang3.tuple.Pair;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;

@Component(
    immediate = true,
    service = { PlaylistDatabaseService.class },
    property = {
        &quot;service.description=Playlist Database Service&quot;
    }
)
<span class="fc" id="L59">public class PlaylistDatabaseServiceImpl implements PlaylistDatabaseService {</span>

  /** JPA persistence unit name */
  public static final String PERSISTENCE_UNIT = &quot;org.opencastproject.playlists&quot;;
<span class="fc" id="L63">  private static final Logger logger = LoggerFactory.getLogger(PlaylistDatabaseServiceImpl.class);</span>
  /** Factory used to create {@link EntityManager}s for transactions */
  private EntityManagerFactory emf;

  private DBSessionFactory dbSessionFactory;
  private DBSession db;

  /** The security service */
  protected SecurityService securityService;

  /** OSGi DI */
  @Reference(target = &quot;(osgi.unit.name=org.opencastproject.playlists)&quot;)
  public void setEntityManagerFactory(EntityManagerFactory emf) {
<span class="fc" id="L76">    this.emf = emf;</span>
<span class="fc" id="L77">  }</span>

  @Reference
  public void setDBSessionFactory(DBSessionFactory dbSessionFactory) {
<span class="fc" id="L81">    this.dbSessionFactory = dbSessionFactory;</span>
<span class="fc" id="L82">  }</span>

  /**
   * OSGi callback to set the security service.
   *
   * @param securityService
   *          the securityService to set
   */
  @Reference(name = &quot;security-service&quot;)
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L92">    this.securityService = securityService;</span>
<span class="fc" id="L93">  }</span>

  @Activate
  public void activate(ComponentContext cc) {
<span class="fc" id="L97">    logger.info(&quot;Activating persistence manager for playlists&quot;);</span>
<span class="fc" id="L98">    db = dbSessionFactory.createSession(emf);</span>
<span class="fc" id="L99">  }</span>

  /**
   * {@inheritDoc}
   * @see PlaylistDatabaseService#getPlaylist(String)
   */
  @Override
  public Playlist getPlaylist(String playlistId) throws NotFoundException, PlaylistDatabaseException {
<span class="fc" id="L107">    return getPlaylist(playlistId, securityService.getOrganization().getId());</span>
  }

  /**
   * {@inheritDoc}
   * @see PlaylistDatabaseService#getPlaylist(String, String)
   */
  @Override
  public Playlist getPlaylist(String playlistId, String orgId) throws NotFoundException, PlaylistDatabaseException {
    try {
<span class="fc" id="L117">      return db.execTxChecked(em -&gt; {</span>
<span class="fc" id="L118">        Optional&lt;Playlist&gt; playlist = getPlaylistById(playlistId, orgId).apply(em);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (playlist.isEmpty()) {</span>
<span class="fc" id="L120">          throw new NotFoundException(&quot;No playlist with id=&quot; + playlistId + &quot; exists&quot;);</span>
        }
<span class="fc" id="L122">        return playlist.get();</span>
      });
<span class="fc" id="L124">    } catch (NotFoundException e) {</span>
<span class="fc" id="L125">      throw e;</span>
<span class="nc" id="L126">    } catch (Exception e) {</span>
<span class="nc" id="L127">      logger.error(&quot;Could not retrieve playlist with ID '{}'&quot;, playlistId, e);</span>
<span class="nc" id="L128">      throw new PlaylistDatabaseException(e);</span>
    }
  }

  /**
   * {@inheritDoc}
   * @see PlaylistDatabaseService#getPlaylists(int, int, SortCriterion)
   */
  @Override
  public List&lt;Playlist&gt; getPlaylists(int limit, int offset, SortCriterion sortCriterion)
          throws PlaylistDatabaseException {

    try {
<span class="fc" id="L141">      return db.exec(em -&gt; {</span>
<span class="fc" id="L142">        CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();</span>
<span class="fc" id="L143">        CriteriaQuery&lt;Playlist&gt; criteriaQuery = criteriaBuilder.createQuery(Playlist.class);</span>
<span class="fc" id="L144">        Root&lt;Playlist&gt; from = criteriaQuery.from(Playlist.class);</span>
<span class="fc" id="L145">        CriteriaQuery&lt;Playlist&gt; select = criteriaQuery.select(from)</span>
<span class="fc" id="L146">            .where(criteriaBuilder.isNull(from.get(&quot;deletionDate&quot;)));</span>

<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (sortCriterion.getOrder().equals(SortCriterion.Order.Ascending)) {</span>
<span class="nc" id="L149">          criteriaQuery.orderBy(criteriaBuilder.asc(from.get(sortCriterion.getFieldName())));</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        } else if (sortCriterion.getOrder().equals(SortCriterion.Order.Descending)) {</span>
<span class="nc" id="L151">          criteriaQuery.orderBy(criteriaBuilder.desc(from.get(sortCriterion.getFieldName())));</span>
        }

<span class="fc" id="L154">        TypedQuery&lt;Playlist&gt; allQuery = em.createQuery(select);</span>

<span class="fc" id="L156">        allQuery.setMaxResults(limit);</span>
<span class="fc" id="L157">        allQuery.setFirstResult(offset);</span>

<span class="fc" id="L159">        return allQuery.getResultList();</span>
      });
<span class="nc" id="L161">    } catch (Exception e) {</span>
<span class="nc" id="L162">      throw new PlaylistDatabaseException(&quot;Error fetching playlists from database&quot;, e);</span>
    }
  }

  public List&lt;Playlist&gt; getAllForAdministrativeRead(Date startDate, Date endDate, int limit)
          throws PlaylistDatabaseException {
    try {
<span class="nc" id="L169">      return db.exec(em -&gt; {</span>
<span class="nc" id="L170">        final var criteriaBuilder = em.getCriteriaBuilder();</span>
<span class="nc" id="L171">        final var criteriaQuery = criteriaBuilder.createQuery(Playlist.class);</span>
<span class="nc" id="L172">        final var from = criteriaQuery.from(Playlist.class);</span>
<span class="nc" id="L173">        final var org = securityService.getOrganization().getId();</span>
<span class="nc" id="L174">        final var select = criteriaQuery.select(from)</span>
<span class="nc" id="L175">            .where(</span>
<span class="nc" id="L176">                criteriaBuilder.greaterThanOrEqualTo(from.get(&quot;updated&quot;), startDate),</span>
<span class="nc" id="L177">                criteriaBuilder.lessThan(from.get(&quot;updated&quot;), endDate),</span>
<span class="nc" id="L178">                criteriaBuilder.equal(from.get(&quot;organization&quot;), org)</span>
            )
<span class="nc" id="L180">            .orderBy(criteriaBuilder.asc(from.get(&quot;updated&quot;)));</span>

<span class="nc" id="L182">        return em.createQuery(select)</span>
<span class="nc" id="L183">            .setMaxResults(limit)</span>
<span class="nc" id="L184">            .getResultList();</span>
      });
<span class="nc" id="L186">    } catch (Exception e) {</span>
<span class="nc" id="L187">      throw new PlaylistDatabaseException(&quot;Error fetching playlists from database&quot;, e);</span>
    }
  }

  /**
   * {@inheritDoc}
   * @see PlaylistDatabaseService#updatePlaylist(Playlist, String)
   */
  @Override
  public Playlist updatePlaylist(Playlist playlist, String orgId) throws PlaylistDatabaseException {
    try {
<span class="fc" id="L198">      return db.execTx(em -&gt; {</span>
<span class="fc" id="L199">        Optional&lt;Playlist&gt; fromDb = getPlaylistById(playlist.getId(), orgId).apply(em);</span>
<span class="fc" id="L200">        playlist.setUpdated(new Date());</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (fromDb.isEmpty()) {</span>
<span class="fc" id="L202">          em.persist(playlist);</span>
        } else {
<span class="fc" id="L204">          return em.merge(playlist);</span>
        }

<span class="fc" id="L207">        return playlist;</span>
      });
<span class="nc" id="L209">    } catch (Exception e) {</span>
<span class="nc" id="L210">      throw new PlaylistDatabaseException(&quot;Could not update playlist with ID '&quot; + playlist.getId() + &quot;'&quot;, e);</span>
    }
  }

  /**
   * {@inheritDoc}
   * @see PlaylistDatabaseService#deletePlaylist(Playlist, String)
   */
  @Override
  public Playlist deletePlaylist(Playlist playlist, String orgId) throws PlaylistDatabaseException {
    try {
<span class="fc" id="L221">      return db.execTx(em -&gt; {</span>
<span class="fc" id="L222">        Optional&lt;Playlist&gt; fromDb = getPlaylistById(playlist.getId(), orgId).apply(em);</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (fromDb.isPresent()) {</span>
<span class="fc" id="L224">          Date now = new Date();</span>
<span class="fc" id="L225">          playlist.setUpdated(now);</span>
<span class="fc" id="L226">          playlist.setDeletionDate(now);</span>
<span class="fc" id="L227">          em.merge(playlist);</span>
        }
<span class="fc" id="L229">        logger.debug(&quot;Playlist with id {} was deleted.&quot;, playlist.getId());</span>
<span class="fc" id="L230">        return playlist;</span>
      });
<span class="nc" id="L232">    } catch (Exception e) {</span>
<span class="nc" id="L233">      throw new PlaylistDatabaseException(&quot;Could not delete playlist with ID '&quot; + playlist.getId() + &quot;'&quot;, e);</span>
    }
  }

  /**
   * Gets a non-deleted playlist by its id
   *
   * @param playlistId the playlist identifier
   * @param orgId the organisation identifier
   * @return the playlist in an optional
   */
  protected Function&lt;EntityManager, Optional&lt;Playlist&gt;&gt; getPlaylistById(String playlistId, String orgId) {
<span class="fc bfc" id="L245" title="All 2 branches covered.">    return em -&gt; getPotentiallyDeletedPlaylist(playlistId, orgId).apply(em).filter(e -&gt; !e.isDeleted());</span>
  }

  /**
   * Gets a potentially deleted series by its ID, using the current organizational context.
   *
   * @param playlistId the playlist identifier
   * @param orgId the organisation identifier
   * @return the playlist in an optional
   */
  protected Function&lt;EntityManager, Optional&lt;Playlist&gt;&gt; getPotentiallyDeletedPlaylist(String playlistId, String orgId) {
<span class="fc" id="L256">    return namedQuery.findOpt(</span>
        &quot;Playlist.findById&quot;,
        Playlist.class,
<span class="fc" id="L259">        Pair.of(&quot;id&quot;, playlistId),</span>
<span class="fc" id="L260">        Pair.of(&quot;organizationId&quot;, orgId)</span>
    );
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>