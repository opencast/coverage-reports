<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MicrosoftAzureSpeechTranscriptionJsonRecognizedPhrases.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-transcription-service-microsoft-azure</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.transcription.microsoft.azure.model</a> &gt; <span class="el_source">MicrosoftAzureSpeechTranscriptionJsonRecognizedPhrases.java</span></div><h1>MicrosoftAzureSpeechTranscriptionJsonRecognizedPhrases.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.transcription.microsoft.azure.model;

import org.apache.commons.lang3.StringUtils;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.TimeZone;

public class MicrosoftAzureSpeechTranscriptionJsonRecognizedPhrases {

  // CHECKSTYLE:OFF checkstyle:LineLength

  // Documentation:
  // https://eastus.dev.cognitive.microsoft.com/docs/services/speech-to-text-api-v3-1/operations/Transcriptions_ListFiles

  // CHECKSTYLE:ON checkstyle:LineLength
  // CHECKSTYLE:OFF checkstyle:VisibilityModifier

  public String recognitionStatus;
  public int channel;
  public String offset;
  public String duration;
  public long offsetInTicks;
  public long durationInTicks;
  public List&lt;MicrosoftAzureSpeechTranscriptionJsonRecognizedPhrase&gt; nBest;
  public String locale;

  // CHECKSTYLE:ON checkstyle:VisibilityModifier

<span class="nc" id="L54">  public MicrosoftAzureSpeechTranscriptionJsonRecognizedPhrases() { }</span>

  public String[] toSrt(float minConfidence, int maxCueLength) {
<span class="nc" id="L57">    String text = getBestRecognizedText(minConfidence);</span>
<span class="nc" id="L58">    String[] cueText = splitCueText(text, maxCueLength);</span>
<span class="nc" id="L59">    return timestampCues(false, cueText);</span>
  }

  public String[] toWebVtt(float minConfidence, int maxCueLength) {
<span class="nc" id="L63">    String text = getBestRecognizedText(minConfidence);</span>
<span class="nc" id="L64">    String[] cueText = splitCueText(text, maxCueLength);</span>
<span class="nc" id="L65">    return timestampCues(true, cueText);</span>
  }

  String[] timestampCues(boolean formatWebVtt, String[] cueText) {
<span class="nc" id="L69">    long ticksPerMillisecond = 10000;</span>
    String format;
<span class="nc bnc" id="L71" title="All 2 branches missed.">    if (formatWebVtt) {</span>
<span class="nc" id="L72">      format = &quot;HH:mm:ss.SSS&quot;;</span>
    } else {
      // SRT format requires ',' as decimal separator rather than '.'.
<span class="nc" id="L75">      format = &quot;HH:mm:ss,SSS&quot;;</span>
    }
<span class="nc" id="L77">    SimpleDateFormat formatter = new SimpleDateFormat(format);</span>
    // If we don't do this, the time is adjusted for our local time zone, which we don't want.
<span class="nc" id="L79">    formatter.setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L80">    int cueTextLength = 0;</span>
<span class="nc" id="L81">    int[] cuesTextLenth = new int[cueText.length];</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">    for (int i = 0; i &lt; cueText.length; i++) {</span>
<span class="nc" id="L83">      cuesTextLenth[i] = StringUtils.length(cueText[i]);</span>
<span class="nc" id="L84">      cueTextLength += cuesTextLenth[i];</span>
    }
<span class="nc" id="L86">    String[] result = new String[cueText.length];</span>
<span class="nc" id="L87">    long cueOffsetInTicks = 0;</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">    for (int i = 0; i &lt; cueText.length; i++) {</span>
<span class="nc" id="L89">      long cueLengthInTicks = (long)Math.ceil((double)durationInTicks * (double)cuesTextLenth[i]</span>
          / (double)cueTextLength);

<span class="nc" id="L92">      Date startTime = new Date((offsetInTicks + cueOffsetInTicks) / ticksPerMillisecond);</span>
<span class="nc" id="L93">      Date endTime = new Date((offsetInTicks  + cueOffsetInTicks + cueLengthInTicks) / ticksPerMillisecond);</span>
<span class="nc" id="L94">      cueOffsetInTicks += cueLengthInTicks;</span>
<span class="nc" id="L95">      result[i] = String.format(&quot;%s --&gt; %s\n%s\n&quot;, formatter.format(startTime), formatter.format(endTime), cueText[i]);</span>
    }
<span class="nc" id="L97">    return result;</span>
  }

  public String getBestRecognizedText(float minConfidence) {
<span class="nc bnc" id="L101" title="All 2 branches missed.">    if (nBest == null) {</span>
<span class="nc" id="L102">      return null;</span>
    }
    Optional&lt;MicrosoftAzureSpeechTranscriptionJsonRecognizedPhrase&gt; bestPhrase;
<span class="nc bnc" id="L105" title="All 4 branches missed.">    if (minConfidence &gt;= 0 &amp;&amp; minConfidence &lt; 1) {</span>
<span class="nc" id="L106">      bestPhrase = nBest.stream()</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">          .filter(phrase -&gt; phrase.confidence &gt;= minConfidence)</span>
<span class="nc" id="L108">          .sorted((t1, t2) -&gt; Float.compare(t2.confidence, t1.confidence))  // descendant order</span>
<span class="nc" id="L109">          .findFirst();</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">    } else if (minConfidence &gt;= 1) {</span>
<span class="nc" id="L111">      bestPhrase = nBest.stream().findFirst();</span>
    } else {
<span class="nc" id="L113">      bestPhrase = nBest.stream()</span>
<span class="nc" id="L114">          .sorted((t1, t2) -&gt; Float.compare(t2.confidence, t1.confidence))  // descendant order</span>
<span class="nc" id="L115">          .findFirst();</span>
    }
<span class="nc bnc" id="L117" title="All 2 branches missed.">    return bestPhrase.isPresent() ? bestPhrase.get().display : &quot;&quot;;</span>
  }

  public static String[] splitCueText(String text, int maxCueLength) {
<span class="fc" id="L121">    int textLength = StringUtils.length(text);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">    if (textLength == 0) {</span>
<span class="fc" id="L123">      return new String[0];</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">    } else if (textLength &lt;= maxCueLength) {</span>
<span class="nc" id="L125">      return new String[] { text };</span>
    }
<span class="fc" id="L127">    List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L128">    int start = 0;</span>
    do {
<span class="fc bfc" id="L130" title="All 2 branches covered.">      if (textLength - start &lt;= maxCueLength) {</span>
<span class="fc" id="L131">        result.add(StringUtils.trimToEmpty(StringUtils.substring(text, start, textLength)));</span>
<span class="fc" id="L132">        break;</span>
      }
<span class="fc" id="L134">      int end = StringUtils.lastIndexOf(text, &quot; &quot;, start + maxCueLength);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">      if (start &gt;= end) {</span>
<span class="fc" id="L136">        end = Math.min(textLength, start + maxCueLength);</span>
      }
<span class="fc" id="L138">      result.add(StringUtils.trimToEmpty(StringUtils.substring(text, start, end)));</span>
<span class="fc" id="L139">      start = end;</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">    } while (start &lt; textLength);</span>
<span class="fc" id="L141">    return result.toArray(new String[0]);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>