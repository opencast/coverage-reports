<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SearchServiceIndex.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-search-service-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.search.impl</a> &gt; <span class="el_source">SearchServiceIndex.java</span></div><h1>SearchServiceIndex.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.search.impl;

import static org.opencastproject.security.util.SecurityUtil.getEpisodeRoleId;

import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.rebuild.AbstractIndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildException;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildService;
import org.opencastproject.list.api.ListProviderException;
import org.opencastproject.list.api.ListProvidersService;
import org.opencastproject.list.api.ResourceListQuery;
import org.opencastproject.list.impl.ResourceListQueryImpl;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreUtil;
import org.opencastproject.metadata.dublincore.DublinCoreValue;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.search.api.SearchException;
import org.opencastproject.search.api.SearchResult;
import org.opencastproject.search.api.SearchService;
import org.opencastproject.search.impl.persistence.SearchServiceDatabase;
import org.opencastproject.search.impl.persistence.SearchServiceDatabaseException;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.Role;
import org.opencastproject.security.api.SecurityConstants;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.api.User;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.series.api.SeriesException;
import org.opencastproject.series.api.SeriesService;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.workspace.api.Workspace;

import com.google.gson.Gson;
import com.google.gson.JsonElement;

import org.apache.commons.io.IOUtils;
import org.elasticsearch.ElasticsearchStatusException;
import org.elasticsearch.action.DocWriteResponse;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.update.UpdateRequest;
import org.elasticsearch.action.update.UpdateResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.indices.CreateIndexRequest;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.rest.RestStatus;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * A Elasticsearch-based {@link SearchService} implementation.
 */
@Component(
        immediate = true,
        service = { SearchServiceIndex.class, IndexProducer.class },
        property = {
                &quot;service.description=Search Service Index&quot;,
                &quot;service.pid=org.opencastproject.search.impl.SearchServiceIndex&quot;
        }
)
public final class SearchServiceIndex extends AbstractIndexProducer implements IndexProducer {

  @Override
  public IndexRebuildService.Service getService() {
<span class="nc" id="L118">    return IndexRebuildService.Service.Search;</span>
  }

  /** Log facility */
<span class="nc" id="L122">  private static final Logger logger = LoggerFactory.getLogger(SearchServiceIndex.class);</span>

  public static final String INDEX_NAME = &quot;opencast_search&quot;;

<span class="nc" id="L126">  private final Gson gson = new Gson();</span>

  private ElasticsearchIndex esIndex;

  private SeriesService seriesService;

  /** The local workspace */
  private Workspace workspace;

  /** The security service */
  private SecurityService securityService;

  /** The authorization service */
  private AuthorizationService authorizationService;

  /** Persistent storage */
  private SearchServiceDatabase persistence;

  /** The organization directory service */
<span class="nc" id="L145">  private OrganizationDirectoryService organizationDirectory = null;</span>

  private ListProvidersService listProvidersService;

<span class="nc" id="L149">  private String systemUserName = null;</span>


  /**
   * Creates a new instance of the search service index.
   */
<span class="nc" id="L155">  public SearchServiceIndex() {</span>
<span class="nc" id="L156">  }</span>

  /**
   * Service activator, called via declarative services configuration.
   *
   * @param cc
   *          the component context
   */
  @Activate
  public void activate(final ComponentContext cc) throws IllegalStateException {
<span class="nc" id="L166">    createIndex();</span>
<span class="nc" id="L167">    systemUserName = SecurityUtil.getSystemUserName(cc);</span>
<span class="nc" id="L168">  }</span>

  private void createIndex() {
<span class="nc" id="L171">    var mapping = &quot;&quot;;</span>
<span class="nc" id="L172">    try (var in = this.getClass().getResourceAsStream(&quot;/search-mapping.json&quot;)) {</span>
<span class="nc" id="L173">      mapping = IOUtils.toString(in, StandardCharsets.UTF_8);</span>
<span class="nc" id="L174">    } catch (IOException e) {</span>
<span class="nc" id="L175">      throw new SearchException(&quot;Could not read mapping.&quot;, e);</span>
<span class="nc" id="L176">    }</span>
    try {
<span class="nc" id="L178">      logger.debug(&quot;Trying to create index for '{}'&quot;, INDEX_NAME);</span>
<span class="nc" id="L179">      InputStream is = getClass().getResourceAsStream(&quot;/elasticsearch/indexSettings.json&quot;);</span>
<span class="nc" id="L180">      String indexSettings = IOUtils.toString(is, StandardCharsets.UTF_8);</span>
<span class="nc" id="L181">      final CreateIndexRequest request = new CreateIndexRequest(INDEX_NAME)</span>
<span class="nc" id="L182">          .settings(indexSettings, XContentType.JSON)</span>
<span class="nc" id="L183">          .mapping(mapping, XContentType.JSON);</span>
<span class="nc" id="L184">      var response = esIndex.getClient().indices().create(request, RequestOptions.DEFAULT);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">      if (!response.isAcknowledged()) {</span>
<span class="nc" id="L186">        throw new SearchException(&quot;Unable to create index for '&quot; + INDEX_NAME + &quot;'&quot;);</span>
      }
<span class="nc" id="L188">    } catch (ElasticsearchStatusException e) {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">      if (e.getDetailedMessage().contains(&quot;already_exists_exception&quot;)) {</span>
<span class="nc" id="L190">        logger.info(&quot;Detected existing index '{}'&quot;, INDEX_NAME);</span>
      } else {
<span class="nc" id="L192">        throw e;</span>
      }
<span class="nc" id="L194">    } catch (IOException e) {</span>
<span class="nc" id="L195">      throw new SearchException(e);</span>
<span class="nc" id="L196">    }</span>
<span class="nc" id="L197">  }</span>

  @Reference
  public void setEsIndex(ElasticsearchIndex esIndex) {
<span class="nc" id="L201">    this.esIndex = esIndex;</span>
<span class="nc" id="L202">  }</span>


  public SearchResponse search(SearchSourceBuilder searchSource) throws SearchException {
<span class="nc" id="L206">    SearchRequest searchRequest = new SearchRequest(INDEX_NAME);</span>
<span class="nc" id="L207">    logger.debug(&quot;Sending for query: {}&quot;, searchSource.query());</span>
<span class="nc" id="L208">    searchRequest.source(searchSource);</span>
    try {
<span class="nc" id="L210">      return esIndex.getClient().search(searchRequest, RequestOptions.DEFAULT);</span>
<span class="nc" id="L211">    } catch (IOException e) {</span>
<span class="nc" id="L212">      throw new SearchException(e);</span>
    }
  }

  /**
   * Immediately adds the mediapackage to the search index.
   *
   * @param mediaPackage
   *          the media package
   * @throws SearchException
   *           if the media package cannot be added to the search index
   * @throws IllegalArgumentException
   *           if the media package is &lt;code&gt;null&lt;/code&gt;
   * @throws UnauthorizedException
   *           if the user does not have the rights to add the mediapackage
   */
  public void addSynchronously(MediaPackage mediaPackage)
          throws SearchException, IllegalArgumentException, UnauthorizedException, SearchServiceDatabaseException {
<span class="nc bnc" id="L230" title="All 2 branches missed.">    if (mediaPackage == null) {</span>
<span class="nc" id="L231">      throw new IllegalArgumentException(&quot;Unable to add a null mediapackage&quot;);</span>
    }
<span class="nc" id="L233">    var mediaPackageId = mediaPackage.getIdentifier().toString();</span>

<span class="nc" id="L235">    checkSearchEntityWritePermission(mediaPackageId);</span>

<span class="nc" id="L237">    logger.debug(&quot;Attempting to add media package {} to search index&quot;, mediaPackageId);</span>
<span class="nc" id="L238">    final var acls = new AccessControlList[1];</span>
<span class="nc" id="L239">    final var org = securityService.getOrganization();</span>
<span class="nc" id="L240">    final var systemUser = SecurityUtil.createSystemUser(systemUserName, org);</span>
    // Ensure we always get the actual acl by forcing access
<span class="nc" id="L242">    SecurityUtil.runAs(securityService, org, systemUser, () -&gt; {</span>
<span class="nc" id="L243">      acls[0] = authorizationService.getActiveAcl(mediaPackage).getA();</span>
<span class="nc" id="L244">    });</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">    var acl = acls[0] == null ? new AccessControlList() : acls[0];</span>
<span class="nc" id="L246">    var now = new Date();</span>

    try {
<span class="nc" id="L249">      persistence.storeMediaPackage(mediaPackage, acl, now);</span>
<span class="nc" id="L250">    } catch (SearchServiceDatabaseException e) {</span>
<span class="nc" id="L251">      throw new SearchException(String.format(&quot;Could not store media package to search database %s&quot;, mediaPackageId),</span>
          e);
<span class="nc" id="L253">    }</span>

<span class="nc" id="L255">    indexMediaPackage(mediaPackage, acl);</span>
<span class="nc" id="L256">  }</span>

  public void indexMediaPackage(String mediaPackageId)
          throws SearchException, SearchServiceDatabaseException, UnauthorizedException, NotFoundException {
<span class="nc bnc" id="L260" title="All 2 branches missed.">    if (!securityService.getUser().hasRole(&quot;ROLE_ADMIN&quot;)) {</span>
<span class="nc" id="L261">      throw new UnauthorizedException(&quot;Only global administrators may trigger manual event updates.&quot;);</span>
    }
    try {
<span class="nc" id="L264">      MediaPackage mp = persistence.getMediaPackage(mediaPackageId);</span>
<span class="nc" id="L265">      AccessControlList acl = persistence.getAccessControlList(mediaPackageId);</span>
<span class="nc" id="L266">      Date modificationDate = persistence.getModificationDate(mediaPackageId);</span>
<span class="nc" id="L267">      Date deletionDate = persistence.getDeletionDate(mediaPackageId);</span>
<span class="nc" id="L268">      indexMediaPackage(mp, acl, modificationDate, deletionDate);</span>
<span class="nc" id="L269">    } catch (RuntimeException e) {</span>
<span class="nc" id="L270">      logSkippingElement(logger, &quot;event&quot;, mediaPackageId, e);</span>
<span class="nc" id="L271">    }</span>
<span class="nc" id="L272">  }</span>

  private void indexMediaPackage(MediaPackage mediaPackage, AccessControlList acl)
          throws SearchException, SearchServiceDatabaseException {
<span class="nc" id="L276">    indexMediaPackage(mediaPackage, acl, null, null);</span>
<span class="nc" id="L277">  }</span>

  private void indexMediaPackage(MediaPackage mediaPackage, AccessControlList acl, Date modDate, Date delDate)
          throws SearchException, SearchServiceDatabaseException {
<span class="nc" id="L281">    String mediaPackageId = mediaPackage.getIdentifier().toString();</span>
<span class="nc" id="L282">    String orgId = securityService.getOrganization().getId();</span>
    //If the entry has been deleted then there's *probably* no dc file to load.
<span class="nc bnc" id="L284" title="All 2 branches missed.">    DublinCoreCatalog dc = null == delDate</span>
<span class="nc" id="L285">        ? DublinCoreUtil.loadEpisodeDublinCore(workspace, mediaPackage).orElse(DublinCores.mkSimple())</span>
<span class="nc" id="L286">        : DublinCores.mkSimple();</span>

<span class="nc" id="L288">    List&lt;DublinCoreCatalog&gt; seriesList = Collections.emptyList();</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">    if (dc.hasValue(DublinCore.PROPERTY_IS_PART_OF)) {</span>
      //Find the series (if any), filter for those which exist to prevent linking non-existent series
<span class="nc" id="L291">      seriesList = dc.get(DublinCore.PROPERTY_IS_PART_OF).stream().map(DublinCoreValue::getValue).map(s -&gt; {</span>
        try {
<span class="nc" id="L293">          return seriesService.getSeries(s);</span>
<span class="nc" id="L294">        } catch (NotFoundException e) {</span>
<span class="nc" id="L295">          logger.warn(&quot;Series {} not found during index of event {}, omitting the link from the indexed data&quot;, s,</span>
              mediaPackageId);
<span class="nc" id="L297">        } catch (UnauthorizedException e) {</span>
<span class="nc" id="L298">          logger.warn(&quot;Not authorized for series {} during index of event {}, omitting the link from the indexed data&quot;,</span>
              s, mediaPackageId);
<span class="nc" id="L300">        } catch (SeriesException e) {</span>
<span class="nc" id="L301">          throw new SearchException(e);</span>
<span class="nc" id="L302">        }</span>
<span class="nc" id="L303">        return null;</span>
<span class="nc" id="L304">      }).filter(Objects::nonNull).collect(Collectors.toList());</span>
    }

    // Add custom roles if enabled
<span class="nc" id="L308">    acl = addCustomAclRoles(mediaPackageId, acl);</span>

<span class="nc" id="L310">    SearchResult item = new SearchResult(SearchService.IndexEntryType.Episode, dc, acl, orgId, mediaPackage,</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        null != modDate ? modDate.toInstant() : Instant.now(),</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        null != delDate ? delDate.toInstant() : null);</span>
<span class="nc" id="L313">    Map&lt;String, Object&gt; metadata = item.dehydrateForIndex();</span>
    try {
<span class="nc" id="L315">      var request = new IndexRequest(INDEX_NAME);</span>
<span class="nc" id="L316">      request.id(mediaPackageId);</span>
<span class="nc" id="L317">      request.source(metadata);</span>
<span class="nc" id="L318">      esIndex.getClient().index(request, RequestOptions.DEFAULT);</span>
<span class="nc" id="L319">      logger.debug(&quot;Indexed episode {}&quot;, mediaPackageId);</span>
<span class="nc" id="L320">    } catch (IOException e) {</span>
<span class="nc" id="L321">      throw new SearchException(e);</span>
<span class="nc" id="L322">    }</span>

    // Elasticsearch series
<span class="nc bnc" id="L325" title="All 2 branches missed.">    for (DublinCoreCatalog seriesDc : seriesList) {</span>
<span class="nc" id="L326">      String seriesId = seriesDc.getFirst(DublinCore.PROPERTY_IDENTIFIER);</span>
<span class="nc" id="L327">      AccessControlList seriesAcl = persistence.getAccessControlLists(seriesId, mediaPackageId).stream()</span>
<span class="nc" id="L328">          .map(aclPair -&gt; addCustomAclRoles(aclPair.getKey(), aclPair.getValue()))</span>
<span class="nc" id="L329">          .reduce(new AccessControlList(acl.getEntries()), AccessControlList::mergeActions);</span>
<span class="nc" id="L330">      item = new SearchResult(SearchService.IndexEntryType.Series, seriesDc, seriesAcl, orgId,</span>
<span class="nc" id="L331">          null, Instant.now(), null);</span>

<span class="nc" id="L333">      Map&lt;String, Object&gt; seriesData = item.dehydrateForIndex();</span>
      try {
<span class="nc" id="L335">        var request = new IndexRequest(INDEX_NAME);</span>
<span class="nc" id="L336">        request.id(seriesId);</span>
<span class="nc" id="L337">        request.source(seriesData);</span>
<span class="nc" id="L338">        esIndex.getClient().index(request, RequestOptions.DEFAULT);</span>
<span class="nc" id="L339">        logger.debug(&quot;Indexed series {} related to episode {}&quot;, seriesId, mediaPackageId);</span>
<span class="nc" id="L340">      } catch (IOException e) {</span>
<span class="nc" id="L341">        throw new SearchException(e);</span>
<span class="nc" id="L342">      }</span>
<span class="nc" id="L343">    }</span>
<span class="nc" id="L344">  }</span>

  /**
   * Add custom roles of the media package to the passed ACL
   *
   * @param mediaPackageId
   *          the media package
   * @param acl
   *          the existing access control list
   * @return {@link AccessControlList} containing the passed and the custom roles merged together
   *
   */
  private AccessControlList addCustomAclRoles(String mediaPackageId, AccessControlList acl) {
    // This allows users with a role of the form ROLE_EPISODE_&lt;ID&gt;_&lt;ACTION&gt; to access the event through the index
<span class="nc" id="L358">    Set&lt;AccessControlEntry&gt; customEntries = new HashSet&lt;&gt;();</span>
<span class="nc" id="L359">    customEntries.add(new AccessControlEntry(getEpisodeRoleId(mediaPackageId, &quot;READ&quot;), &quot;read&quot;, true));</span>
<span class="nc" id="L360">    customEntries.add(new AccessControlEntry(getEpisodeRoleId(mediaPackageId, &quot;WRITE&quot;), &quot;write&quot;, true));</span>

<span class="nc" id="L362">    ResourceListQuery query = new ResourceListQueryImpl();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">    if (listProvidersService.hasProvider(&quot;ACL.ACTIONS&quot;)) {</span>
<span class="nc" id="L364">      Map&lt;String, String&gt; actions = new HashMap&lt;&gt;();</span>
      try {
<span class="nc" id="L366">        actions = listProvidersService.getList(&quot;ACL.ACTIONS&quot;, query, true);</span>
<span class="nc" id="L367">      } catch (ListProviderException e) {</span>
<span class="nc" id="L368">        throw new SearchException(&quot;Listproviders not loaded. &quot; + e);</span>
<span class="nc" id="L369">      }</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">      for (String action : actions.keySet()) {</span>
<span class="nc" id="L371">        customEntries.add(</span>
<span class="nc" id="L372">            new AccessControlEntry(getEpisodeRoleId(mediaPackageId, action), action, true));</span>
<span class="nc" id="L373">      }</span>
    }

<span class="nc" id="L376">    return acl;</span>
  }

  private void checkSearchEntityWritePermission(final String mediaPackageId) throws SearchException {
<span class="nc" id="L380">    User user = securityService.getUser();</span>
    try {
<span class="nc" id="L382">      AccessControlList acl = persistence.getAccessControlList(mediaPackageId);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">      if (!authorizationService.hasPermission(acl, Permissions.Action.WRITE.toString())) {</span>
<span class="nc" id="L384">        boolean isAdmin = user.getRoles().stream()</span>
<span class="nc" id="L385">            .map(Role::getName)</span>
<span class="nc" id="L386">            .anyMatch(r -&gt; r.equals(SecurityConstants.GLOBAL_ADMIN_ROLE));</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (!isAdmin) {</span>
<span class="nc" id="L388">          throw new UnauthorizedException(user, &quot;Write permission denied for &quot; + mediaPackageId, acl);</span>
        } else {
<span class="nc" id="L390">          logger.debug(&quot;Write for {} is not allowed by ACL, but user has {}&quot;,</span>
              mediaPackageId, SecurityConstants.GLOBAL_ADMIN_ROLE);
        }
      }
<span class="nc" id="L394">    } catch (NotFoundException e) {</span>
<span class="nc" id="L395">      logger.debug(&quot;Mediapackage {} does not exist or was deleted, allowing writes for user {}&quot;, mediaPackageId, user);</span>
<span class="nc" id="L396">    } catch (SearchServiceDatabaseException | UnauthorizedException e) {</span>
<span class="nc" id="L397">      throw new SearchException(e);</span>
<span class="nc" id="L398">    }</span>
<span class="nc" id="L399">  }</span>

  /**
   * Immediately removes the given mediapackage from the search service.
   *
   * @param mediaPackageId
   *          the media package identifier
   * @return &lt;code&gt;true&lt;/code&gt; if the mediapackage was deleted
   * @throws SearchException
   *           if deletion failed
   */
  public boolean deleteSynchronously(final String mediaPackageId) throws SearchException {

<span class="nc" id="L412">    checkSearchEntityWritePermission(mediaPackageId);</span>

<span class="nc" id="L414">    String deletionString = DateTimeFormatter.ISO_INSTANT.format(Instant.now());</span>

    try {
<span class="nc" id="L417">      logger.info(&quot;Marking media package {} as deleted in search index&quot;, mediaPackageId);</span>
<span class="nc" id="L418">      JsonElement json = gson.toJsonTree(Map.of(</span>
          SearchResult.DELETED_DATE, deletionString,
          SearchResult.MODIFIED_DATE, deletionString));
<span class="nc" id="L421">      var updateRequst = new UpdateRequest(INDEX_NAME, mediaPackageId)</span>
<span class="nc" id="L422">          .doc(gson.toJson(json), XContentType.JSON);</span>
<span class="nc" id="L423">      esIndex.getClient().update(updateRequst, RequestOptions.DEFAULT);</span>
<span class="nc" id="L424">    } catch (ElasticsearchStatusException e) {</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">      if (e.status().getStatus() != RestStatus.NOT_FOUND.getStatus()) {</span>
<span class="nc" id="L426">        throw e;</span>
      }
<span class="nc" id="L428">      logger.warn(&quot;Event {} is not in the search index. Skipping deletion&quot;, mediaPackageId);</span>
<span class="nc" id="L429">    } catch (IOException e) {</span>
<span class="nc" id="L430">      throw new SearchException(&quot;Could not delete episode &quot; + mediaPackageId + &quot; from index&quot;, e);</span>
<span class="nc" id="L431">    }</span>

    try {
<span class="nc" id="L434">      logger.info(&quot;Marking media package {} as deleted in search database&quot;, mediaPackageId);</span>

<span class="nc" id="L436">      String seriesId = null;</span>
<span class="nc" id="L437">      Date now = new Date();</span>
      try {
<span class="nc" id="L439">        seriesId = persistence.getMediaPackage(mediaPackageId).getSeries();</span>
<span class="nc" id="L440">        persistence.deleteMediaPackage(mediaPackageId, now);</span>
<span class="nc" id="L441">        logger.info(&quot;Removed media package {} from search persistence&quot;, mediaPackageId);</span>
<span class="nc" id="L442">      } catch (NotFoundException e) {</span>
        // even if mp not found in persistence, it might still exist in search index.
<span class="nc" id="L444">        logger.info(&quot;Could not find media package with id {} in persistence, but will try remove it from index anyway.&quot;,</span>
            mediaPackageId);
<span class="nc" id="L446">      } catch (SearchServiceDatabaseException | UnauthorizedException e) {</span>
<span class="nc" id="L447">        throw new SearchException(</span>
<span class="nc" id="L448">            String.format(&quot;Could not delete media package with id %s from persistence storage&quot;, mediaPackageId), e);</span>
<span class="nc" id="L449">      }</span>

      // Update series
<span class="nc bnc" id="L452" title="All 2 branches missed.">      if (seriesId != null) {</span>
        try {
<span class="nc bnc" id="L454" title="All 2 branches missed.">          if (!persistence.getSeries(seriesId).isEmpty()) {</span>
            // Update series acl if there are still episodes in the series
<span class="nc" id="L456">            final AccessControlList seriesAcl = persistence.getAccessControlLists(seriesId).stream()</span>
<span class="nc" id="L457">                .map(aclPair -&gt; addCustomAclRoles(aclPair.getKey(), aclPair.getValue()))</span>
<span class="nc" id="L458">                .reduce(new AccessControlList(), AccessControlList::mergeActions);</span>
<span class="nc" id="L459">            JsonElement json = gson.toJsonTree(Map.of(</span>
<span class="nc" id="L460">                SearchResult.INDEX_ACL, SearchResult.dehydrateAclForIndex(seriesAcl),</span>
                SearchResult.MODIFIED_DATE, deletionString));
<span class="nc" id="L462">            var updateRequest = new UpdateRequest(INDEX_NAME, seriesId).doc(gson.toJson(json), XContentType.JSON);</span>
            try {
<span class="nc" id="L464">              esIndex.getClient().update(updateRequest, RequestOptions.DEFAULT);</span>
<span class="nc" id="L465">            } catch (ElasticsearchStatusException e) {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">              if (RestStatus.NOT_FOUND == e.status()) {</span>
<span class="nc" id="L467">                logger.warn(&quot;Attempted to modify {}, but that series does not exist in the index.&quot;, seriesId);</span>
              }
<span class="nc" id="L469">            }</span>
<span class="nc" id="L470">          } else {</span>
            // Remove series if there are no episodes in the series any longer
<span class="nc" id="L472">            deleteSeriesSynchronously(seriesId);</span>
          }
<span class="nc" id="L474">        } catch (IOException e) {</span>
<span class="nc" id="L475">          throw new SearchException(e);</span>
<span class="nc" id="L476">        }</span>
      }

<span class="nc" id="L479">      return true;</span>
<span class="nc" id="L480">    } catch (SearchServiceDatabaseException e) {</span>
<span class="nc" id="L481">      logger.info(&quot;Could not delete media package with id {} from search index&quot;, mediaPackageId);</span>
<span class="nc" id="L482">      throw new SearchException(e);</span>
    }
  }

  /**
   * Immediately removes the given series from the search service.
   *
   * @param seriesId
   *          the series
   * @throws SearchException
   */
  public boolean deleteSeriesSynchronously(String seriesId) throws SearchException {
    try {
<span class="nc" id="L495">      logger.info(&quot;Marking {} as deleted in the search index&quot;, seriesId);</span>
<span class="nc" id="L496">      JsonElement json = gson.toJsonTree(Map.of(</span>
<span class="nc" id="L497">          &quot;deleted&quot;, Instant.now().getEpochSecond(),</span>
<span class="nc" id="L498">          &quot;modified&quot;, Instant.now().toString()));</span>
<span class="nc" id="L499">      var updateRequest = new UpdateRequest(INDEX_NAME, seriesId).doc(gson.toJson(json), XContentType.JSON);</span>
      try {
<span class="nc" id="L501">        UpdateResponse response = esIndex.getClient().update(updateRequest, RequestOptions.DEFAULT);</span>
        //NB: We're marking things as deleted but *not actually deleting them**
<span class="nc bnc" id="L503" title="All 2 branches missed.">        return DocWriteResponse.Result.UPDATED == response.getResult();</span>
<span class="nc" id="L504">      } catch (ElasticsearchStatusException e) {</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (RestStatus.NOT_FOUND == e.status()) {</span>
<span class="nc" id="L506">          logger.debug(&quot;Attempted to delete {}, but that series does not exist in the index.&quot;, seriesId);</span>
<span class="nc" id="L507">          return true;</span>
        }
<span class="nc" id="L509">        throw new SearchException(e);</span>
      }
<span class="nc" id="L511">    } catch (IOException e) {</span>
<span class="nc" id="L512">      throw new SearchException(&quot;Could not delete series &quot; + seriesId + &quot; from index&quot;, e);</span>
    }
  }

  @Override
  public void repopulate(IndexRebuildService.DataType type) throws IndexRebuildException {
<span class="nc" id="L518">    final Organization originalOrg = securityService.getOrganization();</span>
<span class="nc" id="L519">    final User originalUser = securityService.getUser();</span>

    try {
<span class="nc" id="L522">      int total = persistence.countMediaPackages();</span>
<span class="nc" id="L523">      int pageSize = 50;</span>
<span class="nc" id="L524">      int pageOffset = 0;</span>
<span class="nc" id="L525">      AtomicInteger current = new AtomicInteger(1);</span>
<span class="nc" id="L526">      logIndexRebuildBegin(logger, total, &quot;search&quot;);</span>
<span class="nc" id="L527">      List&lt;Tuple&lt;MediaPackage, String&gt;&gt; page = null;</span>

      do {
<span class="nc" id="L530">        page = persistence.getAllMediaPackages(pageSize, pageOffset).collect(Collectors.toList());</span>
<span class="nc" id="L531">        page.forEach(tuple -&gt; {</span>
          try {
<span class="nc" id="L533">            MediaPackage mediaPackage = tuple.getA();</span>
<span class="nc" id="L534">            Organization organization = organizationDirectory.getOrganization(tuple.getB());</span>
<span class="nc" id="L535">            final var systemUser = SecurityUtil.createSystemUser(systemUserName, organization);</span>
<span class="nc" id="L536">            securityService.setUser(systemUser);</span>
<span class="nc" id="L537">            securityService.setOrganization(organization);</span>

<span class="nc" id="L539">            String mediaPackageId = mediaPackage.getIdentifier().toString();</span>

<span class="nc" id="L541">            AccessControlList acl = persistence.getAccessControlList(mediaPackageId);</span>
<span class="nc" id="L542">            Date modificationDate = persistence.getModificationDate(mediaPackageId);</span>
<span class="nc" id="L543">            Date deletionDate = persistence.getDeletionDate(mediaPackageId);</span>

<span class="nc" id="L545">            current.getAndIncrement();</span>

<span class="nc" id="L547">            indexMediaPackage(mediaPackage, acl, modificationDate, deletionDate);</span>
<span class="nc" id="L548">          } catch (SearchServiceDatabaseException e) {</span>
<span class="nc" id="L549">            logIndexRebuildError(logger, total, current.get(), e);</span>
            //NB: Runtime exception thrown to escape the functional interfacing
<span class="nc" id="L551">            throw new RuntimeException(&quot;Internal Index Rebuild Failure&quot;, e);</span>
<span class="nc" id="L552">          } catch (RuntimeException | NotFoundException e) {</span>
<span class="nc" id="L553">            logSkippingElement(logger, &quot;event&quot;, tuple.getA().getIdentifier().toString(), e);</span>
<span class="nc" id="L554">          }</span>
<span class="nc" id="L555">        });</span>
        //Current is the *page* index, so we remove one since each page only has pageSize entries
<span class="nc" id="L557">        logIndexRebuildProgress(logger, total, current.get() - 1, pageSize);</span>
<span class="nc" id="L558">        pageOffset += 1;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">      } while (pageOffset * pageSize &lt;= total);</span>
      //NB: Catching RuntimeException since it can be thrown inside the functional forEach here
<span class="nc" id="L561">    } catch (SearchServiceDatabaseException | RuntimeException e) {</span>
<span class="nc" id="L562">      logIndexRebuildError(logger, e);</span>
<span class="nc" id="L563">      throw new IndexRebuildException(&quot;Index Rebuild Failure&quot;, e);</span>
    } finally {
<span class="nc" id="L565">      securityService.setUser(originalUser);</span>
<span class="nc" id="L566">      securityService.setOrganization(originalOrg);</span>
    }
<span class="nc" id="L568">  }</span>

  @Reference
  public void setPersistence(SearchServiceDatabase persistence) {
<span class="nc" id="L572">    this.persistence = persistence;</span>
<span class="nc" id="L573">  }</span>

  @Reference
  public void setSeriesService(SeriesService seriesService) {
<span class="nc" id="L577">    this.seriesService = seriesService;</span>
<span class="nc" id="L578">  }</span>

  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="nc" id="L582">    this.workspace = workspace;</span>
<span class="nc" id="L583">  }</span>

  @Reference
  public void setAuthorizationService(AuthorizationService authorizationService) {
<span class="nc" id="L587">    this.authorizationService = authorizationService;</span>
<span class="nc" id="L588">  }</span>

  /**
   * Callback for setting the security service.
   *
   * @param securityService
   *          the securityService to set
   */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="nc" id="L598">    this.securityService = securityService;</span>
<span class="nc" id="L599">  }</span>

  /**
   * Sets a reference to the organization directory service.
   *
   * @param organizationDirectory
   *          the organization directory
   */
  @Reference
  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectory) {
<span class="nc" id="L609">    this.organizationDirectory = organizationDirectory;</span>
<span class="nc" id="L610">  }</span>

  @Reference
  public void setListProvidersService(ListProvidersService listProvidersService) {
<span class="nc" id="L614">    this.listProvidersService = listProvidersService;</span>
<span class="nc" id="L615">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>