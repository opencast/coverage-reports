<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Value.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-asset-manager-api</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.assetmanager.api</a> &gt; <span class="el_source">Value.java</span></div><h1>Value.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.assetmanager.api;

import static java.lang.String.format;

import org.opencastproject.assetmanager.api.fn.Product;

import java.util.Date;
import java.util.Objects;
import java.util.function.Function;

import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.annotation.concurrent.Immutable;

/**
 * A property value.
 * &lt;p&gt;
 * The wrapped type is not exposed as a generic type parameter since {@link Value}s appear in
 * contexts like lists where this type information cannot be preserved.
 * To access the wrapped type one can choose between two options.
 * If the type is known, use {@link #get(ValueType)}.
 * If the type is not known, safely decompose the value with {@link #decompose(Fn, Fn, Fn, Fn, Fn)}.
 * &lt;/p&gt;
 * The value type is a sum type made up from
 * &lt;ul&gt;
 * &lt;li&gt;{@link StringValue}
 * &lt;li&gt;{@link DateValue}
 * &lt;li&gt;{@link LongValue}
 * &lt;li&gt;{@link BooleanValue}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Use one of the various &lt;code&gt;mk(..)&lt;/code&gt; constructors to create a new {@link Value}.
 *
 * @see Property
 */
@ParametersAreNonnullByDefault
public abstract class Value {
<span class="fc" id="L58">  public static final StringType STRING = new StringType();</span>
<span class="fc" id="L59">  public static final DateType DATE = new DateType();</span>
<span class="fc" id="L60">  public static final LongType LONG = new LongType();</span>
<span class="fc" id="L61">  public static final BooleanType BOOLEAN = new BooleanType();</span>
<span class="fc" id="L62">  public static final VersionType VERSION = new VersionType();</span>
  // TODO: rename to UNKNOWN
<span class="fc" id="L64">  public static final UntypedType UNTYPED = new UntypedType();</span>
//  public static final Class&lt;UntypedValue&gt; UNTYPED = UntypedValue.class;

  private Value() {
  }

  /** Get the wrapped value. */
  public abstract Object get();

  /**
   * Get the wrapped value in a type safe way. Use this method if you are
   * sure about the contained value type. Otherwise consider the use
   * of {@link #decompose(Fn, Fn, Fn, Fn, Fn)}.
   *
   * @param ev
   *         Evidence type. The type parameter &lt;code&gt;A&lt;/code&gt; of the evidence type
   *         must match the type of the wrapped value. Any other value will result
   *         in an exception being thrown.
   * @throws java.lang.RuntimeException
   *         if the passed evidence &lt;code&gt;ev&lt;/code&gt; does not match the type of the wrapped value
   */
  public final &lt;A&gt; A get(ValueType&lt;A&gt; ev) {
<span class="fc bfc" id="L86" title="All 2 branches covered.">    if (getType().getClass().equals(ev.getClass())) {</span>
<span class="fc" id="L87">      return (A) get();</span>
    } else {
<span class="fc" id="L89">      throw new RuntimeException(this + &quot; is not a &quot; + ev.getClass().getSimpleName());</span>
    }
  }

  public final ValueType&lt;?&gt; getType() {
<span class="fc" id="L94">    return decompose(new Function&lt;String, ValueType&lt;?&gt;&gt;() {</span>
      @Override public ValueType&lt;?&gt; apply(String a) {
<span class="fc" id="L96">        return STRING;</span>
      }
<span class="fc" id="L98">    }, new Function&lt;Date, ValueType&lt;?&gt;&gt;() {</span>
      @Override public ValueType&lt;?&gt; apply(Date a) {
<span class="fc" id="L100">        return DATE;</span>
      }
<span class="fc" id="L102">    }, new Function&lt;Long, ValueType&lt;?&gt;&gt;() {</span>
      @Override public ValueType&lt;?&gt; apply(Long a) {
<span class="fc" id="L104">        return LONG;</span>
      }
<span class="fc" id="L106">    }, new Function&lt;Boolean, ValueType&lt;?&gt;&gt;() {</span>
      @Override public ValueType&lt;?&gt; apply(Boolean a) {
<span class="fc" id="L108">        return BOOLEAN;</span>
      }
<span class="fc" id="L110">    }, new Function&lt;Version, ValueType&lt;?&gt;&gt;() {</span>
      @Override public ValueType&lt;?&gt; apply(Version a) {
<span class="nc" id="L112">        return VERSION;</span>
      }
    });
  }

  /**
   * Decompose (or pattern match) the value instance. Provide a function to handle each possible type.
   * Use {@link #doNotMatch()} as a placeholder that yields an error.
   */
  public final &lt;A&gt; A decompose(
      Function&lt;? super String, ? extends  A&gt; stringValue,
      Function&lt;? super Date, ? extends A&gt; dateValue,
      Function&lt;? super Long, ? extends A&gt; longValue,
      Function&lt;? super Boolean, ? extends A&gt; booleanValue,
      Function&lt;? super Version, ? extends A&gt; versionValue
  ) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">    if (this instanceof StringValue) {</span>
<span class="fc" id="L129">      return  stringValue.apply(((StringValue) this).get());</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">    } else if (this instanceof DateValue) {</span>
<span class="fc" id="L131">      return dateValue.apply(((DateValue) this).get());</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">    } else if (this instanceof LongValue) {</span>
<span class="fc" id="L133">      return longValue.apply(((LongValue) this).get());</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">    } else if (this instanceof BooleanValue) {</span>
<span class="fc" id="L135">      return booleanValue.apply(((BooleanValue) this).get());</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">    } else if (this instanceof VersionValue) {</span>
<span class="nc" id="L137">      return versionValue.apply(((VersionValue) this).get());</span>
    } else {
      // catch bug
<span class="nc" id="L140">      throw new Error(&quot;Unexhaustive match: &quot; + this);</span>
    }
  }

  //

  /**
   * Use as a placeholder that yields an error in
   * value decomposition.
   *
   * @see #decompose(Fn, Fn, Fn, Fn, Fn)
   */
  public static &lt;B&gt; Function&lt;Object, B&gt; doNotMatch() {
<span class="fc" id="L153">    return new Function&lt;Object, B&gt;() {</span>
      @Override public B apply(Object a) {
<span class="fc" id="L155">        throw new Error(&quot;Unexhaustive match: &quot; + a);</span>
      }
    };
  }

  /* -------------------------------------------------------------------------------------------------------------- */

  //
  // Type evidence and factory classes
  //

  /**
   * ValueType gives evidence that type &lt;code&gt;A&lt;/code&gt; is suitable for the creation
   * of a {@link Value}.
   * &lt;p&gt;
   * This is a more advanced version of the usual &lt;code&gt;Class&amp;lt;A&amp;gt;&lt;/code&gt; idiom.
   * A &lt;code&gt;ValueType&lt;/code&gt; is also a constructor for {@link TypedValue}s of
   * the same type &lt;code&gt;A&lt;/code&gt;.
   *
   * @param &lt;A&gt; the type to give evidence of
   */
  public abstract static class ValueType&lt;A&gt; {
    /** It should not be possible to inherit from outside class {@link Value}. */
    private ValueType() {
    }

    public abstract TypedValue&lt;A&gt; mk(A a);

    public abstract &lt;B&gt; B match(
            Product&lt;? extends B&gt; stringType,
            Product&lt;? extends B&gt; dateType,
            Product&lt;? extends B&gt; longType,
            Product&lt;? extends B&gt; booleanType,
            Product&lt;? extends B&gt; versionType);
  }

<span class="fc" id="L191">  public static final class StringType extends ValueType&lt;String&gt; {</span>
    @Override public TypedValue&lt;String&gt; mk(String a) {
<span class="fc" id="L193">      return Value.mk(a);</span>
    }

    @Override public &lt;B&gt; B match(
            Product&lt;? extends B&gt; stringType,
            Product&lt;? extends B&gt; dateType,
            Product&lt;? extends B&gt; longType,
            Product&lt;? extends B&gt; booleanType,
            Product&lt;? extends B&gt; versionType) {
<span class="nc" id="L202">      return stringType.get1();</span>
    }
  }

<span class="fc" id="L206">  public static final class DateType extends ValueType&lt;Date&gt; {</span>
    @Override public TypedValue&lt;Date&gt; mk(Date a) {
<span class="fc" id="L208">      return Value.mk(a);</span>
    }

    @Override public &lt;B&gt; B match(
            Product&lt;? extends B&gt; stringType,
            Product&lt;? extends B&gt; dateType,
            Product&lt;? extends B&gt; longType,
            Product&lt;? extends B&gt; booleanType,
            Product&lt;? extends B&gt; versionType) {
<span class="nc" id="L217">      return dateType.get1();</span>
    }
  }

<span class="fc" id="L221">  public static final class LongType extends ValueType&lt;Long&gt; {</span>
    @Override public TypedValue&lt;Long&gt; mk(Long a) {
<span class="fc" id="L223">      return Value.mk(a);</span>
    }

    @Override public &lt;B&gt; B match(
            Product&lt;? extends B&gt; stringType,
            Product&lt;? extends B&gt; dateType,
            Product&lt;? extends B&gt; longType,
            Product&lt;? extends B&gt; booleanType,
            Product&lt;? extends B&gt; versionType) {
<span class="nc" id="L232">      return longType.get1();</span>
    }
  }

<span class="fc" id="L236">  public static final class BooleanType extends ValueType&lt;Boolean&gt; {</span>
    @Override public TypedValue&lt;Boolean&gt; mk(Boolean a) {
<span class="fc" id="L238">      return Value.mk(a);</span>
    }

    @Override public &lt;B&gt; B match(
            Product&lt;? extends B&gt; stringType,
            Product&lt;? extends B&gt; dateType,
            Product&lt;? extends B&gt; longType,
            Product&lt;? extends B&gt; booleanType,
            Product&lt;? extends B&gt; versionType) {
<span class="nc" id="L247">      return booleanType.get1();</span>
    }
  }

<span class="fc" id="L251">  public static final class VersionType extends ValueType&lt;Version&gt; {</span>
    @Override public TypedValue&lt;Version&gt; mk(Version a) {
<span class="nc" id="L253">      return Value.mk(a);</span>
    }

    @Override public &lt;B&gt; B match(
            Product&lt;? extends B&gt; stringType,
            Product&lt;? extends B&gt; dateType,
            Product&lt;? extends B&gt; longType,
            Product&lt;? extends B&gt; booleanType,
            Product&lt;? extends B&gt; versionType) {
<span class="nc" id="L262">      return versionType.get1();</span>
    }
  }

<span class="fc" id="L266">  public static final class UntypedType extends ValueType&lt;Object&gt; {</span>
    @Override public TypedValue&lt;Object&gt; mk(Object a) {
<span class="nc" id="L268">      throw new RuntimeException(&quot;Cannot create an untyped value&quot;);</span>
    }

    @Override public &lt;B&gt; B match(
            Product&lt;? extends B&gt; stringType,
            Product&lt;? extends B&gt; dateType,
            Product&lt;? extends B&gt; longType,
            Product&lt;? extends B&gt; booleanType,
            Product&lt;? extends B&gt; versionType) {
<span class="nc" id="L277">      throw new RuntimeException(&quot;Cannot match an untyped value type&quot;);</span>
    }
  }

  /* -------------------------------------------------------------------------------------------------------------- */

  //
  // Value classes
  //

  /** Helper type to reduce boilerplate code. */
  // CHECKSTYLE:OFF -&gt; class shall be public but not the constructor
  public static class TypedValue&lt;A&gt; extends Value {
    private final A value;

    /** It should not be possible to inherit from outside class {@link Value}. */
<span class="fc" id="L293">    private TypedValue(@Nonnull A value) {</span>
<span class="fc" id="L294">      this.value = value;</span>
<span class="fc" id="L295">    }</span>

    @Override public A get() {
<span class="fc" id="L298">      return value;</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L302">      return Objects.hash(value);</span>
    }

    // generic implementation of equals
    // since all wrapped types cannot equal each other this is safe
    @Override public boolean equals(Object that) {
<span class="pc bpc" id="L308" title="2 of 6 branches missed.">      return (this == that) || (that instanceof TypedValue &amp;&amp; eqFields((TypedValue) that));</span>
    }

    private boolean eqFields(TypedValue that) {
<span class="fc" id="L312">      return Objects.equals(value, that.value);</span>
    }

    @Override public String toString() {
<span class="fc" id="L316">      return format(&quot;%s(%s)&quot;, getClass().getSimpleName(), value);</span>
    }
  }
  // CHECKSTYLE:ON

  /**
   * A value of type {@link String}.
   */
  @Immutable
  public static final class StringValue extends TypedValue&lt;String&gt; {
    public StringValue(@Nonnull String value) {
<span class="fc" id="L327">      super(value);</span>
<span class="fc" id="L328">    }</span>
  }

  /**
   * A value of type {@link java.util.Date}.
   */
  public static final class DateValue extends TypedValue&lt;Date&gt; {
    public DateValue(@Nonnull Date value) {
<span class="fc" id="L336">      super(value);</span>
<span class="fc" id="L337">    }</span>
  }

  /**
   * A value of type {@link java.lang.Long}.
   */
  @Immutable
  public static final class LongValue extends TypedValue&lt;Long&gt; {
    public LongValue(@Nonnull Long value) {
<span class="fc" id="L346">      super(value);</span>
<span class="fc" id="L347">    }</span>
  }

  /**
   * A value of type {@link java.lang.Boolean}.
   */
  @Immutable
  public static final class BooleanValue extends TypedValue&lt;Boolean&gt; {
    public BooleanValue(@Nonnull Boolean value) {
<span class="fc" id="L356">      super(value);</span>
<span class="fc" id="L357">    }</span>
  }

  /**
   * A value of type {@link Version}.
   */
  @Immutable
  public static final class VersionValue extends TypedValue&lt;Version&gt; {
    public VersionValue(@Nonnull Version value) {
<span class="nc" id="L366">      super(value);</span>
<span class="nc" id="L367">    }</span>
  }

  /* -------------------------------------------------------------------------------------------------------------- */

  //
  // constructor methods
  //

  /** Create a new value of type {@link String}. */
  public static StringValue mk(String value) {
<span class="fc" id="L378">    return new StringValue(value);</span>
  }

  /** Create a new value of type {@link java.util.Date}. */
  public static DateValue mk(Date value) {
<span class="fc" id="L383">    return new DateValue(value);</span>
  }

  /** Create a new value of type {@link java.lang.Long}. */
  public static LongValue mk(Long value) {
<span class="fc" id="L388">    return new LongValue(value);</span>
  }

  /** Create a new value of type {@link java.lang.Boolean}. */
  public static BooleanValue mk(Boolean value) {
<span class="fc" id="L393">    return new BooleanValue(value);</span>
  }

  /** Create a new value of type {@link Version}. */
  public static VersionValue mk(Version value) {
<span class="nc" id="L398">    return new VersionValue(value);</span>
  }

  /** Generic constructor. Creates a value for any existing ValueType. */
  public static &lt;A&gt; TypedValue&lt;A&gt; mk(ValueType&lt;A&gt; mk, A a) {
<span class="fc" id="L403">    return mk.mk(a);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>