<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EventCommentDatabaseServiceImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-event-comment</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.event.comment.persistence</a> &gt; <span class="el_source">EventCommentDatabaseServiceImpl.java</span></div><h1>EventCommentDatabaseServiceImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.event.comment.persistence;

import static org.opencastproject.db.Queries.namedQuery;

import org.opencastproject.db.DBSession;
import org.opencastproject.db.DBSessionFactory;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Comment;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.rebuild.AbstractIndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildException;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildService;
import org.opencastproject.event.comment.EventComment;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.User;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.util.NotFoundException;

import org.apache.commons.lang3.tuple.Pair;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;

/**
 * Implements permanent storage for event comments.
 */
@Component(
    immediate = true,
    service = { EventCommentDatabaseService.class, IndexProducer.class },
    property = {
        &quot;service.description=Event Comment Database Service&quot;
    }
)
<span class="fc" id="L74">public class EventCommentDatabaseServiceImpl extends AbstractIndexProducer implements EventCommentDatabaseService {</span>
  /** Logging utilities */
<span class="fc" id="L76">  private static final Logger logger = LoggerFactory.getLogger(EventCommentDatabaseServiceImpl.class);</span>

  public static final String PERSISTENCE_UNIT = &quot;org.opencastproject.event.comment&quot;;

  /** Factory used to create {@link EntityManager}s for transactions */
  private EntityManagerFactory emf;

  private DBSessionFactory dbSessionFactory;
  private DBSession db;

  /** The security service used to retrieve organizations. */
  private OrganizationDirectoryService organizationDirectoryService;

  /** The security service used to run the security context with. */
  private SecurityService securityService;

  /** The user directory service */
  private UserDirectoryService userDirectoryService;

  /** The component context this bundle is running in. */
  private ComponentContext cc;

  /** The elasticsearch indices */
  private ElasticsearchIndex index;

  /** OSGi component activation callback */
  @Activate
  public void activate(ComponentContext cc) {
<span class="fc" id="L104">    logger.info(&quot;Activating persistence manager for event comments&quot;);</span>
<span class="fc" id="L105">    this.cc = cc;</span>
<span class="fc" id="L106">    db = dbSessionFactory.createSession(emf);</span>
<span class="fc" id="L107">  }</span>

  /** OSGi DI */
  @Reference(target = &quot;(osgi.unit.name=org.opencastproject.event.comment)&quot;)
  public void setEntityManagerFactory(EntityManagerFactory emf) {
<span class="fc" id="L112">    this.emf = emf;</span>
<span class="fc" id="L113">  }</span>

  @Reference
  public void setDBSessionFactory(DBSessionFactory dbSessionFactory) {
<span class="fc" id="L117">    this.dbSessionFactory = dbSessionFactory;</span>
<span class="fc" id="L118">  }</span>

  /**
   * OSGi callback to set the security context to run with.
   *
   * @param securityService
   *          The security service
   */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L128">    this.securityService = securityService;</span>
<span class="fc" id="L129">  }</span>

  /**
   * OSGi callback to set the user directory service.
   *
   * @param userDirectoryService
   *          the user directory service
   */
  @Reference
  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {
<span class="fc" id="L139">    this.userDirectoryService = userDirectoryService;</span>
<span class="fc" id="L140">  }</span>

  /**
   * OSGi callback to set the organization directory service.
   *
   * @param organizationDirectoryService
   *          the organization directory service
   */
  @Reference
  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectoryService) {
<span class="nc" id="L150">    this.organizationDirectoryService = organizationDirectoryService;</span>
<span class="nc" id="L151">  }</span>

  /**
   * OSgi callback for the Elasticsearch index.
   *
   * @param index
   *          the Elasticsearch index.
   */
  @Reference
  public void setIndex(ElasticsearchIndex index) {
<span class="fc" id="L161">    this.index = index;</span>
<span class="fc" id="L162">  }</span>

  @Override
  public List&lt;String&gt; getReasons() throws EventCommentDatabaseException {
    try {
<span class="nc" id="L167">      return db.exec(namedQuery.findAll(</span>
          &quot;EventComment.findReasons&quot;,
          String.class,
<span class="nc" id="L170">          Pair.of(&quot;org&quot;, securityService.getOrganization().getId())</span>
      ));
<span class="nc" id="L172">    } catch (Exception e) {</span>
<span class="nc" id="L173">      logger.error(&quot;Could not get reasons&quot;, e);</span>
<span class="nc" id="L174">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  @Override
  public EventComment getComment(long commentId) throws NotFoundException, EventCommentDatabaseException {
    try {
<span class="fc" id="L181">      Optional&lt;EventCommentDto&gt; event = db.exec(getEventCommentQuery(commentId));</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">      if (event.isEmpty()) {</span>
<span class="nc" id="L183">        throw new NotFoundException(&quot;Event comment with ID &quot; + commentId + &quot; does not exist&quot;);</span>
      }
<span class="fc" id="L185">      return event.get().toComment(userDirectoryService, organizationDirectoryService);</span>
<span class="nc" id="L186">    } catch (NotFoundException e) {</span>
<span class="nc" id="L187">      throw e;</span>
<span class="nc" id="L188">    } catch (Exception e) {</span>
<span class="nc" id="L189">      logger.error(&quot;Could not get event comment {}&quot;, commentId, e);</span>
<span class="nc" id="L190">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  @Override
  public void deleteComment(long commentId) throws NotFoundException, EventCommentDatabaseException {
    try {
<span class="nc" id="L197">      EventCommentDto event = db.execTxChecked(em -&gt; {</span>
<span class="nc" id="L198">        Optional&lt;EventCommentDto&gt; eventOpt = getEventCommentQuery(commentId).apply(em);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (eventOpt.isEmpty()) {</span>
<span class="nc" id="L200">          throw new NotFoundException(&quot;Event comment with ID &quot; + commentId + &quot; does not exist&quot;);</span>
        }
<span class="nc" id="L202">        em.remove(eventOpt.get());</span>
<span class="nc" id="L203">        return eventOpt.get();</span>
      });
<span class="nc" id="L205">      updateIndices(event.getEventId());</span>
<span class="nc" id="L206">    } catch (NotFoundException e) {</span>
<span class="nc" id="L207">      throw e;</span>
<span class="nc" id="L208">    } catch (Exception e) {</span>
<span class="nc" id="L209">      logger.error(&quot;Could not delete event comment&quot;, e);</span>
<span class="nc" id="L210">      throw new EventCommentDatabaseException(e);</span>
<span class="nc" id="L211">    }</span>
<span class="nc" id="L212">  }</span>

  @Override
  public void deleteComments(String eventId) throws NotFoundException, EventCommentDatabaseException {
    // Similar to deleteComment but we want to avoid sending a message for each deletion

<span class="nc" id="L218">    int count = 0;</span>
    try {
<span class="nc" id="L220">      count = db.execTxChecked(em -&gt; {</span>
<span class="nc" id="L221">        List&lt;EventComment&gt; comments = getComments(eventId);</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">        for (EventComment comment : comments) {</span>
<span class="nc" id="L224">          long commentId = comment.getId().get().intValue();</span>
<span class="nc" id="L225">          Optional&lt;EventCommentDto&gt; event = getEventCommentQuery(commentId).apply(em);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">          if (event.isEmpty()) {</span>
<span class="nc" id="L227">            throw new NotFoundException(&quot;Event comment with ID &quot; + commentId + &quot; does not exist&quot;);</span>
          }
<span class="nc" id="L229">          em.remove(event.get());</span>
<span class="nc" id="L230">        }</span>

<span class="nc" id="L232">        return comments.size();</span>
      });
<span class="nc" id="L234">    } catch (NotFoundException e) {</span>
<span class="nc" id="L235">      throw e;</span>
<span class="nc" id="L236">    } catch (Exception e) {</span>
<span class="nc" id="L237">      logger.error(&quot;Could not delete event comments&quot;, e);</span>
<span class="nc" id="L238">      throw new EventCommentDatabaseException(e);</span>
<span class="nc" id="L239">    }</span>

    // send updates only if we actually modified anything
<span class="nc bnc" id="L242" title="All 2 branches missed.">    if (count &gt; 0) {</span>
<span class="nc" id="L243">      updateIndices(eventId);</span>
    }
<span class="nc" id="L245">  }</span>

  @Override
  public EventComment updateComment(EventComment comment) throws EventCommentDatabaseException {
    try {
<span class="fc" id="L250">      final EventCommentDto commentDto = EventCommentDto.from(comment);</span>
<span class="fc" id="L251">      final EventComment updatedComment = db.execTx(namedQuery.persistOrUpdate(commentDto))</span>
<span class="fc" id="L252">          .toComment(userDirectoryService, organizationDirectoryService);</span>
<span class="fc" id="L253">      updateIndices(updatedComment.getEventId());</span>
<span class="fc" id="L254">      return updatedComment;</span>
<span class="nc" id="L255">    } catch (Exception e) {</span>
<span class="nc" id="L256">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  /**
   * Gets an event comment, using the current organizational context.
   *
   * @param commentId
   *          the comment identifier
   *
   * @return the event comment entity, or null if not found
   */
  private Function&lt;EntityManager, Optional&lt;EventCommentDto&gt;&gt; getEventCommentQuery(long commentId) {
<span class="fc" id="L269">    return namedQuery.findOpt(</span>
        &quot;EventComment.findByCommentId&quot;,
        EventCommentDto.class,
<span class="fc" id="L272">        Pair.of(&quot;commentId&quot;, commentId)</span>
    );
  }

  @Override
  public List&lt;EventComment&gt; getComments(String eventId) throws EventCommentDatabaseException {
    try {
<span class="fc" id="L279">      return db.exec(namedQuery.findAll(</span>
          &quot;EventComment.findByEvent&quot;,
              EventCommentDto.class,
<span class="fc" id="L282">              Pair.of(&quot;eventId&quot;, eventId),</span>
<span class="fc" id="L283">              Pair.of(&quot;org&quot;, securityService.getOrganization().getId())</span>
<span class="fc" id="L284">          )).stream()</span>
<span class="fc" id="L285">          .map(c -&gt; c.toComment(userDirectoryService, organizationDirectoryService))</span>
<span class="fc" id="L286">          .sorted((c1, c2) -&gt; {</span>
<span class="nc" id="L287">            boolean v1 = c1.isResolvedStatus();</span>
<span class="nc" id="L288">            boolean v2 = c2.isResolvedStatus();</span>
<span class="nc bnc" id="L289" title="All 4 branches missed.">            return (v1 ^ v2) ? ((v1 ^ false) ? 1 : -1) : 0;</span>
          })
<span class="fc" id="L291">          .collect(Collectors.toList());</span>
<span class="nc" id="L292">    } catch (Exception e) {</span>
<span class="nc" id="L293">      logger.error(&quot;Could not retreive comments for event {}&quot;, eventId, e);</span>
<span class="nc" id="L294">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  public Iterator&lt;EventCommentDto&gt; getComments() throws EventCommentDatabaseException {
    try {
<span class="nc" id="L300">      return db.exec(namedQuery.findAll(&quot;EventComment.findAll&quot;, EventCommentDto.class)).iterator();</span>
<span class="nc" id="L301">    } catch (Exception e) {</span>
<span class="nc" id="L302">      logger.error(&quot;Could not retreive event comments&quot;, e);</span>
<span class="nc" id="L303">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  public int countComments() throws EventCommentDatabaseException {
    try {
<span class="nc" id="L309">      return db.exec(namedQuery.find(&quot;EventComment.countAll&quot;, Number.class)).intValue();</span>
<span class="nc" id="L310">    } catch (Exception e) {</span>
<span class="nc" id="L311">      logger.error(&quot;Could not find the number of comments.&quot;, e);</span>
<span class="nc" id="L312">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  /**
   * Return all known event ID's with existing comments, grouped by organization ID
   *
   * @return a list of all event ID's grouped by organization ID
   */
  public Map&lt;String, List&lt;String&gt;&gt; getEventsWithComments() {
<span class="fc" id="L322">    List&lt;Object[]&gt; orgIDsEventIDs = db.exec(namedQuery.findAll(&quot;EventComment.findAllWIthOrg&quot;, Object[].class));</span>
<span class="fc" id="L323">    Map&lt;String, List&lt;String&gt;&gt; orgEventsMap = new Hashtable&lt;&gt;();</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">    for (Object[] orgEventResult : orgIDsEventIDs) {</span>
<span class="fc" id="L325">      String orgId = (String) orgEventResult[0];</span>
<span class="fc" id="L326">      String eventId = (String) orgEventResult[1];</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">      if (!orgEventsMap.containsKey(orgId)) {</span>
<span class="fc" id="L328">        List&lt;String&gt; eventIds = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L329">        eventIds.add(eventId);</span>
<span class="fc" id="L330">        orgEventsMap.put(orgId, eventIds);</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">      } else if (!orgEventsMap.get(orgId).contains(eventId)) {</span>
<span class="fc" id="L332">        orgEventsMap.get(orgId).add(eventId);</span>
      }
<span class="fc" id="L334">    }</span>
<span class="fc" id="L335">    return orgEventsMap;</span>
  }

  private void updateIndices(String eventId) throws EventCommentDatabaseException {
<span class="fc" id="L339">    List&lt;EventComment&gt; comments = getComments(eventId);</span>
<span class="fc" id="L340">    boolean hasOpenComments = comments.stream().anyMatch(filterOpenComments::apply);</span>
<span class="fc" id="L341">    boolean needsCutting = comments.stream().anyMatch(filterNeedsCuttingComment::apply);</span>

<span class="fc" id="L343">    String organization = securityService.getOrganization().getId();</span>
<span class="fc" id="L344">    User user = securityService.getUser();</span>

<span class="fc bfc" id="L346" title="All 2 branches covered.">    updateIndex(eventId, !comments.isEmpty(), hasOpenComments, comments, needsCutting, organization, user);</span>
<span class="fc" id="L347">  }</span>

  private void updateIndex(String eventId, boolean hasComments, boolean hasOpenComments, List&lt;EventComment&gt; comments,
          boolean needsCutting, String organization, User user) {
<span class="fc" id="L351">    logger.debug(&quot;Updating comment status of event {} in the {} index.&quot;, eventId, index.getIndexName());</span>
<span class="pc bpc" id="L352" title="1 of 4 branches missed.">    if (!hasComments &amp;&amp; hasOpenComments) {</span>
<span class="nc" id="L353">      throw new IllegalStateException(</span>
              &quot;Invalid comment update request: You can't have open comments without having any comments!&quot;);
    }
<span class="pc bpc" id="L356" title="1 of 4 branches missed.">    if (!hasOpenComments &amp;&amp; needsCutting) {</span>
<span class="nc" id="L357">      throw new IllegalStateException(</span>
              &quot;Invalid comment update request: You can't have an needs cutting comment without having any open &quot;
                      + &quot;comments!&quot;);
    }

<span class="fc" id="L362">    Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; updateFunction = (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">      if (eventOpt.isEmpty()) {</span>
<span class="nc" id="L364">        logger.debug(&quot;Event {} not found for comment status updating&quot;, eventId);</span>
<span class="nc" id="L365">        return Optional.empty();</span>
      }
<span class="nc" id="L367">      Event event = eventOpt.get();</span>
<span class="nc" id="L368">      event.setHasComments(hasComments);</span>
<span class="nc" id="L369">      event.setHasOpenComments(hasOpenComments);</span>
<span class="nc" id="L370">      List&lt;Comment&gt; indexComments = new ArrayList&lt;Comment&gt;();</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">      for (EventComment comment : comments) {</span>
<span class="nc" id="L372">        indexComments.add(new Comment(</span>
<span class="nc" id="L373">                comment.getId().get().toString(), comment.getReason(), comment.getText(), comment.isResolvedStatus()</span>
        ));
        // Do we want to include replies? Maybe not, no good reason to filter for them?
<span class="nc" id="L376">      }</span>
<span class="nc" id="L377">      event.setComments(indexComments);</span>
<span class="nc" id="L378">      event.setNeedsCutting(needsCutting);</span>
<span class="nc" id="L379">      return Optional.of(event);</span>
    };

    try {
<span class="fc" id="L383">      index.addOrUpdateEvent(eventId, updateFunction, organization, user);</span>
<span class="nc" id="L384">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L385">      logger.error(&quot;Error updating comment status of event {} in the {} index:&quot;, eventId, index.getIndexName(), e);</span>
<span class="fc" id="L386">    }</span>
<span class="fc" id="L387">  }</span>

<span class="fc" id="L389">  private static final Function&lt;EventComment, Boolean&gt; filterOpenComments = new Function&lt;EventComment, Boolean&gt;() {</span>
    @Override
    public Boolean apply(EventComment comment) {
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">      return !comment.isResolvedStatus();</span>
    }
  };

<span class="fc" id="L396">  private static final Function&lt;EventComment, Boolean&gt; filterNeedsCuttingComment =</span>
<span class="fc" id="L397">      new Function&lt;EventComment, Boolean&gt;() {</span>
    @Override
    public Boolean apply(EventComment comment) {
<span class="pc bpc" id="L400" title="3 of 4 branches missed.">      return EventComment.REASON_NEEDS_CUTTING.equals(comment.getReason()) &amp;&amp; !comment.isResolvedStatus();</span>
    }
  };

  @Override
  public void repopulate(IndexRebuildService.DataType type) throws IndexRebuildException {
    try {
<span class="nc" id="L407">      final int total = countComments();</span>
<span class="nc" id="L408">      logIndexRebuildBegin(logger, total, &quot;events with comment&quot;);</span>
<span class="nc" id="L409">      final int[] current = new int[1];</span>
<span class="nc" id="L410">      current[0] = 0;</span>
<span class="nc" id="L411">      int n = 20;</span>
<span class="nc" id="L412">      var updatedEventRange = new ArrayList&lt;Event&gt;();</span>

<span class="nc" id="L414">      final Map&lt;String, List&lt;String&gt;&gt; eventsWithComments = getEventsWithComments();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">      for (String orgId : eventsWithComments.keySet()) {</span>
<span class="nc" id="L416">        Organization organization = organizationDirectoryService.getOrganization(orgId);</span>
<span class="nc" id="L417">        User systemUser = SecurityUtil.createSystemUser(cc, organization);</span>
<span class="nc" id="L418">        SecurityUtil.runAs(securityService, organization, systemUser,</span>
                () -&gt; {
<span class="nc" id="L420">                  int i = 0;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                  for (String eventId : eventsWithComments.get(orgId)) {</span>
                    try {
<span class="nc" id="L423">                      current[0] += getComments(eventId).size();</span>
<span class="nc" id="L424">                      i++;</span>

<span class="nc" id="L426">                      var updatedEventData = index.getEvent(eventId, orgId, securityService.getUser());</span>
<span class="nc" id="L427">                      updatedEventData = getEventUpdateFunction(eventId).apply(updatedEventData);</span>
<span class="nc" id="L428">                      updatedEventData.ifPresent(updatedEventRange::add);</span>

<span class="nc bnc" id="L430" title="All 4 branches missed.">                      if (updatedEventRange.size() &gt;= n || i &gt;= eventsWithComments.get(orgId).size()) {</span>
<span class="nc" id="L431">                        index.bulkEventUpdate(updatedEventRange);</span>
<span class="nc" id="L432">                        logIndexRebuildProgress(logger, total, current[0], n);</span>
<span class="nc" id="L433">                        updatedEventRange.clear();</span>
                      }
<span class="nc" id="L435">                    } catch (Throwable t) {</span>
<span class="nc" id="L436">                      logSkippingElement(logger, &quot;comment of event&quot;, eventId, organization, t);</span>
<span class="nc" id="L437">                    }</span>
<span class="nc" id="L438">                  }</span>
<span class="nc" id="L439">                });</span>
<span class="nc" id="L440">      }</span>
<span class="nc" id="L441">    } catch (Exception e) {</span>
<span class="nc" id="L442">      logIndexRebuildError(logger, e);</span>
<span class="nc" id="L443">      throw new IndexRebuildException(getService(), e);</span>
<span class="nc" id="L444">    }</span>
<span class="nc" id="L445">  }</span>

  @Override
  public IndexRebuildService.Service getService() {
<span class="nc" id="L449">    return IndexRebuildService.Service.Comments;</span>
  }
  /**
   * Get the function to update a commented event in the Elasticsearch index.
   *
   * @param eventId
   *          The id of the current event
   * @return the function to do the update
   */
  private Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; getEventUpdateFunction(String eventId) {
<span class="nc" id="L459">    return (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
      List&lt;EventComment&gt; comments;
      try {
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (eventOpt.isEmpty()) {</span>
<span class="nc" id="L463">          logger.debug(&quot;Event {} not found for comment status updating&quot;, eventId);</span>
<span class="nc" id="L464">          return Optional.empty();</span>
        }
<span class="nc" id="L466">        comments = getComments(eventId);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">        Boolean hasComments = !comments.isEmpty();</span>
<span class="nc" id="L468">        boolean hasOpenComments = comments.stream().anyMatch(filterOpenComments::apply);</span>
<span class="nc" id="L469">        boolean needsCutting = comments.stream().anyMatch(filterNeedsCuttingComment::apply);</span>

<span class="nc" id="L471">        logger.debug(&quot;Updating comment status of event {} in the {} index.&quot;, eventId, index.getIndexName());</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">        if (!hasComments &amp;&amp; hasOpenComments) {</span>
<span class="nc" id="L473">          throw new IllegalStateException(</span>
                  &quot;Invalid comment update request: You can't have open comments without having any comments!&quot;);
        }
<span class="nc bnc" id="L476" title="All 4 branches missed.">        if (!hasOpenComments &amp;&amp; needsCutting) {</span>
<span class="nc" id="L477">          throw new IllegalStateException(</span>
                  &quot;Invalid comment update request: You can't have an needs cutting comment without having any open &quot;
                          + &quot;comments!&quot;);
        }
<span class="nc" id="L481">        Event event = eventOpt.get();</span>
<span class="nc" id="L482">        event.setHasComments(hasComments);</span>
<span class="nc" id="L483">        event.setHasOpenComments(hasOpenComments);</span>
<span class="nc" id="L484">        List&lt;Comment&gt; indexComments = new ArrayList&lt;Comment&gt;();</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">        for (EventComment comment : comments) {</span>
<span class="nc" id="L486">          indexComments.add(new Comment(</span>
<span class="nc" id="L487">                  comment.getId().get().toString(), comment.getReason(), comment.getText(), comment.isResolvedStatus()</span>
          ));
          // Do we want to include replies? Maybe not, no good reason to filter for them?
<span class="nc" id="L490">        }</span>
<span class="nc" id="L491">        event.setComments(indexComments);</span>
<span class="nc" id="L492">        event.setNeedsCutting(needsCutting);</span>
<span class="nc" id="L493">        return Optional.of(event);</span>
<span class="nc" id="L494">      } catch (EventCommentDatabaseException e) {</span>
<span class="nc" id="L495">        logger.error(&quot;Unable to get comments from event {}&quot;, eventId, e);</span>
<span class="nc" id="L496">        return Optional.empty();</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>