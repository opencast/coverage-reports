<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LiveScheduleServiceImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-live-schedule-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.liveschedule.impl</a> &gt; <span class="el_source">LiveScheduleServiceImpl.java</span></div><h1>LiveScheduleServiceImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.liveschedule.impl;

import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.Snapshot;
import org.opencastproject.assetmanager.api.Version;
import org.opencastproject.capture.admin.api.CaptureAgentStateService;
import org.opencastproject.distribution.api.DistributionException;
import org.opencastproject.distribution.api.DownloadDistributionService;
import org.opencastproject.job.api.Job;
import org.opencastproject.job.api.JobBarrier;
import org.opencastproject.liveschedule.api.LiveScheduleException;
import org.opencastproject.liveschedule.api.LiveScheduleService;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementBuilder;
import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.Publication;
import org.opencastproject.mediapackage.PublicationImpl;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.VideoStream;
import org.opencastproject.mediapackage.selector.SimpleElementSelector;
import org.opencastproject.mediapackage.track.TrackImpl;
import org.opencastproject.mediapackage.track.VideoStreamImpl;
import org.opencastproject.metadata.dublincore.DCMIPeriod;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreCatalogService;
import org.opencastproject.metadata.dublincore.EncodingSchemeUtils;
import org.opencastproject.search.api.SearchService;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AclScope;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.api.User;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.series.api.SeriesService;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.util.MimeTypes;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.workspace.api.Workspace;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.Equator;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.client.utils.URIUtils;
import org.osgi.framework.BundleContext;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Component(
    immediate = true,
    service = LiveScheduleService.class,
    property = {
        &quot;service.description=Live Schedule Service&quot;
    }
)
<span class="fc" id="L114">public class LiveScheduleServiceImpl implements LiveScheduleService {</span>
  /** The server url property **/
  static final String SERVER_URL_PROPERTY = &quot;org.opencastproject.server.url&quot;;
  /** The engage base url property **/
  static final String ENGAGE_URL_PROPERTY = &quot;org.opencastproject.engage.ui.url&quot;;
  /** The default path to the player **/
  static final String PLAYER_PATH = &quot;/play/&quot;;

  /** Default values for configuration options */
  private static final String DEFAULT_STREAM_MIME_TYPE = &quot;video/mp4&quot;;
  private static final String DEFAULT_STREAM_RESOLUTION = &quot;1920x1080&quot;;
  private static final String DEFAULT_STREAM_NAME = &quot;live-stream&quot;;
  private static final String DEFAULT_LIVE_TARGET_FLAVORS = &quot;presenter/delivery&quot;;
  static final String DEFAULT_LIVE_DISTRIBUTION_SERVICE = &quot;download&quot;;

  // Deactivating checkstyle to preserve the long URL
  // CHECKSTYLE:OFF
  // If the capture agent registered this property, we expect to get a resolution and
  // a url in the following format:
  // capture.device.live.resolution.WIDTHxHEIGHT=COMPLETE_STREAMING_URL e.g.
  // capture.device.live.resolution.960x270=rtmp://cp398121.live.edgefcs.net/live/dev-epiphan005-2-presenter-delivery.stream-960x270_1_200@355694
  public static final String CA_PROPERTY_RESOLUTION_URL_PREFIX = &quot;capture.device.live.resolution.&quot;;
  // CHECKSTYLE:ON

  /** Variables that can be replaced in stream name */
  public static final String REPLACE_ID = &quot;id&quot;;
  public static final String REPLACE_FLAVOR = &quot;flavor&quot;;
  public static final String REPLACE_CA_NAME = &quot;caName&quot;;
  public static final String REPLACE_RESOLUTION = &quot;resolution&quot;;

  public static final String LIVE_STREAMING_URL = &quot;live.streamingUrl&quot;;
  public static final String LIVE_STREAM_NAME = &quot;live.streamName&quot;;
  public static final String LIVE_STREAM_MIME_TYPE = &quot;live.mimeType&quot;;
  public static final String LIVE_STREAM_RESOLUTION = &quot;live.resolution&quot;;
  public static final String LIVE_TARGET_FLAVORS = &quot;live.targetFlavors&quot;;
  public static final String LIVE_DISTRIBUTION_SERVICE = &quot;live.distributionService&quot;;
  public static final String LIVE_PUBLISH_STREAMING = &quot;live.publishStreaming&quot;;

<span class="fc" id="L152">  private static final MediaPackageElementFlavor[] publishFlavors = { MediaPackageElements.EPISODE,</span>
      MediaPackageElements.SERIES, MediaPackageElements.XACML_POLICY_EPISODE,
      MediaPackageElements.XACML_POLICY_SERIES }; // make configurable later

  /** The logger */
<span class="fc" id="L157">  private static final Logger logger = LoggerFactory.getLogger(LiveScheduleServiceImpl.class);</span>

  private String liveStreamingUrl;
  private String streamName;
  private String streamMimeType;
  private String[] streamResolution;
  private MediaPackageElementFlavor[] liveFlavors;
  private String serverUrl;
<span class="fc" id="L165">  private Cache&lt;String, Version&gt; snapshotVersionCache</span>
<span class="fc" id="L166">      = CacheBuilder.newBuilder().expireAfterWrite(5, TimeUnit.MINUTES).build();</span>
  /** Which streaming formats should be published automatically */
<span class="fc" id="L168">  private List&lt;String&gt; publishedStreamingFormats = null;</span>
  private String systemUserName;

  /** Services */
  private DownloadDistributionService downloadDistributionService; // to distribute episode and series catalogs
  private SearchService searchService; // to publish/retract live media package
  private SeriesService seriesService; // to get series metadata
  private DublinCoreCatalogService dublinCoreService; // to setialize dc catalogs
  private CaptureAgentStateService captureAgentService; // to get agent capabilities
  private ServiceRegistry serviceRegistry; // to create publish/retract jobs
  private Workspace workspace; // to save dc catalogs before distributing
  private AssetManager assetManager; // to get current media package
  private AuthorizationService authService;
  private OrganizationDirectoryService organizationService;
  private SecurityService securityService;

<span class="fc" id="L184">  private long jobPollingInterval = JobBarrier.DEFAULT_POLLING_INTERVAL;</span>

  private SimpleElementSelector publishElementSelector;

  /**
   * OSGi callback on component activation.
   *
   * @param context
   *          the component context
   */
  @Activate
  protected void activate(ComponentContext context) {
<span class="fc" id="L196">    BundleContext bundleContext = context.getBundleContext();</span>

<span class="fc" id="L198">    serverUrl = StringUtils.trimToNull(bundleContext.getProperty(SERVER_URL_PROPERTY));</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">    if (serverUrl == null) {</span>
<span class="fc" id="L200">      logger.warn(&quot;Server url was not set in '{}'&quot;, SERVER_URL_PROPERTY);</span>
    } else {
<span class="nc" id="L202">      logger.info(&quot;Server url is {}&quot;, serverUrl);</span>
    }
<span class="fc" id="L204">    systemUserName = bundleContext.getProperty(SecurityUtil.PROPERTY_KEY_SYS_USER);</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L207">    Dictionary properties = context.getProperties();</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">    if (!StringUtils.isBlank((String) properties.get(LIVE_STREAMING_URL))) {</span>
<span class="fc" id="L209">      liveStreamingUrl = StringUtils.trimToEmpty((String) properties.get(LIVE_STREAMING_URL));</span>
<span class="fc" id="L210">      logger.info(&quot;Live streaming server url is {}&quot;, liveStreamingUrl);</span>
    } else {
<span class="nc" id="L212">      logger.info(&quot;Live streaming url not set in '{}'. Streaming urls must be provided by capture agent properties.&quot;,</span>
              LIVE_STREAMING_URL);
    }

<span class="pc bpc" id="L216" title="1 of 2 branches missed.">    if (!StringUtils.isBlank((String) properties.get(LIVE_STREAM_NAME))) {</span>
<span class="fc" id="L217">      streamName = StringUtils.trimToEmpty((String) properties.get(LIVE_STREAM_NAME));</span>
    } else {
<span class="nc" id="L219">      streamName = DEFAULT_STREAM_NAME;</span>
    }

<span class="pc bpc" id="L222" title="1 of 2 branches missed.">    if (!StringUtils.isBlank((String) properties.get(LIVE_STREAM_MIME_TYPE))) {</span>
<span class="fc" id="L223">      streamMimeType = StringUtils.trimToEmpty((String) properties.get(LIVE_STREAM_MIME_TYPE));</span>
    } else {
<span class="nc" id="L225">      streamMimeType = DEFAULT_STREAM_MIME_TYPE;</span>
    }

<span class="fc" id="L228">    String resolution = null;</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">    if (!StringUtils.isBlank((String) properties.get(LIVE_STREAM_RESOLUTION))) {</span>
<span class="fc" id="L230">      resolution = StringUtils.trimToEmpty((String) properties.get(LIVE_STREAM_RESOLUTION));</span>
    } else {
<span class="nc" id="L232">      resolution = DEFAULT_STREAM_RESOLUTION;</span>
    }
<span class="fc" id="L234">    streamResolution = resolution.split(&quot;,&quot;);</span>

<span class="fc" id="L236">    String flavors = null;</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">    if (!StringUtils.isBlank((String) properties.get(LIVE_TARGET_FLAVORS))) {</span>
<span class="fc" id="L238">      flavors = StringUtils.trimToEmpty((String) properties.get(LIVE_TARGET_FLAVORS));</span>
    } else {
<span class="nc" id="L240">      flavors = DEFAULT_LIVE_TARGET_FLAVORS;</span>
    }
<span class="fc" id="L242">    String[] flavorArray = StringUtils.split(flavors, &quot;,&quot;);</span>
<span class="fc" id="L243">    liveFlavors = new MediaPackageElementFlavor[flavorArray.length];</span>
<span class="fc" id="L244">    int i = 0;</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">    for (String f : flavorArray) {</span>
<span class="fc" id="L246">      liveFlavors[i++] = MediaPackageElementFlavor.parseFlavor(f);</span>
    }

<span class="fc" id="L249">    publishedStreamingFormats = Arrays.asList(Optional.ofNullable(StringUtils.split(</span>
<span class="fc" id="L250">            (String)properties.get(LIVE_PUBLISH_STREAMING), &quot;,&quot;)).orElse(new String[0]));</span>

<span class="fc" id="L252">    publishElementSelector = new SimpleElementSelector();</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">    for (MediaPackageElementFlavor flavor : publishFlavors) {</span>
<span class="fc" id="L254">      publishElementSelector.addFlavor(flavor);</span>
    }

<span class="fc" id="L257">    logger.info(</span>
            &quot;Configured live stream name: {}, mime type: {}, resolution: {}, target flavors: {}&quot;,
            streamName, streamMimeType, resolution, flavors);
<span class="fc" id="L260">  }</span>

  @Override
  public boolean createOrUpdateLiveEvent(String mpId, DublinCoreCatalog episodeDC) throws LiveScheduleException {
<span class="fc" id="L264">    MediaPackage mp = getMediaPackageFromSearch(mpId);</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">    if (mp == null) {</span>
      // Check if capture not over. We have to check because we may get a notification for past events if
      // the admin ui index is rebuilt
<span class="fc" id="L268">      DCMIPeriod period = EncodingSchemeUtils.decodeMandatoryPeriod(episodeDC.getFirst(DublinCore.PROPERTY_TEMPORAL));</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">      if (period.getEnd().getTime() &lt;= System.currentTimeMillis()) {</span>
<span class="fc" id="L270">        logger.info(&quot;Live media package {} not created in search index because event is already past (end date: {})&quot;,</span>
<span class="fc" id="L271">                mpId, period.getEnd());</span>
<span class="fc" id="L272">        return false;</span>
      }
<span class="nc" id="L274">      return createLiveEvent(mpId, episodeDC);</span>
    } else {
      // Check if the media package found in the search index is live. We have to check because we may get a
      // notification for past events if the admin ui index is rebuilt
<span class="nc bnc" id="L278" title="All 2 branches missed.">      if (!mp.isLive()) {</span>
<span class="nc" id="L279">        logger.info(&quot;Media package {} is in search index but not live so not updating it.&quot;, mpId);</span>
<span class="nc" id="L280">        return false;</span>
      }
<span class="nc" id="L282">      return updateLiveEvent(mp, episodeDC);</span>
    }
  }

  @Override
  public boolean deleteLiveEvent(String mpId) throws LiveScheduleException {
<span class="nc" id="L288">    MediaPackage mp = getMediaPackageFromSearch(mpId);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">    if (mp == null) {</span>
<span class="nc" id="L290">      logger.debug(&quot;Live media package {} not found in search index&quot;, mpId);</span>
<span class="nc" id="L291">      return false;</span>
    } else {
<span class="nc bnc" id="L293" title="All 2 branches missed.">      if (!mp.isLive()) {</span>
<span class="nc" id="L294">        logger.info(&quot;Media package {} is not live. Not retracting.&quot;, mpId);</span>
<span class="nc" id="L295">        return false;</span>
      }
<span class="nc" id="L297">      return retractLiveEvent(mp);</span>
    }
  }

  @Override
  public boolean updateLiveEventAcl(String mpId, AccessControlList acl) throws LiveScheduleException {
<span class="nc" id="L303">    MediaPackage previousMp = getMediaPackageFromSearch(mpId);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">    if (previousMp != null) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">      if (!previousMp.isLive()) {</span>
<span class="nc" id="L306">        logger.info(&quot;Media package {} is not live. Not updating acl.&quot;, mpId);</span>
<span class="nc" id="L307">        return false;</span>
      }
      // Replace and distribute acl, this creates new mp
<span class="nc" id="L310">      MediaPackage newMp = replaceAndDistributeAcl(previousMp, acl);</span>
      // Publish mp to engage search index
<span class="nc" id="L312">      publishToSearch(newMp);</span>
      // Don't leave garbage there!
<span class="nc" id="L314">      retractPreviousElements(previousMp, newMp);</span>
<span class="nc" id="L315">      logger.info(&quot;Updated live acl for media package {}&quot;, newMp);</span>
<span class="nc" id="L316">      return true;</span>
    }
<span class="nc" id="L318">    return false;</span>
  }

  boolean createLiveEvent(String mpId, DublinCoreCatalog episodeDC) throws LiveScheduleException {
    try {
<span class="fc" id="L323">      logger.info(&quot;Creating live media package {}&quot;, mpId);</span>
<span class="fc" id="L324">      Snapshot snapshot = getSnapshotFromArchive(mpId);</span>

      // generate live tracks
<span class="fc" id="L327">      MediaPackage tmpMp = (MediaPackage) snapshot.getMediaPackage().clone();</span>
<span class="fc" id="L328">      setDurationForMediaPackage(tmpMp, episodeDC); // duration is used by live tracks</span>
<span class="fc" id="L329">      Map&lt;String, Track&gt; liveTracks = addLiveTracksToMediaPackage(tmpMp, episodeDC);</span>

      // publish to search
<span class="fc" id="L332">      MediaPackage mpForSearch = distributeAclsAndCatalogs(snapshot);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">      for (Track t : tmpMp.getTracks()) {</span>
<span class="fc" id="L334">        mpForSearch.add(t);</span>
      }
<span class="fc" id="L336">      publishToSearch(mpForSearch);</span>

      // add live publication to archive
<span class="fc" id="L339">      MediaPackage updatedArchivedMp = addLivePublicationToMediaPackage(snapshot, liveTracks);</span>
<span class="fc" id="L340">      snapshotVersionCache.put(mpId, assetManager.takeSnapshot(updatedArchivedMp).getVersion());</span>
<span class="fc" id="L341">      return true;</span>
<span class="nc" id="L342">    } catch (Exception e) {</span>
<span class="nc" id="L343">      throw new LiveScheduleException(e);</span>
    }
  }

  boolean updateLiveEvent(MediaPackage mpFromSearch, DublinCoreCatalog episodeDC) throws LiveScheduleException {
<span class="fc" id="L348">    String mpId = mpFromSearch.getIdentifier().toString();</span>
<span class="fc" id="L349">    Snapshot snapshot = getSnapshotFromArchive(mpId);</span>

    // If the snapshot version is in our local cache, it means that this snapshot was created by us so
    // nothing to do. Note that this is just to save time; if the entry has already been deleted, the mp
    // will be compared below.
<span class="fc bfc" id="L354" title="All 2 branches covered.">    if (snapshot.getVersion().equals(snapshotVersionCache.getIfPresent(mpId))) {</span>
<span class="fc" id="L355">      logger.debug(&quot;Snapshot version {} was created by us so this change is ignored.&quot;, snapshot.getVersion());</span>
<span class="fc" id="L356">      return false;</span>
    }

    // create temp mp for comparison
<span class="fc" id="L360">    MediaPackage tmpMp = (MediaPackage) snapshot.getMediaPackage().clone();</span>
    // remove all elements that would not be published
<span class="fc" id="L362">    Collection&lt;MediaPackageElement&gt; elements = publishElementSelector.select(tmpMp, false);</span>
<span class="fc" id="L363">    Arrays.stream(tmpMp.getElements()).filter(Predicate.not(elements::contains)).collect(Collectors.toList())</span>
<span class="fc" id="L364">            .forEach(tmpMp::remove);</span>
    // generate new live tracks
<span class="fc" id="L366">    setDurationForMediaPackage(tmpMp, episodeDC); // duration is used by live tracks</span>
<span class="fc" id="L367">    Map&lt;String, Track&gt; liveTracks = addLiveTracksToMediaPackage(tmpMp, episodeDC);</span>

    // if nothing changed, no need to do anything
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">    if (isSameMediaPackage(mpFromSearch, tmpMp)) {</span>
<span class="nc" id="L371">      logger.debug(&quot;Live media package {} seems to be the same. Not updating.&quot;, mpFromSearch);</span>
<span class="nc" id="L372">      return false;</span>
    }

<span class="fc" id="L375">    logger.info(&quot;Updating live media package {}&quot;, mpFromSearch);</span>

    // update mp in search
<span class="fc" id="L378">    MediaPackage mpForSearch = distributeAclsAndCatalogs(snapshot);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">    for (Track t : tmpMp.getTracks()) {</span>
<span class="fc" id="L380">      mpForSearch.add(t);</span>
    }
<span class="fc" id="L382">    removeLivePublicationChannel(mpForSearch); // we don't need the live publication in search</span>
<span class="fc" id="L383">    publishToSearch(mpForSearch);</span>
<span class="fc" id="L384">    retractPreviousElements(mpFromSearch, mpForSearch); // cleanup</span>

    // update live publication in archive
<span class="fc" id="L387">    MediaPackage updatedArchivedMp = updateLivePublication(snapshot.getMediaPackage(), liveTracks);</span>
<span class="fc" id="L388">    snapshotVersionCache.put(mpId, assetManager.takeSnapshot(updatedArchivedMp).getVersion());</span>
<span class="fc" id="L389">    return true;</span>
  }

  private void createOrUpdatePublicationTracks(Publication publication, Map&lt;String, Track&gt; generatedTracks) {
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">    if (publication.getTracks().length &gt; 0) {</span>
<span class="nc" id="L394">      publication.clearTracks();</span>
    }

<span class="pc bpc" id="L397" title="1 of 2 branches missed.">    for (String publishedStreamingFormat : publishedStreamingFormats) {</span>
<span class="nc" id="L398">      Track track = generatedTracks.get(publishedStreamingFormat);</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">      if (track != null) {</span>
<span class="nc" id="L400">        publication.addTrack(track);</span>
      }
<span class="nc" id="L402">    }</span>
<span class="fc" id="L403">  }</span>

  private MediaPackage updateLivePublication(MediaPackage mediaPackage, Map&lt;String, Track&gt; generatedTracks) {
<span class="fc" id="L406">    Publication[] publications = mediaPackage.getPublications();</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">    for (Publication publication : publications) {</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">      if (publication.getChannel().equals(CHANNEL_ID)) {</span>
<span class="fc" id="L409">        createOrUpdatePublicationTracks(publication, generatedTracks);</span>
      }
    }
<span class="fc" id="L412">    return mediaPackage;</span>
  }

  boolean retractLiveEvent(MediaPackage mp) throws LiveScheduleException {
<span class="fc" id="L416">    retract(mp);</span>

    // Get latest mp from the asset manager if there to remove the publication
    try {
<span class="fc" id="L420">      String mpId = mp.getIdentifier().toString();</span>
<span class="fc" id="L421">      Snapshot snapshot = getSnapshotFromArchive(mpId);</span>
<span class="fc" id="L422">      MediaPackage archivedMp = snapshot.getMediaPackage();</span>
<span class="fc" id="L423">      removeLivePublicationChannel(archivedMp);</span>
<span class="fc" id="L424">      logger.debug(&quot;Removed live pub channel from archived media package {}&quot;, mp);</span>
      // Take a snapshot with the publication removed and put its version in our local cache
      // so that we ignore notifications for this snapshot version.
<span class="fc" id="L427">      snapshotVersionCache.put(mpId, assetManager.takeSnapshot(archivedMp).getVersion());</span>
<span class="nc" id="L428">    } catch (LiveScheduleException e) {</span>
      // It was not found in asset manager. This is ok.
<span class="fc" id="L430">    }</span>
<span class="fc" id="L431">    return true;</span>
  }

  void publishToSearch(MediaPackage mp) throws LiveScheduleException {
    try {
      // Add media package to the search index
<span class="fc" id="L437">      logger.info(&quot;Publishing LIVE media package {} to search index&quot;, mp);</span>
<span class="fc" id="L438">      Job publishJob = searchService.add(mp);</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">      if (!waitForStatus(publishJob).isSuccess()) {</span>
<span class="nc" id="L440">        throw new LiveScheduleException(&quot;Live media package &quot; + mp.getIdentifier() + &quot; could not be published&quot;);</span>
      }
<span class="nc" id="L442">    } catch (LiveScheduleException e) {</span>
<span class="nc" id="L443">      throw e;</span>
<span class="nc" id="L444">    } catch (Exception e) {</span>
<span class="nc" id="L445">      throw new LiveScheduleException(e);</span>
<span class="fc" id="L446">    }</span>
<span class="fc" id="L447">  }</span>

  void retract(MediaPackage mp) throws LiveScheduleException {
<span class="fc" id="L450">    Organization org = securityService.getOrganization();</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">    User prevUser = org != null ? securityService.getUser() : null;</span>
    try {
<span class="fc" id="L453">      securityService.setUser(SecurityUtil.createSystemUser(systemUserName, org));</span>
<span class="fc" id="L454">      Set&lt;String&gt; elementIds = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L455">      String mpId = mp.getIdentifier().toString();</span>
<span class="fc" id="L456">      logger.info(&quot;Removing LIVE media package {} from the search index&quot;, mpId);</span>

<span class="fc bfc" id="L458" title="All 2 branches covered.">      for (MediaPackageElement mpe : mp.getElements()) {</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (!MediaPackageElement.Type.Publication.equals(mpe.getElementType())) {</span>
<span class="fc" id="L460">          elementIds.add(mpe.getIdentifier());</span>
        }
      }

<span class="fc" id="L464">      List&lt;String&gt; failedJobs = new ArrayList&lt;&gt;();</span>
      // Remove media package from the search index
<span class="fc" id="L466">      Job searchDeleteJob = searchService.delete(mpId);</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">      if (!waitForStatus(searchDeleteJob).isSuccess()) {</span>
<span class="nc" id="L468">        failedJobs.add(&quot;Search Index&quot;);</span>
      }

      // Removing media from the download distribution service
<span class="fc" id="L472">      Job distributionRetractJob =  downloadDistributionService.retract(CHANNEL_ID, mp, elementIds);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">      if (!waitForStatus(distributionRetractJob).isSuccess()) {</span>
<span class="nc" id="L474">        failedJobs.add(&quot;Distribution&quot;);</span>
      }

<span class="pc bpc" id="L477" title="1 of 2 branches missed.">      if (!failedJobs.isEmpty()) {</span>
<span class="nc" id="L478">        throw new LiveScheduleException(</span>
<span class="nc" id="L479">            String.format(&quot;Removing live media package %s from %s failed&quot;, mpId, String.join(&quot; and &quot;, failedJobs)));</span>
      }
<span class="nc" id="L481">    } catch (LiveScheduleException e) {</span>
<span class="nc" id="L482">      throw e;</span>
<span class="nc" id="L483">    } catch (Exception e) {</span>
<span class="nc" id="L484">      throw new LiveScheduleException(e);</span>
    } finally {
<span class="fc" id="L486">      securityService.setUser(prevUser);</span>
    }
<span class="fc" id="L488">  }</span>

  /**
   * Retrieves the media package from the search index.
   *
   * @param mediaPackageId
   *          the media package id
   * @return the media package in the search index or null if not there
   * @throws LiveScheduleException
   *           if found many media packages with the same id
   */
  MediaPackage getMediaPackageFromSearch(String mediaPackageId) throws LiveScheduleException {
    // Issue #2504: make sure the search index is read by admin so that the media package is always found.
<span class="fc" id="L501">    Organization org = securityService.getOrganization();</span>
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">    User prevUser = org != null ? securityService.getUser() : null;</span>
<span class="fc" id="L503">    securityService.setUser(SecurityUtil.createSystemUser(systemUserName, org));</span>
    try {
      // Look for the media package in the search index
<span class="fc" id="L506">      return searchService.get(mediaPackageId);</span>
<span class="nc" id="L507">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L508">      logger.warn(&quot;Unexpected unauthorized exception when querying the search index for mp {}&quot;, mediaPackageId, e);</span>
<span class="nc" id="L509">      return null;</span>
<span class="fc" id="L510">    } catch (NotFoundException e) {</span>
<span class="fc" id="L511">      return null;</span>
    } finally {
<span class="fc" id="L513">      securityService.setUser(prevUser);</span>
    }
  }

  void setDurationForMediaPackage(MediaPackage mp, DublinCoreCatalog dc) {
<span class="fc" id="L518">    DCMIPeriod period = EncodingSchemeUtils.decodeMandatoryPeriod(dc.getFirst(DublinCore.PROPERTY_TEMPORAL));</span>
<span class="fc" id="L519">    long duration = period.getEnd().getTime() - period.getStart().getTime();</span>
<span class="fc" id="L520">    mp.setDuration(duration);</span>
<span class="fc" id="L521">    logger.debug(&quot;Live media package {} has start {} and duration {}&quot;, mp.getIdentifier(), mp.getDate(),</span>
<span class="fc" id="L522">            mp.getDuration());</span>
<span class="fc" id="L523">  }</span>

  Map&lt;String, Track&gt; addLiveTracksToMediaPackage(MediaPackage mp, DublinCoreCatalog episodeDC)
          throws LiveScheduleException {
<span class="fc" id="L527">    String caName = episodeDC.getFirst(DublinCore.PROPERTY_SPATIAL);</span>
<span class="fc" id="L528">    HashMap&lt;String, Track&gt; generatedTracks = new HashMap&lt;&gt;();</span>
<span class="fc" id="L529">    String mpId = mp.getIdentifier().toString();</span>
    try {
      // If capture agent registered the properties:
      // capture.device.live.resolution.WIDTHxHEIGHT=COMPLETE_STREAMING_URL, use them!
      try {
<span class="fc" id="L534">        Properties caProps = captureAgentService.getAgentCapabilities(caName);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (caProps != null) {</span>
<span class="fc" id="L536">          Enumeration&lt;Object&gt; en = caProps.keys();</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">          while (en.hasMoreElements()) {</span>
<span class="fc" id="L538">            String key = (String) en.nextElement();</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">            if (key.startsWith(CA_PROPERTY_RESOLUTION_URL_PREFIX)) {</span>
<span class="fc" id="L540">              String resolution = key.substring(CA_PROPERTY_RESOLUTION_URL_PREFIX.length());</span>
<span class="fc" id="L541">              String url = caProps.getProperty(key);</span>
              // Note: only one flavor is supported in this format (the default: presenter/delivery)
<span class="fc" id="L543">              MediaPackageElementFlavor flavor = MediaPackageElementFlavor.parseFlavor(DEFAULT_LIVE_TARGET_FLAVORS);</span>
<span class="fc" id="L544">              String replacedUrl = replaceVariables(mpId, caName, url, flavor, resolution);</span>
<span class="fc" id="L545">              mp.add(buildStreamingTrack(replacedUrl, flavor, streamMimeType, resolution, mp.getDuration()));</span>
            }
<span class="fc" id="L547">          }</span>
        }
<span class="nc" id="L549">      } catch (NotFoundException e) {</span>
        // Capture agent not found so we can't get its properties. Assume the service configuration should
        // be used instead. Note that we can't schedule anything on a CA that has not registered so this is
        // unlikely to happen.
<span class="fc" id="L553">      }</span>

      // Capture agent did not pass any CA_PROPERTY_RESOLUTION_URL_PREFIX property when registering
      // so use the service configuration
<span class="fc bfc" id="L557" title="All 2 branches covered.">      if (mp.getTracks().length == 0) {</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        if (liveStreamingUrl == null) {</span>
<span class="nc" id="L559">          throw new LiveScheduleException(</span>
                  &quot;Cannot build live tracks because '&quot; + LIVE_STREAMING_URL + &quot;' configuration was not set.&quot;);
        }

<span class="fc bfc" id="L563" title="All 2 branches covered.">        for (MediaPackageElementFlavor flavor : liveFlavors) {</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">          for (int i = 0; i &lt; streamResolution.length; i++) {</span>
<span class="fc" id="L565">            String uri = replaceVariables(mpId, caName, UrlSupport.concat(liveStreamingUrl.toString(), streamName),</span>
                    flavor, streamResolution[i]);
<span class="fc" id="L567">            Track track = buildStreamingTrack(uri, flavor, streamMimeType, streamResolution[i], mp.getDuration());</span>
<span class="fc" id="L568">            mp.add(track);</span>
<span class="fc" id="L569">            generatedTracks.put(flavor + &quot;:&quot; + streamResolution[i], track);</span>
          }
        }
      }
<span class="nc" id="L573">    } catch (URISyntaxException e) {</span>
<span class="nc" id="L574">      throw new LiveScheduleException(e);</span>
<span class="fc" id="L575">    }</span>
<span class="fc" id="L576">    return generatedTracks;</span>
  }

  Track buildStreamingTrack(String uriString, MediaPackageElementFlavor flavor, String mimeType, String resolution,
          long duration) throws URISyntaxException {

<span class="fc" id="L582">    URI uri = new URI(uriString);</span>

<span class="fc" id="L584">    MediaPackageElementBuilder elementBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();</span>
<span class="fc" id="L585">    MediaPackageElement element = elementBuilder.elementFromURI(uri, MediaPackageElement.Type.Track, flavor);</span>
<span class="fc" id="L586">    TrackImpl track = (TrackImpl) element;</span>

    // Set duration and mime type
<span class="fc" id="L589">    track.setDuration(duration);</span>
<span class="fc" id="L590">    track.setLive(true);</span>
<span class="fc" id="L591">    track.setMimeType(MimeTypes.parseMimeType(mimeType));</span>

<span class="fc" id="L593">    VideoStreamImpl video = new VideoStreamImpl(&quot;video-&quot; + flavor.getType() + &quot;-&quot; + flavor.getSubtype());</span>
    // Set video resolution
<span class="fc" id="L595">    String[] dimensions = resolution.split(&quot;x&quot;);</span>
<span class="fc" id="L596">    video.setFrameWidth(Integer.parseInt(dimensions[0]));</span>
<span class="fc" id="L597">    video.setFrameHeight(Integer.parseInt(dimensions[1]));</span>

<span class="fc" id="L599">    track.addStream(video);</span>

<span class="fc" id="L601">    logger.debug(&quot;Creating live track element of flavor {}, resolution {}, and url {}&quot;,</span>
            new Object[] { flavor, resolution, uriString });

<span class="fc" id="L604">    return track;</span>
  }

  /**
   * Replaces variables in the live stream name. Currently, this is only prepared to handle the following: #{id} = media
   * package id, #{flavor} = type-subtype of flavor, #{caName} = capture agent name, #{resolution} = stream resolution
   */
  String replaceVariables(String mpId, String caName, String toBeReplaced, MediaPackageElementFlavor flavor,
          String resolution) {

    // Substitution pattern: any string in the form #{name}, where 'name' has only word characters: [a-zA-Z_0-9].
<span class="fc" id="L615">    final Pattern pat = Pattern.compile(&quot;#\\{(\\w+)\\}&quot;);</span>

<span class="fc" id="L617">    Matcher matcher = pat.matcher(toBeReplaced);</span>
<span class="fc" id="L618">    StringBuffer sb = new StringBuffer();</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">      if (matcher.group(1).equals(REPLACE_ID)) {</span>
<span class="fc" id="L621">        matcher.appendReplacement(sb, mpId);</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">      } else if (matcher.group(1).equals(REPLACE_FLAVOR)) {</span>
<span class="fc" id="L623">        matcher.appendReplacement(sb, flavor.getType() + &quot;-&quot; + flavor.getSubtype());</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">      } else if (matcher.group(1).equals(REPLACE_CA_NAME)) {</span>
        // Taking the easy route to find the capture agent name...
<span class="fc" id="L626">        matcher.appendReplacement(sb, caName);</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">      } else if (matcher.group(1).equals(REPLACE_RESOLUTION)) {</span>
        // Taking the easy route to find the capture agent name...
<span class="fc" id="L629">        matcher.appendReplacement(sb, resolution);</span>
      } // else will not replace
    }
<span class="fc" id="L632">    matcher.appendTail(sb);</span>
<span class="fc" id="L633">    return sb.toString();</span>
  }

  private JobBarrier.Result waitForStatus(Job... jobs) throws IllegalStateException, IllegalArgumentException {
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">    if (serviceRegistry == null) {</span>
<span class="nc" id="L638">      throw new IllegalStateException(&quot;Can't wait for job status without providing a service registry first&quot;);</span>
    }
<span class="fc" id="L640">    JobBarrier barrier = new JobBarrier(null, serviceRegistry, jobPollingInterval, jobs);</span>
<span class="fc" id="L641">    return barrier.waitForJobs();</span>
  }

  Snapshot getSnapshotFromArchive(String mpId) throws LiveScheduleException {
<span class="fc" id="L645">    Optional&lt;Snapshot&gt; snapshot = assetManager.getLatestSnapshot(mpId);</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">    if (snapshot.isEmpty()) {</span>
      // No snapshot?
<span class="nc" id="L648">      throw new LiveScheduleException(String.format(&quot;Unexpected error: media package %s has not been archived.&quot;, mpId));</span>
    }
<span class="fc" id="L650">    return snapshot.get();</span>
  }

  MediaPackage distributeAclsAndCatalogs(Snapshot snapshot) throws LiveScheduleException {
    try {
<span class="fc" id="L655">      MediaPackage mp = (MediaPackage) snapshot.getMediaPackage().clone();</span>

      // Select elements
<span class="fc" id="L658">      Collection&lt;MediaPackageElement&gt; elements = publishElementSelector.select(mp, false);</span>
<span class="fc" id="L659">      Set&lt;String&gt; elementIds = elements.stream().map(MediaPackageElement::getIdentifier).collect(Collectors.toSet());</span>

      // Distribute elements
<span class="fc" id="L662">      Job distributionJob = downloadDistributionService.distribute(CHANNEL_ID, mp, elementIds, false);</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">      if (!waitForStatus(distributionJob).isSuccess()) {</span>
<span class="nc" id="L664">        throw new LiveScheduleException(</span>
<span class="nc" id="L665">                &quot;Element(s) for live media package &quot; + mp.getIdentifier() + &quot; could not be distributed&quot;);</span>
      }

      // Remove all elements from mp
<span class="fc bfc" id="L669" title="All 2 branches covered.">      for (MediaPackageElement e: mp.getElements()) {</span>
<span class="fc" id="L670">        mp.remove(e);</span>
      }

      // Re-add distributed elements
<span class="fc" id="L674">      List&lt;MediaPackageElement&gt; distributedElements = (List&lt;MediaPackageElement&gt;) MediaPackageElementParser</span>
<span class="fc" id="L675">              .getArrayFromXml(distributionJob.getPayload());</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">      for (MediaPackageElement distributedElement : distributedElements) {</span>
<span class="fc" id="L677">        mp.add(distributedElement);</span>
<span class="fc" id="L678">      }</span>

      // Clean up
<span class="fc bfc" id="L681" title="All 2 branches covered.">      for (String id : elementIds) {</span>
<span class="fc" id="L682">        MediaPackageElement e = mp.getElementById(id);</span>
<span class="fc" id="L683">        workspace.delete(e.getURI());</span>
<span class="fc" id="L684">      }</span>

<span class="fc" id="L686">      return mp;</span>
<span class="nc" id="L687">    } catch (LiveScheduleException e) {</span>
<span class="nc" id="L688">      throw e;</span>
<span class="nc" id="L689">    } catch (Exception e) {</span>
<span class="nc" id="L690">      throw new LiveScheduleException(e);</span>
    }
  }

  MediaPackage replaceAndDistributeAcl(MediaPackage previousMp, AccessControlList acl) throws LiveScheduleException {
    try {
      // This is the mp from the search index
<span class="fc" id="L697">      MediaPackage mp = (MediaPackage) previousMp.clone();</span>

      // Remove previous Acl from the mp
<span class="fc" id="L700">      Attachment[] atts = mp.getAttachments(MediaPackageElements.XACML_POLICY_EPISODE);</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">      if (atts.length &gt; 0) {</span>
<span class="fc" id="L702">        mp.remove(atts[0]);</span>
      }

      // Attach current ACL to mp, acl will be created in the ws/wfr
<span class="fc" id="L706">      authService.setAcl(mp, AclScope.Episode, acl);</span>
<span class="fc" id="L707">      atts = mp.getAttachments(MediaPackageElements.XACML_POLICY_EPISODE);</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">      if (atts.length &gt; 0) {</span>
<span class="fc" id="L709">        String aclId = atts[0].getIdentifier();</span>
        // Distribute new acl
<span class="fc" id="L711">        Job distributionJob = downloadDistributionService.distribute(CHANNEL_ID, mp, aclId, false);</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">        if (!waitForStatus(distributionJob).isSuccess()) {</span>
<span class="nc" id="L713">          throw new LiveScheduleException(</span>
<span class="nc" id="L714">                  &quot;Acl for live media package &quot; + mp.getIdentifier() + &quot; could not be distributed&quot;);</span>
        }

<span class="fc" id="L717">        MediaPackageElement e = mp.getElementById(aclId);</span>
        // Cleanup workspace/wfr
<span class="fc" id="L719">        mp.remove(e);</span>
<span class="fc" id="L720">        workspace.delete(e.getURI());</span>

        // Add distributed acl to mp
<span class="fc" id="L723">        mp.add(MediaPackageElementParser.getFromXml(distributionJob.getPayload()));</span>
      }
<span class="fc" id="L725">      return mp;</span>
<span class="nc" id="L726">    } catch (LiveScheduleException e) {</span>
<span class="nc" id="L727">      throw e;</span>
<span class="nc" id="L728">    } catch (Exception e) {</span>
<span class="nc" id="L729">      throw new LiveScheduleException(e);</span>
    }
  }

  MediaPackage addLivePublicationToMediaPackage(Snapshot snapshot, Map&lt;String, Track&gt; generatedTracks)
          throws LiveScheduleException {
<span class="fc" id="L735">    MediaPackage mp = snapshot.getMediaPackage();</span>

<span class="fc" id="L737">    Organization currentOrg = null;</span>
    try {
<span class="fc" id="L739">      currentOrg = organizationService.getOrganization(snapshot.getOrganizationId());</span>
<span class="nc" id="L740">    } catch (NotFoundException e) {</span>
<span class="nc" id="L741">      logger.warn(&quot;Organization in snapshot not found: {}&quot;, snapshot.getOrganizationId());</span>
<span class="fc" id="L742">    }</span>

<span class="fc" id="L744">    logger.debug(&quot;Adding live channel publication element to media package {}&quot;, mp);</span>
<span class="fc" id="L745">    String engageUrlString = null;</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">    if (currentOrg != null) {</span>
<span class="fc" id="L747">      engageUrlString = StringUtils.trimToNull(currentOrg.getProperties().get(ENGAGE_URL_PROPERTY));</span>
    }
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">    if (engageUrlString == null) {</span>
<span class="nc" id="L750">      engageUrlString = serverUrl;</span>
<span class="nc" id="L751">      logger.info(</span>
          &quot;Using 'server.url' as a fallback for the non-existing organization level key '{}' for the publication url&quot;,
          ENGAGE_URL_PROPERTY);
    }

    try {
      // Create new distribution element
<span class="fc" id="L758">      URI engageUri = URIUtils.resolve(new URI(engageUrlString), PLAYER_PATH + mp.getIdentifier().toString());</span>
<span class="fc" id="L759">      Publication publicationElement = PublicationImpl.publication(UUID.randomUUID().toString(), CHANNEL_ID, engageUri,</span>
<span class="fc" id="L760">              MimeTypes.parseMimeType(&quot;text/html&quot;));</span>
<span class="fc" id="L761">      mp.add(publicationElement);</span>
<span class="fc" id="L762">      createOrUpdatePublicationTracks(publicationElement, generatedTracks);</span>
<span class="fc" id="L763">      return mp;</span>
<span class="nc" id="L764">    } catch (URISyntaxException e) {</span>
<span class="nc" id="L765">      throw new LiveScheduleException(e);</span>
    }
  }

  void removeLivePublicationChannel(MediaPackage mp) {
    // Remove publication element
<span class="fc" id="L771">    Publication[] publications = mp.getPublications();</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">    if (publications != null) {</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">      for (Publication publication : publications) {</span>
<span class="pc bpc" id="L774" title="1 of 2 branches missed.">        if (CHANNEL_ID.equals(publication.getChannel())) {</span>
<span class="fc" id="L775">          mp.remove(publication);</span>
        }
      }
    }
<span class="fc" id="L779">  }</span>

  boolean isSameMediaPackage(MediaPackage previous, MediaPackage current) {

<span class="fc" id="L783">    Equator&lt;Track&gt; liveTrackEquator = new Equator&lt;&gt;() {</span>
      @Override
      public boolean equate(Track track1, Track track2) {
        // we can safely assume that each live track has exactly one video stream since we generated that ourselves
<span class="fc" id="L787">        VideoStream videostream1 = (VideoStream) track1.getStreams()[0];</span>
<span class="fc" id="L788">        VideoStream videostream2 = (VideoStream) track2.getStreams()[0];</span>

<span class="pc bpc" id="L790" title="1 of 2 branches missed.">        return Objects.equals(track1.getURI(), track2.getURI())</span>
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">                &amp;&amp; Objects.equals(track1.getFlavor(), track2.getFlavor())</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">                &amp;&amp; Objects.equals(track1.getMimeType(), track2.getMimeType())</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">                &amp;&amp; Objects.equals(track1.getDuration(), track2.getDuration())</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">                &amp;&amp; Objects.equals(videostream1.getFrameWidth(), videostream2.getFrameWidth())</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">                &amp;&amp; Objects.equals(videostream1.getFrameHeight(), videostream2.getFrameHeight());</span>
      }

      @Override
      public int hash(Track track) {
<span class="fc" id="L800">        VideoStream videostream = (VideoStream) track.getStreams()[0];</span>
<span class="fc" id="L801">        return Objects.hash(track.getURI(), track.getFlavor(), track.getMimeType(), track.getDuration(),</span>
<span class="fc" id="L802">                videostream.getFrameWidth(), videostream.getFrameHeight());</span>
      }
    };

<span class="fc" id="L806">    Equator&lt;MediaPackageElement&gt; catalogAndAttachmentEquator = new Equator&lt;&gt;() {</span>
      @Override
      public boolean equate(MediaPackageElement mpe1, MediaPackageElement mpe2) {
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">        return Objects.equals(mpe1.getIdentifier(), mpe2.getIdentifier())</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">                &amp;&amp; Objects.equals(mpe1.getElementType(), mpe2.getElementType())</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">                &amp;&amp; Objects.equals(mpe1.getChecksum(), mpe2.getChecksum())</span>
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">                &amp;&amp; Objects.equals(mpe1.getFlavor(), mpe2.getFlavor());</span>
      }

      @Override
      public int hash(MediaPackageElement mpe) {
<span class="fc" id="L817">        return Objects.hash(mpe.getIdentifier(), mpe.getElementType(), mpe.getChecksum(), mpe.getFlavor());</span>
      }
    };

<span class="fc bfc" id="L821" title="All 2 branches covered.">    if (!CollectionUtils.isEqualCollection(Arrays.asList(previous.getTracks()), Arrays.asList(current.getTracks()),</span>
            liveTrackEquator)) {
<span class="fc" id="L823">      return false;</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">    } else if (!CollectionUtils.isEqualCollection(Arrays.asList(previous.getCatalogs()),</span>
<span class="fc" id="L825">            Arrays.asList(current.getCatalogs()), catalogAndAttachmentEquator)) {</span>
<span class="fc" id="L826">      return false;</span>
    } else {
<span class="fc" id="L828">      return CollectionUtils.isEqualCollection(Arrays.asList(previous.getAttachments()),</span>
<span class="fc" id="L829">              Arrays.asList(current.getAttachments()), catalogAndAttachmentEquator);</span>
    }
  }

  void retractPreviousElements(MediaPackage previousMp, MediaPackage newMp) throws LiveScheduleException {
    try {
      // Now can retract elements from previous publish. Before creating a retraction
      // job, check if the element url is still used by the new media package.
<span class="fc" id="L837">      Set&lt;String&gt; elementIds = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">      for (MediaPackageElement element : previousMp.getElements()) {</span>
        // We don't retract tracks because they are just live links
<span class="fc bfc" id="L840" title="All 2 branches covered.">        if (!Track.TYPE.equals(element.getElementType())) {</span>
<span class="fc" id="L841">          boolean canBeDeleted = true;</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">          for (MediaPackageElement newElement : newMp.getElements()) {</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">            if (element.getURI().equals(newElement.getURI())) {</span>
<span class="fc" id="L844">              logger.debug(</span>
                  &quot;Not retracting element {} with URI {} from download distribution because it is &quot;
                      + &quot;still used by updated live media package&quot;,
<span class="fc" id="L847">                  element.getIdentifier(), element.getURI());</span>
<span class="fc" id="L848">              canBeDeleted = false;</span>
<span class="fc" id="L849">              break;</span>
            }
          }
<span class="fc bfc" id="L852" title="All 2 branches covered.">          if (canBeDeleted) {</span>
<span class="fc" id="L853">            elementIds.add(element.getIdentifier());</span>
          }
        }
      }
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">      if (elementIds.size() &gt; 0) {</span>
<span class="fc" id="L858">        Job job = downloadDistributionService.retract(CHANNEL_ID, previousMp, elementIds);</span>
        // Wait for retraction to finish
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">        if (!waitForStatus(job).isSuccess()) {</span>
<span class="nc" id="L861">          logger.warn(&quot;One of the download retract jobs did not complete successfully&quot;);</span>
        } else {
<span class="fc" id="L863">          logger.debug(&quot;Retraction of previously published elements complete&quot;);</span>
        }
      }
<span class="nc" id="L866">    } catch (DistributionException e) {</span>
<span class="nc" id="L867">      throw new LiveScheduleException(e);</span>
<span class="fc" id="L868">    }</span>
<span class="fc" id="L869">  }</span>

  @Reference
  public void setDublinCoreService(DublinCoreCatalogService service) {
<span class="fc" id="L873">    this.dublinCoreService = service;</span>
<span class="fc" id="L874">  }</span>

  @Reference
  public void setSearchService(SearchService service) {
<span class="fc" id="L878">    this.searchService = service;</span>
<span class="fc" id="L879">  }</span>

  @Reference
  public void setSeriesService(SeriesService service) {
<span class="fc" id="L883">    this.seriesService = service;</span>
<span class="fc" id="L884">  }</span>

  @Reference
  public void setServiceRegistry(ServiceRegistry service) {
<span class="fc" id="L888">    this.serviceRegistry = service;</span>
<span class="fc" id="L889">  }</span>

  @Reference
  public void setCaptureAgentService(CaptureAgentStateService service) {
<span class="fc" id="L893">    this.captureAgentService = service;</span>
<span class="fc" id="L894">  }</span>

  @Reference(
      name = &quot;DownloadDistributionService&quot;,
      target = &quot;(distribution.channel=download)&quot;
  )
  public void setDownloadDistributionService(DownloadDistributionService service) {
<span class="fc" id="L901">    this.downloadDistributionService = service;</span>
<span class="fc" id="L902">    logger.info(&quot;Distribution service with type '{}' set.&quot;, downloadDistributionService.getDistributionType());</span>
<span class="fc" id="L903">  }</span>

  @Reference
  public void setWorkspace(Workspace ws) {
<span class="fc" id="L907">    this.workspace = ws;</span>
<span class="fc" id="L908">  }</span>

  @Reference
  public void setAssetManager(AssetManager assetManager) {
<span class="fc" id="L912">    this.assetManager = assetManager;</span>
<span class="fc" id="L913">  }</span>

  @Reference
  public void setAuthorizationService(AuthorizationService service) {
<span class="fc" id="L917">    this.authService = service;</span>
<span class="fc" id="L918">  }</span>

  @Reference
  public void setOrganizationService(OrganizationDirectoryService service) {
<span class="fc" id="L922">    this.organizationService = service;</span>
<span class="fc" id="L923">  }</span>

  @Reference
  public void setSecurityService(SecurityService service) {
<span class="fc" id="L927">    this.securityService = service;</span>
<span class="fc" id="L928">  }</span>
  // === Set by OSGI - end

  // === Used by unit tests - begin
  void setJobPollingInterval(long jobPollingInterval) {
<span class="fc" id="L933">    this.jobPollingInterval = jobPollingInterval;</span>
<span class="fc" id="L934">  }</span>

  Cache&lt;String, Version&gt; getSnapshotVersionCache() {
<span class="fc" id="L937">    return this.snapshotVersionCache;</span>
  }
  // === Used by unit tests - end
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>