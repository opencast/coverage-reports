<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EncodingSchemeUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-dublincore</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.metadata.dublincore</a> &gt; <span class="el_source">EncodingSchemeUtils.java</span></div><h1>EncodingSchemeUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */


package org.opencastproject.metadata.dublincore;

import org.joda.time.Duration;
import org.joda.time.format.ISODateTimeFormat;
import org.joda.time.format.ISOPeriodFormat;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.TimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utility class to facilitate the work with DCMI encoding schemes.
 */
public final class EncodingSchemeUtils {

<span class="fc" id="L43">  private static final Map&lt;Precision, String&gt; formats = new HashMap&lt;Precision, String&gt;();</span>

  static {
<span class="fc" id="L46">    formats.put(Precision.Year, &quot;yyyy&quot;);</span>
<span class="fc" id="L47">    formats.put(Precision.Month, &quot;yyyy-MM&quot;);</span>
<span class="fc" id="L48">    formats.put(Precision.Day, &quot;yyyy-MM-dd&quot;);</span>
<span class="fc" id="L49">    formats.put(Precision.Minute, &quot;yyyy-MM-dd'T'HH:mm'Z'&quot;);</span>
<span class="fc" id="L50">    formats.put(Precision.Second, &quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;);</span>
<span class="fc" id="L51">    formats.put(Precision.Fraction, &quot;yyyy-MM-dd'T'HH:mm:ss.SSS'Z'&quot;);</span>
  }

  /** Disable construction of this utility class */
  private EncodingSchemeUtils() {
  }

  /**
   * Encode a date with the given precision into a Dublin Core string value, using the recommended W3C-DTF scheme. The
   * UTC timezone is used for all precisions from {@link Precision#Minute} to {@link Precision#Fraction}. For years,
   * months and days the local timezone is used instead to ensure that the given date enters the DublinCore as is. If
   * UTC was used it may happen that you get the previous or next day, month or year respectively
   * &lt;p&gt;
   * The language of the returned value is {@link DublinCore#LANGUAGE_UNDEFINED}.
   * &lt;p&gt;
   * See &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;http://www.w3.org/TR/NOTE-datetime&lt;/a&gt; for more information about
   * W3C-DTF.
   *
   * @param date
   *          the date to encode
   * @param precision
   *          the precision to use
   */
  public static DublinCoreValue encodeDate(Date date, Precision precision) {
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">    if (date == null)</span>
<span class="nc" id="L76">      throw new IllegalArgumentException(&quot;The date must not be null&quot;);</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">    if (precision == null)</span>
<span class="nc" id="L78">      throw new IllegalArgumentException(&quot;The precision must not be null&quot;);</span>

<span class="fc" id="L80">    return DublinCoreValue.mk(formatDate(date, precision), DublinCore.LANGUAGE_UNDEFINED, Optional.of(DublinCore.ENC_SCHEME_W3CDTF));</span>
  }

  public static String formatDate(Date date, Precision precision) {
<span class="fc" id="L84">    SimpleDateFormat f = new SimpleDateFormat(formats.get(precision));</span>
<span class="fc bfc" id="L85" title="All 6 branches covered.">    if (precision == Precision.Minute || precision == Precision.Second || precision == Precision.Fraction)</span>
<span class="fc" id="L86">      f.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
<span class="fc" id="L87">    return f.format(date);</span>
  }

  /**
   * Encode a period with the given precision into a Dublin Core string value using the recommended DCMI Period scheme.
   * For the usage of the UTC timezone please refer to {@link #encodeDate(Date, Precision)} for further information.
   * &lt;p&gt;
   * One of the dates may be null to create an open interval.
   * &lt;p&gt;
   * The language of the returned value is {@link DublinCore#LANGUAGE_UNDEFINED}.
   * &lt;p&gt;
   * See &lt;a href=&quot;http://dublincore.org/documents/dcmi-period/&quot;&gt;http://dublincore.org/documents/dcmi-period/&lt;/a&gt; for
   * more information about DCMI Period.
   *
   * @param period
   *          the period
   * @param precision
   *          the precision
   */
  public static DublinCoreValue encodePeriod(DCMIPeriod period, Precision precision) {
<span class="fc bfc" id="L107" title="All 2 branches covered.">    if (period == null)</span>
<span class="fc" id="L108">      throw new IllegalArgumentException(&quot;The period must not be null&quot;);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">    if (precision == null)</span>
<span class="fc" id="L110">      throw new IllegalArgumentException(&quot;The precision must not be null&quot;);</span>

<span class="fc" id="L112">    StringBuilder b = new StringBuilder();</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">    if (period.hasStart()) {</span>
<span class="fc" id="L114">      b.append(&quot;start=&quot;).append(formatDate(period.getStart(), precision)).append(&quot;;&quot;);</span>
    }
<span class="fc bfc" id="L116" title="All 2 branches covered.">    if (period.hasEnd()) {</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">      if (b.length() &gt; 0)</span>
<span class="fc" id="L118">        b.append(&quot; &quot;);</span>
<span class="fc" id="L119">      b.append(&quot;end=&quot;).append(formatDate(period.getEnd(), precision)).append(&quot;;&quot;);</span>
    }
<span class="fc bfc" id="L121" title="All 2 branches covered.">    if (period.hasName()) {</span>
<span class="fc" id="L122">      b.append(&quot; &quot;).append(&quot;name=&quot;).append(period.getName().replace(&quot;;&quot;, &quot;&quot;)).append(&quot;;&quot;);</span>
    }
<span class="fc" id="L124">    b.append(&quot; &quot;).append(&quot;scheme=W3C-DTF;&quot;);</span>
<span class="fc" id="L125">    return DublinCoreValue.mk(b.toString(), DublinCore.LANGUAGE_UNDEFINED, Optional.of(DublinCore.ENC_SCHEME_PERIOD));</span>
  }

  /**
   * Encode a duration measured in milliseconds into a Dublin Core string using the
   * {@link DublinCore#ENC_SCHEME_ISO8601} encoding scheme &lt;code&gt;PTnHnMnS&lt;/code&gt;.
   * &lt;p&gt;
   * The language of the returned value is {@link DublinCore#LANGUAGE_UNDEFINED}.
   * &lt;p&gt;
   * See &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt; ISO8601 Durations&lt;/a&gt; for details.
   *
   * @param duration
   *          the duration in milliseconds
   */
  public static DublinCoreValue encodeDuration(long duration) {
<span class="fc" id="L140">    return DublinCoreValue.mk(ISOPeriodFormat.standard().print(new Duration(duration).toPeriod()),</span>
<span class="fc" id="L141">            DublinCore.LANGUAGE_UNDEFINED, Optional.of(DublinCore.ENC_SCHEME_ISO8601));</span>
  }

  /**
   * Decode a string encoded in the ISO8601 encoding scheme.
   * &lt;p&gt;
   * Also supports the REPLAY legacy format &lt;code&gt;hh:mm:ss&lt;/code&gt;.
   * &lt;p&gt;
   * See &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt; ISO8601 Durations&lt;/a&gt; for details.
   *
   * @param value
   *          the ISO encoded string
   * @return the duration in milliseconds or null, if the value cannot be parsed
   */
  public static Long decodeDuration(String value) {
    try {
<span class="fc" id="L157">      return ISOPeriodFormat.standard().parsePeriod(value).toStandardDuration().getMillis();</span>
<span class="fc" id="L158">    } catch (IllegalArgumentException ignore) {</span>
    }
    // also support the legacy format hh:mm:ss
<span class="fc" id="L161">    String[] parts = value.split(&quot;:&quot;);</span>
    try {
<span class="fc bfc" id="L163" title="All 2 branches covered.">      if (parts.length == 1)</span>
<span class="nc" id="L164">        return Long.parseLong(parts[0]) * 1000;</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">      if (parts.length == 2)</span>
<span class="nc" id="L166">        return Long.parseLong(parts[0]) * 1000 * 60 + Long.parseLong(parts[1]) * 1000;</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">      if (parts.length == 3)</span>
<span class="fc" id="L168">        return Long.parseLong(parts[0]) * 1000 * 60 * 60 + Long.parseLong(parts[1]) * 1000 * 60</span>
<span class="fc" id="L169">                + Long.parseLong(parts[2]) * 1000;</span>
<span class="fc" id="L170">    } catch (NumberFormatException ignore) {</span>
<span class="nc" id="L171">    }</span>
<span class="fc" id="L172">    return null;</span>
  }

  /**
   * Decode a string encoded in the ISO8601 encoding scheme.
   *
   * @param value
   *          the Dublin Core value
   * @return the duration in milliseconds or null, if the value cannot be parsed or is in a different encoding scheme
   */
  public static Long decodeDuration(DublinCoreValue value) {
<span class="pc bpc" id="L183" title="1 of 4 branches missed.">    if (!value.hasEncodingScheme() || value.getEncodingScheme().get().equals(DublinCore.ENC_SCHEME_ISO8601)) {</span>
<span class="fc" id="L184">      return decodeDuration(value.getValue());</span>
    }
<span class="fc" id="L186">    return null;</span>
  }

  public static Long decodeMandatoryDuration(String value) {
<span class="nc" id="L190">    Long l = decodeDuration(value);</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">    if (l == null)</span>
<span class="nc" id="L192">      throw new IllegalArgumentException(&quot;Cannot decode duration: &quot; + value);</span>
<span class="nc" id="L193">    return l;</span>
  }

  /**
   * Tries to decode the given value as a W3C-DTF encoded date. If decoding fails, null is returned.
   *
   * @return the date or null if decoding fails
   */
  public static Date decodeDate(DublinCoreValue value) {
<span class="pc bpc" id="L202" title="1 of 4 branches missed.">    if (!value.hasEncodingScheme() || value.getEncodingScheme().get().equals(DublinCore.ENC_SCHEME_W3CDTF)) {</span>
      try {
<span class="fc" id="L204">        return parseW3CDTF(value.getValue());</span>
<span class="fc" id="L205">      } catch (IllegalArgumentException ignore) {</span>
      }
    }

    // Try unixtime in milliseconds (backwards-compatibility with older mediapackages)
    try {
<span class="fc" id="L211">      long timestamp = Long.parseLong(value.getValue());</span>
<span class="fc" id="L212">      Date decoded = new java.util.Date(timestamp);</span>
<span class="fc" id="L213">      return decoded;</span>
<span class="fc" id="L214">    } catch (NumberFormatException nfe) {</span>
    }

<span class="fc" id="L217">    return null;</span>
  }

  /**
   * Tries to decode the given value as a W3C-DTF encoded date. If decoding fails, null is returned.
   *
   * @return the date or null if decoding fails
   */
  public static Date decodeDate(String value) {
    try {
<span class="fc" id="L227">      return parseW3CDTF(value);</span>
<span class="fc" id="L228">    } catch (IllegalArgumentException ignore) {</span>
    }

    // Try unixtime in milliseconds (backwards-compatibility with older mediapackages)
    try {
<span class="fc" id="L233">      long timestamp = Long.parseLong(value);</span>
<span class="fc" id="L234">      Date decoded = new java.util.Date(timestamp);</span>
<span class="fc" id="L235">      return decoded;</span>
<span class="nc" id="L236">    } catch (NumberFormatException nfe) {</span>
    }

<span class="nc" id="L239">    return null;</span>
  }

  /**
   * Like {@link #decodeDate(String)}, but throws an {@link IllegalArgumentException} if the value cannot be decoded.
   *
   * @param value
   *          the value
   * @return the date
   * @throws IllegalArgumentException
   *           if the value cannot be decoded
   */
  public static Date decodeMandatoryDate(DublinCoreValue value) {
<span class="nc" id="L252">    Date date = decodeDate(value);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    if (date == null)</span>
<span class="nc" id="L254">      throw new IllegalArgumentException(&quot;Cannot decode to Date: &quot; + value);</span>
<span class="nc" id="L255">    return date;</span>
  }

  /**
   * Like {@link #decodeDate(String)}, but throws an {@link IllegalArgumentException} if the value cannot be decoded.
   *
   * @return the date
   * @throws IllegalArgumentException
   *           if the value cannot be decoded
   */
  public static Date decodeMandatoryDate(String value) {
<span class="nc" id="L266">    Date date = decodeDate(value);</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">    if (date == null)</span>
<span class="nc" id="L268">      throw new IllegalArgumentException(&quot;Cannot decode to Date: &quot; + value);</span>
<span class="nc" id="L269">    return date;</span>
  }

<span class="fc" id="L272">  private static final Pattern DCMI_PERIOD = Pattern.compile(&quot;(start|end|name)\\s*=\\s*(.*?)(?:;|\\s*$)&quot;);</span>
<span class="fc" id="L273">  private static final Pattern DCMI_PERIOD_SCHEME = Pattern.compile(&quot;scheme\\s*=\\s*(.*?)(?:;|\\s*$)&quot;);</span>

  /**
   * Tries to decode a string in the DCMI period format, using W3C-DTF for the encoding of the individual dates. If
   * parsing fails at any point, null will be returned.
   *
   * @return the period or null if decoding fails
   */
  public static DCMIPeriod decodePeriod(DublinCoreValue value) {
<span class="fc" id="L282">    return decodePeriod(value.getValue());</span>
  }

  /**
   * Tries to decode a string in the DCMI period format, using W3C-DTF for the encoding of the individual dates. If
   * parsing fails at any point, null will be returned.
   *
   * @return the period or null if decoding fails
   */
  public static DCMIPeriod decodePeriod(String value) {
    // Parse value
<span class="fc" id="L293">    Matcher schemeMatcher = DCMI_PERIOD_SCHEME.matcher(value);</span>
<span class="fc" id="L294">    boolean mayBeW3CDTFEncoded = true;</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">    if (schemeMatcher.find()) {</span>
<span class="fc" id="L296">      String schemeString = schemeMatcher.group(1);</span>
<span class="pc bpc" id="L297" title="1 of 4 branches missed.">      if (!&quot;W3C-DTF&quot;.equalsIgnoreCase(schemeString) &amp;&amp; !&quot;W3CDTF&quot;.equalsIgnoreCase(schemeString)) {</span>
<span class="fc" id="L298">        mayBeW3CDTFEncoded = false;</span>
      }
    }
    try {
<span class="fc bfc" id="L302" title="All 2 branches covered.">      if (mayBeW3CDTFEncoded) {</span>
        // Declare fields
<span class="fc" id="L304">        Date start = null;</span>
<span class="fc" id="L305">        Date end = null;</span>
<span class="fc" id="L306">        String name = null;</span>
        // Parse
<span class="fc" id="L308">        Matcher m = DCMI_PERIOD.matcher(value);</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        while (m.find()) {</span>
<span class="fc" id="L310">          String field = m.group(1);</span>
<span class="fc" id="L311">          String fieldValue = m.group(2);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">          if (&quot;start&quot;.equals(field)) {</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">            if (start != null)</span>
<span class="nc" id="L314">              return null;</span>
<span class="fc" id="L315">            start = parseW3CDTF(fieldValue);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">          } else if (&quot;end&quot;.equals(field)) {</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            if (end != null)</span>
<span class="nc" id="L318">              return null;</span>
<span class="fc" id="L319">            end = parseW3CDTF(fieldValue);</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">          } else if (&quot;name&quot;.equals(field)) {</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            if (name != null)</span>
<span class="nc" id="L322">              return null;</span>
<span class="nc" id="L323">            name = fieldValue;</span>
          }
<span class="fc" id="L325">        }</span>
<span class="pc bpc" id="L326" title="1 of 4 branches missed.">        if (start == null &amp;&amp; end == null)</span>
<span class="fc" id="L327">          return null;</span>
<span class="fc" id="L328">        return new DCMIPeriod(start, end, name);</span>
      }
<span class="fc" id="L330">    } catch (IllegalArgumentException ignore) {</span>
      // Parse error
<span class="fc" id="L332">    }</span>
<span class="fc" id="L333">    return null;</span>
  }

  /**
   * Like {@link #decodePeriod(String)}, but throws an {@link IllegalArgumentException} if the value cannot be decoded.
   *
   * @return the period
   * @throws IllegalArgumentException
   *           if the value cannot be decoded
   */
  public static DCMIPeriod decodeMandatoryPeriod(DublinCoreValue value) {
<span class="nc" id="L344">    return decodeMandatoryPeriod(value.getValue());</span>
  }

  /**
   * Like {@link #decodePeriod(DublinCoreValue)}, but throws an {@link IllegalArgumentException} if the value cannot be
   * decoded.
   *
   * @return the period
   * @throws IllegalArgumentException
   *           if the value cannot be decoded
   */
  public static DCMIPeriod decodeMandatoryPeriod(String value) {
<span class="fc" id="L356">    DCMIPeriod period = decodePeriod(value);</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">    if (period == null)</span>
<span class="nc" id="L358">      throw new IllegalArgumentException(&quot;Cannot decode to DCMIPeriod: &quot; + value);</span>

<span class="fc" id="L360">    return period;</span>
  }

  /**
   * Tries to decode the value to a temporal object. For now, supported types are {@link java.util.Date},
   * {@link DCMIPeriod} and Long for a duration.
   *
   * @param value
   *          the value to decode
   * @return a temporal object of the said types or null if decoding fails
   */
  public static Temporal decodeTemporal(DublinCoreValue value) {
    // First try Date
<span class="fc" id="L373">    Date instant = decodeDate(value);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">    if (instant != null)</span>
<span class="fc" id="L375">      return Temporal.instant(instant);</span>
<span class="fc" id="L376">    DCMIPeriod period = decodePeriod(value);</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">    if (period != null)</span>
<span class="fc" id="L378">      return Temporal.period(period);</span>
<span class="fc" id="L379">    Long duration = decodeDuration(value);</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">    if (duration != null)</span>
<span class="fc" id="L381">      return Temporal.duration(duration);</span>
<span class="nc" id="L382">    return null;</span>
  }

  /**
   * Like {@link #decodeTemporal(DublinCoreValue)}, but throws an {@link IllegalArgumentException} if the value cannot
   * be decoded.
   *
   * @return the temporal object of type {@link java.util.Date} or {@link DCMIPeriod}
   * @throws IllegalArgumentException
   *           if the value cannot be decoded
   */
  public static Temporal decodeMandatoryTemporal(DublinCoreValue value) {
<span class="nc" id="L394">    Temporal temporal = decodeTemporal(value);</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">    if (value == null)</span>
<span class="nc" id="L396">      throw new IllegalArgumentException(&quot;Cannot decode to either Date or DCMIPeriod: &quot; + value);</span>

<span class="nc" id="L398">    return temporal;</span>
  }

  /**
   * @throws IllegalArgumentException
   *           if the value cannot be parsed
   */
  private static Date parseW3CDTF(String value) {
<span class="fc" id="L406">    return ISODateTimeFormat.dateTimeParser().parseDateTime(value).toDate();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>