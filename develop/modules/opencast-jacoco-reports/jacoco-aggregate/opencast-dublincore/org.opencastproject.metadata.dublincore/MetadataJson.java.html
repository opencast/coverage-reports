<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MetadataJson.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-dublincore</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.metadata.dublincore</a> &gt; <span class="el_source">MetadataJson.java</span></div><h1>MetadataJson.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.metadata.dublincore;

import static org.apache.commons.lang3.exception.ExceptionUtils.getMessage;

import org.opencastproject.mediapackage.MediaPackageElementFlavor;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.DurationFormatUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Map;
import java.util.Objects;
import java.util.TimeZone;

public final class MetadataJson {
<span class="fc" id="L51">  private static final Logger logger = LoggerFactory.getLogger(MetadataJson.class);</span>

  /* Keys for the different properties of the metadata JSON Object */
  private static final String JSON_KEY_ID = &quot;id&quot;;
  private static final String JSON_KEY_LABEL = &quot;label&quot;;
  private static final String JSON_KEY_READONLY = &quot;readOnly&quot;;
  private static final String JSON_KEY_REQUIRED = &quot;required&quot;;
  private static final String JSON_KEY_TYPE = &quot;type&quot;;
  private static final String JSON_KEY_VALUE = &quot;value&quot;;
  private static final String JSON_KEY_COLLECTION = &quot;collection&quot;;
  private static final String JSON_KEY_TRANSLATABLE = &quot;translatable&quot;;
  private static final String JSON_KEY_DELIMITER = &quot;delimiter&quot;;
  private static final String JSON_KEY_DIFFERENT_VALUES = &quot;differentValues&quot;;
  private static final String KEY_METADATA_TITLE = &quot;title&quot;;
  private static final String KEY_METADATA_FLAVOR = &quot;flavor&quot;;
  private static final String KEY_METADATA_FIELDS = &quot;fields&quot;;
  private static final String KEY_METADATA_LOCKED = &quot;locked&quot;;

  /* Keys for the different properties of the metadata JSON Object */
  private static final String KEY_METADATA_ID = &quot;id&quot;;
  private static final String KEY_METADATA_VALUE = &quot;value&quot;;

  private static final String PATTERN_DURATION = &quot;HH:mm:ss&quot;;

  /**
   * Turn a map into a {@link JSONObject} object
   *
   * @param map the source map
   * @return a new {@link JSONObject} generated with the map values
   */
  private static JsonObject mapToJson(final Map&lt;String, String&gt; map) {
<span class="fc" id="L82">    Objects.requireNonNull(map);</span>
<span class="fc" id="L83">    JsonObject json = new JsonObject();</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">    for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L85">      json.addProperty(entry.getKey(), safeString(entry.getValue()));</span>
<span class="fc" id="L86">    }</span>
<span class="fc" id="L87">    return json;</span>
  }

<span class="fc" id="L90">  public enum JsonType {</span>
<span class="fc" id="L91">    BOOLEAN, DATE, NUMBER, TEXT, MIXED_TEXT, ORDERED_TEXT, TEXT_LONG, TIME</span>
  }

  private MetadataJson() {
  }

  private static SimpleDateFormat getSimpleDateFormatter(final String pattern) {
    final SimpleDateFormat dateFormat;
<span class="fc bfc" id="L99" title="All 2 branches covered.">    if (StringUtils.isNotBlank(pattern)) {</span>
<span class="fc" id="L100">      dateFormat = new SimpleDateFormat(pattern);</span>
    } else {
<span class="fc" id="L102">      dateFormat = new SimpleDateFormat();</span>
    }
<span class="fc" id="L104">    dateFormat.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
<span class="fc" id="L105">    return dateFormat;</span>
  }

  private static &lt;T&gt; JsonElement valueToJson(final T rawValue, final MetadataField.Type type, final String pattern) {
<span class="pc bpc" id="L109" title="3 of 8 branches missed.">    switch (type) {</span>
      case BOOLEAN:
<span class="nc bnc" id="L111" title="All 2 branches missed.">        return rawValue == null ? new JsonPrimitive(&quot;&quot;) : new JsonPrimitive(rawValue.toString());</span>

      case DATE: {
<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (rawValue == null) return new JsonPrimitive(&quot;&quot;);</span>
<span class="fc" id="L115">        SimpleDateFormat dateFormat = getSimpleDateFormatter(pattern);</span>
<span class="fc" id="L116">        return new JsonPrimitive(dateFormat.format((Date) rawValue));</span>
      }

      case DURATION: {
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (rawValue == null) return new JsonPrimitive(&quot;&quot;);</span>
<span class="fc" id="L121">        long returnValue = 0L;</span>
<span class="fc" id="L122">        String value = (String) rawValue;</span>
<span class="fc" id="L123">        DCMIPeriod period = EncodingSchemeUtils.decodePeriod(value);</span>

<span class="pc bpc" id="L125" title="5 of 6 branches missed.">        if (period != null &amp;&amp; period.hasStart() &amp;&amp; period.hasEnd()) {</span>
<span class="nc" id="L126">          returnValue = period.getEnd().getTime() - period.getStart().getTime();</span>
        } else {
          try {
<span class="fc" id="L129">            returnValue = Long.parseLong(value);</span>
<span class="fc" id="L130">          } catch (NumberFormatException e) {</span>
<span class="fc" id="L131">            logger.debug(&quot;Unable to parse duration '{}' as either period or millisecond duration.&quot;, value);</span>
<span class="fc" id="L132">          }</span>
        }
<span class="fc" id="L134">        return new JsonPrimitive(DurationFormatUtils.formatDuration(returnValue, PATTERN_DURATION));</span>
      }

      case ITERABLE_TEXT:
      case MIXED_TEXT: {
<span class="fc" id="L139">        JsonArray jsonArray = new JsonArray();</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (rawValue == null) return jsonArray;</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (rawValue instanceof String) {</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">          for (String entry : ((String) rawValue).split(&quot;,&quot;)) {</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">            if (StringUtils.isNotBlank(entry)) {</span>
<span class="fc" id="L146">              jsonArray.add(safeString(entry));</span>
            }
          }
        } else {
<span class="fc bfc" id="L150" title="All 2 branches covered.">          for (Object val : (Iterable&lt;?&gt;) rawValue) {</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">            if (val != null) jsonArray.add(safeString(val));</span>
<span class="fc" id="L152">          }</span>
        }
<span class="fc" id="L154">        return jsonArray;</span>
      }

      case ORDERED_TEXT:
      case TEXT_LONG:
      case TEXT:
<span class="fc bfc" id="L160" title="All 2 branches covered.">        return rawValue == null ? new JsonPrimitive(&quot;&quot;) : new JsonPrimitive(rawValue.toString());</span>

      case LONG:
<span class="nc bnc" id="L163" title="All 2 branches missed.">        return rawValue == null ? new JsonPrimitive(&quot;&quot;) : new JsonPrimitive(rawValue.toString());</span>

      case START_DATE:
      case START_TIME: {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (rawValue == null) return new JsonPrimitive(&quot;&quot;);</span>
<span class="fc" id="L168">        String value = (String) rawValue;</span>

<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (StringUtils.isBlank(value)) return new JsonPrimitive(&quot;&quot;);</span>

        // Try to parse the metadata as DCIM metadata.
<span class="fc" id="L173">        final DCMIPeriod p = EncodingSchemeUtils.decodePeriod(value);</span>
<span class="fc" id="L174">        final SimpleDateFormat dateFormat = getSimpleDateFormatter(pattern);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (p != null) return new JsonPrimitive(dateFormat.format(p.getStart()));</span>

        // Not DCIM metadata so it might already be formatted (given from the front and is being returned there
        try {
<span class="fc" id="L179">          dateFormat.parse(value);</span>
<span class="fc" id="L180">          return new JsonPrimitive(value);</span>
<span class="nc" id="L181">        } catch (Exception e) {</span>
<span class="nc" id="L182">          logger.error(</span>
              &quot;Unable to parse temporal metadata '{}' as either DCIM data or a formatted date using pattern {} because:&quot;,
              value,
              pattern,
              e);
<span class="nc" id="L187">          throw new IllegalArgumentException(e);</span>
        }
      }

      default:
<span class="nc" id="L192">        throw new IllegalArgumentException(&quot;invalid metadata field of type '&quot; + type + &quot;'&quot;);</span>
    }
  }

  private static JsonType jsonType(final MetadataField f, final boolean withOrderedText) {
<span class="pc bpc" id="L197" title="4 of 9 branches missed.">    switch (f.getType()) {</span>
      case BOOLEAN:
<span class="nc" id="L199">        return JsonType.BOOLEAN;</span>
      case DATE:
      case START_DATE:
<span class="fc" id="L202">        return JsonType.DATE;</span>
      case DURATION:
      case ITERABLE_TEXT:
      case TEXT:
<span class="fc" id="L206">        return JsonType.TEXT;</span>
      case MIXED_TEXT:
<span class="fc" id="L208">        return JsonType.MIXED_TEXT;</span>
      case ORDERED_TEXT:
<span class="nc bnc" id="L210" title="All 2 branches missed.">        return withOrderedText ? JsonType.ORDERED_TEXT : JsonType.TEXT;</span>
      case LONG:
<span class="nc" id="L212">        return JsonType.NUMBER;</span>
      case START_TIME:
<span class="fc" id="L214">        return JsonType.TIME;</span>
      case TEXT_LONG:
<span class="fc" id="L216">        return JsonType.TEXT_LONG;</span>
      default:
<span class="nc" id="L218">        throw new IllegalArgumentException(&quot;invalid field type '&quot; + f.getType() + &quot;'&quot;);</span>
    }
  }

  private static Object valueFromJson(final Object value, final MetadataField field) {
<span class="pc bpc" id="L223" title="7 of 9 branches missed.">    switch (field.getType()) {</span>
      case BOOLEAN: {
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (value instanceof Boolean)</span>
<span class="nc" id="L226">          return value;</span>
<span class="nc" id="L227">        final String stringValue = value.toString();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (StringUtils.isBlank(stringValue))</span>
<span class="nc" id="L229">          return null;</span>
<span class="nc" id="L230">        return Boolean.parseBoolean(stringValue);</span>
      }
      case DATE: {
<span class="nc" id="L233">        final SimpleDateFormat dateFormat = getSimpleDateFormatter(field.getPattern());</span>
        try {
<span class="nc" id="L235">          final String date = (String) value;</span>

<span class="nc bnc" id="L237" title="All 2 branches missed.">          if (StringUtils.isBlank(date))</span>
<span class="nc" id="L238">            return null;</span>

<span class="nc" id="L240">          return dateFormat.parse(date);</span>
<span class="nc" id="L241">        } catch (final java.text.ParseException e) {</span>
<span class="nc" id="L242">          logger.error(&quot;Not able to parse date {}: {}&quot;, value, e.getMessage());</span>
<span class="nc" id="L243">          return null;</span>
        }
      }
      case DURATION: {
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (!(value instanceof String)) {</span>
<span class="nc" id="L248">          logger.warn(&quot;The given value for duration can not be parsed.&quot;);</span>
<span class="nc" id="L249">          return &quot;&quot;;</span>
        }

<span class="nc" id="L252">        final String duration = (String) value;</span>
<span class="nc" id="L253">        final String[] durationParts = duration.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (durationParts.length &lt; 3)</span>
<span class="nc" id="L255">          return null;</span>
<span class="nc" id="L256">        final long hours = Long.parseLong(durationParts[0]);</span>
<span class="nc" id="L257">        final long minutes = Long.parseLong(durationParts[1]);</span>
<span class="nc" id="L258">        final long seconds = Long.parseLong(durationParts[2]);</span>

<span class="nc" id="L260">        final long returnValue = ((hours * 60 + minutes) * 60 + seconds) * 1000;</span>

<span class="nc" id="L262">        return Long.toString(returnValue);</span>
      }
      case ITERABLE_TEXT: {
<span class="nc" id="L265">        final JSONArray array = (JSONArray) value;</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (array == null)</span>
<span class="nc" id="L267">          return null;</span>
<span class="nc" id="L268">        final String[] arrayOut = new String[array.size()];</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        for (int i = 0; i &lt; array.size(); i++)</span>
<span class="nc" id="L270">          arrayOut[i] = (String) array.get(i);</span>
<span class="nc" id="L271">        return Arrays.asList(arrayOut);</span>
      }
      case MIXED_TEXT: {
<span class="nc" id="L274">        final JSONParser parser = new JSONParser();</span>
        final JSONArray array;
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (value instanceof String) {</span>
          try {
<span class="nc" id="L278">            array = (JSONArray) parser.parse((String) value);</span>
<span class="nc" id="L279">          } catch (final ParseException e) {</span>
<span class="nc" id="L280">            throw new IllegalArgumentException(&quot;Unable to parse Mixed Iterable value into a JSONArray:&quot;, e);</span>
<span class="nc" id="L281">          }</span>
        } else {
<span class="nc" id="L283">          array = (JSONArray) value;</span>
        }

<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (array == null)</span>
<span class="nc" id="L287">          return new ArrayList&lt;&gt;();</span>
<span class="nc" id="L288">        final String[] arrayOut = new String[array.size()];</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        for (int i = 0; i &lt; array.size(); i++)</span>
<span class="nc" id="L290">          arrayOut[i] = (String) array.get(i);</span>
<span class="nc" id="L291">        return Arrays.asList(arrayOut);</span>
      }
      case TEXT:
      case TEXT_LONG:
      case ORDERED_TEXT: {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (value == null)</span>
<span class="nc" id="L297">          return &quot;&quot;;</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (!(value instanceof String)) {</span>
<span class="nc" id="L299">          logger.warn(&quot;Value cannot be parsed as String. Expecting type 'String', but received type '{}'.&quot;, value.getClass().getName());</span>
<span class="nc" id="L300">          return null;</span>
        }
<span class="fc" id="L302">        return value;</span>
      }
      case LONG: {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (!(value instanceof String)) {</span>
<span class="nc" id="L306">          logger.warn(&quot;The given value for Long can not be parsed.&quot;);</span>
<span class="nc" id="L307">          return 0L;</span>
        }
<span class="nc" id="L309">        final String longString = (String) value;</span>
<span class="nc" id="L310">        return Long.parseLong(longString);</span>
      }
      case START_DATE:
      case START_TIME:
      {
<span class="fc" id="L315">        final String date = (String) value;</span>

<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (StringUtils.isBlank(date))</span>
<span class="nc" id="L318">          return &quot;&quot;;</span>

        try {
<span class="fc" id="L321">          final SimpleDateFormat dateFormat = getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L322">          dateFormat.parse(date);</span>
<span class="nc" id="L323">        } catch (final java.text.ParseException e) {</span>
<span class="nc" id="L324">          logger.error(&quot;Not able to parse date string {}: {}&quot;, value, getMessage(e));</span>
<span class="nc" id="L325">          return null;</span>
<span class="fc" id="L326">        }</span>

<span class="fc" id="L328">        return date;</span>
      }
      default:
<span class="nc" id="L331">        throw new IllegalArgumentException(&quot;invalid field type '&quot; + field.getType() + &quot;'&quot;);</span>
    }
  }

  public static JsonObject fieldToJson(final MetadataField f, final boolean withOrderedText) {
<span class="fc" id="L336">    Objects.requireNonNull(f);</span>

<span class="fc" id="L338">    JsonObject json = new JsonObject();</span>

<span class="fc" id="L340">    json.addProperty(JSON_KEY_ID, safeString(f.getOutputID()));</span>
<span class="fc" id="L341">    json.addProperty(JSON_KEY_LABEL, safeString(f.getLabel()));</span>
<span class="fc" id="L342">    json.add(JSON_KEY_VALUE, valueToJson(f.getValue(), f.getType(), f.getPattern()));</span>
<span class="fc" id="L343">    json.addProperty(JSON_KEY_TYPE, safeString(jsonType(f, withOrderedText).toString().toLowerCase()));</span>
<span class="fc" id="L344">    json.addProperty(JSON_KEY_READONLY, f.isReadOnly());</span>
<span class="fc" id="L345">    json.addProperty(JSON_KEY_REQUIRED, f.isRequired());</span>

<span class="fc bfc" id="L347" title="All 2 branches covered.">    if (f.getCollection() != null) {</span>
<span class="fc" id="L348">      json.add(JSON_KEY_COLLECTION, mapToJson(f.getCollection()));</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">    } else if (f.getCollectionID() != null) {</span>
<span class="fc" id="L350">      json.addProperty(JSON_KEY_COLLECTION, f.getCollectionID());</span>
    }

<span class="fc bfc" id="L353" title="All 2 branches covered.">    if (f.isTranslatable() != null) {</span>
<span class="fc" id="L354">      json.addProperty(JSON_KEY_TRANSLATABLE, f.isTranslatable());</span>
    }
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">    if (f.getDelimiter() != null) {</span>
<span class="nc" id="L357">      json.addProperty(JSON_KEY_DELIMITER, f.getDelimiter());</span>
    }
<span class="fc bfc" id="L359" title="All 2 branches covered.">    if (f.hasDifferentValues() != null) {</span>
<span class="fc" id="L360">      json.addProperty(JSON_KEY_DIFFERENT_VALUES, f.hasDifferentValues());</span>
    }

<span class="fc" id="L363">    return json;</span>
  }

  public static String safeString(Object input) {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">    return input != null ? input.toString() : &quot;&quot;;</span>
  }

  public static MetadataField copyWithDifferentJsonValue(final MetadataField t, final String v) {
<span class="fc" id="L371">    final MetadataField copy = new MetadataField(t);</span>
<span class="fc" id="L372">    copy.setValue(valueFromJson(v, copy));</span>
<span class="fc" id="L373">    return copy;</span>
  }

  public static JsonArray collectionToJson(final DublinCoreMetadataCollection collection, final boolean withOrderedText) {
<span class="fc" id="L377">    JsonArray jsonArray = new JsonArray();</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">    for (MetadataField field : collection.getFields()) {</span>
<span class="fc" id="L379">      JsonObject fieldJson = fieldToJson(field, withOrderedText);</span>
<span class="fc" id="L380">      jsonArray.add(fieldJson);</span>
<span class="fc" id="L381">    }</span>
<span class="fc" id="L382">    return jsonArray;</span>
  }

  public static JSONArray extractSingleCollectionfromListJson(JSONArray json) {
<span class="nc bnc" id="L386" title="All 4 branches missed.">    if (json == null || json.size() != 1) {</span>
<span class="nc" id="L387">      throw new IllegalArgumentException(&quot;Input has to be a JSONArray with one entry&quot;);</span>
    }

<span class="nc" id="L390">    return (JSONArray) ((JSONObject) json.get(0)).get(KEY_METADATA_FIELDS);</span>
  }

  public static void fillCollectionFromJson(final DublinCoreMetadataCollection collection, final Object json) {
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">    if (!(json instanceof  JSONArray))</span>
<span class="nc" id="L395">      throw new IllegalArgumentException(&quot;couldn't fill metadata collection, didn't get an array&quot;);</span>

<span class="fc" id="L397">    final JSONArray metadataJson = (JSONArray) json;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">    for (final JSONObject item : (Iterable&lt;JSONObject&gt;) metadataJson) {</span>
<span class="fc" id="L399">      final String fieldId = (String) item.get(KEY_METADATA_ID);</span>

<span class="pc bpc" id="L401" title="1 of 2 branches missed.">      if (fieldId == null)</span>
<span class="nc" id="L402">        continue;</span>
<span class="fc" id="L403">      final Object value = item.get(KEY_METADATA_VALUE);</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">      if (value == null)</span>
<span class="nc" id="L405">        continue;</span>

<span class="fc" id="L407">      final MetadataField target = collection.getOutputFields().get(fieldId);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">      if (target == null)</span>
<span class="fc" id="L409">        continue;</span>

<span class="fc" id="L411">      final Object o = valueFromJson(value, target);</span>
<span class="fc" id="L412">      target.setValue(o);</span>
<span class="fc" id="L413">    }</span>
<span class="fc" id="L414">  }</span>

  public static void fillListFromJson(final MetadataList metadataList, final JSONArray json) {
<span class="fc bfc" id="L417" title="All 2 branches covered.">    for (final JSONObject item : (Iterable&lt;JSONObject&gt;) json) {</span>
<span class="fc" id="L418">      final MediaPackageElementFlavor flavor = MediaPackageElementFlavor</span>
<span class="fc" id="L419">              .parseFlavor((String) item.get(KEY_METADATA_FLAVOR));</span>
<span class="fc" id="L420">      final String title = (String) item.get(KEY_METADATA_TITLE);</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">      if (title == null)</span>
<span class="nc" id="L422">        continue;</span>

<span class="fc" id="L424">      final JSONArray value = (JSONArray) item.get(KEY_METADATA_FIELDS);</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">      if (value == null)</span>
<span class="nc" id="L426">        continue;</span>

<span class="fc" id="L428">      final DublinCoreMetadataCollection collection = metadataList.getMetadataByFlavor(flavor.toString());</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">      if (collection == null)</span>
<span class="fc" id="L430">        continue;</span>
<span class="fc" id="L431">      MetadataJson.fillCollectionFromJson(collection, value);</span>
<span class="fc" id="L432">    }</span>
<span class="fc" id="L433">  }</span>

  public static JsonArray listToJson(final MetadataList metadataList, final boolean withOrderedText) {
<span class="fc" id="L436">    JsonArray catalogs = new JsonArray();</span>

<span class="fc bfc" id="L438" title="All 2 branches covered.">    for (Map.Entry&lt;String, MetadataList.TitledMetadataCollection&gt; metadata : metadataList.getMetadataList().entrySet()) {</span>
<span class="fc" id="L439">      JsonObject catalogJson = new JsonObject();</span>

<span class="fc" id="L441">      DublinCoreMetadataCollection metadataCollection = metadata.getValue().getCollection();</span>

<span class="fc bfc" id="L443" title="All 2 branches covered.">      if (!MetadataList.Locked.NONE.equals(metadataList.getLocked())) {</span>
<span class="fc" id="L444">        catalogJson.addProperty(KEY_METADATA_LOCKED, metadataList.getLocked().getValue());</span>
<span class="fc" id="L445">        metadataCollection = metadataCollection.readOnlyCopy();</span>
      }

<span class="fc" id="L448">      catalogJson.addProperty(KEY_METADATA_FLAVOR, metadata.getKey());</span>
<span class="fc" id="L449">      catalogJson.addProperty(KEY_METADATA_TITLE, metadata.getValue().getTitle());</span>
<span class="fc" id="L450">      catalogJson.add(KEY_METADATA_FIELDS, collectionToJson(metadataCollection, withOrderedText));</span>

<span class="fc" id="L452">      catalogs.add(catalogJson);</span>
<span class="fc" id="L453">    }</span>

<span class="fc" id="L455">    return catalogs;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>