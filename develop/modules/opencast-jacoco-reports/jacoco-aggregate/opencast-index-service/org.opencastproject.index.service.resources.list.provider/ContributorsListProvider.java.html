<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ContributorsListProvider.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-index-service</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.index.service.resources.list.provider</a> &gt; <span class="el_source">ContributorsListProvider.java</span></div><h1>ContributorsListProvider.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.index.service.resources.list.provider;

import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.objects.event.EventIndexSchema;
import org.opencastproject.elasticsearch.index.objects.series.Series;
import org.opencastproject.elasticsearch.index.objects.series.SeriesIndexSchema;
import org.opencastproject.list.api.ResourceListProvider;
import org.opencastproject.list.api.ResourceListQuery;
import org.opencastproject.list.util.ListProviderUtil;
import org.opencastproject.security.api.User;
import org.opencastproject.security.api.UserDirectoryService;

import org.apache.commons.lang3.StringUtils;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Modified;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

@Component(
    service = ResourceListProvider.class,
    property = {
        &quot;service.description=Contributors list provider&quot;,
        &quot;opencast.service.type=org.opencastproject.index.service.resources.list.provider.ContributorsListProvider&quot;
    }
)
<span class="fc" id="L64">public class ContributorsListProvider implements ResourceListProvider {</span>

  private static final String CONFIGURATION_KEY_EXCLUDE_USER_PROVIDER = &quot;exclude.user.provider&quot;;
  private static final String ALL_USER_PROVIDERS_VALUE = &quot;*&quot;;

  private static final String PROVIDER_PREFIX = &quot;CONTRIBUTORS&quot;;

  public static final String DEFAULT = PROVIDER_PREFIX;
  public static final String NAMES_TO_USERNAMES = PROVIDER_PREFIX + &quot;.NAMES.TO.USERNAMES&quot;;
  public static final String USERNAMES = PROVIDER_PREFIX + &quot;.USERNAMES&quot;;

<span class="fc" id="L75">  protected static final String[] NAMES = { PROVIDER_PREFIX, USERNAMES, NAMES_TO_USERNAMES };</span>

<span class="fc" id="L77">  private static final Logger logger = LoggerFactory.getLogger(ContributorsListProvider.class);</span>

<span class="fc" id="L79">  private final Set&lt;String&gt; excludeUserProvider = new HashSet&lt;&gt;();</span>
  private UserDirectoryService userDirectoryService;
  private ElasticsearchIndex searchIndex;

  @Activate
  protected void activate(Map&lt;String, Object&gt; properties) {
<span class="nc" id="L85">    modified(properties);</span>
<span class="nc" id="L86">    logger.info(&quot;Contributors list provider activated!&quot;);</span>
<span class="nc" id="L87">  }</span>

  @Modified
  public void modified(Map&lt;String, Object&gt; properties) {
<span class="fc" id="L91">    Object excludeUserProviderValue = properties.get(CONFIGURATION_KEY_EXCLUDE_USER_PROVIDER);</span>
<span class="fc" id="L92">    excludeUserProvider.clear();</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">    if (excludeUserProviderValue != null) {</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">      for (String userProvider : StringUtils.split(excludeUserProviderValue.toString(), ',')) {</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        if (StringUtils.trimToNull(userProvider) != null) {</span>
<span class="fc" id="L96">          excludeUserProvider.add(StringUtils.trimToNull(userProvider));</span>
        }
      }
    }
<span class="fc" id="L100">    logger.debug(&quot;Excluded user providers: {}&quot;, excludeUserProvider);</span>
<span class="fc" id="L101">  }</span>

  /** OSGi callback for users services. */
  @Reference
  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {
<span class="fc" id="L106">    this.userDirectoryService = userDirectoryService;</span>
<span class="fc" id="L107">  }</span>

  /** OSGi callback for the search index. */
  @Reference
  public void setIndex(ElasticsearchIndex index) {
<span class="fc" id="L112">    this.searchIndex = index;</span>
<span class="fc" id="L113">  }</span>

  @Override
  public String[] getListNames() {
<span class="fc" id="L117">    return NAMES;</span>
  }

  @Override
  public Map&lt;String, String&gt; getList(String listName, ResourceListQuery query) {
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    if (listName.equalsIgnoreCase(USERNAMES)) {</span>
<span class="nc" id="L123">      return getListWithUserNames(query);</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">    } else if (listName.equalsIgnoreCase(NAMES_TO_USERNAMES)) {</span>
<span class="fc" id="L125">      return getListWithTechnicalPresenters(query);</span>
    } else {
<span class="fc" id="L127">      return getList(query);</span>
    }
  }

  /**
   * Get all of the contributors with friendly printable names.
   *
   * @param query
   *          The query for the list including limit and offset.
   * @return The {@link Map} including all of the contributors.
   */
  protected Map&lt;String, String&gt; getList(ResourceListQuery query) {
<span class="fc" id="L139">    Map&lt;String, String&gt; usersList = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L140">    int offset = 0;</span>
<span class="fc" id="L141">    int limit = 0;</span>
<span class="fc" id="L142">    SortedSet&lt;String&gt; contributorsList = new TreeSet&lt;String&gt;(new Comparator&lt;String&gt;() {</span>
      @Override
      public int compare(String name1, String name2) {
<span class="fc" id="L145">        return name1.compareTo(name2);</span>
      }
    });

<span class="pc bpc" id="L149" title="1 of 2 branches missed.">    if (!excludeUserProvider.contains(ALL_USER_PROVIDERS_VALUE)) {</span>
<span class="fc" id="L150">      Iterator&lt;User&gt; users = userDirectoryService.findUsers(&quot;%&quot;, offset, limit);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">      while (users.hasNext()) {</span>
<span class="fc" id="L152">        User u = users.next();</span>
<span class="fc bfc" id="L153" title="All 4 branches covered.">        if (!excludeUserProvider.contains(u.getProvider()) &amp;&amp; StringUtils.isNotBlank(u.getName()))</span>
<span class="fc" id="L154">          contributorsList.add(u.getName());</span>
<span class="fc" id="L155">      }</span>
    }

<span class="fc" id="L158">    contributorsList.addAll(searchIndex.getTermsForField(EventIndexSchema.CONTRIBUTOR,</span>
            Event.DOCUMENT_TYPE));
<span class="fc" id="L160">    contributorsList.addAll(searchIndex.getTermsForField(EventIndexSchema.PRESENTER,</span>
            Event.DOCUMENT_TYPE));
<span class="fc" id="L162">    contributorsList.addAll(searchIndex.getTermsForField(EventIndexSchema.PUBLISHER,</span>
            Event.DOCUMENT_TYPE));
<span class="fc" id="L164">    contributorsList.addAll(searchIndex.getTermsForField(SeriesIndexSchema.CONTRIBUTORS,</span>
            Series.DOCUMENT_TYPE));
<span class="fc" id="L166">    contributorsList.addAll(searchIndex.getTermsForField(SeriesIndexSchema.ORGANIZERS,</span>
            Series.DOCUMENT_TYPE));
<span class="fc" id="L168">    contributorsList.addAll(searchIndex.getTermsForField(SeriesIndexSchema.PUBLISHERS,</span>
            Series.DOCUMENT_TYPE));

    // TODO: TThis is not a good idea.
    // TODO: The search index can handle limit and offset.
    // TODO: We should not request all data.
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">    if (query != null) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">      if (query.getLimit().isSome())</span>
<span class="nc" id="L176">        limit = query.getLimit().get();</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">      if (query.getOffset().isSome())</span>
<span class="nc" id="L179">        offset = query.getOffset().get();</span>
    }

<span class="fc" id="L182">    int i = 0;</span>

<span class="fc bfc" id="L184" title="All 2 branches covered.">    for (String contributor : contributorsList) {</span>
<span class="pc bpc" id="L185" title="4 of 6 branches missed.">      if (i &gt;= offset &amp;&amp; (limit == 0 || i &lt; limit)) {</span>
<span class="fc" id="L186">        usersList.put(contributor, contributor);</span>
      }
<span class="fc" id="L188">      i++;</span>
<span class="fc" id="L189">    }</span>

<span class="fc" id="L191">    return usersList;</span>
  }

  /**
   * Get the contributors list including usernames and organizations for the users available.
   *
   * @param query
   *          The query for the list including limit and offset.
   * @return The {@link Map} including all of the contributors.
   */
  protected Map&lt;String, String&gt; getListWithTechnicalPresenters(ResourceListQuery query) {
<span class="fc" id="L202">    int offset = 0;</span>
<span class="fc" id="L203">    int limit = 0;</span>

<span class="fc" id="L205">    List&lt;Contributor&gt; contributorsList = new ArrayList&lt;Contributor&gt;();</span>

<span class="fc" id="L207">    HashSet&lt;String&gt; labels = new HashSet&lt;String&gt;();</span>

<span class="pc bpc" id="L209" title="1 of 2 branches missed.">    if (!excludeUserProvider.contains(ALL_USER_PROVIDERS_VALUE)) {</span>
<span class="fc" id="L210">      Iterator&lt;User&gt; users = userDirectoryService.findUsers(&quot;%&quot;, offset, limit);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">      while (users.hasNext()) {</span>
<span class="fc" id="L212">        User u = users.next();</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (!excludeUserProvider.contains(u.getProvider())) {</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">          if (StringUtils.isNotBlank(u.getName())) {</span>
<span class="fc" id="L215">            contributorsList.add(new Contributor(u.getUsername(), u.getName()));</span>
<span class="fc" id="L216">            labels.add(u.getName());</span>
          } else {
<span class="fc" id="L218">            contributorsList.add(new Contributor(u.getUsername(), u.getUsername()));</span>
<span class="fc" id="L219">            labels.add(u.getUsername());</span>
          }
        }
<span class="fc" id="L222">      }</span>
    }

<span class="fc" id="L225">    addIndexNamesToMap(labels, contributorsList, searchIndex</span>
<span class="fc" id="L226">            .getTermsForField(EventIndexSchema.PRESENTER, Event.DOCUMENT_TYPE));</span>
<span class="fc" id="L227">    addIndexNamesToMap(labels, contributorsList, searchIndex</span>
<span class="fc" id="L228">            .getTermsForField(EventIndexSchema.CONTRIBUTOR, Event.DOCUMENT_TYPE));</span>
<span class="fc" id="L229">    addIndexNamesToMap(labels, contributorsList, searchIndex</span>
<span class="fc" id="L230">            .getTermsForField(SeriesIndexSchema.CONTRIBUTORS, Event.DOCUMENT_TYPE));</span>
<span class="fc" id="L231">    addIndexNamesToMap(labels, contributorsList, searchIndex</span>
<span class="fc" id="L232">            .getTermsForField(SeriesIndexSchema.ORGANIZERS, Event.DOCUMENT_TYPE));</span>
<span class="fc" id="L233">    addIndexNamesToMap(labels, contributorsList, searchIndex</span>
<span class="fc" id="L234">            .getTermsForField(SeriesIndexSchema.PUBLISHERS, Event.DOCUMENT_TYPE));</span>

<span class="fc" id="L236">    Collections.sort(contributorsList, new Comparator&lt;Contributor&gt;() {</span>
      @Override
      public int compare(Contributor contributor1, Contributor contributor2) {
<span class="fc" id="L239">        return contributor1.getLabel().compareTo(contributor2.getLabel());</span>
      }
    });

<span class="fc" id="L243">    Map&lt;String, String&gt; contributorMap = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">    for (Contributor contributor : contributorsList) {</span>
<span class="fc" id="L245">      contributorMap.put(contributor.getKey(), contributor.getLabel());</span>
<span class="fc" id="L246">    }</span>

<span class="fc" id="L248">    return ListProviderUtil.filterMap(contributorMap, query);</span>
  }

  /**
   * Get the contributors list including usernames and organizations for the users available.
   *
   * @param query
   *          The query for the list including limit and offset.
   * @return The {@link Map} including all of the contributors.
   */
  protected Map&lt;String, String&gt; getListWithUserNames(ResourceListQuery query) {

<span class="nc" id="L260">    int offset = 0;</span>
<span class="nc" id="L261">    int limit = 0;</span>

<span class="nc" id="L263">    List&lt;Contributor&gt; contributorsList = new ArrayList&lt;Contributor&gt;();</span>

<span class="nc" id="L265">    HashSet&lt;String&gt; labels = new HashSet&lt;String&gt;();</span>

<span class="nc bnc" id="L267" title="All 2 branches missed.">    if (!excludeUserProvider.contains(ALL_USER_PROVIDERS_VALUE)) {</span>
<span class="nc" id="L268">      Iterator&lt;User&gt; users = userDirectoryService.findUsers(&quot;%&quot;, offset, limit);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">      while (users.hasNext()) {</span>
<span class="nc" id="L270">        User u = users.next();</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (!excludeUserProvider.contains(u.getProvider())) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">          if (StringUtils.isNotBlank(u.getName())) {</span>
<span class="nc" id="L273">            contributorsList.add(new Contributor(u.getUsername(), u.getName()));</span>
<span class="nc" id="L274">            labels.add(u.getName());</span>
          } else {
<span class="nc" id="L276">            contributorsList.add(new Contributor(u.getUsername(), u.getUsername()));</span>
<span class="nc" id="L277">            labels.add(u.getUsername());</span>
          }
        }
<span class="nc" id="L280">      }</span>
    }

<span class="nc" id="L283">    Collections.sort(contributorsList, new Comparator&lt;Contributor&gt;() {</span>
      @Override
      public int compare(Contributor contributor1, Contributor contributor2) {
<span class="nc" id="L286">        return contributor1.getLabel().compareTo(contributor2.getLabel());</span>
      }
    });

<span class="nc" id="L290">    Map&lt;String, String&gt; contributorMap = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">    for (Contributor contributor : contributorsList) {</span>
<span class="nc" id="L292">      contributorMap.put(contributor.getKey(), contributor.getLabel());</span>
<span class="nc" id="L293">    }</span>

<span class="nc" id="L295">    return ListProviderUtil.filterMap(contributorMap, query);</span>
  }

  /**
   * Add all names in the index to the map if they aren't already present as a user.
   *
   * @param userLabels
   *          The collection of user labels, the full names of the users.
   * @param contributors
   *          The collection of all contributors including the index names that will be added.
   * @param indexNames
   *          The list of new names from the index.
   */
  protected void addIndexNamesToMap(Set&lt;String&gt; userLabels, Collection&lt;Contributor&gt; contributors,
          List&lt;String&gt; indexNames) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">    for (String indexName : indexNames) {</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">      if (!userLabels.contains(indexName)) {</span>
<span class="fc" id="L312">        contributors.add(new Contributor(indexName, indexName));</span>
      }
<span class="fc" id="L314">    }</span>
<span class="fc" id="L315">  }</span>

  @Override
  public boolean isTranslatable(String listName) {
<span class="nc" id="L319">    return false;</span>
  }

  @Override
  public String getDefault() {
<span class="nc" id="L324">    return null;</span>
  }

  private class Contributor {
    public String getKey() {
<span class="fc" id="L329">      return key;</span>
    }

    public String getLabel() {
<span class="fc" id="L333">      return label;</span>
    }

    private String key;
    private String label;

<span class="fc" id="L339">    Contributor(String key, String label) {</span>
<span class="fc" id="L340">      this.key = key;</span>
<span class="fc" id="L341">      this.label = label;</span>
<span class="fc" id="L342">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L346">      return key + &quot;:&quot; + label;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>