<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IndexServiceImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-index-service</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.index.service.impl</a> &gt; <span class="el_source">IndexServiceImpl.java</span></div><h1>IndexServiceImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.index.service.impl;

import static org.opencastproject.metadata.dublincore.DublinCore.PROPERTY_IDENTIFIER;
import static org.opencastproject.security.api.DefaultOrganization.DEFAULT_ORGANIZATION_ID;
import static org.opencastproject.workflow.api.ConfiguredWorkflow.workflow;

import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.AssetManagerException;
import org.opencastproject.assetmanager.api.Snapshot;
import org.opencastproject.assetmanager.util.WorkflowPropertiesUtil;
import org.opencastproject.assetmanager.util.Workflows;
import org.opencastproject.authorization.xacml.manager.api.AclService;
import org.opencastproject.authorization.xacml.manager.api.AclServiceFactory;
import org.opencastproject.capture.CaptureParameters;
import org.opencastproject.capture.admin.api.CaptureAgentStateService;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.objects.event.EventSearchQuery;
import org.opencastproject.elasticsearch.index.objects.series.Series;
import org.opencastproject.event.comment.EventComment;
import org.opencastproject.event.comment.EventCommentException;
import org.opencastproject.event.comment.EventCommentParser;
import org.opencastproject.event.comment.EventCommentService;
import org.opencastproject.index.service.api.IndexService;
import org.opencastproject.index.service.catalog.adapter.DublinCoreMetadataUtil;
import org.opencastproject.index.service.catalog.adapter.MetadataUtils;
import org.opencastproject.index.service.catalog.adapter.events.CommonEventCatalogUIAdapter;
import org.opencastproject.index.service.catalog.adapter.series.CommonSeriesCatalogUIAdapter;
import org.opencastproject.index.service.exception.IndexServiceException;
import org.opencastproject.index.service.exception.UnsupportedAssetException;
import org.opencastproject.index.service.impl.util.EventHttpServletRequest;
import org.opencastproject.index.service.impl.util.EventUtils;
import org.opencastproject.index.service.impl.util.Retraction;
import org.opencastproject.index.service.impl.util.RetractionListener;
import org.opencastproject.index.service.util.JSONUtils;
import org.opencastproject.index.service.util.RequestUtils;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.ingest.api.IngestException;
import org.opencastproject.ingest.api.IngestService;
import org.opencastproject.list.api.ListProvidersService;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.EName;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElement.Type;
import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.metadata.dublincore.DCMIPeriod;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.DublinCoreUtil;
import org.opencastproject.metadata.dublincore.DublinCoreValue;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.metadata.dublincore.EncodingSchemeUtils;
import org.opencastproject.metadata.dublincore.EventCatalogUIAdapter;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.MetadataJson;
import org.opencastproject.metadata.dublincore.MetadataList;
import org.opencastproject.metadata.dublincore.Precision;
import org.opencastproject.metadata.dublincore.SeriesCatalogUIAdapter;
import org.opencastproject.scheduler.api.SchedulerException;
import org.opencastproject.scheduler.api.SchedulerService;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.AclScope;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.api.User;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.security.util.SecurityContext;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.series.api.SeriesException;
import org.opencastproject.series.api.SeriesService;
import org.opencastproject.util.Checksum;
import org.opencastproject.util.ChecksumType;
import org.opencastproject.util.DateTimeSupport;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.XmlNamespaceBinding;
import org.opencastproject.util.XmlNamespaceContext;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.workflow.api.ConfiguredWorkflow;
import org.opencastproject.workflow.api.WorkflowDatabaseException;
import org.opencastproject.workflow.api.WorkflowDefinition;
import org.opencastproject.workflow.api.WorkflowException;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowInstance.WorkflowState;
import org.opencastproject.workflow.api.WorkflowParsingException;
import org.opencastproject.workflow.api.WorkflowService;
import org.opencastproject.workspace.api.Workspace;

import com.google.common.net.MediaType;

import net.fortuna.ical4j.model.Period;
import net.fortuna.ical4j.model.property.RRule;

import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.jettison.json.JSONException;
import org.joda.time.DateTimeZone;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.TimeZone;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;

@Component(
    immediate = true,
    service = IndexService.class,
    property = {
        &quot;service.description=Index Services Implementation&quot;
    }
)
<span class="fc" id="L184">public class IndexServiceImpl implements IndexService {</span>

  private static final String WORKFLOW_CONFIG_PREFIX = &quot;org.opencastproject.workflow.config.&quot;;

  public static final String THEME_PROPERTY_NAME = &quot;theme&quot;;

  /** The logging facility */
<span class="fc" id="L191">  private static final Logger logger = LoggerFactory.getLogger(IndexServiceImpl.class);</span>

<span class="fc" id="L193">  private final List&lt;EventCatalogUIAdapter&gt; eventCatalogUIAdapters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L194">  private final List&lt;SeriesCatalogUIAdapter&gt; seriesCatalogUIAdapters = new ArrayList&lt;&gt;();</span>

  /** A parser for handling JSON documents inside the body of a request. **/
<span class="fc" id="L197">  private static final JSONParser parser = new JSONParser();</span>

<span class="fc" id="L199">  private String attachmentRegex = &quot;^attachment.*&quot;;</span>
<span class="fc" id="L200">  private String catalogRegex = &quot;^catalog.*&quot;;</span>
<span class="fc" id="L201">  private String trackRegex = &quot;^track.*&quot;;</span>
<span class="fc" id="L202">  private String numberedAssetRegex = &quot;^\\*$&quot;;</span>

<span class="fc" id="L204">  private Pattern patternAttachment = Pattern.compile(attachmentRegex);</span>
<span class="fc" id="L205">  private Pattern patternCatalog = Pattern.compile(catalogRegex);</span>
<span class="fc" id="L206">  private Pattern patternTrack = Pattern.compile(trackRegex);</span>
<span class="fc" id="L207">  private Pattern patternNumberedAsset = Pattern.compile(numberedAssetRegex);</span>

  private AclServiceFactory aclServiceFactory;
  private AuthorizationService authorizationService;
  private CaptureAgentStateService captureAgentStateService;
  private EventCommentService eventCommentService;
  private IngestService ingestService;
  private ListProvidersService listProvidersService;
  private AssetManager assetManager;
  private SchedulerService schedulerService;
  private SecurityService securityService;
  private SeriesService seriesService;
  private UserDirectoryService userDirectoryService;
  private WorkflowService workflowService;
  private Workspace workspace;
  private ElasticsearchIndex elasticsearchIndex;

  /** The single thread executor service */
<span class="fc" id="L225">  private ExecutorService executorService = Executors.newSingleThreadExecutor();</span>

<span class="fc" id="L227">  private Map&lt;Long, Retraction&gt; retractions = new ConcurrentHashMap&lt;&gt;();</span>

  /**
   * OSGi DI.
   *
   * @param aclServiceFactory
   *          the factory to set
   */
  @Reference
  public void setAclServiceFactory(AclServiceFactory aclServiceFactory) {
<span class="nc" id="L237">    this.aclServiceFactory = aclServiceFactory;</span>
<span class="nc" id="L238">  }</span>

  @Reference
  public void setElasticsearchIndex(ElasticsearchIndex elasticsearchIndex) {
<span class="nc" id="L242">    this.elasticsearchIndex = elasticsearchIndex;</span>
<span class="nc" id="L243">  }</span>

  /**
   * OSGi DI.
   *
   * @param authorizationService
   *          the service to set
   */
  @Reference
  public void setAuthorizationService(AuthorizationService authorizationService) {
<span class="fc" id="L253">    this.authorizationService = authorizationService;</span>
<span class="fc" id="L254">  }</span>

  /**
   * OSGi DI.
   *
   * @param captureAgentStateService
   *          the service to set
   */
  @Reference
  public void setCaptureAgentStateService(CaptureAgentStateService captureAgentStateService) {
<span class="fc" id="L264">    this.captureAgentStateService = captureAgentStateService;</span>
<span class="fc" id="L265">  }</span>

  /**
   * OSGi callback for the event comment service.
   *
   * @param eventCommentService
   *          the service to set
   */
  @Reference
  public void setEventCommentService(EventCommentService eventCommentService) {
<span class="nc" id="L275">    this.eventCommentService = eventCommentService;</span>
<span class="nc" id="L276">  }</span>

  /**
   * OSGi callback to add {@link EventCatalogUIAdapter} instance.
   *
   * @param catalogUIAdapter
   *          the adapter to add
   */
  @Reference(
      name = &quot;EventCatalogUIAdapter&quot;,
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeCatalogUIAdapter&quot;
  )
  public void addCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="fc" id="L291">    eventCatalogUIAdapters.add(catalogUIAdapter);</span>
<span class="fc" id="L292">  }</span>

  /**
   * OSGi callback to remove {@link EventCatalogUIAdapter} instance.
   *
   * @param catalogUIAdapter
   *          the adapter to remove
   */
  public void removeCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L301">    eventCatalogUIAdapters.remove(catalogUIAdapter);</span>
<span class="nc" id="L302">  }</span>

  /**
   * OSGi callback to add {@link SeriesCatalogUIAdapter} instance.
   *
   * @param catalogUIAdapter
   *          the adapter to add
   */
  @Reference(
      name = &quot;SeriesCatalogUIAdapter&quot;,
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeCatalogUIAdapter&quot;
  )
  public void addCatalogUIAdapter(SeriesCatalogUIAdapter catalogUIAdapter) {
<span class="fc" id="L317">    seriesCatalogUIAdapters.add(catalogUIAdapter);</span>
<span class="fc" id="L318">  }</span>

  /**
   * OSGi callback to remove {@link SeriesCatalogUIAdapter} instance.
   *
   * @param catalogUIAdapter
   *          the adapter to remove
   */
  public void removeCatalogUIAdapter(SeriesCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L327">    seriesCatalogUIAdapters.remove(catalogUIAdapter);</span>
<span class="nc" id="L328">  }</span>

  /**
   * OSGi DI.
   *
   * @param ingestService
   *          the service to set
   */
  @Reference
  public void setIngestService(IngestService ingestService) {
<span class="fc" id="L338">    this.ingestService = ingestService;</span>
<span class="fc" id="L339">  }</span>

  /**
   * OSGi DI.
   *
   * @param listProvidersService
   *          the service to set
   */
  @Reference
  public void setListProvidersService(ListProvidersService listProvidersService) {
<span class="nc" id="L349">    this.listProvidersService = listProvidersService;</span>
<span class="nc" id="L350">  }</span>

  /**
   * OSGi DI.
   *
   * @param assetManager
   *          the manager to set
   */
  @Reference
  public void setAssetManager(AssetManager assetManager) {
<span class="fc" id="L360">    this.assetManager = assetManager;</span>
<span class="fc" id="L361">  }</span>

  /**
   * OSGi DI.
   *
   * @param schedulerService
   *          the service to set
   */
  @Reference
  public void setSchedulerService(SchedulerService schedulerService) {
<span class="fc" id="L371">    this.schedulerService = schedulerService;</span>
<span class="fc" id="L372">  }</span>

  /**
   * OSGi DI.
   *
   * @param securityService
   *          the service to set
   */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L382">    this.securityService = securityService;</span>
<span class="fc" id="L383">  }</span>

  /**
   * OSGi DI.
   *
   * @param seriesService
   *          the service to set
   */
  @Reference
  public void setSeriesService(SeriesService seriesService) {
<span class="fc" id="L393">    this.seriesService = seriesService;</span>
<span class="fc" id="L394">  }</span>

  /**
   * OSGi DI.
   *
   * @param workflowService
   *          the service to set
   */
  @Reference
  public void setWorkflowService(WorkflowService workflowService) {
<span class="nc" id="L404">    this.workflowService = workflowService;</span>
<span class="nc" id="L405">  }</span>

  /**
   * OSGi DI.
   *
   * @param workspace
   *          the workspace to set
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="fc" id="L415">    this.workspace = workspace;</span>
<span class="fc" id="L416">  }</span>

  /**
   * OSGi DI.
   *
   * @param userDirectoryService
   *          the service to set
   */
  @Reference
  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {
<span class="fc" id="L426">    this.userDirectoryService = userDirectoryService;</span>
<span class="fc" id="L427">  }</span>

  /**
   *
   * @return the acl service
   */
  public AclService getAclService() {
<span class="nc" id="L434">    return aclServiceFactory.serviceFor(securityService.getOrganization());</span>
  }

  public List&lt;EventCatalogUIAdapter&gt; getEventCatalogUIAdapters(String organization) {
<span class="fc" id="L438">    return eventCatalogUIAdapters.stream().filter(a -&gt; a.handlesOrganization(organization))</span>
<span class="fc" id="L439">            .collect(Collectors.toList());</span>
  }

  /**
   * @param organization
   *          The organization to filter the results with.
   * @return A {@link List} of {@link SeriesCatalogUIAdapter} that provide the metadata to the front end.
   */
  public List&lt;SeriesCatalogUIAdapter&gt; getSeriesCatalogUIAdapters(String organization) {
<span class="nc" id="L448">    return seriesCatalogUIAdapters.stream().filter(a -&gt; a.handlesOrganization(organization))</span>
<span class="nc" id="L449">            .collect(Collectors.toList());</span>
  }

  public EventCatalogUIAdapter getCommonEventCatalogUIAdapter(String organization) {
<span class="fc" id="L453">    Optional&lt;EventCatalogUIAdapter&gt; orgEventCatalogUIAdapter = eventCatalogUIAdapters.stream()</span>
<span class="fc" id="L454">            .filter(a -&gt; a instanceof CommonEventCatalogUIAdapter)</span>
<span class="fc" id="L455">            .filter(a -&gt; a.handlesOrganization(organization))</span>
<span class="fc" id="L456">            .findFirst();</span>

<span class="pc bpc" id="L458" title="1 of 2 branches missed.">    if (orgEventCatalogUIAdapter.isPresent()) {</span>
<span class="fc" id="L459">      return orgEventCatalogUIAdapter.get();</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">    } else if (!organization.equals(DEFAULT_ORGANIZATION_ID)) {</span>
<span class="nc" id="L461">      return getCommonEventCatalogUIAdapter(DEFAULT_ORGANIZATION_ID);</span>
    } else {
<span class="nc" id="L463">       throw new IllegalStateException(&quot;Common event metadata for &quot; + DEFAULT_ORGANIZATION_ID + &quot; needs to be &quot;</span>
               + &quot;configured!&quot;);
    }
  }

  public SeriesCatalogUIAdapter getCommonSeriesCatalogUIAdapter(String organization) {
<span class="nc" id="L469">    Optional&lt;SeriesCatalogUIAdapter&gt; orgSeriesCatalogUIAdapter = seriesCatalogUIAdapters.stream()</span>
<span class="nc" id="L470">            .filter(a -&gt; a instanceof CommonSeriesCatalogUIAdapter)</span>
<span class="nc" id="L471">            .filter(a -&gt; a.handlesOrganization(organization))</span>
<span class="nc" id="L472">            .findFirst();</span>

<span class="nc bnc" id="L474" title="All 2 branches missed.">    if (orgSeriesCatalogUIAdapter.isPresent()) {</span>
<span class="nc" id="L475">      return orgSeriesCatalogUIAdapter.get();</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">    } else if (!organization.equals(DEFAULT_ORGANIZATION_ID)) {</span>
<span class="nc" id="L477">      return getCommonSeriesCatalogUIAdapter(DEFAULT_ORGANIZATION_ID);</span>
    } else {
<span class="nc" id="L479">      throw new IllegalStateException(&quot;Common series metadata for &quot; + DEFAULT_ORGANIZATION_ID + &quot; needs to be &quot;</span>
              + &quot;configured!&quot;);
    }
  }

  @Override
  public List&lt;EventCatalogUIAdapter&gt; getEventCatalogUIAdapters() {
<span class="fc" id="L486">    return new ArrayList&lt;&gt;(getEventCatalogUIAdapters(securityService.getOrganization().getId()));</span>
  }

  @Override
  public List&lt;EventCatalogUIAdapter&gt; getExtendedEventCatalogUIAdapters() {
<span class="nc" id="L491">    String organization = securityService.getOrganization().getId();</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">    return eventCatalogUIAdapters.stream().filter(a -&gt; !(a instanceof CommonEventCatalogUIAdapter))</span>
<span class="nc" id="L493">            .filter(a -&gt; a.handlesOrganization(organization)).collect(Collectors.toList());</span>
  }

  @Override
  public List&lt;SeriesCatalogUIAdapter&gt; getSeriesCatalogUIAdapters() {
<span class="nc" id="L498">    return new LinkedList&lt;&gt;(getSeriesCatalogUIAdapters(securityService.getOrganization().getId()));</span>
  }

  @Override
  public EventCatalogUIAdapter getCommonEventCatalogUIAdapter() {
<span class="fc" id="L503">    return getCommonEventCatalogUIAdapter(securityService.getOrganization().getId());</span>
  }

  @Override
  public SeriesCatalogUIAdapter getCommonSeriesCatalogUIAdapter() {
<span class="nc" id="L508">    return getCommonSeriesCatalogUIAdapter(securityService.getOrganization().getId());</span>
  }

  @Activate
  public void activate(ComponentContext cc) {
<span class="nc" id="L513">    workflowService.addWorkflowListener(new RetractionListener(this, securityService, retractions));</span>
<span class="nc" id="L514">  }</span>

  @Deactivate
  public void deactivate(ComponentContext cc) {
<span class="nc" id="L518">    executorService.shutdown();</span>
<span class="nc" id="L519">  }</span>

  @Override
  public String createEvent(HttpServletRequest request) throws IndexServiceException, UnsupportedAssetException {
<span class="nc" id="L523">    JSONObject metadataJson = null;</span>
<span class="nc" id="L524">    MediaPackage mp = null;</span>
    // regex for form field name matching an attachment or a catalog
    // The first sub items identifies if the file is an attachment or catalog
    // The second is the item flavor
    // Example form field names:  &quot;catalog/captions/timedtext&quot; and &quot;attachment/captions/vtt&quot;
    // The prefix of field name for attachment and catalog
<span class="nc" id="L530">    List&lt;String&gt; assetList = new LinkedList&lt;String&gt;();</span>
    try {
<span class="nc bnc" id="L532" title="All 2 branches missed.">      if (ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L533">        mp = ingestService.createMediaPackage();</span>

<span class="nc bnc" id="L535" title="All 2 branches missed.">        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L536">          FileItemStream item = iter.next();</span>

<span class="nc" id="L538">          String fieldName = item.getFieldName();</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">          if (item.isFormField()) {</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            if (&quot;metadata&quot;.equals(fieldName)) {</span>
<span class="nc" id="L541">              String metadata = Streams.asString(item.openStream());</span>
              try {
<span class="nc" id="L543">                metadataJson = (JSONObject) new JSONParser().parse(metadata);</span>
                // in case of scheduling: Check if user has access to the CA
<span class="nc bnc" id="L545" title="All 2 branches missed.">                if (metadataJson.containsKey(&quot;source&quot;)) {</span>
<span class="nc" id="L546">                  final JSONObject sourceJson = (JSONObject) metadataJson.get(&quot;source&quot;);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                  if (sourceJson.containsKey(&quot;metadata&quot;)) {</span>
<span class="nc" id="L548">                    final JSONObject sourceMetadataJson = (JSONObject) sourceJson.get(&quot;metadata&quot;);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">                    if (sourceMetadataJson.containsKey(&quot;device&quot;)) {</span>
<span class="nc" id="L550">                      SecurityUtil.checkAgentAccess(securityService, (String) sourceMetadataJson.get(&quot;device&quot;));</span>
                    }
                  }
                }
<span class="nc" id="L554">              } catch (Exception e) {</span>
<span class="nc" id="L555">                logger.warn(&quot;Unable to parse metadata {}&quot;, metadata);</span>
<span class="nc" id="L556">                throw new IllegalArgumentException(&quot;Unable to parse metadata&quot;);</span>
<span class="nc" id="L557">              }</span>
<span class="nc" id="L558">            }</span>
          } else {
            // AngularJS file upload lib appends &quot;.0&quot; to field name, so we cut that off
<span class="nc" id="L561">            fieldName = fieldName.substring(0, fieldName.lastIndexOf(&quot;.&quot;));</span>
<span class="nc" id="L562">            final MediaType mediaType = MediaType.parse(item.getContentType());</span>
<span class="nc" id="L563">            final boolean accepted = RequestUtils.typeIsAccepted(item.getName(), fieldName, mediaType,</span>
                    listProvidersService);
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if (!accepted) {</span>
<span class="nc" id="L566">              throw new UnsupportedAssetException(&quot;Provided file format &quot; + mediaType.toString() + &quot; not allowed.&quot;);</span>
            }
<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (&quot;presenter&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L569">              mp = ingestService.addTrack(item.openStream(), item.getName(), MediaPackageElements.PRESENTER_SOURCE, mp);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">            } else if (&quot;presentation&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L571">              mp = ingestService.addTrack(item.openStream(), item.getName(), MediaPackageElements.PRESENTATION_SOURCE,</span>
                      mp);
<span class="nc bnc" id="L573" title="All 2 branches missed.">            } else if (&quot;audio&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L574">              mp = ingestService.addTrack(item.openStream(), item.getName(),</span>
                      new MediaPackageElementFlavor(&quot;presenter-audio&quot;, &quot;source&quot;), mp);
              // For dynamic uploads, cannot get flavor at this point, so saving with temporary flavor
<span class="nc bnc" id="L577" title="All 2 branches missed.">            } else if (item.getFieldName().toLowerCase().matches(attachmentRegex)) {</span>
<span class="nc" id="L578">              assetList.add(item.getFieldName());</span>
<span class="nc" id="L579">              mp =  ingestService.addAttachment(item.openStream(), item.getName(),</span>
<span class="nc" id="L580">                      new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">            } else if (item.getFieldName().toLowerCase().matches(catalogRegex)) {</span>
              // Cannot get flavor at this point, so saving with temporary flavor
<span class="nc" id="L583">              assetList.add(item.getFieldName());</span>
<span class="nc" id="L584">              mp =  ingestService.addCatalog(item.openStream(), item.getName(),</span>
<span class="nc" id="L585">                      new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">            } else if (item.getFieldName().toLowerCase().matches(trackRegex)) {</span>
              // Cannot get flavor at this point, so saving with temporary flavor
<span class="nc" id="L588">              assetList.add(item.getFieldName());</span>
<span class="nc" id="L589">              mp = ingestService.addTrack(item.openStream(), item.getName(),</span>
<span class="nc" id="L590">                      new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
            } else {
<span class="nc" id="L592">              logger.warn(&quot;Unknown field name found {}&quot;, item.getFieldName());</span>
            }
          }
<span class="nc" id="L595">        }</span>
        // MH-12085 update the flavors of any newly added assets.
        try {
<span class="nc" id="L598">          JSONArray assetMetadata = (JSONArray)((JSONObject) metadataJson.get(&quot;assets&quot;)).get(&quot;options&quot;);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">          if (assetMetadata != null) {</span>
<span class="nc" id="L600">            mp = updateMpAssetFlavor(assetList, mp, assetMetadata);</span>
           }
<span class="nc" id="L602">          } catch (Exception e) {</span>
            // Assuming a parse error versus a file error and logging the error type
<span class="nc" id="L604">            logger.warn(&quot;Unable to process asset metadata {}&quot;, metadataJson.get(&quot;assets&quot;), e);</span>
<span class="nc" id="L605">            throw new IllegalArgumentException(&quot;Unable to parse metadata&quot;, e);</span>
<span class="nc" id="L606">          }</span>

      } else {
<span class="nc" id="L609">        throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
      }

      // MH-10834 If there is only an audio track, change the flavor from presenter-audio/source to presenter/source.
<span class="nc bnc" id="L613" title="All 2 branches missed.">      if (mp.getTracks().length == 1</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">              &amp;&amp; mp.getTracks()[0].getFlavor().equals(new MediaPackageElementFlavor(&quot;presenter-audio&quot;, &quot;source&quot;))) {</span>
<span class="nc" id="L615">        Track audioTrack = mp.getTracks()[0];</span>
<span class="nc" id="L616">        mp.remove(audioTrack);</span>
<span class="nc" id="L617">        audioTrack.setFlavor(MediaPackageElements.PRESENTER_SOURCE);</span>
<span class="nc" id="L618">        mp.add(audioTrack);</span>
      }

<span class="nc" id="L621">      return createEvent(metadataJson, mp);</span>
<span class="nc" id="L622">    } catch (FileUploadException | UnauthorizedException | ParseException | IngestException | SchedulerException</span>
        | MediaPackageException | IOException | NotFoundException e) {
<span class="nc" id="L624">      logger.error(&quot;Unable to create event:&quot;, e);</span>
<span class="nc" id="L625">      throw new IndexServiceException(&quot;Unable to create event&quot;, e);</span>
    }
  }

  @Override
  public String updateEventAssets(MediaPackage mp, HttpServletRequest request) throws IndexServiceException, UnsupportedAssetException {
<span class="nc" id="L631">    JSONObject metadataJson = null;</span>
    // regex for form field name matching an attachment or a catalog
    // The first sub items identifies if the file is an attachment or catalog
    // The second is the item flavor
    // Example form field names:  &quot;catalog/captions/timedtext&quot; and &quot;attachment/captions/vtt&quot;
    // The prefix of field name for attachment and catalog
    // The metadata is expected to contain a workflow definition id and
    // asset metadata mapped to the asset field id.
<span class="nc" id="L639">    List&lt;String&gt; assetList = new LinkedList&lt;String&gt;();</span>
    // 1. save assets with temporary flavors
    try {
<span class="nc bnc" id="L642" title="All 2 branches missed.">      if (!ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L643">        throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
      }
<span class="nc bnc" id="L645" title="All 2 branches missed.">      for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L646">        FileItemStream item = iter.next();</span>
<span class="nc" id="L647">        String fieldName = item.getFieldName();</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">        if (item.isFormField()) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">          if (&quot;metadata&quot;.equals(fieldName)) {</span>
<span class="nc" id="L650">            String metadata = Streams.asString(item.openStream());</span>
            try {
<span class="nc" id="L652">              metadataJson = (JSONObject) parser.parse(metadata);</span>
<span class="nc" id="L653">            } catch (Exception e) {</span>
<span class="nc" id="L654">              logger.warn(&quot;Unable to parse metadata {}&quot;, metadata);</span>
<span class="nc" id="L655">              throw new IllegalArgumentException(&quot;Unable to parse metadata&quot;);</span>
<span class="nc" id="L656">            }</span>
<span class="nc" id="L657">          }</span>
        } else {
          // AngularJS file upload lib appends &quot;.0&quot; to field name, so we cut that off
<span class="nc" id="L660">          fieldName = fieldName.substring(0, fieldName.lastIndexOf(&quot;.&quot;));</span>
<span class="nc" id="L661">          final MediaType mediaType = MediaType.parse(item.getContentType());</span>
<span class="nc" id="L662">          final boolean accepted = RequestUtils.typeIsAccepted(item.getName(), fieldName, mediaType,</span>
                  listProvidersService);
<span class="nc bnc" id="L664" title="All 2 branches missed.">          if (!accepted) {</span>
<span class="nc" id="L665">            throw new UnsupportedAssetException(&quot;Provided file format &quot; + mediaType.toString() + &quot; not allowed.&quot;);</span>
          }
<span class="nc bnc" id="L667" title="All 2 branches missed.">          if (item.getFieldName().toLowerCase().matches(attachmentRegex)) {</span>
<span class="nc" id="L668">            assetList.add(item.getFieldName());</span>
            // Add attachment with field name as temporary flavor
<span class="nc" id="L670">            mp =  ingestService.addAttachment(item.openStream(), item.getName(),</span>
<span class="nc" id="L671">                    new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">          } else if (item.getFieldName().toLowerCase().matches(catalogRegex)) {</span>
<span class="nc" id="L673">            assetList.add(item.getFieldName());</span>
            // Add catalog with field name as temporary flavor
<span class="nc" id="L675">            mp = ingestService.addCatalog(item.openStream(), item.getName(),</span>
<span class="nc" id="L676">                new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">          } else if (item.getFieldName().toLowerCase().matches(trackRegex)) {</span>
            // Cannot get flavor at this point, so saving with temporary flavor
<span class="nc" id="L679">            assetList.add(item.getFieldName());</span>
<span class="nc" id="L680">            mp = ingestService.addTrack(item.openStream(), item.getName(),</span>
<span class="nc" id="L681">                new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
          } else {
<span class="nc" id="L683">            logger.warn(&quot;Unknown field name found {}&quot;, item.getFieldName());</span>
          }
        }
<span class="nc" id="L686">      }</span>
      // 2. remove existing assets of the new flavor
      // and correct the temporary flavor to the new flavor.
      try {
<span class="nc" id="L690">        JSONArray assetMetadata = (JSONArray)((JSONObject) metadataJson.get(&quot;assets&quot;)).get(&quot;options&quot;);</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (assetMetadata != null) {</span>
<span class="nc" id="L692">          mp = updateMpAssetFlavor(assetList, mp, assetMetadata);</span>
        } else {
<span class="nc" id="L694">          logger.warn(&quot;The asset option mapping parameter was not found&quot;);</span>
<span class="nc" id="L695">          throw new IndexServiceException(&quot;The asset option mapping parameter was not found&quot;);</span>
        }
<span class="nc" id="L697">      } catch (Exception e) {</span>
        // Assuming a parse error versus a file error and logging the error type
<span class="nc" id="L699">        logger.warn(&quot;Unable to process asset metadata {}&quot;, metadataJson.get(&quot;assets&quot;), e);</span>
<span class="nc" id="L700">        throw new IllegalArgumentException(&quot;Unable to parse metadata&quot;, e);</span>
<span class="nc" id="L701">      }</span>

<span class="nc" id="L703">      return startAddAssetWorkflow(metadataJson, mp);</span>
<span class="nc" id="L704">    } catch (MediaPackageException | FileUploadException | IOException | IngestException e) {</span>
<span class="nc" id="L705">      logger.error(&quot;Unable to create event:&quot;, e);</span>
<span class="nc" id="L706">      throw new IndexServiceException(&quot;Unable to create event&quot;, e);</span>
    }
  }

  /**
   * Parses the processing information, including the workflowDefinitionId, from the metadataJson and starts the
   * workflow with the passed mediapackage.
   * Example of processing json:
   * ...., &quot;processing&quot;: { &quot;workflow&quot;: &quot;full&quot;, &quot;configuration&quot;: { &quot;videoPreview&quot;: &quot;false&quot;, &quot;trimHold&quot;: &quot;false&quot;,
   * &quot;captionHold&quot;: &quot;false&quot;, &quot;archiveOp&quot;: &quot;true&quot;, &quot;publishEngage&quot;: &quot;true&quot;, &quot;publishHarvesting&quot;: &quot;true&quot; } }, ....
   *
   * @param metadataJson
   * @param mediaPackage
   * @return the created workflow instance id
   * @throws IndexServiceException
   */
  private String startAddAssetWorkflow(JSONObject metadataJson, MediaPackage mediaPackage)
          throws IndexServiceException {
<span class="nc" id="L724">    String wfId = null;</span>
<span class="nc" id="L725">    String mpId = mediaPackage.getIdentifier().toString();</span>

<span class="nc" id="L727">    JSONObject processing = (JSONObject) metadataJson.get(&quot;processing&quot;);</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">    if (processing == null)</span>
<span class="nc" id="L729">      throw new IllegalArgumentException(&quot;No processing field in metadata&quot;);</span>

<span class="nc" id="L731">    String workflowDefId = (String) processing.get(&quot;workflow&quot;);</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">    if (workflowDefId == null)</span>
<span class="nc" id="L733">      throw new IllegalArgumentException(&quot;No workflow definition field in processing metadata&quot;);</span>

<span class="nc" id="L735">    JSONObject configJson = (JSONObject) processing.get(&quot;configuration&quot;);</span>

    try {
      // Start the new workflow on the snapshot
      // Workflow params are assumed to be String (not mixed with Number)
<span class="nc" id="L740">      Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">      if (configJson != null) {</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">        for (Object key: configJson.keySet()) {</span>
<span class="nc" id="L743">          params.put((String)key, (String) configJson.get(key));</span>
<span class="nc" id="L744">        }</span>
      }

<span class="nc" id="L747">      WorkflowInstance workflowInstance = workflowService.start(</span>
<span class="nc" id="L748">              workflowService.getWorkflowDefinitionById(workflowDefId), mediaPackage, params);</span>
<span class="nc" id="L749">      logger.info(&quot;Asset update and publish workflow {} scheduled for mp {}&quot;, workflowInstance.getId(), mpId);</span>
<span class="nc" id="L750">    } catch (AssetManagerException | WorkflowParsingException | UnauthorizedException e) {</span>
<span class="nc" id="L751">      throw new IndexServiceException(&quot;Unable to start workflow &quot; + workflowDefId + &quot; on &quot; + mpId);</span>
<span class="nc" id="L752">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L753">      logger.warn(&quot;Unable to load workflow '{}' from workflow service:&quot;, wfId, e);</span>
<span class="nc" id="L754">    } catch (NotFoundException e) {</span>
<span class="nc" id="L755">      logger.warn(&quot;Workflow '{}' not found&quot;, wfId);</span>
<span class="nc" id="L756">    }</span>
<span class="nc" id="L757">    return wfId;</span>
  }

  /**
   * Get the type of the source that is creating the event.
   *
   * @param source
   *          The source of the event e.g. upload, single scheduled, multi scheduled
   * @return The type of the source
   * @throws IllegalArgumentException
   *           Thrown if unable to get the source from the json object.
   */
  private SourceType getSourceType(JSONObject source) {
    SourceType type;
    try {
<span class="fc" id="L772">      type = SourceType.valueOf((String) source.get(&quot;type&quot;));</span>
<span class="nc" id="L773">    } catch (Exception e) {</span>
<span class="nc" id="L774">      logger.error(&quot;Unknown source type '{}'&quot;, source.get(&quot;type&quot;));</span>
<span class="nc" id="L775">      throw new IllegalArgumentException(&quot;Unknown source type&quot;);</span>
<span class="fc" id="L776">    }</span>
<span class="fc" id="L777">    return type;</span>
  }

  /**
   * Get the access control list from a JSON representation
   *
   * @param metadataJson
   *          The {@link JSONObject} that has the access json
   * @return An {@link AccessControlList}
   * @throws IllegalArgumentException
   *           Thrown if unable to parse the access control list
   */
  private AccessControlList getAccessControlList(JSONObject metadataJson) {
<span class="fc" id="L790">    AccessControlList acl = new AccessControlList();</span>
<span class="fc" id="L791">    JSONObject accessJson = (JSONObject) metadataJson.get(&quot;access&quot;);</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">    if (accessJson != null) {</span>
      try {
<span class="fc" id="L794">        acl = AccessControlParser.parseAcl(accessJson.toJSONString());</span>
<span class="nc" id="L795">      } catch (Exception e) {</span>
<span class="nc" id="L796">        throw new IllegalArgumentException(&quot;Unable to parse access control list: &quot; + accessJson.toJSONString());</span>
<span class="fc" id="L797">      }</span>
    }
<span class="fc" id="L799">    return acl;</span>
  }

  public String createEvent(JSONObject metadataJson, MediaPackage mp) throws ParseException, IOException,
          MediaPackageException, IngestException, NotFoundException, SchedulerException, UnauthorizedException {
<span class="fc bfc" id="L804" title="All 2 branches covered.">    if (metadataJson == null)</span>
<span class="fc" id="L805">      throw new IllegalArgumentException(&quot;No metadata set&quot;);</span>

<span class="fc" id="L807">    JSONObject source = (JSONObject) metadataJson.get(&quot;source&quot;);</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">    if (source == null)</span>
<span class="fc" id="L809">      throw new IllegalArgumentException(&quot;No source field in metadata&quot;);</span>

<span class="fc" id="L811">    JSONObject processing = (JSONObject) metadataJson.get(&quot;processing&quot;);</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">    if (processing == null)</span>
<span class="fc" id="L813">      throw new IllegalArgumentException(&quot;No processing field in metadata&quot;);</span>

<span class="fc" id="L815">    JSONArray allEventMetadataJson = (JSONArray) metadataJson.get(&quot;metadata&quot;);</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">    if (allEventMetadataJson == null)</span>
<span class="fc" id="L817">      throw new IllegalArgumentException(&quot;No metadata field in metadata&quot;);</span>

<span class="fc" id="L819">    AccessControlList acl = getAccessControlList(metadataJson);</span>

<span class="fc" id="L821">    MetadataList metadataList = getMetadataListWithAllEventCatalogUIAdapters();</span>
<span class="fc" id="L822">    MetadataJson.fillListFromJson(metadataList, allEventMetadataJson);</span>

<span class="fc" id="L824">    EventHttpServletRequest eventHttpServletRequest = new EventHttpServletRequest();</span>
<span class="fc" id="L825">    eventHttpServletRequest.setAcl(acl);</span>
<span class="fc" id="L826">    eventHttpServletRequest.setMetadataList(metadataList);</span>
<span class="fc" id="L827">    eventHttpServletRequest.setMediaPackage(mp);</span>
<span class="fc" id="L828">    eventHttpServletRequest.setProcessing(processing);</span>
<span class="fc" id="L829">    eventHttpServletRequest.setSource(source);</span>

<span class="fc" id="L831">    return createEvent(eventHttpServletRequest);</span>
  }

  @Override
  public String createEvent(EventHttpServletRequest eventHttpServletRequest) throws ParseException, IOException,
          MediaPackageException, IngestException, NotFoundException, SchedulerException, UnauthorizedException {
    // Preconditions
<span class="pc bpc" id="L838" title="1 of 2 branches missed.">    if (eventHttpServletRequest.getAcl().isEmpty()) {</span>
<span class="nc" id="L839">      throw new IllegalArgumentException(&quot;No access control list available to create new event.&quot;);</span>
    }
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">    if (eventHttpServletRequest.getMediaPackage().isEmpty()) {</span>
<span class="nc" id="L842">      throw new IllegalArgumentException(&quot;No mediapackage available to create new event.&quot;);</span>
    }
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">    if (eventHttpServletRequest.getMetadataList().isEmpty()) {</span>
<span class="nc" id="L845">      throw new IllegalArgumentException(&quot;No metadata list available to create new event.&quot;);</span>
    }
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">    if (eventHttpServletRequest.getProcessing().isEmpty()) {</span>
<span class="nc" id="L848">      throw new IllegalArgumentException(&quot;No processing metadata available to create new event.&quot;);</span>
    }
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">    if (eventHttpServletRequest.getSource().isEmpty()) {</span>
<span class="nc" id="L851">      throw new IllegalArgumentException(&quot;No source field metadata available to create new event.&quot;);</span>
    }

    // Get Workflow
<span class="fc" id="L855">    String workflowTemplate = (String) eventHttpServletRequest.getProcessing().get().get(&quot;workflow&quot;);</span>
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">    if (workflowTemplate == null)</span>
<span class="nc" id="L857">      throw new IllegalArgumentException(&quot;No workflow template in metadata&quot;);</span>

    // Get Type of Source
<span class="fc" id="L860">    SourceType type = getSourceType(eventHttpServletRequest.getSource().get());</span>

<span class="fc" id="L862">    DublinCoreMetadataCollection eventMetadata = eventHttpServletRequest.getMetadataList().get()</span>
<span class="fc" id="L863">            .getMetadataByAdapter(getCommonEventCatalogUIAdapter());</span>

<span class="fc" id="L865">    Date currentStartDate = null;</span>
<span class="fc" id="L866">    JSONObject sourceMetadata = (JSONObject) eventHttpServletRequest.getSource().get().get(&quot;metadata&quot;);</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">    if (sourceMetadata != null</span>
<span class="pc bpc" id="L868" title="1 of 4 branches missed.">            &amp;&amp; (type.equals(SourceType.SCHEDULE_SINGLE) || type.equals(SourceType.SCHEDULE_MULTIPLE))) {</span>
      try {
<span class="fc" id="L870">        MetadataField current = eventMetadata.getOutputFields().get(&quot;location&quot;);</span>
<span class="fc" id="L871">        eventMetadata.updateStringField(current, (String) sourceMetadata.get(&quot;device&quot;));</span>
<span class="nc" id="L872">      } catch (Exception e) {</span>
<span class="nc" id="L873">        logger.warn(&quot;Unable to parse device {}&quot;, sourceMetadata.get(&quot;device&quot;));</span>
<span class="nc" id="L874">        throw new IllegalArgumentException(&quot;Unable to parse device&quot;);</span>
<span class="fc" id="L875">      }</span>
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">      if (StringUtils.isNotEmpty((String) sourceMetadata.get(&quot;start&quot;))) {</span>
<span class="fc" id="L877">        currentStartDate = EncodingSchemeUtils.decodeDate((String) sourceMetadata.get(&quot;start&quot;));</span>
      }
    }

<span class="fc" id="L881">    MetadataField startDate = eventMetadata.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="pc bpc" id="L882" title="4 of 6 branches missed.">    if (startDate != null &amp;&amp; startDate.isUpdated() &amp;&amp; startDate.getValue() != null) {</span>
<span class="nc" id="L883">      SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(startDate.getPattern());</span>
<span class="nc" id="L884">      currentStartDate = sdf.parse((String) startDate.getValue());</span>
<span class="pc bfc" id="L885" title="All 2 branches covered.">    } else if (currentStartDate != null) {</span>
<span class="fc" id="L886">      eventMetadata.removeField(startDate);</span>
<span class="fc" id="L887">      MetadataField newStartDate = new MetadataField(startDate);</span>
<span class="fc" id="L888">      newStartDate.setValue(EncodingSchemeUtils.encodeDate(currentStartDate, Precision.Fraction).getValue());</span>
<span class="fc" id="L889">      eventMetadata.addField(newStartDate);</span>
    }

    // This field is null when it is not used in the Admin UI event details metadata tab.
    // If used, set it to the the start Date or a new date.
    // Note, even though this field borrows the DublinCore.PROPERTY_CREATED key,
    // the startDate is used to update the DublinCore catalog PROPERTY_CREATED field,
    // event, and mediapackage start fields.
<span class="fc" id="L897">    MetadataField created = eventMetadata.getOutputFields().get(DublinCore.PROPERTY_CREATED.getLocalName());</span>
<span class="pc bpc" id="L898" title="4 of 6 branches missed.">    if (created != null &amp;&amp; (!created.isUpdated() || created.getValue() == null)) {</span>
<span class="fc" id="L899">      eventMetadata.removeField(created);</span>
<span class="fc" id="L900">      MetadataField newCreated = new MetadataField(created);</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">      if (currentStartDate != null) {</span>
<span class="fc" id="L902">        newCreated.setValue(EncodingSchemeUtils.encodeDate(currentStartDate, Precision.Second).getValue());</span>
      } else {
<span class="fc" id="L904">        newCreated.setValue(EncodingSchemeUtils.encodeDate(new Date(), Precision.Second).getValue());</span>
      }
<span class="fc" id="L906">      eventMetadata.addField(newCreated);</span>
    }

    // Get presenter usernames for use as technical presenters
<span class="fc" id="L910">    Set&lt;String&gt; presenterUsernames = new HashSet&lt;&gt;();</span>
<span class="fc" id="L911">    Optional&lt;Set&lt;String&gt;&gt; technicalPresenters = updatePresenters(eventMetadata);</span>
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">    if (technicalPresenters.isPresent()) {</span>
<span class="fc" id="L913">      presenterUsernames = technicalPresenters.get();</span>
    }

<span class="fc" id="L916">    eventHttpServletRequest.getMetadataList().get().add(getCommonEventCatalogUIAdapter(), eventMetadata);</span>
<span class="fc" id="L917">    updateMediaPackageMetadata(eventHttpServletRequest.getMediaPackage().get(),</span>
<span class="fc" id="L918">            eventHttpServletRequest.getMetadataList().get());</span>

<span class="fc" id="L920">    DublinCoreCatalog dc = getDublinCoreCatalog(eventHttpServletRequest);</span>
<span class="fc" id="L921">    String captureAgentId = null;</span>
<span class="fc" id="L922">    TimeZone tz = null;</span>
<span class="fc" id="L923">    org.joda.time.DateTime start = null;</span>
<span class="fc" id="L924">    org.joda.time.DateTime end = null;</span>
<span class="fc" id="L925">    long duration = 0L;</span>
<span class="fc" id="L926">    Properties caProperties = new Properties();</span>
<span class="fc" id="L927">    RRule rRule = null;</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">    if (sourceMetadata != null</span>
<span class="pc bpc" id="L929" title="1 of 4 branches missed.">            &amp;&amp; (type.equals(SourceType.SCHEDULE_SINGLE) || type.equals(SourceType.SCHEDULE_MULTIPLE))) {</span>
      Properties configuration;
      try {
<span class="fc" id="L932">        captureAgentId = (String) sourceMetadata.get(&quot;device&quot;);</span>
<span class="fc" id="L933">        configuration = captureAgentStateService.getAgentConfiguration((String) sourceMetadata.get(&quot;device&quot;));</span>
<span class="nc" id="L934">      } catch (Exception e) {</span>
<span class="nc" id="L935">        logger.warn(&quot;Unable to parse device {}: because:&quot;, sourceMetadata.get(&quot;device&quot;), e);</span>
<span class="nc" id="L936">        throw new IllegalArgumentException(&quot;Unable to parse device&quot;);</span>
<span class="fc" id="L937">      }</span>

<span class="fc" id="L939">      String durationString = (String) sourceMetadata.get(&quot;duration&quot;);</span>
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">      if (StringUtils.isBlank(durationString))</span>
<span class="nc" id="L941">        throw new IllegalArgumentException(&quot;No duration in source metadata&quot;);</span>

      // Create timezone based on CA's reported TZ.
<span class="fc" id="L944">      String agentTimeZone = configuration.getProperty(&quot;capture.device.timezone&quot;);</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(agentTimeZone)) {</span>
<span class="fc" id="L946">        tz = TimeZone.getTimeZone(agentTimeZone);</span>
<span class="fc" id="L947">        dc.set(DublinCores.OC_PROPERTY_AGENT_TIMEZONE, tz.getID());</span>
      } else { // No timezone was present, assume the serve's local timezone.
<span class="nc" id="L949">        tz = TimeZone.getDefault();</span>
<span class="nc" id="L950">        logger.debug(</span>
                &quot;The field 'capture.device.timezone' has not been set in the agent configuration. The default server timezone will be used.&quot;);
      }

<span class="fc" id="L954">      org.joda.time.DateTime now = new org.joda.time.DateTime(DateTimeZone.UTC);</span>
<span class="fc" id="L955">      start = now.withMillis(DateTimeSupport.fromUTC((String) sourceMetadata.get(&quot;start&quot;)));</span>
<span class="fc" id="L956">      end = now.withMillis(DateTimeSupport.fromUTC((String) sourceMetadata.get(&quot;end&quot;)));</span>
<span class="fc" id="L957">      duration = Long.parseLong(durationString);</span>
<span class="fc" id="L958">      DublinCoreValue period = EncodingSchemeUtils</span>
<span class="fc" id="L959">              .encodePeriod(new DCMIPeriod(start.toDate(), start.plus(duration).toDate()), Precision.Second);</span>
<span class="fc" id="L960">      String inputs = (String) sourceMetadata.get(&quot;inputs&quot;);</span>

<span class="fc" id="L962">      caProperties.putAll(configuration);</span>
<span class="fc" id="L963">      dc.set(DublinCore.PROPERTY_TEMPORAL, period);</span>
<span class="fc" id="L964">      caProperties.put(CaptureParameters.CAPTURE_DEVICE_NAMES, inputs);</span>
    }

<span class="fc bfc" id="L967" title="All 2 branches covered.">    if (type.equals(SourceType.SCHEDULE_MULTIPLE)) {</span>
<span class="fc" id="L968">      rRule = new RRule((String) sourceMetadata.get(&quot;rrule&quot;));</span>
    }

<span class="fc" id="L971">    Map&lt;String, String&gt; configuration = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">    if (eventHttpServletRequest.getProcessing().get().get(&quot;configuration&quot;) != null) {</span>
<span class="fc" id="L973">      configuration = new HashMap&lt;&gt;((JSONObject) eventHttpServletRequest.getProcessing().get().get(&quot;configuration&quot;));</span>

    }
<span class="fc bfc" id="L976" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; entry : configuration.entrySet()) {</span>
<span class="fc" id="L977">      caProperties.put(WORKFLOW_CONFIG_PREFIX.concat(entry.getKey()), entry.getValue());</span>
<span class="fc" id="L978">    }</span>
<span class="fc" id="L979">    caProperties.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, workflowTemplate);</span>

<span class="fc" id="L981">    eventHttpServletRequest.setMediaPackage(authorizationService.setAcl(eventHttpServletRequest.getMediaPackage().get(),</span>
<span class="fc" id="L982">            AclScope.Episode, eventHttpServletRequest.getAcl().get()).getA());</span>

    MediaPackage mediaPackage;
<span class="pc bpc" id="L985" title="1 of 4 branches missed.">    switch (type) {</span>
      case UPLOAD:
      case UPLOAD_LATER:
<span class="fc" id="L988">        eventHttpServletRequest</span>
<span class="fc" id="L989">                .setMediaPackage(updateDublincCoreCatalog(eventHttpServletRequest.getMediaPackage().get(), dc));</span>
<span class="fc" id="L990">        configuration.put(&quot;workflowDefinitionId&quot;, workflowTemplate);</span>
<span class="fc" id="L991">        WorkflowInstance ingest = ingestService.ingest(eventHttpServletRequest.getMediaPackage().get(),</span>
                workflowTemplate, configuration);
<span class="fc" id="L993">        return eventHttpServletRequest.getMediaPackage().get().getIdentifier().toString();</span>
      case SCHEDULE_SINGLE:
<span class="fc" id="L995">        mediaPackage = updateDublincCoreCatalog(eventHttpServletRequest.getMediaPackage().get(), dc);</span>
<span class="fc" id="L996">        eventHttpServletRequest.setMediaPackage(mediaPackage);</span>
        try {
<span class="fc" id="L998">          schedulerService.addEvent(start.toDate(), start.plus(duration).toDate(), captureAgentId, presenterUsernames,</span>
<span class="fc" id="L999">                  mediaPackage, configuration, (Map) caProperties, Optional.empty());</span>
        } finally {
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">          for (MediaPackageElement mediaPackageElement : mediaPackage.getElements()) {</span>
            try {
<span class="nc" id="L1003">              workspace.delete(mediaPackage.getIdentifier().toString(), mediaPackageElement.getIdentifier());</span>
<span class="nc" id="L1004">            } catch (NotFoundException | IOException e) {</span>
<span class="nc" id="L1005">              logger.warn(&quot;Failed to delete media package element&quot;, e);</span>
<span class="nc" id="L1006">            }</span>
          }
        }
<span class="fc" id="L1009">        return mediaPackage.getIdentifier().toString();</span>
      case SCHEDULE_MULTIPLE:
<span class="fc" id="L1011">        final Map&lt;String, Period&gt; scheduled = schedulerService.addMultipleEvents(rRule, start.toDate(), end.toDate(), duration, tz, captureAgentId,</span>
<span class="fc" id="L1012">                presenterUsernames, eventHttpServletRequest.getMediaPackage().get(), configuration, (Map) caProperties, Optional.empty());</span>
<span class="fc" id="L1013">        return StringUtils.join(scheduled.keySet(), &quot;,&quot;);</span>
      default:
<span class="nc" id="L1015">        throw new IllegalArgumentException(&quot;Unknown source type: &quot; + type);</span>
    }
  }

  /**
   * Get the {@link DublinCoreCatalog} from an {@link EventHttpServletRequest}.
   *
   * @param eventHttpServletRequest
   *          The request to extract the {@link DublinCoreCatalog} from.
   * @return The {@link DublinCoreCatalog}
   */
  private DublinCoreCatalog getDublinCoreCatalog(EventHttpServletRequest eventHttpServletRequest) {
    DublinCoreCatalog dc;
<span class="fc" id="L1028">    Optional&lt;DublinCoreCatalog&gt; dcOpt = DublinCoreUtil.loadEpisodeDublinCore(workspace,</span>
<span class="fc" id="L1029">            eventHttpServletRequest.getMediaPackage().get());</span>
<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">    if (dcOpt.isPresent()) {</span>
<span class="nc" id="L1031">      dc = dcOpt.get();</span>
      // make sure to bind the OC_PROPERTY namespace
<span class="nc" id="L1033">      dc.addBindings(XmlNamespaceContext</span>
<span class="nc" id="L1034">              .mk(XmlNamespaceBinding.mk(DublinCores.OC_PROPERTY_NS_PREFIX, DublinCores.OC_PROPERTY_NS_URI)));</span>
    } else {
<span class="fc" id="L1036">      dc = DublinCores.mkOpencastEpisode().getCatalog();</span>
    }
<span class="fc" id="L1038">    return dc;</span>
  }

  /**
   * Update the presenters field in the event {@link DublinCoreMetadataCollection} to have friendly names loaded by the
   * {@link UserDirectoryService} and return the usernames of the presenters.
   *
   * @param eventMetadata
   *          The {@link DublinCoreMetadataCollection} to update the presenters (creator field) with full names.
   * @return If the presenters (creator) field has been updated, the set of user names, if any, of the presenters. None
   *         if it wasn't updated.
   */
  private Optional&lt;Set&lt;String&gt;&gt; updatePresenters(DublinCoreMetadataCollection eventMetadata) {
<span class="fc" id="L1051">    MetadataField presentersMetadataField = eventMetadata.getOutputFields()</span>
<span class="fc" id="L1052">            .get(DublinCore.PROPERTY_CREATOR.getLocalName());</span>
<span class="fc bfc" id="L1053" title="All 2 branches covered.">    if (presentersMetadataField.isUpdated()) {</span>
<span class="fc" id="L1054">      Tuple&lt;List&lt;String&gt;, Set&lt;String&gt;&gt; updatedPresenters = getTechnicalPresenters(eventMetadata);</span>
<span class="fc" id="L1055">      Set&lt;String&gt; presenterUsernames = updatedPresenters.getB();</span>
<span class="fc" id="L1056">      eventMetadata.removeField(presentersMetadataField);</span>
<span class="fc" id="L1057">      MetadataField newPresentersMetadataField = new MetadataField(presentersMetadataField);</span>
<span class="fc" id="L1058">      newPresentersMetadataField.setValue(updatedPresenters.getA());</span>
<span class="fc" id="L1059">      eventMetadata.addField(newPresentersMetadataField);</span>
<span class="fc" id="L1060">      return Optional.of(presenterUsernames);</span>
    } else {
<span class="fc" id="L1062">      return Optional.empty();</span>
    }
  }

  /**
   *
   * @param mp
   *          the mediapackage to update
   * @param dc
   *          the dublincore metadata to use to update the mediapackage
   * @return the updated mediapackage
   * @throws IOException
   *           Thrown if an IO error occurred adding the dc catalog file
   * @throws MediaPackageException
   *           Thrown if an error occurred updating the mediapackage
   * @throws IngestException
   *           Thrown if an error occurred attaching the catalog to the mediapackage
   */
  private MediaPackage updateDublincCoreCatalog(MediaPackage mp, DublinCoreCatalog dc)
          throws IOException, MediaPackageException, IngestException {
<span class="fc" id="L1082">    try (InputStream inputStream = IOUtils.toInputStream(dc.toXmlString(), &quot;UTF-8&quot;)) {</span>
      // Update dublincore catalog
<span class="fc" id="L1084">      Catalog[] catalogs = mp.getCatalogs(MediaPackageElements.EPISODE);</span>
<span class="pc bpc" id="L1085" title="1 of 2 branches missed.">      if (catalogs.length &gt; 0) {</span>
<span class="nc" id="L1086">        Catalog catalog = catalogs[0];</span>
<span class="nc" id="L1087">        URI uri = workspace.put(mp.getIdentifier().toString(), catalog.getIdentifier(), &quot;dublincore.xml&quot;, inputStream);</span>
<span class="nc" id="L1088">        catalog.setURI(uri);</span>
        // setting the URI to a new source so the checksum will most like be invalid
<span class="nc" id="L1090">        catalog.setChecksum(null);</span>
<span class="nc" id="L1091">      } else {</span>
<span class="fc" id="L1092">        mp = ingestService.addCatalog(inputStream, &quot;dublincore.xml&quot;, MediaPackageElements.EPISODE, mp);</span>
      }
    }
<span class="fc" id="L1095">    return mp;</span>
  }

  /**
   * Update the flavor of newly added asset with the passed metadata
   *
   * @param assetList
   *          the list of assets to update
   * @param mp
   *          the mediapackage to update
   * @param assetMetadata
   *          a set of mapping metadata for the asset list
   * @return mediapackage updated with assets
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  protected MediaPackage updateMpAssetFlavor(List&lt;String&gt; assetList, MediaPackage mp, JSONArray assetMetadata) {
    // Create JSONObject data map
<span class="fc" id="L1112">    JSONObject assetDataMap = new JSONObject();</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">    for (int i = 0; i &lt; assetMetadata.size(); i++) {</span>
      try {
<span class="fc" id="L1115">        assetDataMap.put(((JSONObject) assetMetadata.get(i)).get(&quot;id&quot;), assetMetadata.get(i));</span>
<span class="nc" id="L1116">      } catch (Exception e) {</span>
<span class="nc" id="L1117">        throw new IllegalArgumentException(&quot;Unable to parse metadata&quot;, e);</span>
<span class="fc" id="L1118">      }</span>
    }
    // Find the correct flavor for each asset.
<span class="fc bfc" id="L1121" title="All 2 branches covered.">    for (String assetOrig: assetList) {</span>
      // expecting file assets to contain postfix &quot;track_trackpart.0&quot;
<span class="fc" id="L1123">      String asset = assetOrig;</span>
<span class="fc" id="L1124">      String assetNumber = null;</span>
<span class="fc" id="L1125">      String[] assetNameParts = asset.split(Pattern.quote(&quot;.&quot;));</span>
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">      if (assetNameParts.length &gt; 1) {</span>
<span class="nc" id="L1127">        asset = assetNameParts[0];</span>
<span class="nc" id="L1128">        assetNumber = assetNameParts[1];</span>
      }
      try {
<span class="pc bpc" id="L1131" title="2 of 4 branches missed.">        if ((assetMetadata != null) &amp;&amp; (assetDataMap.get(asset) != null)) {</span>
<span class="fc" id="L1132">          String type = (String)((JSONObject) assetDataMap.get(asset)).get(&quot;type&quot;);</span>
<span class="fc" id="L1133">          String flavorType = (String)((JSONObject) assetDataMap.get(asset)).get(&quot;flavorType&quot;);</span>
<span class="fc" id="L1134">          String flavorSubType = (String)((JSONObject) assetDataMap.get(asset)).get(&quot;flavorSubType&quot;);</span>
<span class="fc" id="L1135">          String tags = (String)((JSONObject) assetDataMap.get(asset)).get(&quot;tags&quot;);</span>
<span class="fc" id="L1136">          String[] tagsArray = null;</span>
          // Captions may have lang:LANG_CODE tag set.
<span class="fc" id="L1138">          String langTag = null;</span>
<span class="pc bpc" id="L1139" title="1 of 2 branches missed.">          if (tags != null) {</span>
<span class="nc" id="L1140">            tagsArray = tags.split(&quot;,&quot;);</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">            for (String tag : tagsArray) {</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">              if (StringUtils.startsWith(StringUtils.trimToEmpty(tag), &quot;lang:&quot;)) {</span>
<span class="nc" id="L1143">                langTag = StringUtils.trimToEmpty(tag);</span>
<span class="nc" id="L1144">                break;</span>
              }
            }
          }
          // Use 'multiple' setting to allow multiple elements with same flavor or not.
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">          boolean overwriteExisting = !(Boolean) ((JSONObject) assetDataMap.get(asset)).getOrDefault(&quot;multiple&quot;, false);</span>
<span class="pc bpc" id="L1150" title="3 of 4 branches missed.">          if (patternNumberedAsset.matcher(flavorSubType).matches() &amp;&amp; (assetNumber != null)) {</span>
<span class="nc" id="L1151">            flavorSubType = assetNumber;</span>
          }
<span class="fc" id="L1153">          MediaPackageElementFlavor newElemflavor = new MediaPackageElementFlavor(flavorType, flavorSubType);</span>
<span class="pc bpc" id="L1154" title="1 of 2 branches missed.">          if (patternAttachment.matcher(type).matches()) {</span>
<span class="pc bpc" id="L1155" title="1 of 2 branches missed.">            if (overwriteExisting) {</span>
              // remove existing attachments of the new flavor
<span class="fc" id="L1157">              Attachment[] existing = mp.getAttachments(newElemflavor);</span>
<span class="pc bpc" id="L1158" title="1 of 2 branches missed.">              for (int i = 0; i &lt; existing.length; i++) {</span>
                // if lang tag is set, we should only remove elements with the same lang tag
<span class="nc bnc" id="L1160" title="All 4 branches missed.">                if (null == langTag || existing[i].containsTag(langTag)) {</span>
<span class="nc" id="L1161">                  mp.remove(existing[i]);</span>
<span class="nc" id="L1162">                  logger.info(&quot;Overwriting existing asset {} {}&quot;, type, newElemflavor);</span>
                }
              }
            }
            // correct the flavor of the new attachment
<span class="fc" id="L1167">            Attachment[] elArray = mp.getAttachments(new MediaPackageElementFlavor(assetOrig, &quot;*&quot;));</span>
<span class="fc" id="L1168">            elArray[0].setFlavor(newElemflavor);</span>
<span class="pc bpc" id="L1169" title="3 of 4 branches missed.">            if (tags != null &amp;&amp; tagsArray.length &gt; 0) {</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">              for (String tag : tagsArray) {</span>
<span class="nc" id="L1171">                elArray[0].addTag(tag);</span>
              }
            }
<span class="fc" id="L1174">            logger.info(&quot;Updated asset {} {}&quot;, type, newElemflavor);</span>
<span class="pc bnc" id="L1175" title="All 2 branches missed.">          } else if (patternCatalog.matcher(type).matches()) {</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">            if (overwriteExisting) {</span>
              // remove existing catalogs of the new flavor
<span class="nc" id="L1178">              Catalog[] existing = mp.getCatalogs(newElemflavor);</span>
<span class="nc bnc" id="L1179" title="All 2 branches missed.">              for (int i = 0; i &lt; existing.length; i++) {</span>
                // if lang tag is set, we should only remove elements with the same lang tag
<span class="nc bnc" id="L1181" title="All 4 branches missed.">                if (null == langTag || existing[i].containsTag(langTag)) {</span>
<span class="nc" id="L1182">                  mp.remove(existing[i]);</span>
<span class="nc" id="L1183">                  logger.info(&quot;Overwriting existing asset {} {}&quot;, type, newElemflavor);</span>
                }
              }
            }
<span class="nc" id="L1187">            Catalog[] catArray = mp.getCatalogs(new MediaPackageElementFlavor(assetOrig, &quot;*&quot;));</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">            if (catArray.length &gt; 1) {</span>
<span class="nc" id="L1189">              throw new IllegalArgumentException(&quot;More than one &quot; + asset + &quot; found, only one expected.&quot;);</span>
            }
<span class="nc" id="L1191">            catArray[0].setFlavor(newElemflavor);</span>
<span class="nc bnc" id="L1192" title="All 4 branches missed.">            if (tags != null &amp;&amp; tagsArray.length &gt; 0) {</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">              for (String tag : tagsArray) {</span>
<span class="nc" id="L1194">                catArray[0].addTag(tag);</span>
              }
            }
<span class="nc" id="L1197">            logger.info(&quot;Update asset {} {}&quot;, type, newElemflavor);</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">          } else if (patternTrack.matcher(type).matches()) {</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">            if (overwriteExisting) {</span>
              // remove existing catalogs of the new flavor
<span class="nc" id="L1201">              Track[] existing = mp.getTracks(newElemflavor);</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">              for (int i = 0; i &lt; existing.length; i++) {</span>
                // if lang tag is set, we should only remove elements with the same lang tag
<span class="nc bnc" id="L1204" title="All 4 branches missed.">                if (null == langTag || existing[i].containsTag(langTag)) {</span>
<span class="nc" id="L1205">                  mp.remove(existing[i]);</span>
<span class="nc" id="L1206">                  logger.info(&quot;Overwriting existing asset {} {}&quot;, type, newElemflavor);</span>
                }
              }
            }
<span class="nc" id="L1210">            Track[]  trackArray = mp.getTracks(new MediaPackageElementFlavor(assetOrig, &quot;*&quot;));</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">            if (trackArray.length &gt; 1) {</span>
<span class="nc" id="L1212">              throw new IllegalArgumentException(&quot;More than one &quot; + asset + &quot; found, only one expected.&quot;);</span>
            }
<span class="nc" id="L1214">            trackArray[0].setFlavor(newElemflavor);</span>
<span class="nc bnc" id="L1215" title="All 4 branches missed.">            if (tags != null &amp;&amp; tagsArray.length &gt; 0) {</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">              for (String tag : tagsArray) {</span>
<span class="nc" id="L1217">                trackArray[0].addTag(tag);</span>
              }
            }
<span class="nc" id="L1220">            logger.info(&quot;Update asset {} {}&quot;, type, newElemflavor);</span>
<span class="nc" id="L1221">          } else {</span>
<span class="nc" id="L1222">            logger.warn(&quot;Unknown asset type {} {} for field {}&quot;, type, newElemflavor, asset);</span>
          }
        }
<span class="nc" id="L1225">      } catch (Exception e) {</span>
        // Assuming a parse error versus a file error and logging the error type
<span class="nc" id="L1227">        throw new IllegalArgumentException(&quot;Unable to parse metadata: &quot; + assetMetadata.toJSONString(), e);</span>
<span class="fc" id="L1228">      }</span>
<span class="fc" id="L1229">    }</span>
<span class="fc" id="L1230">    return mp;</span>
  }

  @Override
  public MetadataList updateAllEventMetadata(
          final String id, final String metadataJSON, final ElasticsearchIndex index)
          throws IllegalArgumentException, IndexServiceException, NotFoundException, SearchIndexException,
          UnauthorizedException {
    final MetadataList metadataList;
    try {
<span class="fc" id="L1240">      metadataList = getMetadataListWithAllEventCatalogUIAdapters();</span>
<span class="nc" id="L1241">      MetadataJson.fillListFromJson(metadataList, (JSONArray) new JSONParser().parse(metadataJSON));</span>
<span class="nc" id="L1242">    } catch (final org.json.simple.parser.ParseException e) {</span>
<span class="nc" id="L1243">      throw new IllegalArgumentException(&quot;Not able to parse the event metadata &quot; + metadataJSON, e);</span>
<span class="nc" id="L1244">    }</span>
<span class="nc" id="L1245">    return updateEventMetadata(id, metadataList, index);</span>
  }

  @Override
  public void removeCatalogByFlavor(Event event, MediaPackageElementFlavor flavor)
          throws IndexServiceException, NotFoundException, UnauthorizedException {
<span class="nc" id="L1251">    MediaPackage mediaPackage = getEventMediapackage(event);</span>
<span class="nc" id="L1252">    Catalog[] catalogs = mediaPackage.getCatalogs(flavor);</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">    if (catalogs.length == 0) {</span>
<span class="nc" id="L1254">      throw new NotFoundException(String.format(&quot;Cannot find a catalog with flavor '%s' for event with id '%s'.&quot;,</span>
<span class="nc" id="L1255">              flavor.toString(), event.getIdentifier()));</span>
    }
<span class="nc bnc" id="L1257" title="All 2 branches missed.">    for (Catalog catalog : catalogs) {</span>
<span class="nc" id="L1258">      mediaPackage.remove(catalog);</span>
    }
<span class="nc bnc" id="L1260" title="All 4 branches missed.">    switch (getEventSource(event)) {</span>
      case WORKFLOW:
        try {
<span class="nc" id="L1263">          Optional&lt;WorkflowInstance&gt; workflowInstance = workflowService.</span>
<span class="nc" id="L1264">                  getRunningWorkflowInstanceByMediaPackage(event.getIdentifier(), Permissions.Action.WRITE.toString());</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">          if (workflowInstance.isEmpty()) {</span>
<span class="nc" id="L1266">            throw new IndexServiceException(&quot;No workflow instance found for event &quot; + event.getIdentifier());</span>
          }
<span class="nc" id="L1268">          WorkflowInstance instance = workflowInstance.get();</span>
<span class="nc" id="L1269">          instance.setMediaPackage(mediaPackage);</span>
<span class="nc" id="L1270">          updateWorkflowInstance(instance);</span>
<span class="nc" id="L1271">        } catch (WorkflowException e) {</span>
<span class="nc" id="L1272">          throw new IndexServiceException(&quot;Unable to remove catalog with flavor '&quot; + flavor</span>
<span class="nc" id="L1273">              + &quot;' by updating workflow event &quot; + event.getIdentifier(), e);</span>
<span class="nc" id="L1274">        }</span>
        break;
      case ARCHIVE:
<span class="nc" id="L1277">        assetManager.takeSnapshot(mediaPackage);</span>
<span class="nc" id="L1278">        break;</span>
      case SCHEDULE:
        try {
<span class="nc" id="L1281">          schedulerService.updateEvent(event.getIdentifier(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),</span>
<span class="nc" id="L1282">              Optional.of(mediaPackage), Optional.empty(), Optional.empty());</span>
<span class="nc" id="L1283">        } catch (SchedulerException e) {</span>
<span class="nc" id="L1284">          throw new IndexServiceException(&quot;Unable to remove catalog with flavor &quot; + flavor + &quot; by updating scheduled &quot;</span>
<span class="nc" id="L1285">              + &quot;event &quot; + event.getIdentifier(), e);</span>
<span class="nc" id="L1286">        }</span>
        break;
      default:
<span class="nc" id="L1289">        throw new IndexServiceException(</span>
<span class="nc" id="L1290">                String.format(&quot;Unable to handle event source type '%s'&quot;, getEventSource(event)));</span>
    }
<span class="nc" id="L1292">  }</span>

  @Override
  public void removeCatalogByFlavor(Series series, MediaPackageElementFlavor flavor)
          throws NotFoundException, IndexServiceException {
<span class="nc bnc" id="L1297" title="All 2 branches missed.">    if (series == null) {</span>
<span class="nc" id="L1298">      throw new IllegalArgumentException(&quot;The series cannot be null.&quot;);</span>
    }
<span class="nc bnc" id="L1300" title="All 2 branches missed.">    if (flavor == null) {</span>
<span class="nc" id="L1301">      throw new IllegalArgumentException(&quot;The flavor cannot be null.&quot;);</span>
    }
<span class="nc" id="L1303">    boolean found = false;</span>
    try {
<span class="nc" id="L1305">      found = seriesService.deleteSeriesElement(series.getIdentifier(), flavor.getType());</span>
<span class="nc" id="L1306">    } catch (SeriesException e) {</span>
<span class="nc" id="L1307">      throw new IndexServiceException(String.format(&quot;Unable to delete catalog from series '%s' with type '%s'&quot;,</span>
<span class="nc" id="L1308">              series.getIdentifier(), flavor.getType()), e);</span>
<span class="nc" id="L1309">    }</span>

<span class="nc bnc" id="L1311" title="All 2 branches missed.">    if (!found) {</span>
<span class="nc" id="L1312">      throw new NotFoundException(String.format(&quot;Unable to find a catalog for series '%s' with flavor '%s'&quot;,</span>
<span class="nc" id="L1313">              series.getIdentifier(), flavor));</span>
    }
<span class="nc" id="L1315">  }</span>

  @Override
  public MetadataList updateEventMetadata(String id, MetadataList metadataList, ElasticsearchIndex index)
          throws IndexServiceException, SearchIndexException, NotFoundException, UnauthorizedException {
<span class="fc" id="L1320">    Optional&lt;Event&gt; optEvent = getEvent(id, index);</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">    if (optEvent.isEmpty())</span>
<span class="fc" id="L1322">      throw new NotFoundException(&quot;Cannot find an event with id &quot; + id);</span>

<span class="fc" id="L1324">    Event event = optEvent.get();</span>
<span class="fc" id="L1325">    MediaPackage mediaPackage = getEventMediapackage(event);</span>
<span class="fc" id="L1326">    updateMediaPackageMetadata(mediaPackage, metadataList);</span>
<span class="pc bpc" id="L1327" title="3 of 4 branches missed.">    switch (getEventSource(event)) {</span>
      case WORKFLOW:
        try {
<span class="nc" id="L1330">          Optional&lt;WorkflowInstance&gt; workflowInstance = workflowService.</span>
<span class="nc" id="L1331">                  getRunningWorkflowInstanceByMediaPackage(event.getIdentifier(), Permissions.Action.WRITE.toString());</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">          if (workflowInstance.isEmpty()) {</span>
<span class="nc" id="L1333">            throw new IndexServiceException(&quot;No workflow instance found for event &quot; + event.getIdentifier());</span>
          }
<span class="nc" id="L1335">          WorkflowInstance instance = workflowInstance.get();</span>
<span class="nc" id="L1336">          instance.setMediaPackage(mediaPackage);</span>
<span class="nc" id="L1337">          updateWorkflowInstance(instance);</span>
<span class="nc" id="L1338">        } catch (WorkflowException e) {</span>
<span class="nc" id="L1339">          throw new IndexServiceException(&quot;Unable to update workflow event &quot; + id + &quot; with metadata &quot;</span>
<span class="nc" id="L1340">              + RestUtils.getJsonStringSilent(MetadataJson.listToJson(metadataList, true)), e);</span>
<span class="nc" id="L1341">        }</span>
        break;
      case ARCHIVE:
<span class="nc" id="L1344">        assetManager.takeSnapshot(mediaPackage);</span>
<span class="nc" id="L1345">        break;</span>
      case SCHEDULE:
<span class="fc" id="L1347">        DublinCoreMetadataCollection eventCatalog = metadataList.getMetadataByAdapter(getCommonEventCatalogUIAdapter());</span>
<span class="pc bpc" id="L1348" title="1 of 2 branches missed.">        Optional&lt;Set&lt;String&gt;&gt; presenters = eventCatalog == null ? Optional.empty() : updatePresenters(eventCatalog);</span>
        try {
<span class="fc" id="L1350">          schedulerService.updateEvent(id, Optional.empty(), Optional.empty(), Optional.empty(), presenters, Optional.of(mediaPackage),</span>
<span class="fc" id="L1351">              Optional.empty(), Optional.empty());</span>
<span class="nc" id="L1352">        } catch (SchedulerException e) {</span>
<span class="nc" id="L1353">          throw new IndexServiceException(&quot;Unable to update scheduled event &quot; + id + &quot; with metadata &quot;</span>
<span class="nc" id="L1354">              + RestUtils.getJsonStringSilent(MetadataJson.listToJson(metadataList, true)), e);</span>
<span class="fc" id="L1355">        }</span>
        break;
      default:
<span class="nc" id="L1358">        logger.error(&quot;Unknown event source!&quot;);</span>
    }
<span class="fc" id="L1360">    return metadataList;</span>
  }

  /**
   * Processes the combined usernames and free text entries of the presenters (creator) field into a list of presenters
   * using the full names of the users if available and adds the usernames to a set of technical presenters.
   *
   * @param eventMetadata
   *          The metadata list that has the presenter (creator) field to pull the list of presenters from.
   * @return A {@link Tuple} with a list of friendly presenter names and a set of user names if available for the
   *         presenters.
   */
  protected Tuple&lt;List&lt;String&gt;, Set&lt;String&gt;&gt; getTechnicalPresenters(DublinCoreMetadataCollection eventMetadata) {
<span class="fc" id="L1373">    MetadataField presentersMetadataField = eventMetadata.getOutputFields()</span>
<span class="fc" id="L1374">            .get(DublinCore.PROPERTY_CREATOR.getLocalName());</span>
<span class="fc" id="L1375">    List&lt;String&gt; presenters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1376">    Set&lt;String&gt; technicalPresenters = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">    for (String presenter : MetadataUtils.getIterableStringMetadata(presentersMetadataField)) {</span>
<span class="fc" id="L1378">      User user = userDirectoryService.loadUser(presenter);</span>
<span class="fc bfc" id="L1379" title="All 2 branches covered.">      if (user == null) {</span>
<span class="fc" id="L1380">        presenters.add(presenter);</span>
      } else {
<span class="fc bfc" id="L1382" title="All 2 branches covered.">        String fullname = StringUtils.isNotBlank(user.getName()) ? user.getName() : user.getUsername();</span>
<span class="fc" id="L1383">        presenters.add(fullname);</span>
<span class="fc" id="L1384">        technicalPresenters.add(user.getUsername());</span>
      }
<span class="fc" id="L1386">    }</span>
<span class="fc" id="L1387">    return Tuple.tuple(presenters, technicalPresenters);</span>
  }

  @Override
  public AccessControlList updateEventAcl(String id, AccessControlList acl, ElasticsearchIndex index)
          throws IllegalArgumentException, IndexServiceException, SearchIndexException, NotFoundException,
          UnauthorizedException {
<span class="nc" id="L1394">    Optional&lt;Event&gt; optEvent = getEvent(id, index);</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">    if (optEvent.isEmpty())</span>
<span class="nc" id="L1396">      throw new NotFoundException(&quot;Cannot find an event with id &quot; + id);</span>

<span class="nc" id="L1398">    Event event = optEvent.get();</span>
<span class="nc" id="L1399">    MediaPackage mediaPackage = getEventMediapackage(event);</span>
<span class="nc bnc" id="L1400" title="All 4 branches missed.">    switch (getEventSource(event)) {</span>
      case WORKFLOW:
        // Not updating the acl as the workflow might have already passed the point of distribution.
<span class="nc" id="L1403">        throw new IllegalArgumentException(&quot;Unable to update the ACL of this event as it is currently processing.&quot;);</span>
      case ARCHIVE:
        try {
<span class="nc" id="L1406">          mediaPackage = authorizationService.setAcl(mediaPackage, AclScope.Episode, acl).getA();</span>
<span class="nc" id="L1407">        } catch (MediaPackageException e) {</span>
<span class="nc" id="L1408">          throw new IndexServiceException(&quot;Unable to update  acl&quot;, e);</span>
<span class="nc" id="L1409">        }</span>
<span class="nc" id="L1410">        assetManager.takeSnapshot(mediaPackage);</span>
<span class="nc" id="L1411">        return acl;</span>
      case SCHEDULE:
        try {
<span class="nc" id="L1414">          mediaPackage = authorizationService.setAcl(mediaPackage, AclScope.Episode, acl).getA();</span>
<span class="nc" id="L1415">          schedulerService.updateEvent(id, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.of(mediaPackage),</span>
<span class="nc" id="L1416">                  Optional.empty(), Optional.empty());</span>
<span class="nc" id="L1417">        } catch (SchedulerException | MediaPackageException e) {</span>
<span class="nc" id="L1418">          throw new IndexServiceException(&quot;Unable to update the acl for the scheduled event&quot;, e);</span>
<span class="nc" id="L1419">        }</span>
<span class="nc" id="L1420">        return acl;</span>
      default:
<span class="nc" id="L1422">        throw new IndexServiceException(</span>
<span class="nc" id="L1423">                String.format(&quot;Unable to update the ACL as '%s' is an unknown event source.&quot;, getEventSource(event)));</span>
    }
  }

  private boolean hasSnapshots(String eventId) {
<span class="nc" id="L1428">    return assetManager.snapshotExists(eventId);</span>
  }

  @Override
  public Map&lt;String, Map&lt;String, String&gt;&gt; getEventWorkflowProperties(final List&lt;String&gt; eventIds) {
<span class="nc" id="L1433">    return WorkflowPropertiesUtil.getLatestWorkflowPropertiesForEvents(assetManager, eventIds);</span>
  }

  @Override
  public Optional&lt;Event&gt; getEvent(String id, ElasticsearchIndex index) throws SearchIndexException {
<span class="fc" id="L1438">    SearchResult&lt;Event&gt; result = index</span>
<span class="fc" id="L1439">            .getByQuery(new EventSearchQuery(securityService.getOrganization().getId(), securityService.getUser())</span>
<span class="fc" id="L1440">                    .withIdentifier(id));</span>
    // If the results list if empty, we return already a response.
<span class="fc bfc" id="L1442" title="All 2 branches covered.">    if (result.getPageSize() == 0) {</span>
<span class="fc" id="L1443">      logger.debug(&quot;Didn't find event with id {}&quot;, id);</span>
<span class="fc" id="L1444">      return Optional.empty();</span>
    }
<span class="fc" id="L1446">    return Optional.of(result.getItems()[0].getSource());</span>
  }

  @Override
  public EventRemovalResult removeEvent(Event event, String retractWorkflowId)
      throws UnauthorizedException, WorkflowDatabaseException, NotFoundException {
<span class="nc bnc" id="L1452" title="All 2 branches missed.">    final boolean hasOnlyEngageLive = event.getPublications().size() == 1</span>
<span class="nc bnc" id="L1453" title="All 2 branches missed.">        &amp;&amp; EventUtils.ENGAGE_LIVE_CHANNEL_ID.equals(event.getPublications().get(0).getChannel());</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">    final boolean retract = event.hasPreview()</span>
<span class="nc bnc" id="L1455" title="All 6 branches missed.">        || (!event.getPublications().isEmpty()  &amp;&amp; !hasOnlyEngageLive &amp;&amp; this.hasSnapshots(event.getIdentifier()));</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">    if (retract) {</span>
<span class="nc" id="L1457">      retractAndRemoveEvent(event.getIdentifier(), retractWorkflowId);</span>
<span class="nc" id="L1458">      return EventRemovalResult.RETRACTING;</span>
    } else {
      try {
<span class="nc" id="L1461">        final boolean success = removeEvent(event.getIdentifier());</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">        return success ? EventRemovalResult.SUCCESS : EventRemovalResult.GENERAL_FAILURE;</span>
<span class="nc" id="L1463">      } catch (NotFoundException e) {</span>
<span class="nc" id="L1464">        return EventRemovalResult.NOT_FOUND;</span>
      }
    }
  }

  private void retractAndRemoveEvent(String id, String retractWorkflowId)
      throws WorkflowDatabaseException, NotFoundException {
<span class="nc" id="L1471">    final WorkflowDefinition wfd = workflowService.getWorkflowDefinitionById(retractWorkflowId);</span>
<span class="nc" id="L1472">    final Workflows workflows = new Workflows(assetManager, workflowService);</span>
<span class="nc" id="L1473">    final ConfiguredWorkflow workflow = workflow(wfd);</span>
<span class="nc" id="L1474">    final List&lt;WorkflowInstance&gt; result = workflows.applyWorkflowToLatestVersion(Collections.singleton(id), workflow);</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">    if (result.size() != 1) {</span>
<span class="nc" id="L1476">        throw new IllegalStateException(&quot;Couldn't start workflow to retract media package&quot; + id);</span>
    }
<span class="nc" id="L1478">    this.retractions.put(</span>
<span class="nc" id="L1479">        result.get(0).getId(),</span>
<span class="nc" id="L1480">        new Retraction(securityService.getUser(), securityService.getOrganization())</span>
    );
<span class="nc" id="L1482">  }</span>

  @Override
  public boolean removeEvent(String id) throws NotFoundException, UnauthorizedException {
<span class="nc" id="L1486">    boolean unauthorizedWorkflow = false;</span>
<span class="nc" id="L1487">    boolean notFoundWorkflow = false;</span>
<span class="nc" id="L1488">    boolean removedWorkflow = false;</span>
    try {
<span class="nc" id="L1490">      List&lt;WorkflowInstance&gt; workflowInstances = workflowService.getWorkflowInstancesByMediaPackage(id);</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">      if (workflowInstances.isEmpty()) {</span>
<span class="nc" id="L1492">        notFoundWorkflow = true;</span>
      } else {
<span class="nc" id="L1494">        var toRemove = workflowInstances.size();</span>
<span class="nc bnc" id="L1495" title="All 2 branches missed.">        for (WorkflowInstance instance : workflowInstances) {</span>
          try {
<span class="nc" id="L1497">            workflowService.stop(instance.getId());</span>
<span class="nc" id="L1498">            workflowService.remove(instance.getId());</span>
<span class="nc" id="L1499">            toRemove--;</span>
<span class="nc" id="L1500">          } catch (WorkflowDatabaseException e) {</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">            if (e.getCause() instanceof  NotFoundException) {</span>
              // Someone already removed this. That's fine. Continue with the next workflow
<span class="nc" id="L1503">              logger.warn(&quot;Workflow {} has already been removed&quot;, instance.getId());</span>
            } else {
<span class="nc" id="L1505">              throw e;</span>
            }
<span class="nc" id="L1507">          }</span>
<span class="nc" id="L1508">        }</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">        removedWorkflow = toRemove == 0;</span>
<span class="nc bnc" id="L1510" title="All 2 branches missed.">        notFoundWorkflow = toRemove &gt;= 1;</span>
      }
<span class="nc" id="L1512">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1513">      unauthorizedWorkflow = true;</span>
<span class="nc" id="L1514">    } catch (WorkflowException e) {</span>
<span class="nc" id="L1515">      logger.error(&quot;Unable to remove the event '{}' because removing workflow failed:&quot;, id, e);</span>
<span class="nc" id="L1516">    }</span>

<span class="nc" id="L1518">    boolean unauthorizedScheduler = false;</span>
<span class="nc" id="L1519">    boolean notFoundScheduler = false;</span>
<span class="nc" id="L1520">    boolean removedScheduler = false;</span>
    try {
<span class="nc" id="L1522">      schedulerService.removeEvent(id);</span>
<span class="nc" id="L1523">      removedScheduler = true;</span>
<span class="nc" id="L1524">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1525">      notFoundScheduler = true;</span>
<span class="nc" id="L1526">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1527">      unauthorizedScheduler = true;</span>
<span class="nc" id="L1528">    } catch (SchedulerException e) {</span>
<span class="nc" id="L1529">      logger.error(&quot;Unable to remove the event '{}' from scheduler service:&quot;, id, e);</span>
<span class="nc" id="L1530">    }</span>

<span class="nc" id="L1532">    boolean unauthorizedArchive = false;</span>
<span class="nc" id="L1533">    boolean notFoundArchive = false;</span>
<span class="nc" id="L1534">    boolean removedArchive = false;</span>
    try {
<span class="nc" id="L1536">      List&lt;Snapshot&gt; snapshots = assetManager.getSnapshotsById(id);</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">      if (snapshots.size() &gt; 0) {</span>
<span class="nc" id="L1538">        assetManager.deleteSnapshots(id);</span>
<span class="nc" id="L1539">        removedArchive = true;</span>
      } else {
<span class="nc" id="L1541">        notFoundArchive = true;</span>
      }
<span class="nc" id="L1543">    } catch (AssetManagerException e) {</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">      if (e.getCause() instanceof UnauthorizedException) {</span>
<span class="nc" id="L1545">        unauthorizedArchive = true;</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">      } else if (e.getCause() instanceof NotFoundException) {</span>
<span class="nc" id="L1547">        notFoundArchive = true;</span>
      } else {
<span class="nc" id="L1549">        logger.error(&quot;Unable to remove the event '{}' from the archive:&quot;, id, e);</span>
      }
<span class="nc" id="L1551">    }</span>

<span class="nc bnc" id="L1553" title="All 6 branches missed.">    if (unauthorizedScheduler || unauthorizedWorkflow || unauthorizedArchive)</span>
<span class="nc" id="L1554">      throw new UnauthorizedException(&quot;Not authorized to remove event id &quot; + id);</span>

    // if all three services either removed the event successfully or couldn't find it, make sure it's also removed
    // from the index
<span class="nc bnc" id="L1558" title="All 12 branches missed.">    if ((removedScheduler || notFoundScheduler) &amp;&amp; (removedWorkflow || notFoundWorkflow)</span>
            &amp;&amp; (removedArchive || notFoundArchive)) {
      try {
<span class="nc" id="L1561">        elasticsearchIndex.deleteEvent(id, securityService.getOrganization().getId());</span>
<span class="nc" id="L1562">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L1563">        logger.error(&quot;Removing event {} from the {} index failed&quot;, id, elasticsearchIndex.getIndexName(), e);</span>
<span class="nc" id="L1564">      }</span>
    }

    try {
<span class="nc" id="L1568">      eventCommentService.deleteComments(id);</span>
<span class="nc" id="L1569">    } catch (EventCommentException e) {</span>
<span class="nc" id="L1570">      logger.error(&quot;Unable to remove comments for event '{}':&quot;, id, e);</span>
<span class="nc" id="L1571">    }</span>

<span class="nc bnc" id="L1573" title="All 6 branches missed.">    if (notFoundScheduler &amp;&amp; notFoundWorkflow &amp;&amp; notFoundArchive)</span>
<span class="nc" id="L1574">      throw new NotFoundException(&quot;Event id &quot; + id + &quot; not found.&quot;);</span>

<span class="nc bnc" id="L1576" title="All 12 branches missed.">    return ((removedScheduler || notFoundScheduler) &amp;&amp; (removedWorkflow || notFoundWorkflow)</span>
            &amp;&amp; (removedArchive || notFoundArchive));
  }

  private void updateWorkflowInstance(WorkflowInstance workflowInstance)
          throws WorkflowException, UnauthorizedException {
    // Only update the workflow if the instance is in a working state
<span class="nc bnc" id="L1583" title="All 2 branches missed.">    if (WorkflowInstance.WorkflowState.FAILED.equals(workflowInstance.getState())</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">            || WorkflowInstance.WorkflowState.FAILING.equals(workflowInstance.getState())</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">            || WorkflowInstance.WorkflowState.STOPPED.equals(workflowInstance.getState())</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">            || WorkflowInstance.WorkflowState.SUCCEEDED.equals(workflowInstance.getState())) {</span>
<span class="nc" id="L1587">      logger.info(&quot;Skip updating {} workflow mediapackage {} with updated comments catalog&quot;,</span>
<span class="nc" id="L1588">              workflowInstance.getState(), workflowInstance.getMediaPackage().getIdentifier().toString());</span>
<span class="nc" id="L1589">      return;</span>
    }
<span class="nc" id="L1591">    workflowService.update(workflowInstance);</span>
<span class="nc" id="L1592">  }</span>

  @Override
  public MediaPackage getEventMediapackage(Event event) throws IndexServiceException {
<span class="pc bpc" id="L1596" title="3 of 4 branches missed.">    switch (getEventSource(event)) {</span>
      case WORKFLOW:
        try {
<span class="nc" id="L1599">          Optional&lt;WorkflowInstance&gt; currentWorkflowInstance = workflowService.</span>
<span class="nc" id="L1600">                  getRunningWorkflowInstanceByMediaPackage(event.getIdentifier(), Permissions.Action.READ.toString());</span>
<span class="nc bnc" id="L1601" title="All 2 branches missed.">          if (currentWorkflowInstance.isEmpty()) {</span>
<span class="nc" id="L1602">            throw new IndexServiceException(&quot;No workflow instance found for event &quot; + event.getIdentifier());</span>
          }
<span class="nc" id="L1604">          return currentWorkflowInstance.get().getMediaPackage();</span>
<span class="nc" id="L1605">        } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L1606">          throw new IndexServiceException(&quot;Unable to get current workflow instance for event with id &quot; + event.getIdentifier() + &quot; from workflow service&quot;, e);</span>
<span class="nc" id="L1607">        } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1608">          throw new IndexServiceException(&quot;Not authorized to read media package &quot; + event.getIdentifier() + &quot; from workflow&quot;, e);</span>
<span class="nc" id="L1609">        } catch (WorkflowException e) {</span>
<span class="nc" id="L1610">          throw new IndexServiceException(&quot;Unable to get event media package &quot; + event.getIdentifier() + &quot; from WorkflowService because&quot;, e);</span>
        }
      case ARCHIVE:
<span class="nc" id="L1613">        Optional&lt;MediaPackage&gt; mpOpt = assetManager.getMediaPackage(event.getIdentifier());</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">        if (mpOpt.isPresent()) {</span>
<span class="nc" id="L1615">          logger.debug(&quot;Found event in archive with id {}&quot;, event.getIdentifier());</span>
<span class="nc" id="L1616">          return mpOpt.get();</span>
        }
<span class="nc" id="L1618">        throw new IndexServiceException(&quot;No archived event found with id &quot; + event.getIdentifier());</span>
      case SCHEDULE:
        try {
<span class="fc" id="L1621">          MediaPackage mediaPackage = schedulerService.getMediaPackage(event.getIdentifier());</span>
<span class="fc" id="L1622">          logger.debug(&quot;Found event in scheduler with id {}&quot;, event.getIdentifier());</span>
<span class="fc" id="L1623">          return mediaPackage;</span>
<span class="nc" id="L1624">        } catch (NotFoundException e) {</span>
<span class="nc" id="L1625">          throw new IndexServiceException(&quot;No scheduled event with id &quot; + event.getIdentifier(), e);</span>
<span class="nc" id="L1626">        } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1627">          throw new IndexServiceException(&quot;Unauthorized to get event &quot; + event.getIdentifier() + &quot; from scheduler&quot;, e);</span>
<span class="nc" id="L1628">        } catch (SchedulerException e) {</span>
<span class="nc" id="L1629">          throw new IndexServiceException(&quot;Unable to get event &quot; + event.getIdentifier() + &quot; from scheduler&quot;, e);</span>
        }
      default:
<span class="nc" id="L1632">        throw new IllegalStateException(&quot;Unknown event type!&quot;);</span>
    }
  }

  /**
   * Determines in a very basic way what kind of source the event is
   *
   * @param event
   *          the event
   * @return the source type
   */
  @Override
  public Source getEventSource(Event event) {
<span class="pc bpc" id="L1645" title="3 of 4 branches missed.">    if (event.getWorkflowId() != null &amp;&amp; isWorkflowActive(event.getWorkflowState())) {</span>
<span class="nc" id="L1646">      return Source.WORKFLOW;</span>
<span class="pc bpc" id="L1647" title="3 of 4 branches missed.">    } else if (event.isScheduledEvent() &amp;&amp; !event.hasRecordingStarted()) {</span>
<span class="nc" id="L1648">      return Source.SCHEDULE;</span>
<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">    } else if (event.getArchiveVersion() != null) {</span>
<span class="nc" id="L1650">      return Source.ARCHIVE;</span>
<span class="pc bpc" id="L1651" title="1 of 2 branches missed.">    } else if (event.getWorkflowId() != null) {</span>
<span class="nc" id="L1652">      return Source.WORKFLOW;</span>
    } else {
<span class="fc" id="L1654">      return Source.SCHEDULE;</span>
    }
  }

  private void updateMediaPackageMetadata(MediaPackage mp, MetadataList metadataList) {
<span class="fc" id="L1659">    String oldSeriesId = mp.getSeries();</span>
<span class="fc bfc" id="L1660" title="All 2 branches covered.">    for (EventCatalogUIAdapter catalogUIAdapter : getEventCatalogUIAdapters()) {</span>
<span class="fc" id="L1661">      final DublinCoreMetadataCollection metadata = metadataList.getMetadataByAdapter(catalogUIAdapter);</span>
<span class="pc bpc" id="L1662" title="2 of 4 branches missed.">      if (metadata != null &amp;&amp; metadata.isUpdated()) {</span>
<span class="fc" id="L1663">        catalogUIAdapter.storeFields(mp, metadata);</span>
      }
<span class="fc" id="L1665">    }</span>

    // update series catalogs
<span class="fc bfc" id="L1668" title="All 2 branches covered.">    if (!StringUtils.equals(oldSeriesId, mp.getSeries())) {</span>
<span class="fc" id="L1669">      List&lt;String&gt; seriesDcTags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1670">      List&lt;String&gt; seriesAclTags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1671">      Map&lt;String, List&lt;String&gt;&gt; seriesExtDcTags = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(oldSeriesId)) {</span>
        // remove series dublincore from the media package
<span class="nc bnc" id="L1674" title="All 2 branches missed.">        for (MediaPackageElement mpe : mp.getElementsByFlavor(MediaPackageElements.SERIES)) {</span>
<span class="nc" id="L1675">          mp.remove(mpe);</span>
<span class="nc" id="L1676">          seriesDcTags.addAll(Arrays.asList(mpe.getTags()));</span>
        }
<span class="nc bnc" id="L1678" title="All 4 branches missed.">        if (mp.getSeries() != null || mp.getElementsByFlavor(MediaPackageElements.XACML_POLICY_EPISODE).length &gt; 0) {</span>
          // a new series was set or the series was unset and episode ACL exists
          // remove series ACL from the media package
<span class="nc bnc" id="L1681" title="All 2 branches missed.">          for (MediaPackageElement mpe : mp.getElementsByFlavor(MediaPackageElements.XACML_POLICY_SERIES)) {</span>
<span class="nc" id="L1682">            mp.remove(mpe);</span>
<span class="nc" id="L1683">            seriesAclTags.addAll(Arrays.asList(mpe.getTags()));</span>
          }
        } else {
          // series was unset but episode don't have an episode ACL
          // in this case user may lose access to the episode if we delete the series ACL
          // but, we also shouldn't keep the series ACL because the series was unset
          // let's keep the series ACL as episode ACL and provide same access rights as before
<span class="nc" id="L1690">          Tuple&lt;AccessControlList, AclScope&gt; activeAcl = authorizationService.getActiveAcl(mp);</span>
          try {
<span class="nc" id="L1692">            authorizationService.setAcl(mp, AclScope.Episode, activeAcl.getA());</span>
<span class="nc" id="L1693">            authorizationService.removeAcl(mp, AclScope.Series);</span>
<span class="nc" id="L1694">          } catch (MediaPackageException e) {</span>
<span class="nc" id="L1695">            throw new IllegalStateException(&quot;Unable to set episode ACL on media package&quot;, e);</span>
<span class="nc" id="L1696">          }</span>
        }
        // remove series extended metadata from the media package
        try {
<span class="nc" id="L1700">          Optional&lt;Map&lt;String, byte[]&gt;&gt; oldSeriesElementsOpt = seriesService.getSeriesElements(oldSeriesId);</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">          if (oldSeriesElementsOpt.isPresent()) {</span>
<span class="nc" id="L1702">            var oldSeriesElements = oldSeriesElementsOpt.get();</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">            for (String oldSeriesElementType : oldSeriesElements.keySet()) {</span>
<span class="nc bnc" id="L1704" title="All 2 branches missed.">              for (MediaPackageElement mpe : mp</span>
<span class="nc" id="L1705">                      .getElementsByFlavor(MediaPackageElementFlavor.flavor(oldSeriesElementType, &quot;series&quot;))) {</span>
<span class="nc" id="L1706">                mp.remove(mpe);</span>
<span class="nc" id="L1707">                String elementType = mpe.getFlavor().getType();</span>
<span class="nc bnc" id="L1708" title="All 2 branches missed.">                if (StringUtils.isNotBlank(elementType)) {</span>
                  // remember the tags for this type of element
<span class="nc bnc" id="L1710" title="All 2 branches missed.">                  if (!seriesExtDcTags.containsKey(elementType)) {</span>
                    // initialize the tags list on the first occurrence of this element type
<span class="nc" id="L1712">                    seriesExtDcTags.put(elementType, new ArrayList&lt;&gt;());</span>
                  }
<span class="nc bnc" id="L1714" title="All 2 branches missed.">                  for (String tag : mpe.getTags()) {</span>
<span class="nc" id="L1715">                    seriesExtDcTags.get(elementType).add(tag);</span>
                  }
                }
              }
<span class="nc" id="L1719">            }</span>
          }
<span class="nc" id="L1721">        } catch (SeriesException e) {</span>
<span class="nc" id="L1722">          logger.info(&quot;Unable to retrieve series element types from series service for the series {}&quot;, oldSeriesId, e);</span>
<span class="nc" id="L1723">        }</span>
      }

<span class="pc bpc" id="L1726" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(mp.getSeries())) {</span>
        // add updated series dublincore to the media package
        try {
<span class="fc" id="L1729">          DublinCoreCatalog seriesDC = seriesService.getSeries(mp.getSeries());</span>
<span class="pc bpc" id="L1730" title="1 of 2 branches missed.">          if (seriesDC != null) {</span>
<span class="fc" id="L1731">            mp.setSeriesTitle(seriesDC.getFirst(DublinCore.PROPERTY_TITLE));</span>
<span class="fc" id="L1732">            try (InputStream in = IOUtils.toInputStream(seriesDC.toXmlString(), &quot;UTF-8&quot;)) {</span>
<span class="fc" id="L1733">              String elementId = UUID.randomUUID().toString();</span>
<span class="fc" id="L1734">              URI catalogUrl = workspace.put(mp.getIdentifier().toString(), elementId, &quot;dublincore.xml&quot;, in);</span>
<span class="fc" id="L1735">              MediaPackageElement mpe = mp.add(catalogUrl, MediaPackageElement.Type.Catalog, MediaPackageElements.SERIES);</span>
<span class="fc" id="L1736">              mpe.setIdentifier(elementId);</span>
<span class="fc" id="L1737">              mpe.setChecksum(Checksum.create(ChecksumType.DEFAULT_TYPE, workspace.read(catalogUrl)));</span>
<span class="pc bpc" id="L1738" title="1 of 2 branches missed.">              if (StringUtils.isNotBlank(oldSeriesId)) {</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">                for (String tag : seriesDcTags) {</span>
<span class="nc" id="L1740">                  mpe.addTag(tag);</span>
<span class="nc" id="L1741">                }</span>
              } else {
                // add archive tag to the element if the media package had no series set before
<span class="fc" id="L1744">                mpe.addTag(&quot;archive&quot;);</span>
              }
<span class="nc" id="L1746">            } catch (IOException e) {</span>
<span class="nc" id="L1747">              throw new IllegalStateException(&quot;Unable to add the series dublincore to the media package &quot; + mp.getIdentifier(), e);</span>
<span class="fc" id="L1748">            }</span>
          }
<span class="nc" id="L1750">        } catch (SeriesException e) {</span>
<span class="nc" id="L1751">          throw new IllegalStateException(&quot;Unable to retrieve series dublincore catalog for the series &quot; + mp.getSeries(), e);</span>
<span class="nc" id="L1752">        } catch (NotFoundException | UnauthorizedException e) {</span>
<span class="nc" id="L1753">          throw new IllegalArgumentException(&quot;Unable to retrieve series dublincore catalog for the series &quot; + mp.getSeries(), e);</span>
<span class="fc" id="L1754">        }</span>
        // add updated series ACL to the media package
        try {
<span class="fc" id="L1757">          AccessControlList seriesAccessControl = seriesService.getSeriesAccessControl(mp.getSeries());</span>
<span class="pc bpc" id="L1758" title="1 of 2 branches missed.">          if (seriesAccessControl != null) {</span>
<span class="nc" id="L1759">            mp = authorizationService.setAcl(mp, AclScope.Series, seriesAccessControl).getA();</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">            for (MediaPackageElement seriesAclMpe : mp.getElementsByFlavor(MediaPackageElements.XACML_POLICY_SERIES)) {</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">              if (StringUtils.isNotBlank(oldSeriesId)) {</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">                for (String tag : seriesAclTags) {</span>
<span class="nc" id="L1763">                  seriesAclMpe.addTag(tag);</span>
<span class="nc" id="L1764">                }</span>
              } else {
                // add archive tag to the element if the media package had no series set before
<span class="nc" id="L1767">                seriesAclMpe.addTag(&quot;archive&quot;);</span>
              }
            }
          }
<span class="nc" id="L1771">        } catch (SeriesException | MediaPackageException e) {</span>
<span class="nc" id="L1772">          throw new IllegalStateException(&quot;Unable to retrieve series ACL for series &quot; + oldSeriesId, e);</span>
<span class="nc" id="L1773">        } catch (NotFoundException e) {</span>
<span class="nc" id="L1774">          logger.debug(&quot;There is no ACL set for the series {}&quot;, mp.getSeries());</span>
<span class="fc" id="L1775">        }</span>
        // add updated series extended metadata to the media package
        try {
<span class="fc" id="L1778">          Optional&lt;Map&lt;String, byte[]&gt;&gt; seriesElementsOpt = seriesService.getSeriesElements(mp.getSeries());</span>
<span class="pc bpc" id="L1779" title="1 of 2 branches missed.">          if (seriesElementsOpt.isPresent()) {</span>
<span class="nc" id="L1780">            var seriesElements = seriesElementsOpt.get();</span>
<span class="nc bnc" id="L1781" title="All 2 branches missed.">            for (String seriesElementType : seriesElements.keySet()) {</span>
<span class="nc" id="L1782">              try (InputStream in = new ByteArrayInputStream(seriesElements.get(seriesElementType))) {</span>
<span class="nc" id="L1783">                String elementId = UUID.randomUUID().toString();</span>
<span class="nc" id="L1784">                URI catalogUrl = workspace.put(mp.getIdentifier().toString(), elementId, &quot;dublincore.xml&quot;, in);</span>
<span class="nc" id="L1785">                MediaPackageElement mpe = mp.add(catalogUrl, MediaPackageElement.Type.Catalog,</span>
<span class="nc" id="L1786">                        MediaPackageElementFlavor.flavor(seriesElementType, &quot;series&quot;));</span>
<span class="nc" id="L1787">                mpe.setIdentifier(elementId);</span>
<span class="nc" id="L1788">                mpe.setChecksum(Checksum.create(ChecksumType.DEFAULT_TYPE, workspace.read(catalogUrl)));</span>
<span class="nc bnc" id="L1789" title="All 2 branches missed.">                if (StringUtils.isNotBlank(oldSeriesId)) {</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">                  if (seriesExtDcTags.containsKey(seriesElementType)) {</span>
<span class="nc bnc" id="L1791" title="All 2 branches missed.">                    for (String tag : seriesExtDcTags.get(seriesElementType)) {</span>
<span class="nc" id="L1792">                      mpe.addTag(tag);</span>
<span class="nc" id="L1793">                    }</span>
                  }
                } else {
                  // add archive tag to the element if the media package had no series set before
<span class="nc" id="L1797">                  mpe.addTag(&quot;archive&quot;);</span>
                }
<span class="nc" id="L1799">              } catch (IOException e) {</span>
<span class="nc" id="L1800">                throw new IllegalStateException(String.format(&quot;Unable to serialize series element %s for the series %s&quot;,</span>
<span class="nc" id="L1801">                        seriesElementType, mp.getSeries()), e);</span>
<span class="nc" id="L1802">              } catch (NotFoundException e) {</span>
<span class="nc" id="L1803">                throw new IllegalArgumentException(&quot;Unable to retrieve series element dublincore catalog for the series &quot;</span>
<span class="nc" id="L1804">                        + mp.getSeries(), e);</span>
<span class="nc" id="L1805">              }</span>
<span class="nc" id="L1806">            }</span>
          }
<span class="nc" id="L1808">        } catch (SeriesException e) {</span>
<span class="nc" id="L1809">          throw new IllegalStateException(&quot;Unable to retrieve series elements for the series &quot; + mp.getSeries(), e);</span>
<span class="fc" id="L1810">        }</span>
      }
    }
<span class="fc" id="L1813">  }</span>

  @Override
  public String createSeries(MetadataList metadataList, Map&lt;String, String&gt; options, Optional&lt;AccessControlList&gt; optAcl,
          Optional&lt;Long&gt; optThemeId) throws IndexServiceException {
<span class="nc" id="L1818">    DublinCoreCatalog dc = DublinCores.mkOpencastSeries().getCatalog();</span>
<span class="nc" id="L1819">    dc.set(PROPERTY_IDENTIFIER, UUID.randomUUID().toString());</span>
<span class="nc" id="L1820">    dc.set(DublinCore.PROPERTY_CREATED, EncodingSchemeUtils.encodeDate(new Date(), Precision.Second));</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">    for (Entry&lt;String, String&gt; entry : options.entrySet()) {</span>
<span class="nc" id="L1822">      dc.set(new EName(DublinCores.OC_PROPERTY_NS_URI, entry.getKey()), entry.getValue());</span>
<span class="nc" id="L1823">    }</span>

<span class="nc" id="L1825">    DublinCoreMetadataCollection seriesMetadata = metadataList.getMetadataByFlavor(MediaPackageElements.SERIES.toString());</span>
<span class="nc bnc" id="L1826" title="All 2 branches missed.">    if (seriesMetadata != null) {</span>
<span class="nc" id="L1827">      DublinCoreMetadataUtil.updateDublincoreCatalog(dc, seriesMetadata);</span>
    }

    AccessControlList acl;
<span class="nc bnc" id="L1831" title="All 2 branches missed.">    if (optAcl.isPresent()) {</span>
<span class="nc" id="L1832">      acl = optAcl.get();</span>
    } else {
<span class="nc" id="L1834">      acl = new AccessControlList();</span>
    }

    String seriesId;
    try {
<span class="nc" id="L1839">      DublinCoreCatalog createdSeries = seriesService.updateSeries(dc);</span>
<span class="nc" id="L1840">      seriesId = createdSeries.getFirst(PROPERTY_IDENTIFIER);</span>
<span class="nc" id="L1841">      seriesService.updateAccessControl(seriesId, acl);</span>
<span class="nc bnc" id="L1842" title="All 2 branches missed.">      if (optThemeId.isPresent())</span>
<span class="nc" id="L1843">        seriesService.updateSeriesProperty(seriesId, THEME_PROPERTY_NAME, Long.toString(optThemeId.get()));</span>
<span class="nc" id="L1844">    } catch (Exception e) {</span>
<span class="nc" id="L1845">      logger.error(&quot;Unable to create new series:&quot;, e);</span>
<span class="nc" id="L1846">      throw new IndexServiceException(&quot;Unable to create new series&quot;);</span>
<span class="nc" id="L1847">    }</span>

<span class="nc" id="L1849">    updateSeriesMetadata(seriesId, metadataList);</span>

<span class="nc" id="L1851">    return seriesId;</span>
  }

  @Override
  public String createSeries(JSONObject metadata)
          throws IllegalArgumentException, IndexServiceException, UnauthorizedException {

<span class="nc" id="L1858">    JSONArray seriesMetadataJson = (JSONArray) metadata.get(&quot;metadata&quot;);</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">    if (seriesMetadataJson == null)</span>
<span class="nc" id="L1860">      throw new IllegalArgumentException(&quot;No metadata field in metadata&quot;);</span>

<span class="nc" id="L1862">    JSONObject options = (JSONObject) metadata.get(&quot;options&quot;);</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">    if (options == null)</span>
<span class="nc" id="L1864">      throw new IllegalArgumentException(&quot;No options field in metadata&quot;);</span>

<span class="nc" id="L1866">    Optional&lt;Long&gt; themeId = Optional.empty();</span>
<span class="nc" id="L1867">    Long theme = (Long) metadata.get(&quot;theme&quot;);</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">    if (theme != null) {</span>
<span class="nc" id="L1869">      themeId = Optional.of(theme);</span>
    }

    Map&lt;String, String&gt; optionsMap;
    try {
<span class="nc" id="L1874">      optionsMap = JSONUtils.toMap(new org.codehaus.jettison.json.JSONObject(options.toJSONString()));</span>
<span class="nc" id="L1875">    } catch (JSONException e) {</span>
<span class="nc" id="L1876">      throw new IllegalArgumentException(&quot;Unable to parse options to map&quot;, e);</span>
<span class="nc" id="L1877">    }</span>

<span class="nc" id="L1879">    DublinCoreCatalog dc = DublinCores.mkOpencastSeries().getCatalog();</span>
<span class="nc" id="L1880">    dc.set(PROPERTY_IDENTIFIER, UUID.randomUUID().toString());</span>
<span class="nc" id="L1881">    dc.set(DublinCore.PROPERTY_CREATED, EncodingSchemeUtils.encodeDate(new Date(), Precision.Second));</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">    for (Entry&lt;String, String&gt; entry : optionsMap.entrySet()) {</span>
<span class="nc" id="L1883">      dc.set(new EName(DublinCores.OC_PROPERTY_NS_URI, entry.getKey()), entry.getValue());</span>
<span class="nc" id="L1884">    }</span>

<span class="nc" id="L1886">    final MetadataList metadataList = getMetadataListWithAllSeriesCatalogUIAdapters();</span>
<span class="nc" id="L1887">    MetadataJson.fillListFromJson(metadataList, seriesMetadataJson);</span>

<span class="nc" id="L1889">    DublinCoreMetadataCollection seriesMetadata = metadataList.getMetadataByFlavor(MediaPackageElements.SERIES.toString());</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">    if (seriesMetadata != null) {</span>
<span class="nc" id="L1891">      DublinCoreMetadataUtil.updateDublincoreCatalog(dc, seriesMetadata);</span>
    }

<span class="nc" id="L1894">    AccessControlList acl = getAccessControlList(metadata);</span>

    String seriesId;
    try {
<span class="nc" id="L1898">      DublinCoreCatalog createdSeries = seriesService.updateSeries(dc);</span>
<span class="nc" id="L1899">      seriesId = createdSeries.getFirst(PROPERTY_IDENTIFIER);</span>
<span class="nc" id="L1900">      seriesService.updateAccessControl(seriesId, acl);</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">      if (themeId.isPresent())</span>
<span class="nc" id="L1902">        seriesService.updateSeriesProperty(seriesId, THEME_PROPERTY_NAME, Long.toString(themeId.get()));</span>
<span class="nc" id="L1903">    } catch (Exception e) {</span>
<span class="nc" id="L1904">      throw new IndexServiceException(&quot;Unable to create new series&quot;, e);</span>
<span class="nc" id="L1905">    }</span>

<span class="nc" id="L1907">    updateSeriesMetadata(seriesId, metadataList);</span>

<span class="nc" id="L1909">    return seriesId;</span>
  }

  @Override
  public void removeSeries(String id) throws NotFoundException, SeriesException, UnauthorizedException {
<span class="nc" id="L1914">    seriesService.deleteSeries(id);</span>
<span class="nc" id="L1915">  }</span>

  @Override
  public MetadataList updateAllSeriesMetadata(String id, String metadataJSON, ElasticsearchIndex index)
          throws IllegalArgumentException, IndexServiceException, NotFoundException {
<span class="nc" id="L1920">    MetadataList metadataList = getMetadataListWithAllSeriesCatalogUIAdapters();</span>
<span class="nc" id="L1921">    return updateSeriesMetadata(id, metadataJSON, index, metadataList);</span>
  }

  @Override
  public MetadataList updateAllSeriesMetadata(String id, MetadataList metadataList, ElasticsearchIndex index)
          throws IndexServiceException, NotFoundException {
<span class="nc" id="L1927">    checkSeriesExists(id, index);</span>
<span class="nc" id="L1928">    updateSeriesMetadata(id, metadataList);</span>
<span class="nc" id="L1929">    return metadataList;</span>
  }

  @Override
  public void updateCommentCatalog(final Event event, final List&lt;EventComment&gt; comments) throws Exception {
<span class="nc" id="L1934">    final SecurityContext securityContext = new SecurityContext(securityService, securityService.getOrganization(),</span>
<span class="nc" id="L1935">            securityService.getUser());</span>
<span class="nc" id="L1936">    executorService.execute(() -&gt; securityContext.runInContext(() -&gt; {</span>
      try {
<span class="nc" id="L1938">        MediaPackage mediaPackage = getEventMediapackage(event);</span>
<span class="nc" id="L1939">        updateMediaPackageCommentCatalog(mediaPackage, comments);</span>
<span class="nc bnc" id="L1940" title="All 4 branches missed.">        switch (getEventSource(event)) {</span>
          case WORKFLOW:
<span class="nc" id="L1942">            logger.info(&quot;Update workflow media pacakge {} with updated comments catalog.&quot;, event.getIdentifier());</span>
<span class="nc" id="L1943">            Optional&lt;WorkflowInstance&gt; workflowInstance = workflowService.</span>
<span class="nc" id="L1944">                    getRunningWorkflowInstanceByMediaPackage(event.getIdentifier(), Permissions.Action.WRITE.toString());</span>
<span class="nc bnc" id="L1945" title="All 2 branches missed.">            if (workflowInstance.isEmpty()) {</span>
<span class="nc" id="L1946">              throw new IndexServiceException(&quot;No workflow instance found for event &quot; + event.getIdentifier());</span>
            }
<span class="nc" id="L1948">            WorkflowInstance instance = workflowInstance.get();</span>
<span class="nc" id="L1949">            instance.setMediaPackage(mediaPackage);</span>
<span class="nc" id="L1950">            updateWorkflowInstance(instance);</span>
<span class="nc" id="L1951">            break;</span>
          case ARCHIVE:
<span class="nc" id="L1953">            logger.info(&quot;Update archive mediapacakge {} with updated comments catalog.&quot;, event.getIdentifier());</span>
<span class="nc" id="L1954">            assetManager.takeSnapshot(mediaPackage);</span>
<span class="nc" id="L1955">            break;</span>
          case SCHEDULE:
<span class="nc" id="L1957">            logger.info(&quot;Update scheduled mediapacakge {} with updated comments catalog.&quot;, event.getIdentifier());</span>
<span class="nc" id="L1958">            schedulerService.updateEvent(event.getIdentifier(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),</span>
<span class="nc" id="L1959">                    Optional.of(mediaPackage), Optional.empty(), Optional.empty());</span>
<span class="nc" id="L1960">            break;</span>
          default:
<span class="nc" id="L1962">            logger.error(&quot;Unknown event source {}!&quot;, event.getSource());</span>
        }
<span class="nc" id="L1964">      } catch (Exception e) {</span>
<span class="nc" id="L1965">        logger.error(&quot;Unable to update event {} comment catalog&quot;, event.getIdentifier(), e);</span>
<span class="nc" id="L1966">      }</span>
<span class="nc" id="L1967">    }));</span>
<span class="nc" id="L1968">  }</span>

  private void updateMediaPackageCommentCatalog(MediaPackage mediaPackage, List&lt;EventComment&gt; comments)
          throws EventCommentException, IOException {
    // Get the comments catalog
<span class="nc" id="L1973">    Catalog[] commentCatalogs = mediaPackage.getCatalogs(MediaPackageElements.COMMENTS);</span>
<span class="nc" id="L1974">    Catalog c = null;</span>
<span class="nc bnc" id="L1975" title="All 2 branches missed.">    if (commentCatalogs.length == 1)</span>
<span class="nc" id="L1976">      c = commentCatalogs[0];</span>

<span class="nc bnc" id="L1978" title="All 2 branches missed.">    if (comments.size() &gt; 0) {</span>
      // If no comments catalog found, create a new one
<span class="nc bnc" id="L1980" title="All 2 branches missed.">      if (c == null) {</span>
<span class="nc" id="L1981">        c = (Catalog) MediaPackageElementBuilderFactory.newInstance().newElementBuilder().newElement(Type.Catalog,</span>
                MediaPackageElements.COMMENTS);
<span class="nc" id="L1983">        c.setIdentifier(UUID.randomUUID().toString());</span>
<span class="nc" id="L1984">        mediaPackage.add(c);</span>
      }

      // Update comments catalog
<span class="nc" id="L1988">      InputStream in = null;</span>
      try {
<span class="nc" id="L1990">        String commentCatalog = EventCommentParser.getAsXml(comments);</span>
<span class="nc" id="L1991">        in = IOUtils.toInputStream(commentCatalog, &quot;UTF-8&quot;);</span>
<span class="nc" id="L1992">        URI uri = workspace.put(mediaPackage.getIdentifier().toString(), c.getIdentifier(), &quot;comments.xml&quot;, in);</span>
<span class="nc" id="L1993">        c.setURI(uri);</span>
        // setting the URI to a new source so the checksum will most like be invalid
<span class="nc" id="L1995">        c.setChecksum(null);</span>
      } finally {
<span class="nc" id="L1997">        IOUtils.closeQuietly(in);</span>
      }
<span class="nc" id="L1999">    } else {</span>
      // Remove comments catalog
<span class="nc bnc" id="L2001" title="All 2 branches missed.">      if (c != null) {</span>
<span class="nc" id="L2002">        mediaPackage.remove(c);</span>
        try {
<span class="nc" id="L2004">          workspace.delete(c.getURI());</span>
<span class="nc" id="L2005">        } catch (NotFoundException e) {</span>
<span class="nc" id="L2006">          logger.warn(&quot;Comments catalog {} not found to delete!&quot;, c.getURI());</span>
<span class="nc" id="L2007">        }</span>
      }
    }
<span class="nc" id="L2010">  }</span>

  /**
   * Checks to see if a given series exists.
   *
   * @param seriesID
   *          The id of the series.
   * @param index
   *          The index to check for the particular series.
   * @throws NotFoundException
   *           Thrown if unable to find the series.
   * @throws IndexServiceException
   *           Thrown if unable to access the index to get the series.
   */
  private void checkSeriesExists(String seriesID, ElasticsearchIndex index)
          throws NotFoundException, IndexServiceException {
    try {
<span class="nc" id="L2027">      Optional&lt;Series&gt; optSeries = index.getSeries(seriesID, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">      if (optSeries.isEmpty())</span>
<span class="nc" id="L2029">        throw new NotFoundException(&quot;Cannot find a series with id &quot; + seriesID);</span>
<span class="nc" id="L2030">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L2031">      throw new IndexServiceException(&quot;Unable to get a series with id: &quot; + seriesID, e);</span>
<span class="nc" id="L2032">    }</span>
<span class="nc" id="L2033">  }</span>

  private MetadataList updateSeriesMetadata(
          final String seriesID,
          final String metadataJSON,
          final ElasticsearchIndex index,
          final MetadataList metadataList)
          throws IllegalArgumentException, IndexServiceException, NotFoundException {
<span class="nc" id="L2041">    checkSeriesExists(seriesID, index);</span>
    try {
<span class="nc" id="L2043">      MetadataJson.fillListFromJson(metadataList, (JSONArray) new JSONParser().parse(metadataJSON));</span>
<span class="nc" id="L2044">    } catch (final org.json.simple.parser.ParseException e) {</span>
<span class="nc" id="L2045">      throw new IllegalArgumentException(&quot;Not able to parse the event metadata: &quot; + metadataJSON, e);</span>
<span class="nc" id="L2046">    }</span>

<span class="nc" id="L2048">    updateSeriesMetadata(seriesID, metadataList);</span>
<span class="nc" id="L2049">    return metadataList;</span>
  }

  /**
   * @return A {@link MetadataList} with all of the available CatalogUIAdapters empty {@link DublinCoreMetadataCollection}
   *         available
   */
  @Override
  public MetadataList getMetadataListWithAllSeriesCatalogUIAdapters() {
<span class="nc" id="L2058">    MetadataList metadataList = new MetadataList();</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">    for (SeriesCatalogUIAdapter adapter : getSeriesCatalogUIAdapters()) {</span>
<span class="nc" id="L2060">      metadataList.add(adapter.getFlavor().toString(), adapter.getUITitle(), adapter.getRawFields());</span>
<span class="nc" id="L2061">    }</span>
<span class="nc" id="L2062">    return metadataList;</span>
  }

  @Override
  public MetadataList getMetadataListWithAllEventCatalogUIAdapters() {
<span class="fc" id="L2067">    MetadataList metadataList = new MetadataList();</span>
<span class="fc bfc" id="L2068" title="All 2 branches covered.">    for (EventCatalogUIAdapter catalogUIAdapter : getEventCatalogUIAdapters()) {</span>
<span class="fc" id="L2069">      metadataList.add(catalogUIAdapter, catalogUIAdapter.getRawFields());</span>
<span class="fc" id="L2070">    }</span>
<span class="fc" id="L2071">    return metadataList;</span>
  }

  /**
   * Checks the list of metadata for updated fields and stores/updates them in the respective metadata catalog.
   *
   * @param seriesId
   *          The series identifier
   * @param metadataList
   *          The metadata list
   */
  private void updateSeriesMetadata(String seriesId, MetadataList metadataList) {
<span class="nc bnc" id="L2083" title="All 2 branches missed.">    for (SeriesCatalogUIAdapter adapter : seriesCatalogUIAdapters) {</span>
<span class="nc" id="L2084">      final DublinCoreMetadataCollection metadata = metadataList.getMetadataByFlavor(adapter.getFlavor().toString());</span>
<span class="nc bnc" id="L2085" title="All 4 branches missed.">      if (metadata != null &amp;&amp; metadata.isUpdated()) {</span>
<span class="nc" id="L2086">        adapter.storeFields(seriesId, metadata);</span>
      }
<span class="nc" id="L2088">    }</span>
<span class="nc" id="L2089">  }</span>

  public boolean isWorkflowActive(String workflowState) {
<span class="nc bnc" id="L2092" title="All 2 branches missed.">    return WorkflowState.INSTANTIATED.toString().equals(workflowState)</span>
<span class="nc bnc" id="L2093" title="All 2 branches missed.">            || WorkflowState.RUNNING.toString().equals(workflowState)</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">            || WorkflowState.PAUSED.toString().equals(workflowState);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>