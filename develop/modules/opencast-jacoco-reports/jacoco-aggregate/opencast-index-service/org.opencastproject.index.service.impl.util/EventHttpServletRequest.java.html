<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EventHttpServletRequest.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-index-service</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.index.service.impl.util</a> &gt; <span class="el_source">EventHttpServletRequest.java</span></div><h1>EventHttpServletRequest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.index.service.impl.util;

import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.index.service.exception.IndexServiceException;
import org.opencastproject.index.service.util.RequestUtils;
import org.opencastproject.ingest.api.IngestException;
import org.opencastproject.ingest.api.IngestService;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.EventCatalogUIAdapter;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.MetadataJson;
import org.opencastproject.metadata.dublincore.MetadataList;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.util.NotFoundException;

import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.lang3.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Optional;
import java.util.TimeZone;

import javax.servlet.http.HttpServletRequest;

<span class="fc" id="L68">public class EventHttpServletRequest {</span>
  /** The logging facility */
<span class="fc" id="L70">  private static final Logger logger = LoggerFactory.getLogger(EventHttpServletRequest.class);</span>

  private static final String ACTION_JSON_KEY = &quot;action&quot;;
  private static final String ALLOW_JSON_KEY = &quot;allow&quot;;
  private static final String METADATA_JSON_KEY = &quot;metadata&quot;;
  private static final String ROLE_JSON_KEY = &quot;role&quot;;

<span class="fc" id="L77">  private Optional&lt;AccessControlList&gt; acl = Optional.empty();</span>
<span class="fc" id="L78">  private Optional&lt;MediaPackage&gt; mediaPackage = Optional.empty();</span>
<span class="fc" id="L79">  private Optional&lt;MetadataList&gt; metadataList = Optional.empty();</span>
<span class="fc" id="L80">  private Optional&lt;JSONObject&gt; processing = Optional.empty();</span>
<span class="fc" id="L81">  private Optional&lt;JSONObject&gt; source = Optional.empty();</span>
<span class="fc" id="L82">  private Optional&lt;JSONObject&gt; scheduling = Optional.empty();</span>

  public void setAcl(AccessControlList acl) {
<span class="fc" id="L85">    this.acl = Optional.of(acl);</span>
<span class="fc" id="L86">  }</span>

  public void setMediaPackage(MediaPackage mediaPackage) {
<span class="fc" id="L89">    this.mediaPackage = Optional.of(mediaPackage);</span>
<span class="fc" id="L90">  }</span>

  public void setMetadataList(MetadataList metadataList) {
<span class="fc" id="L93">    this.metadataList = Optional.of(metadataList);</span>
<span class="fc" id="L94">  }</span>

  public void setProcessing(JSONObject processing) {
<span class="fc" id="L97">    this.processing = Optional.of(processing);</span>
<span class="fc" id="L98">  }</span>

  public void setScheduling(JSONObject scheduling) {
<span class="nc" id="L101">    this.scheduling = Optional.of(scheduling);</span>
<span class="nc" id="L102">  }</span>

  public void setSource(JSONObject source) {
<span class="fc" id="L105">    this.source = Optional.of(source);</span>
<span class="fc" id="L106">  }</span>

  public Optional&lt;AccessControlList&gt; getAcl() {
<span class="fc" id="L109">    return acl;</span>
  }

  public Optional&lt;MediaPackage&gt; getMediaPackage() {
<span class="fc" id="L113">    return mediaPackage;</span>
  }

  public Optional&lt;MetadataList&gt; getMetadataList() {
<span class="fc" id="L117">    return metadataList;</span>
  }

  public Optional&lt;JSONObject&gt; getProcessing() {
<span class="fc" id="L121">    return processing;</span>
  }

  public Optional&lt;JSONObject&gt; getScheduling() {
<span class="fc" id="L125">    return scheduling;</span>
  }

  public Optional&lt;JSONObject&gt; getSource() {
<span class="fc" id="L129">    return source;</span>
  }

  /**
   * Create a {@link EventHttpServletRequest} from a {@link HttpServletRequest} to create a new {@link Event}.
   *
   * @param request
   *          The multipart request that should result in a new {@link Event}
   * @param ingestService
   *          The {@link IngestService} to use to ingest {@link Event} media.
   * @param eventCatalogUIAdapters
   *          The catalog ui adapters to use for getting the event metadata.
   * @param startDatePattern
   *          The pattern to use to parse the start date from the request.
   * @param startTimePattern
   *          The pattern to use to parse the start time from the request.
   * @return An {@link EventHttpServletRequest} populated from the request.
   * @throws IndexServiceException
   *           Thrown if unable to create the event for an internal reason.
   * @throws IllegalArgumentException
   *           Thrown if the multi part request doesn't have the necessary data.
   */
  public static EventHttpServletRequest createFromHttpServletRequest(
          HttpServletRequest request,
          IngestService ingestService,
          List&lt;EventCatalogUIAdapter&gt; eventCatalogUIAdapters,
          String startDatePattern,
          String startTimePattern)
                  throws IndexServiceException {
<span class="nc" id="L158">    EventHttpServletRequest eventHttpServletRequest = new EventHttpServletRequest();</span>
    try {
<span class="nc bnc" id="L160" title="All 2 branches missed.">      if (ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L161">        eventHttpServletRequest.setMediaPackage(ingestService.createMediaPackage());</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (eventHttpServletRequest.getMediaPackage().isEmpty()) {</span>
<span class="nc" id="L163">          throw new IndexServiceException(&quot;Unable to create a new mediapackage to store the new event's media.&quot;);</span>
        }

<span class="nc bnc" id="L166" title="All 2 branches missed.">        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L167">          FileItemStream item = iter.next();</span>
<span class="nc" id="L168">          String fieldName = item.getFieldName();</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">          if (item.isFormField()) {</span>
<span class="nc" id="L170">            setFormField(eventCatalogUIAdapters, eventHttpServletRequest, item, fieldName, startDatePattern, startTimePattern);</span>
          } else {
<span class="nc bnc" id="L172" title="All 2 branches missed.">            if (!item.getName().isBlank()) {</span>
<span class="nc" id="L173">              ingestFile(ingestService, eventHttpServletRequest, item);</span>
            } else {
<span class="nc" id="L175">              logger.debug(&quot;Skipping field {} due to missing filename&quot;, item.getFieldName());</span>
            }
          }
<span class="nc" id="L178">        }</span>
      } else {
<span class="nc" id="L180">        throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
      }

<span class="nc" id="L183">      return eventHttpServletRequest;</span>

<span class="nc" id="L185">    } catch (Exception e) {</span>
<span class="nc" id="L186">      throw new IndexServiceException(&quot;Unable to parse new event.&quot;, e);</span>
    }
  }

  /**
   * Ingest a file from a multi part request for a new event.
   *
   * @param ingestService
   *          The {@link IngestService} to use to ingest the file.
   * @param eventHttpServletRequest
   *          The {@link EventHttpServletRequest} that has the ingest mediapackage.
   * @param item
   *          The representation of the file.
   * @throws MediaPackageException
   *           Thrown if unable to add the track to the mediapackage.
   * @throws IOException
   *           Thrown if unable to upload the file into the mediapackage.
   * @throws IngestException
   *           Thrown if unable to ingest the file.
   */
  private static void ingestFile(IngestService ingestService, EventHttpServletRequest eventHttpServletRequest,
          FileItemStream item) throws MediaPackageException, IOException, IngestException {
<span class="nc" id="L208">    MediaPackage mp = eventHttpServletRequest.getMediaPackage().get();</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">    if (&quot;presenter&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L210">      eventHttpServletRequest.setMediaPackage(</span>
<span class="nc" id="L211">              ingestService.addTrack(item.openStream(), item.getName(), MediaPackageElements.PRESENTER_SOURCE, mp));</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">    } else if (&quot;presentation&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L213">      eventHttpServletRequest.setMediaPackage(</span>
<span class="nc" id="L214">              ingestService.addTrack(item.openStream(), item.getName(), MediaPackageElements.PRESENTATION_SOURCE, mp));</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">    } else if (&quot;audio&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L216">      eventHttpServletRequest.setMediaPackage(ingestService.addTrack(item.openStream(), item.getName(),</span>
              new MediaPackageElementFlavor(&quot;presenter-audio&quot;, &quot;source&quot;), mp));
    } else {
<span class="nc" id="L219">      logger.warn(&quot;Unknown field name found {}&quot;, item.getFieldName());</span>
    }
<span class="nc" id="L221">  }</span>

  /**
   * Set a value for creating a new event from a form field.
   *
   * @param eventCatalogUIAdapters
   *          The list of event catalog ui adapters used for loading the metadata for the new event.
   * @param eventHttpServletRequest
   *          The current details of the request that have been loaded.
   * @param item
   *          The content of the field.
   * @param fieldName
   *          The key of the field.
   * @param startDatePattern
   *          The pattern to use to parse the start date from the request.
   * @param startTimePattern
   *          The pattern to use to parse the start time from the request.
   * @throws IOException
   *           Thrown if unable to laod the content of the field.
   * @throws NotFoundException
   *           Thrown if unable to find a metadata catalog or field that matches an input catalog or field.
   */
  private static void setFormField(List&lt;EventCatalogUIAdapter&gt; eventCatalogUIAdapters,
                                   EventHttpServletRequest eventHttpServletRequest,
                                   FileItemStream item,
                                   String fieldName,
                                   String startDatePattern,
                                   String startTimePattern)
                  throws IOException, NotFoundException {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">    if (METADATA_JSON_KEY.equals(fieldName)) {</span>
<span class="fc" id="L251">      String metadata = Streams.asString(item.openStream());</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">      if (StringUtils.isNotEmpty(metadata)) {</span>
        try {
<span class="fc" id="L254">          MetadataList metadataList = deserializeMetadataList(metadata, eventCatalogUIAdapters, startDatePattern,</span>
                  startTimePattern);
<span class="fc" id="L256">          eventHttpServletRequest.setMetadataList(metadataList);</span>
<span class="nc" id="L257">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L258">          throw e;</span>
<span class="nc" id="L259">        } catch (ParseException e) {</span>
<span class="nc" id="L260">          throw new IllegalArgumentException(String.format(&quot;Unable to parse event metadata because: '%s'&quot;, e.toString()));</span>
<span class="nc" id="L261">        } catch (NotFoundException e) {</span>
<span class="nc" id="L262">          throw e;</span>
<span class="nc" id="L263">        } catch (java.text.ParseException e) {</span>
<span class="nc" id="L264">          throw new IllegalArgumentException(String.format(&quot;Unable to parse event metadata because: '%s'&quot;, e.toString()));</span>
<span class="fc" id="L265">        }</span>
      }
<span class="pc bnc" id="L267" title="All 2 branches missed.">    } else if (&quot;acl&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L268">      String access = Streams.asString(item.openStream());</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">      if (StringUtils.isNotEmpty(access)) {</span>
        try {
<span class="nc" id="L271">          AccessControlList acl = deserializeJsonToAcl(access, true);</span>
<span class="nc" id="L272">          eventHttpServletRequest.setAcl(acl);</span>
<span class="nc" id="L273">        } catch (Exception e) {</span>
<span class="nc" id="L274">          logger.warn(&quot;Unable to parse acl {}&quot;, access);</span>
<span class="nc" id="L275">          throw new IllegalArgumentException(&quot;Unable to parse acl&quot;);</span>
<span class="nc" id="L276">        }</span>
      }
<span class="nc bnc" id="L278" title="All 2 branches missed.">    } else if (&quot;processing&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L279">      String processing = Streams.asString(item.openStream());</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">      if (StringUtils.isNotEmpty(processing)) {</span>
<span class="nc" id="L281">        JSONParser parser = new JSONParser();</span>
        try {
<span class="nc" id="L283">          eventHttpServletRequest.setProcessing((JSONObject) parser.parse(processing));</span>
<span class="nc" id="L284">        } catch (Exception e) {</span>
<span class="nc" id="L285">          logger.warn(&quot;Unable to parse processing configuration {}&quot;, processing);</span>
<span class="nc" id="L286">          throw new IllegalArgumentException(&quot;Unable to parse processing configuration&quot;);</span>
<span class="nc" id="L287">        }</span>
      }
<span class="nc bnc" id="L289" title="All 2 branches missed.">    } else if (&quot;scheduling&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L290">      String scheduling = Streams.asString(item.openStream());</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">      if (StringUtils.isNotEmpty(scheduling)) {</span>
<span class="nc" id="L292">        JSONParser parser = new JSONParser();</span>
        try {
<span class="nc" id="L294">          eventHttpServletRequest.setScheduling((JSONObject) parser.parse(scheduling));</span>
<span class="nc" id="L295">        } catch (Exception e) {</span>
<span class="nc" id="L296">          logger.warn(&quot;Unable to parse scheduling information {}&quot;, scheduling);</span>
<span class="nc" id="L297">          throw new IllegalArgumentException(&quot;Unable to parse scheduling information&quot;);</span>
<span class="nc" id="L298">        }</span>
      }
    }
<span class="fc" id="L301">  }</span>

  /**
   * Load the details of updating an event.
   *
   * @param event
   *          The event to update.
   * @param request
   *          The multipart request that has the data to load the updated event.
   * @param eventCatalogUIAdapters
   *          The list of catalog ui adapters to use to load the event metadata.
   * @param startDatePattern
   *          The pattern to use to parse the start date from the request.
   * @param startTimePattern
   *          The pattern to use to parse the start time from the request.
   * @return The data for the event update
   * @throws IllegalArgumentException
   *           Thrown if the request to update the event is malformed.
   * @throws IndexServiceException
   *           Thrown if something is unable to load the event data.
   * @throws NotFoundException
   *           Thrown if unable to find a metadata catalog or field that matches an input catalog or field.
   */
  public static EventHttpServletRequest updateFromHttpServletRequest(
          Event event,
          HttpServletRequest request,
          List&lt;EventCatalogUIAdapter&gt; eventCatalogUIAdapters,
          String startDatePattern,
          String startTimePattern)
                  throws IllegalArgumentException, IndexServiceException, NotFoundException {
<span class="fc" id="L331">    EventHttpServletRequest eventHttpServletRequest = new EventHttpServletRequest();</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">    if (ServletFileUpload.isMultipartContent(request)) {</span>
      try {
<span class="fc bfc" id="L334" title="All 2 branches covered.">        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="fc" id="L335">          FileItemStream item = iter.next();</span>
<span class="fc" id="L336">          String fieldName = item.getFieldName();</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">          if (item.isFormField()) {</span>
<span class="fc" id="L338">            setFormField(eventCatalogUIAdapters, eventHttpServletRequest, item, fieldName, startDatePattern, startTimePattern);</span>
          }
<span class="fc" id="L340">        }</span>
<span class="nc" id="L341">      } catch (IOException e) {</span>
<span class="nc" id="L342">        throw new IndexServiceException(&quot;Unable to update event&quot;, e);</span>
<span class="nc" id="L343">      } catch (FileUploadException e) {</span>
<span class="nc" id="L344">        throw new IndexServiceException(&quot;Unable to update event&quot;, e);</span>
<span class="fc" id="L345">      }</span>
    } else {
<span class="nc" id="L347">      throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
    }
<span class="fc" id="L349">    return eventHttpServletRequest;</span>
  }

  /**
   * De-serialize an JSON into an {@link AccessControlList}.
   *
   * @param json
   *          The {@link AccessControlList} to serialize.
   * @param assumeAllow
   *          Assume that all entries are allows.
   * @return An {@link AccessControlList} representation of the Json
   * @throws ParseException
   */
  protected static AccessControlList deserializeJsonToAcl(String json, boolean assumeAllow) throws ParseException {
<span class="nc" id="L363">    JSONParser parser = new JSONParser();</span>
<span class="nc" id="L364">    JSONArray aclJson = (JSONArray) parser.parse(json);</span>
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L366">    ListIterator&lt;Object&gt; iterator = aclJson.listIterator();</span>
    JSONObject aceJson;
<span class="nc" id="L368">    List&lt;AccessControlEntry&gt; entries = new ArrayList&lt;AccessControlEntry&gt;();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">    while (iterator.hasNext()) {</span>
<span class="nc" id="L370">      aceJson = (JSONObject) iterator.next();</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">      String action = aceJson.get(ACTION_JSON_KEY) != null ? aceJson.get(ACTION_JSON_KEY).toString() : &quot;&quot;;</span>
      String allow;
<span class="nc bnc" id="L373" title="All 2 branches missed.">      if (assumeAllow) {</span>
<span class="nc" id="L374">        allow = &quot;true&quot;;</span>
      } else {
<span class="nc bnc" id="L376" title="All 2 branches missed.">        allow = aceJson.get(ALLOW_JSON_KEY) != null ? aceJson.get(ALLOW_JSON_KEY).toString() : &quot;&quot;;</span>
      }
<span class="nc bnc" id="L378" title="All 2 branches missed.">      String role = aceJson.get(ROLE_JSON_KEY) != null ? aceJson.get(ROLE_JSON_KEY).toString() : &quot;&quot;;</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">      if (StringUtils.trimToNull(action) != null &amp;&amp; StringUtils.trimToNull(allow) != null</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">              &amp;&amp; StringUtils.trimToNull(role) != null) {</span>
<span class="nc" id="L381">        AccessControlEntry ace = new AccessControlEntry(role, action, Boolean.parseBoolean(allow));</span>
<span class="nc" id="L382">        entries.add(ace);</span>
<span class="nc" id="L383">      } else {</span>
<span class="nc" id="L384">        throw new IllegalArgumentException(String.format(</span>
                &quot;One of the access control elements is missing a property. The action was '%s', allow was '%s' and the role was '%s'&quot;,
                action, allow, role));
      }
<span class="nc" id="L388">    }</span>
<span class="nc" id="L389">    return new AccessControlList(entries);</span>
  }

  /**
   * Change the simplified fields of key values provided to the external api into a {@link MetadataList}.
   *
   * @param json
   *          The json string that contains an array of metadata field lists for the different catalogs.
   * @param startDatePattern
   *          The pattern to use to parse the start date from the json payload.
   * @param startTimePattern
   *          The pattern to use to parse the start time from the json payload.
   * @return A {@link MetadataList} with the fields populated with the values provided.
   * @throws ParseException
   *           Thrown if unable to parse the json string.
   * @throws NotFoundException
   *           Thrown if unable to find the catalog or field that the json refers to.
   */
  protected static MetadataList deserializeMetadataList(
          String json,
          List&lt;EventCatalogUIAdapter&gt; catalogAdapters,
          String startDatePattern,
          String startTimePattern)
          throws ParseException, NotFoundException, java.text.ParseException {
<span class="fc" id="L413">    MetadataList metadataList = new MetadataList();</span>
<span class="fc" id="L414">    JSONParser parser = new JSONParser();</span>
<span class="fc" id="L415">    JSONArray jsonCatalogs = (JSONArray) parser.parse(json);</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">    for (int i = 0; i &lt; jsonCatalogs.size(); i++) {</span>
<span class="fc" id="L417">      JSONObject catalog = (JSONObject) jsonCatalogs.get(i);</span>
<span class="pc bpc" id="L418" title="2 of 4 branches missed.">      if (catalog.get(&quot;flavor&quot;) == null || StringUtils.isBlank(catalog.get(&quot;flavor&quot;).toString())) {</span>
<span class="nc" id="L419">        throw new IllegalArgumentException(</span>
                &quot;Unable to create new event as no flavor was given for one of the metadata collections&quot;);
      }
<span class="fc" id="L422">      String flavorString = catalog.get(&quot;flavor&quot;).toString();</span>
<span class="fc" id="L423">      MediaPackageElementFlavor flavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>

<span class="fc" id="L425">      DublinCoreMetadataCollection collection = null;</span>
<span class="fc" id="L426">      EventCatalogUIAdapter adapter = null;</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">      for (EventCatalogUIAdapter eventCatalogUIAdapter : catalogAdapters) {</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (eventCatalogUIAdapter.getFlavor().equals(flavor)) {</span>
<span class="fc" id="L429">          adapter = eventCatalogUIAdapter;</span>
<span class="fc" id="L430">          collection = eventCatalogUIAdapter.getRawFields();</span>
        }
<span class="fc" id="L432">      }</span>

<span class="pc bpc" id="L434" title="1 of 2 branches missed.">      if (collection == null) {</span>
<span class="nc" id="L435">        throw new IllegalArgumentException(</span>
<span class="nc" id="L436">                String.format(&quot;Unable to find an EventCatalogUIAdapter with Flavor '%s'&quot;, flavorString));</span>
      }

<span class="fc" id="L439">      String fieldsJson = catalog.get(&quot;fields&quot;).toString();</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">      if (StringUtils.trimToNull(fieldsJson) != null) {</span>
<span class="fc" id="L441">        Map&lt;String, String&gt; fields = RequestUtils.getKeyValueMap(fieldsJson);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">        for (String key : fields.keySet()) {</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">          if (&quot;subjects&quot;.equals(key)) {</span>
            // Handle the special case of allowing subjects to be an array.
<span class="fc" id="L445">            MetadataField field = collection.getOutputFields().get(DublinCore.PROPERTY_SUBJECT.getLocalName());</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L447">              throw new NotFoundException(String.format(</span>
                      &quot;Cannot find a metadata field with id 'subject' from Catalog with Flavor '%s'.&quot;, flavorString));
            }
<span class="fc" id="L450">            collection.removeField(field);</span>
            try {
<span class="fc" id="L452">              JSONArray subjects = (JSONArray) parser.parse(fields.get(key));</span>
<span class="fc" id="L453">              collection.addField(MetadataJson</span>
<span class="fc" id="L454">                      .copyWithDifferentJsonValue(field, StringUtils.join(subjects.iterator(), &quot;,&quot;)));</span>
<span class="nc" id="L455">            } catch (ParseException e) {</span>
<span class="nc" id="L456">              throw new IllegalArgumentException(</span>
<span class="nc" id="L457">                      String.format(&quot;Unable to parse the 'subjects' metadata array field because: %s&quot;, e.toString()));</span>
<span class="fc" id="L458">            }</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">          } else if (&quot;startDate&quot;.equals(key)) {</span>
            // Special handling for start date since in API v1 we expect start date and start time to be separate fields.
<span class="fc" id="L461">            MetadataField field = collection.getOutputFields().get(key);</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L463">              throw new NotFoundException(String.format(</span>
                      &quot;Cannot find a metadata field with id '%s' from Catalog with Flavor '%s'.&quot;, key, flavorString));
            }
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">            SimpleDateFormat apiSdf = MetadataField.getSimpleDateFormatter(startDatePattern == null ? field.getPattern() : startDatePattern);</span>
<span class="fc" id="L467">            SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L468">            DateTime newStartDate = new DateTime(apiSdf.parse(fields.get(key)), DateTimeZone.UTC);</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">            if (field.getValue() != null) {</span>
<span class="nc" id="L470">              DateTime oldStartDate = new DateTime(sdf.parse((String) field.getValue()), DateTimeZone.UTC);</span>
<span class="nc" id="L471">              newStartDate = oldStartDate.withDate(newStartDate.year().get(), newStartDate.monthOfYear().get(), newStartDate.dayOfMonth().get());</span>
            }
<span class="fc" id="L473">            collection.removeField(field);</span>
<span class="fc" id="L474">            collection.addField(MetadataJson.copyWithDifferentJsonValue(field, sdf.format(newStartDate.toDate())));</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">          } else if (&quot;startTime&quot;.equals(key)) {</span>
            // Special handling for start time since in API v1 we expect start date and start time to be separate fields.
<span class="fc" id="L477">            MetadataField field = collection.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L479">              throw new NotFoundException(String.format(</span>
                      &quot;Cannot find a metadata field with id '%s' from Catalog with Flavor '%s'.&quot;, &quot;startDate&quot;, flavorString));
            }
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">            SimpleDateFormat apiSdf = MetadataField.getSimpleDateFormatter(startTimePattern == null ? &quot;HH:mm&quot; : startTimePattern);</span>
<span class="fc" id="L483">            SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L484">            DateTime newStartDate = new DateTime(apiSdf.parse(fields.get(key)), DateTimeZone.UTC);</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">            if (field.getValue() != null) {</span>
<span class="fc" id="L486">              DateTime oldStartDate = new DateTime(sdf.parse((String) field.getValue()), DateTimeZone.UTC);</span>
<span class="fc" id="L487">              newStartDate = oldStartDate.withTime(</span>
<span class="fc" id="L488">                      newStartDate.hourOfDay().get(),</span>
<span class="fc" id="L489">                      newStartDate.minuteOfHour().get(),</span>
<span class="fc" id="L490">                      newStartDate.secondOfMinute().get(),</span>
<span class="fc" id="L491">                      newStartDate.millisOfSecond().get());</span>
            }
<span class="fc" id="L493">            collection.removeField(field);</span>
<span class="fc" id="L494">            collection.addField(MetadataJson.copyWithDifferentJsonValue(field, sdf.format(newStartDate.toDate())));</span>
<span class="fc" id="L495">          } else {</span>
<span class="fc" id="L496">            MetadataField field = collection.getOutputFields().get(key);</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L498">              throw new NotFoundException(String.format(</span>
                      &quot;Cannot find a metadata field with id '%s' from Catalog with Flavor '%s'.&quot;, key, flavorString));
            }
<span class="fc" id="L501">            collection.removeField(field);</span>
<span class="fc" id="L502">            collection.addField(MetadataJson.copyWithDifferentJsonValue(field, fields.get(key)));</span>
          }
<span class="fc" id="L504">        }</span>
      }
<span class="fc" id="L506">      metadataList.add(adapter, collection);</span>
    }
<span class="fc" id="L508">    setStartDateAndTimeIfUnset(metadataList);</span>
<span class="fc" id="L509">    return metadataList;</span>
  }

  /**
   * Set the start date and time to the current date &amp; time if it hasn't been set through the api call.
   *
   * @param metadataList
   *          The metadata list created from the json request to create a new event
   */
  private static void setStartDateAndTimeIfUnset(MetadataList metadataList) {
<span class="fc" id="L519">    final DublinCoreMetadataCollection commonEventCollection = metadataList</span>
<span class="fc" id="L520">            .getMetadataByFlavor(MediaPackageElements.EPISODE.toString());</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">    if (commonEventCollection != null) {</span>
<span class="fc" id="L522">      MetadataField startDate = commonEventCollection.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">      if (!startDate.isUpdated()) {</span>
<span class="nc" id="L524">        SimpleDateFormat utcDateFormat = new SimpleDateFormat(startDate.getPattern());</span>
<span class="nc" id="L525">        utcDateFormat.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
<span class="nc" id="L526">        String currentDate = utcDateFormat.format(new DateTime(DateTimeZone.UTC).toDate());</span>
<span class="nc" id="L527">        commonEventCollection.removeField(startDate);</span>
<span class="nc" id="L528">        commonEventCollection.addField(MetadataJson.copyWithDifferentJsonValue(startDate, currentDate));</span>
      }
    }
<span class="fc" id="L531">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>