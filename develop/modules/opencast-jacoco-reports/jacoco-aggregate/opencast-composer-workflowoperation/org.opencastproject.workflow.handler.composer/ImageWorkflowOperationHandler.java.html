<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ImageWorkflowOperationHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-composer-workflowoperation</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.workflow.handler.composer</a> &gt; <span class="el_source">ImageWorkflowOperationHandler.java</span></div><h1>ImageWorkflowOperationHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.workflow.handler.composer;

import static java.lang.String.format;
import static org.opencastproject.util.EqualsUtil.eq;

import org.opencastproject.composer.api.ComposerService;
import org.opencastproject.composer.api.EncodingProfile;
import org.opencastproject.job.api.Job;
import org.opencastproject.job.api.JobBarrier;
import org.opencastproject.job.api.JobContext;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.MediaPackageSupport;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.VideoStream;
import org.opencastproject.mediapackage.selector.TrackSelector;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.util.JobUtil;
import org.opencastproject.util.MimeTypes;
import org.opencastproject.util.UnknownFileTypeException;
import org.opencastproject.util.data.Collections;
import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;
import org.opencastproject.workflow.api.ConfiguredTagsAndFlavors;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowOperationException;
import org.opencastproject.workflow.api.WorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowOperationInstance;
import org.opencastproject.workflow.api.WorkflowOperationResult;
import org.opencastproject.workflow.api.WorkflowOperationResult.Action;
import org.opencastproject.workspace.api.Workspace;

import org.apache.commons.io.FilenameUtils;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.IllegalFormatException;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * The workflow definition for handling &quot;image&quot; operations
 */
@Component(
    immediate = true,
    service = WorkflowOperationHandler.class,
    property = {
        &quot;service.description=Image Workflow Operation Handler&quot;,
        &quot;workflow.operation=image&quot;
    }
)
<span class="fc" id="L86">public class ImageWorkflowOperationHandler extends AbstractWorkflowOperationHandler {</span>
  /** The logging facility */
<span class="fc" id="L88">  private static final Logger logger = LoggerFactory.getLogger(ImageWorkflowOperationHandler.class);</span>

  // legacy option
  public static final String OPT_PROFILES = &quot;encoding-profile&quot;;
  public static final String OPT_POSITIONS = &quot;time&quot;;
  public static final String OPT_TARGET_BASE_NAME_FORMAT_SECOND = &quot;target-base-name-format-second&quot;;
  public static final String OPT_TARGET_BASE_NAME_FORMAT_PERCENT = &quot;target-base-name-format-percent&quot;;
  public static final String OPT_END_MARGIN = &quot;end-margin&quot;;

  private static final long END_MARGIN_DEFAULT = 100;
  public static final double SINGLE_FRAME_POS = 0.0;

  /** The composer service */
<span class="fc" id="L101">  private ComposerService composerService = null;</span>

  /** The local workspace */
<span class="fc" id="L104">  private Workspace workspace = null;</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param composerService
   *          the composer service
   */
  @Reference
  protected void setComposerService(ComposerService composerService) {
<span class="nc" id="L114">    this.composerService = composerService;</span>
<span class="nc" id="L115">  }</span>

  /**
   * Callback for declarative services configuration that will introduce us to the local workspace service.
   * Implementation assumes that the reference is configured as being static.
   *
   * @param workspace
   *          an instance of the workspace
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="nc" id="L126">    this.workspace = workspace;</span>
<span class="nc" id="L127">  }</span>

  @Override
  public WorkflowOperationResult start(final WorkflowInstance wi, JobContext ctx)
          throws WorkflowOperationException {
<span class="nc" id="L132">    logger.debug(&quot;Running image workflow operation on {}&quot;, wi);</span>
    try {
<span class="nc" id="L134">      MediaPackage mp = wi.getMediaPackage();</span>
<span class="nc" id="L135">      final Extractor e = new Extractor(this, configure(mp, wi));</span>
<span class="nc" id="L136">      return e.main(MediaPackageSupport.copy(mp));</span>
<span class="nc" id="L137">    } catch (Exception e) {</span>
<span class="nc" id="L138">      throw new WorkflowOperationException(e);</span>
    }
  }

  /**
   * Computation within the context of a {@link Cfg}.
   */
  static final class Extractor {
    private final ImageWorkflowOperationHandler handler;
    private final Cfg cfg;

<span class="fc" id="L149">    Extractor(ImageWorkflowOperationHandler handler, Cfg cfg) {</span>
<span class="fc" id="L150">      this.handler = handler;</span>
<span class="fc" id="L151">      this.cfg = cfg;</span>
<span class="fc" id="L152">    }</span>

    /** Run the extraction. */
    WorkflowOperationResult main(final MediaPackage mp) throws WorkflowOperationException {
<span class="nc bnc" id="L156" title="All 2 branches missed.">      if (cfg.sourceTracks.size() == 0) {</span>
<span class="nc" id="L157">        logger.info(&quot;No source tracks found in media package {}, skipping operation&quot;, mp.getIdentifier());</span>
<span class="nc" id="L158">        return handler.createResult(mp, Action.SKIP);</span>
      }
      // start image extraction jobs
<span class="nc" id="L161">      final List&lt;Extraction&gt; extractions = cfg.sourceTracks.stream().flatMap(track -&gt; {</span>
<span class="nc" id="L162">          final List&lt;MediaPosition&gt; positions = limit(track, cfg.positions);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">          if (positions.size() != cfg.positions.size()) {</span>
<span class="nc" id="L164">            logger.warn(&quot;Could not apply all configured positions to track {}&quot;, track);</span>
          }
<span class="nc" id="L166">          logger.info(&quot;Extracting images from {} at position {}&quot;, track, positions);</span>
          // create one extraction per encoding profile
<span class="nc" id="L168">          return cfg.profiles.stream()</span>
<span class="nc" id="L169">                  .map(profile -&gt; new Extraction(extractImages(track, profile, positions), track, profile, positions));</span>
<span class="nc" id="L170">        }).collect(Collectors.toList());</span>
<span class="nc" id="L171">      final List&lt;Job&gt; extractionJobs = concatJobs(extractions);</span>
<span class="nc" id="L172">      final JobBarrier.Result extractionResult = JobUtil.waitForJobs(handler.serviceRegistry, extractionJobs);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">      if (extractionResult.isSuccess()) {</span>
        // all extractions were successful; iterate them
<span class="nc bnc" id="L175" title="All 2 branches missed.">        for (final Extraction extraction : extractions) {</span>
<span class="nc" id="L176">          final List&lt;Attachment&gt; images = getImages(extraction.job);</span>
<span class="nc" id="L177">          final int expectedNrOfImages = extraction.positions.size();</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">          if (images.size() == expectedNrOfImages) {</span>
            // post process images
<span class="nc bnc" id="L180" title="All 2 branches missed.">            for (int i = 0; i &lt; images.size(); i++) {</span>
<span class="nc" id="L181">              Attachment image = images.get(i);</span>
<span class="nc" id="L182">              MediaPosition position = extraction.positions.get(i);</span>

<span class="nc" id="L184">              adjustMetadata(extraction, image);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">              if (image.getIdentifier() == null) {</span>
<span class="nc" id="L186">                image.setIdentifier(UUID.randomUUID().toString());</span>
              }
<span class="nc" id="L188">              mp.addDerived(image, extraction.track);</span>
<span class="nc" id="L189">              String fileName = createFileName(</span>
<span class="nc" id="L190">                  extraction.profile.getSuffix(),</span>
<span class="nc" id="L191">                  extraction.track.getURI(),</span>
                  position
              );
<span class="nc" id="L194">              moveToWorkspace(mp, image, fileName);</span>
            }
          } else {
            // less images than expected have been extracted
<span class="nc" id="L198">            throw new WorkflowOperationException(</span>
<span class="nc" id="L199">                    format(&quot;Only %s of %s images have been extracted from track %s&quot;,</span>
<span class="nc" id="L200">                           images.size(), expectedNrOfImages, extraction.track));</span>
          }
<span class="nc" id="L202">        }</span>
<span class="nc" id="L203">        return handler.createResult(mp, Action.CONTINUE, JobUtil.sumQueueTime(extractionJobs));</span>
      } else {
<span class="nc" id="L205">        throw new WorkflowOperationException(&quot;Image extraction failed&quot;);</span>
      }
    }

    /**
     * Adjust flavor, tags, mime type of &lt;code&gt;image&lt;/code&gt; according to the
     * configuration and the extraction.
     */
    void adjustMetadata(Extraction extraction, Attachment image) {
      // Adjust the target flavor. Make sure to account for partial updates
<span class="nc bnc" id="L215" title="All 2 branches missed.">      for (final MediaPackageElementFlavor flavor : cfg.targetImageFlavor) {</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        final String flavorType = eq(&quot;*&quot;, flavor.getType())</span>
<span class="nc" id="L217">                ? extraction.track.getFlavor().getType()</span>
<span class="nc" id="L218">                : flavor.getType();</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        final String flavorSubtype = eq(&quot;*&quot;, flavor.getSubtype())</span>
<span class="nc" id="L220">                ? extraction.track.getFlavor().getSubtype()</span>
<span class="nc" id="L221">                : flavor.getSubtype();</span>
<span class="nc" id="L222">        image.setFlavor(new MediaPackageElementFlavor(flavorType, flavorSubtype));</span>
<span class="nc" id="L223">        logger.debug(&quot;Resulting image has flavor '{}'&quot;, image.getFlavor());</span>
<span class="nc" id="L224">      }</span>
      // Set the mime type
      try {
<span class="nc" id="L227">        image.setMimeType(MimeTypes.fromURI(image.getURI()));</span>
<span class="nc" id="L228">      } catch (UnknownFileTypeException e) {</span>
<span class="nc" id="L229">        logger.warn(&quot;Mime type unknown for file {}. Setting none.&quot;, image.getURI(), e);</span>
<span class="nc" id="L230">      }</span>
      // Add tags
<span class="nc bnc" id="L232" title="All 2 branches missed.">      for (final String tag : cfg.targetImageTags) {</span>
<span class="nc" id="L233">        logger.trace(&quot;Tagging image with '{}'&quot;, tag);</span>
<span class="nc" id="L234">        image.addTag(tag);</span>
<span class="nc" id="L235">      }</span>
<span class="nc" id="L236">    }</span>

    /** Create a file name for the extracted image. */
    String createFileName(final String suffix, final URI trackUri, final MediaPosition pos) {
<span class="fc" id="L240">      final String trackBaseName = FilenameUtils.getBaseName(trackUri.getPath());</span>
      final String format;
<span class="pc bpc" id="L242" title="1 of 3 branches missed.">      switch (pos.type) {</span>
        case Seconds:
<span class="fc" id="L244">          format = cfg.targetBaseNameFormatSecond.orElse(trackBaseName + &quot;_%.3fs%s&quot;);</span>
<span class="fc" id="L245">          break;</span>
        case Percentage:
<span class="fc" id="L247">          format = cfg.targetBaseNameFormatPercent.orElse(trackBaseName + &quot;_%.1fp%s&quot;);</span>
<span class="fc" id="L248">          break;</span>
        default:
<span class="nc" id="L250">          throw new IllegalArgumentException(&quot;Unhandled MediaPosition type: &quot; + pos.type);</span>
      }
<span class="fc" id="L252">      return formatFileName(format, pos.position, suffix);</span>
    }

    /** Move the extracted &lt;code&gt;image&lt;/code&gt; to its final location in the workspace and rename it to &lt;code&gt;fileName&lt;/code&gt;. */
    private void moveToWorkspace(final MediaPackage mp, final Attachment image, final String fileName) {
      try {
<span class="nc" id="L258">        image.setURI(handler.workspace.moveTo(</span>
<span class="nc" id="L259">                image.getURI(),</span>
<span class="nc" id="L260">                mp.getIdentifier().toString(),</span>
<span class="nc" id="L261">                image.getIdentifier(),</span>
                fileName));
<span class="nc" id="L263">      } catch (Exception e) {</span>
<span class="nc" id="L264">        throw new RuntimeException(new WorkflowOperationException(e));</span>
<span class="nc" id="L265">      }</span>
<span class="nc" id="L266">    }</span>

    /** Start a composer job to extract images from a track at the given positions. */
    private Job extractImages(final Track track, final EncodingProfile profile, final List&lt;MediaPosition&gt; positions) {
<span class="nc" id="L270">      List&lt;Double&gt; seconds = positions.stream()</span>
<span class="nc" id="L271">          .map(position -&gt; toSeconds(track, position, cfg.endMargin))</span>
<span class="nc" id="L272">          .collect(Collectors.toList());</span>

      try {
<span class="nc" id="L275">        return handler.composerService.image(track, profile.getIdentifier(), Collections.toDoubleArray(seconds));</span>
<span class="nc" id="L276">      } catch (Exception e) {</span>
<span class="nc" id="L277">        throw new RuntimeException(new WorkflowOperationException(&quot;Error starting image extraction job&quot;, e));</span>
      }
    }
  }

  // ** ** **

  /**
   * Format a filename and make it &quot;safe&quot;.
   */
  static String formatFileName(String format, double position, String suffix) {
<span class="fc" id="L288">    return format(Locale.ROOT, format, position, suffix);</span>
  }


  /** Concat the jobs of a list of extraction objects. */
  private static List&lt;Job&gt; concatJobs(List&lt;Extraction&gt; extractions) {
<span class="nc" id="L294">    return extractions.stream()</span>
<span class="nc" id="L295">        .map(extraction -&gt; extraction.job)</span>
<span class="nc" id="L296">        .collect(Collectors.toList());</span>
  }

  /** Get the images (payload) from a job. */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static List&lt;Attachment&gt; getImages(Job job) {
    final List&lt;Attachment&gt; images;
    try {
<span class="nc" id="L304">      images = (List&lt;Attachment&gt;) MediaPackageElementParser.getArrayFromXml(job.getPayload());</span>
<span class="nc" id="L305">    } catch (MediaPackageException e) {</span>
<span class="nc" id="L306">      throw new RuntimeException(e);</span>
<span class="nc" id="L307">    }</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">    if (!images.isEmpty()) {</span>
<span class="nc" id="L309">      return images;</span>
    } else {
<span class="nc" id="L311">      throw new RuntimeException(new WorkflowOperationException(&quot;Job did not extract any images&quot;));</span>
    }
  }

  /** Limit the list of media positions to those that fit into the length of the track. */
  static List&lt;MediaPosition&gt; limit(Track track, List&lt;MediaPosition&gt; positions) {
<span class="fc" id="L317">    final Long duration = track.getDuration();</span>
    // if the video has just one frame (e.g.: MP3-Podcasts) it makes no sense to go to a certain position
    // as the video has only one image at position 0
<span class="pc bpc" id="L320" title="2 of 4 branches missed.">    if (duration == null || (track.getStreams() != null &amp;&amp; Arrays.stream(track.getStreams())</span>
<span class="nc" id="L321">            .filter(stream -&gt; stream instanceof VideoStream)</span>
<span class="nc" id="L322">            .map(org.opencastproject.mediapackage.Stream::getFrameCount)</span>
<span class="nc bnc" id="L323" title="All 6 branches missed.">            .allMatch(frameCount -&gt; frameCount == null || frameCount == 1))) {</span>
<span class="nc" id="L324">      return java.util.Collections.singletonList(new MediaPosition(PositionType.Seconds, 0));</span>
    }

<span class="fc" id="L327">    return positions.stream()</span>
<span class="fc bfc" id="L328" title="All 6 branches covered.">        .filter(p -&gt; (PositionType.Seconds.equals(p.type) &amp;&amp; p.position &gt;= 0 &amp;&amp; p.position &lt; duration)</span>
<span class="fc bfc" id="L329" title="All 6 branches covered.">                || (PositionType.Percentage.equals(p.type) &amp;&amp; p.position &gt;= 0 &amp;&amp; p.position &lt;= 100))</span>
<span class="fc" id="L330">        .collect(Collectors.toList());</span>
  }

  /**
   * Convert a &lt;code&gt;position&lt;/code&gt; into seconds in relation to the given track.
   * &lt;em&gt;Attention:&lt;/em&gt; The function does not check if the calculated absolute position is within
   * the bounds of the tracks length.
   */
  static double toSeconds(Track track, MediaPosition position, double endMarginMs) {
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">    final long durationMs = track.getDuration() == null ? 0 : track.getDuration();</span>
    final double posMs;
<span class="pc bpc" id="L341" title="1 of 3 branches missed.">    switch (position.type) {</span>
      case Percentage:
<span class="fc" id="L343">        posMs = durationMs * position.position / 100.0;</span>
<span class="fc" id="L344">        break;</span>
      case Seconds:
<span class="fc" id="L346">        posMs = position.position * 1000.0;</span>
<span class="fc" id="L347">        break;</span>
      default:
<span class="nc" id="L349">        throw new IllegalArgumentException(&quot;Unhandled MediaPosition type: &quot; + position.type);</span>
    }
    // limit maximum position to Xms before the end of the video
<span class="fc bfc" id="L352" title="All 2 branches covered.">    return Math.abs(durationMs - posMs) &gt;= endMarginMs</span>
<span class="fc" id="L353">            ? posMs / 1000.0</span>
<span class="fc" id="L354">            : Math.max(0, ((double) durationMs - endMarginMs)) / 1000.0;</span>
  }

  // ** ** **
  /**
   * Fetch a profile from the composer service. Throw a WorkflowOperationException in case the profile
   * does not exist.
   */
  public static Function&lt;String, EncodingProfile&gt; fetchProfile(final ComposerService composerService) {
<span class="nc" id="L363">    return new Function&lt;String, EncodingProfile&gt;() {</span>
      @Override
      public EncodingProfile apply(String profileName) {
<span class="nc" id="L366">        final EncodingProfile profile = composerService.getProfile(profileName);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (profile != null) {</span>
<span class="nc" id="L368">          return profile;</span>
        } else {
<span class="nc" id="L370">          throw new RuntimeException(new WorkflowOperationException(&quot;Encoding profile '&quot; + profileName + &quot;' was not found&quot;));</span>
        }
      }
    };
  }

  /**
   * Describes the extraction of a list of images from a track, extracted after a certain encoding profile.
   * Track -&gt; (profile, positions)
   */
  static final class Extraction {
    /** The extraction job. */
    private final Job job;
    /** The track to extract from. */
    private final Track track;
    /** The encoding profile to use for extraction. */
    private final EncodingProfile profile;
    /** Media positions. */
    private final List&lt;MediaPosition&gt; positions;

<span class="nc" id="L390">    private Extraction(Job job, Track track, EncodingProfile profile, List&lt;MediaPosition&gt; positions) {</span>
<span class="nc" id="L391">      this.job = job;</span>
<span class="nc" id="L392">      this.track = track;</span>
<span class="nc" id="L393">      this.profile = profile;</span>
<span class="nc" id="L394">      this.positions = positions;</span>
<span class="nc" id="L395">    }</span>
  }

  // ** ** **

  /**
   * The WOH's configuration options.
   */
  static final class Cfg {
    /** List of source tracks, with duration. */
    private final List&lt;Track&gt; sourceTracks;
    private final List&lt;MediaPosition&gt; positions;
    private final List&lt;EncodingProfile&gt; profiles;
    private final List&lt;MediaPackageElementFlavor&gt; targetImageFlavor;
    private final List&lt;String&gt; targetImageTags;
    private final Optional&lt;String&gt; targetBaseNameFormatSecond;
    private final Optional&lt;String&gt; targetBaseNameFormatPercent;
    private final long endMargin;

    Cfg(List&lt;Track&gt; sourceTracks,
        List&lt;MediaPosition&gt; positions,
        List&lt;EncodingProfile&gt; profiles,
        List&lt;MediaPackageElementFlavor&gt; targetImageFlavor,
        List&lt;String&gt; targetImageTags,
        Optional&lt;String&gt; targetBaseNameFormatSecond,
        Optional&lt;String&gt; targetBaseNameFormatPercent,
<span class="fc" id="L421">        long endMargin) {</span>
<span class="fc" id="L422">      this.sourceTracks = sourceTracks;</span>
<span class="fc" id="L423">      this.positions = positions;</span>
<span class="fc" id="L424">      this.profiles = profiles;</span>
<span class="fc" id="L425">      this.targetImageFlavor = targetImageFlavor;</span>
<span class="fc" id="L426">      this.targetImageTags = targetImageTags;</span>
<span class="fc" id="L427">      this.endMargin = endMargin;</span>
<span class="fc" id="L428">      this.targetBaseNameFormatSecond = targetBaseNameFormatSecond;</span>
<span class="fc" id="L429">      this.targetBaseNameFormatPercent = targetBaseNameFormatPercent;</span>
<span class="fc" id="L430">    }</span>
  }

  /** Get and parse the configuration options. */
  private Cfg configure(MediaPackage mp, WorkflowInstance wi) throws WorkflowOperationException {
<span class="nc" id="L435">    WorkflowOperationInstance woi = wi.getCurrentOperation();</span>
<span class="nc" id="L436">    ConfiguredTagsAndFlavors tagsAndFlavors = getTagsAndFlavors(wi,</span>
        Configuration.many, Configuration.many, Configuration.many, Configuration.one);
<span class="nc" id="L438">    final List&lt;EncodingProfile&gt; profiles = getOptConfig(woi, OPT_PROFILES)</span>
<span class="nc" id="L439">        .map(configString -&gt; asList(configString))</span>
<span class="nc" id="L440">        .orElseGet(java.util.Collections::emptyList)</span>
<span class="nc" id="L441">        .stream()</span>
<span class="nc" id="L442">        .map(fetchProfile(composerService))</span>
<span class="nc" id="L443">        .collect(Collectors.toList());</span>
<span class="nc" id="L444">    final List&lt;String&gt; targetImageTags = tagsAndFlavors.getTargetTags();</span>
<span class="nc" id="L445">    final List&lt;MediaPackageElementFlavor&gt; targetImageFlavor = tagsAndFlavors.getTargetFlavors();</span>
    final List&lt;Track&gt; sourceTracks;
    {
      // get the source tags
<span class="nc" id="L449">      final List&lt;String&gt; sourceTags = tagsAndFlavors.getSrcTags();</span>
<span class="nc" id="L450">      final List&lt;MediaPackageElementFlavor&gt; sourceFlavors = tagsAndFlavors.getSrcFlavors();</span>
<span class="nc" id="L451">      TrackSelector trackSelector = new TrackSelector();</span>

      //add tags and flavors to TrackSelector
<span class="nc bnc" id="L454" title="All 2 branches missed.">      for (String tag : sourceTags) {</span>
<span class="nc" id="L455">        trackSelector.addTag(tag);</span>
<span class="nc" id="L456">      }</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">      for (MediaPackageElementFlavor flavor : sourceFlavors) {</span>
<span class="nc" id="L458">        trackSelector.addFlavor(flavor);</span>
<span class="nc" id="L459">      }</span>

      // select the tracks based on source flavors and tags and skip those that don't have video
<span class="nc" id="L462">      sourceTracks = trackSelector.select(mp, true).stream()</span>
<span class="nc" id="L463">          .filter(Track::hasVideo)</span>
<span class="nc" id="L464">          .collect(Collectors.toList());</span>
    }
<span class="nc" id="L466">    final List&lt;MediaPosition&gt; positions = MediaPositionParser.parsePositions(getConfig(woi, OPT_POSITIONS));</span>
<span class="nc" id="L467">    final long endMargin = getOptConfig(woi, OPT_END_MARGIN)</span>
<span class="nc" id="L468">        .flatMap(s -&gt; {</span>
          try {
<span class="nc" id="L470">            return Optional.of(Long.parseLong(s));</span>
<span class="nc" id="L471">          } catch (NumberFormatException e) {</span>
<span class="nc" id="L472">            return Optional.empty();</span>
          }
        })
<span class="nc" id="L475">        .orElse(END_MARGIN_DEFAULT);</span>
    //
<span class="nc" id="L477">    return new Cfg(sourceTracks,</span>
                   positions,
                   profiles,
                   targetImageFlavor,
                   targetImageTags,
<span class="nc" id="L482">                   getTargetBaseNameFormat(woi, OPT_TARGET_BASE_NAME_FORMAT_SECOND),</span>
<span class="nc" id="L483">                   getTargetBaseNameFormat(woi, OPT_TARGET_BASE_NAME_FORMAT_PERCENT),</span>
                   endMargin);
  }

  /** Validate a target base name format. */
  private Optional&lt;String&gt; getTargetBaseNameFormat(WorkflowOperationInstance woi, final String formatName) {
<span class="nc" id="L489">    Optional&lt;String&gt; opt = getOptConfig(woi, formatName);</span>
<span class="nc" id="L490">    opt.ifPresent(validateTargetBaseNameFormat(formatName));</span>
<span class="nc" id="L491">    return opt;</span>
  }

  static Consumer&lt;String&gt; validateTargetBaseNameFormat(final String formatName) {
<span class="fc" id="L495">    return format -&gt; {</span>
      boolean valid;
      try {
<span class="fc" id="L498">        final String name = formatFileName(format, 15.11, &quot;.png&quot;);</span>
<span class="pc bpc" id="L499" title="1 of 4 branches missed.">        valid = name.contains(&quot;.&quot;) &amp;&amp; name.contains(&quot;.png&quot;);</span>
<span class="fc" id="L500">      } catch (IllegalFormatException e) {</span>
<span class="fc" id="L501">        valid = false;</span>
<span class="fc" id="L502">      }</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">      if (!valid) {</span>
<span class="fc" id="L504">        throw new RuntimeException(new WorkflowOperationException(String.format(</span>
            &quot;%s is not a valid format string for config option %s&quot;,
            format, formatName)));
      }
<span class="fc" id="L508">    };</span>
  }

  // ** ** **

  /**
   * Parse media position parameter strings.
   */
  public final class MediaPositionParser {
<span class="nc" id="L517">    private MediaPositionParser() { }</span>

    public static List&lt;MediaPosition&gt; parsePositions(String input) throws WorkflowOperationException {
<span class="pc bpc" id="L520" title="1 of 4 branches missed.">      if (input == null || input.trim().isEmpty()) {</span>
<span class="fc" id="L521">        throw new WorkflowOperationException(&quot;Cannot parse empty or blank time string&quot;);</span>
      }

<span class="fc" id="L524">      List&lt;MediaPosition&gt; positions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L525">      String[] tokens = input.trim().split(&quot;[,\\s]+&quot;);</span>

<span class="fc bfc" id="L527" title="All 2 branches covered.">      for (String token : tokens) {</span>
<span class="fc" id="L528">        MediaPosition position = parseToken(token);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (position == null) {</span>
<span class="fc" id="L530">          throw new WorkflowOperationException(&quot;Cannot parse time string: &quot; + input);</span>
        }
<span class="fc" id="L532">        positions.add(position);</span>
      }
<span class="fc" id="L534">      return positions;</span>
    }

    private static MediaPosition parseToken(String token) {
<span class="fc" id="L538">      token = token.trim();</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">      if (token.endsWith(&quot;%&quot;)) {</span>
        try {
<span class="fc" id="L541">          double value = Double.parseDouble(token.substring(0, token.length() - 1));</span>
<span class="fc" id="L542">          return new MediaPosition(PositionType.Percentage, value);</span>
<span class="nc" id="L543">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L544">          return null;</span>
        }
      } else {
        try {
<span class="fc" id="L548">          double value = Double.parseDouble(token);</span>
<span class="fc" id="L549">          return new MediaPosition(PositionType.Seconds, value);</span>
<span class="fc" id="L550">        } catch (NumberFormatException e) {</span>
<span class="fc" id="L551">          return null;</span>
        }
      }
    }
  }

<span class="fc" id="L557">  enum PositionType {</span>
<span class="fc" id="L558">    Percentage, Seconds</span>
  }

  /**
   * A position in time in a media file.
   */
  static final class MediaPosition {
    private double position;
    private final PositionType type;

<span class="fc" id="L568">    MediaPosition(PositionType type, double position) {</span>
<span class="fc" id="L569">      this.position = position;</span>
<span class="fc" id="L570">      this.type = type;</span>
<span class="fc" id="L571">    }</span>

    public void setPosition(double position) {
<span class="nc" id="L574">      this.position = position;</span>
<span class="nc" id="L575">    }</span>

    @Override public int hashCode() {
<span class="nc" id="L578">      return Objects.hash(position, type);</span>
    }

    @Override public boolean equals(Object that) {
<span class="pc bpc" id="L582" title="3 of 6 branches missed.">      return (this == that) || (that instanceof MediaPosition &amp;&amp; eqFields((MediaPosition) that));</span>
    }

    private boolean eqFields(MediaPosition that) {
<span class="pc bpc" id="L586" title="2 of 4 branches missed.">      return position == that.position &amp;&amp; eq(type, that.type);</span>
    }

    @Override public String toString() {
<span class="nc" id="L590">      return format(&quot;MediaPosition(%s, %s)&quot;, type, position);</span>
    }
  }

  @Reference
  @Override
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="nc" id="L597">    super.setServiceRegistry(serviceRegistry);</span>
<span class="nc" id="L598">  }</span>

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>