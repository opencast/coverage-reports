<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EventIndexUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-elasticsearch-index</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.elasticsearch.index.objects.event</a> &gt; <span class="el_source">EventIndexUtils.java</span></div><h1>EventIndexUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.elasticsearch.index.objects.event;

import static org.opencastproject.security.util.SecurityUtil.getEpisodeRoleId;

import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchMetadata;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.impl.SearchMetadataCollection;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.series.Series;
import org.opencastproject.elasticsearch.index.objects.series.SeriesIndexSchema;
import org.opencastproject.elasticsearch.index.objects.series.SeriesSearchQuery;
import org.opencastproject.list.api.ListProviderException;
import org.opencastproject.list.api.ListProvidersService;
import org.opencastproject.list.api.ResourceListQuery;
import org.opencastproject.list.impl.ResourceListQueryImpl;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.EName;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.Publication;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.metadata.dublincore.DCMIPeriod;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.EncodingSchemeUtils;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.Permissions.Action;
import org.opencastproject.security.api.User;
import org.opencastproject.util.DateTimeSupport;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import javax.xml.bind.Unmarshaller;

/**
 * Utility implementation to deal with the conversion of recording events and its corresponding index data structures.
 */
public final class EventIndexUtils {

<span class="fc" id="L81">  private static final Logger logger = LoggerFactory.getLogger(EventIndexUtils.class);</span>

  // The number of attempts to get the series title in case it hasn't been added to the index.
  public static final int DEFAULT_ATTEMPTS = 10;
  // The amount of time in ms to wait before trying to get the series title again.
  public static final long DEFAULT_SLEEP = 100L;

  /**
   * This is a utility class and should therefore not be instantiated.
   */
  private EventIndexUtils() {
  }

  /**
   * Creates a search result item based on the data returned from the search index.
   *
   * @param metadata
   *          the search metadata
   * @param unmarshaller the unmarshaller to use
   * @return the search result item
   * @throws IOException
   *           if unmarshalling fails
   */
  public static Event toRecordingEvent(SearchMetadataCollection metadata, Unmarshaller unmarshaller)
          throws IOException {
<span class="nc" id="L106">    Map&lt;String, SearchMetadata&lt;?&gt;&gt; metadataMap = metadata.toMap();</span>
<span class="nc" id="L107">    String eventJson = (String) metadataMap.get(EventIndexSchema.OBJECT).getValue();</span>
<span class="nc" id="L108">    return Event.valueOf(IOUtils.toInputStream(eventJson, Charset.defaultCharset()), unmarshaller);</span>
  }

  /**
   * Creates search metadata from a recording event such that the event can be stored in the search index.
   *
   * @param event
   *          the recording event
   * @return the set of metadata
   */
  public static SearchMetadataCollection toSearchMetadata(Event event, ListProvidersService listProviderService) {
<span class="nc" id="L119">    SearchMetadataCollection metadata = new SearchMetadataCollection(</span>
<span class="nc" id="L120">            event.getIdentifier().concat(event.getOrganization()), Event.DOCUMENT_TYPE);</span>
<span class="nc" id="L121">    metadata.addField(EventIndexSchema.UID, event.getIdentifier(), false);</span>
<span class="nc" id="L122">    metadata.addField(EventIndexSchema.ORGANIZATION, event.getOrganization(), false);</span>
<span class="nc" id="L123">    metadata.addField(EventIndexSchema.OBJECT, event.toXML(), false);</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getTitle())) {</span>
<span class="nc" id="L125">      metadata.addField(EventIndexSchema.TITLE, event.getTitle(), true);</span>
    }
<span class="nc bnc" id="L127" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getDescription())) {</span>
<span class="nc" id="L128">      metadata.addField(EventIndexSchema.DESCRIPTION, event.getDescription(), true);</span>
    }
<span class="nc bnc" id="L130" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getLocation())) {</span>
<span class="nc" id="L131">      metadata.addField(EventIndexSchema.LOCATION, event.getLocation(), true);</span>
    }
<span class="nc bnc" id="L133" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getSeriesId())) {</span>
<span class="nc" id="L134">      metadata.addField(EventIndexSchema.SERIES_ID, event.getSeriesId(), false);</span>
    }
<span class="nc bnc" id="L136" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getSeriesName())) {</span>
<span class="nc" id="L137">      metadata.addField(EventIndexSchema.SERIES_NAME, event.getSeriesName(), true);</span>
    }
<span class="nc bnc" id="L139" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getLanguage())) {</span>
<span class="nc" id="L140">      metadata.addField(EventIndexSchema.LANGUAGE, event.getLanguage(), false);</span>
    }
<span class="nc bnc" id="L142" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getSubject())) {</span>
<span class="nc" id="L143">      metadata.addField(EventIndexSchema.SUBJECT, event.getSubject(), true);</span>
    }
<span class="nc bnc" id="L145" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getSource())) {</span>
<span class="nc" id="L146">      metadata.addField(EventIndexSchema.SOURCE, event.getSource(), false);</span>
    }
<span class="nc bnc" id="L148" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getCreated())) {</span>
<span class="nc" id="L149">      metadata.addField(EventIndexSchema.CREATED, event.getCreated(), false);</span>
    }
<span class="nc bnc" id="L151" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getCreator())) {</span>
<span class="nc" id="L152">      metadata.addField(EventIndexSchema.CREATOR, event.getCreator(), true);</span>
    }
<span class="nc bnc" id="L154" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getPublisher())) {</span>
<span class="nc" id="L155">      metadata.addField(EventIndexSchema.PUBLISHER, event.getPublisher(), true);</span>
    }
<span class="nc bnc" id="L157" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getLicense())) {</span>
<span class="nc" id="L158">      metadata.addField(EventIndexSchema.LICENSE, event.getLicense(), false);</span>
    }
<span class="nc bnc" id="L160" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getRights())) {</span>
<span class="nc" id="L161">      metadata.addField(EventIndexSchema.RIGHTS, event.getRights(), true);</span>
    }
<span class="nc bnc" id="L163" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getManagedAcl())) {</span>
<span class="nc" id="L164">      metadata.addField(EventIndexSchema.MANAGED_ACL, event.getManagedAcl(), false);</span>
    }
<span class="nc bnc" id="L166" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getWorkflowState())) {</span>
<span class="nc" id="L167">      metadata.addField(EventIndexSchema.WORKFLOW_STATE, event.getWorkflowState(), false);</span>
    }
<span class="nc bnc" id="L169" title="All 2 branches missed.">    if (event.getWorkflowId() != null) {</span>
<span class="nc" id="L170">      metadata.addField(EventIndexSchema.WORKFLOW_ID, event.getWorkflowId(), false);</span>
    }
<span class="nc bnc" id="L172" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getWorkflowDefinitionId())) {</span>
<span class="nc" id="L173">      metadata.addField(EventIndexSchema.WORKFLOW_DEFINITION_ID, event.getWorkflowDefinitionId(), false);</span>
    }
<span class="nc bnc" id="L175" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getRecordingStartDate())) {</span>
<span class="nc" id="L176">      metadata.addField(EventIndexSchema.START_DATE, event.getRecordingStartDate(), false);</span>
    }
<span class="nc bnc" id="L178" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getRecordingEndDate())) {</span>
<span class="nc" id="L179">      metadata.addField(EventIndexSchema.END_DATE, event.getRecordingEndDate(), false);</span>
    }
<span class="nc bnc" id="L181" title="All 2 branches missed.">    if (event.getDuration() != null) {</span>
<span class="nc" id="L182">      metadata.addField(EventIndexSchema.DURATION, event.getDuration(), false);</span>
    }
<span class="nc bnc" id="L184" title="All 2 branches missed.">    if (event.getArchiveVersion() != null) {</span>
<span class="nc" id="L185">      metadata.addField(EventIndexSchema.ARCHIVE_VERSION, event.getArchiveVersion(), false);</span>
    }
<span class="nc bnc" id="L187" title="All 2 branches missed.">    if (event.getRecordingStatus() != null) {</span>
<span class="nc" id="L188">      metadata.addField(EventIndexSchema.RECORDING_STATUS, event.getRecordingStatus(), false);</span>
    }

<span class="nc" id="L191">    metadata.addField(EventIndexSchema.EVENT_STATUS, event.getEventStatus(), false);</span>

<span class="nc" id="L193">    metadata.addField(EventIndexSchema.HAS_COMMENTS, event.hasComments(), false);</span>
<span class="nc" id="L194">    metadata.addField(EventIndexSchema.HAS_OPEN_COMMENTS, event.hasOpenComments(), false);</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">    if (event.comments() != null) {</span>
<span class="nc" id="L197">      List&lt;Comment&gt; comments = event.comments();</span>
<span class="nc" id="L198">      HashMap&lt;String, Object&gt;[] commentsArray = new HashMap[comments.size()];</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">      for (int i = 0; i &lt; comments.size(); i++) {</span>
<span class="nc" id="L200">        Comment comment = comments.get(i);</span>
<span class="nc" id="L201">        HashMap&lt;String, Object&gt; myMap = new HashMap&lt;String, Object&gt;() {{</span>
<span class="nc" id="L202">            put(CommentIndexSchema.ID, comment.getId());</span>
<span class="nc" id="L203">            put(CommentIndexSchema.REASON, comment.getReason());</span>
<span class="nc" id="L204">            put(CommentIndexSchema.TEXT, comment.getText());</span>
<span class="nc" id="L205">            put(CommentIndexSchema.RESOLVED_STATUS, comment.isResolvedStatus());</span>
<span class="nc" id="L206">          }};</span>
<span class="nc" id="L207">        commentsArray[i] = myMap;</span>
//        generatePublicationDoc(comments.get(i).getType());
      }

<span class="nc" id="L211">      metadata.addField(EventIndexSchema.COMMENTS, commentsArray, false);</span>
    }

<span class="nc" id="L214">    metadata.addField(EventIndexSchema.NEEDS_CUTTING, event.needsCutting(), false);</span>

<span class="nc bnc" id="L216" title="All 2 branches missed.">    if (event.getPublications() != null) {</span>
<span class="nc" id="L217">      List&lt;Publication&gt; publications = event.getPublications();</span>
<span class="nc" id="L218">      HashMap&lt;String, Object&gt;[] publicationsArray = new HashMap[publications.size()];</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">      for (int i = 0; i &lt; publications.size(); i++) {</span>
<span class="nc" id="L220">        publicationsArray[i] = generatePublicationDoc(publications.get(i));</span>
      }

<span class="nc bnc" id="L223" title="All 6 branches missed.">      if (publications.size() == 1 &amp;&amp; !publications.get(0).getChannel().equals(&quot;internal&quot;) || publications.size() &gt; 1) {</span>
<span class="nc" id="L224">        metadata.addField(EventIndexSchema.IS_PUBLISHED, true, false);</span>
      } else {
<span class="nc" id="L226">        metadata.addField(EventIndexSchema.IS_PUBLISHED, false, false);</span>
      }

<span class="nc" id="L229">      metadata.addField(EventIndexSchema.PUBLICATION, publicationsArray, false);</span>

    }

<span class="nc bnc" id="L233" title="All 2 branches missed.">    if (event.getPresenters() != null) {</span>
<span class="nc" id="L234">      List&lt;String&gt; presenters = event.getPresenters();</span>
<span class="nc" id="L235">      metadata.addField(EventIndexSchema.PRESENTER, presenters.toArray(new String[presenters.size()]), true);</span>
    }

<span class="nc bnc" id="L238" title="All 2 branches missed.">    if (event.getContributors() != null) {</span>
<span class="nc" id="L239">      List&lt;String&gt; contributors = event.getContributors();</span>
<span class="nc" id="L240">      metadata.addField(EventIndexSchema.CONTRIBUTOR, contributors.toArray(new String[contributors.size()]), true);</span>
    }

<span class="nc bnc" id="L243" title="All 2 branches missed.">    if (!event.getExtendedMetadata().isEmpty()) {</span>
<span class="nc" id="L244">      addExtendedMetadata(metadata, event.getExtendedMetadata());</span>
    }

<span class="nc bnc" id="L247" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getAccessPolicy())) {</span>
<span class="nc" id="L248">      metadata.addField(EventIndexSchema.ACCESS_POLICY, event.getAccessPolicy(), false);</span>
<span class="nc" id="L249">      addAuthorization(metadata, event.getAccessPolicy(), event.getIdentifier(), listProviderService);</span>
    }

<span class="nc bnc" id="L252" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getAgentId())) {</span>
<span class="nc" id="L253">      metadata.addField(EventIndexSchema.AGENT_ID, event.getAgentId(), false);</span>
    }

<span class="nc bnc" id="L256" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getTechnicalStartTime())) {</span>
<span class="nc" id="L257">      metadata.addField(EventIndexSchema.TECHNICAL_START, event.getTechnicalStartTime(), false);</span>
    }

<span class="nc bnc" id="L260" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getTechnicalEndTime())) {</span>
<span class="nc" id="L261">      metadata.addField(EventIndexSchema.TECHNICAL_END, event.getTechnicalEndTime(), false);</span>
    }

<span class="nc bnc" id="L264" title="All 2 branches missed.">    if (event.getTechnicalPresenters() != null) {</span>
<span class="nc" id="L265">      metadata.addField(EventIndexSchema.TECHNICAL_PRESENTERS,</span>
<span class="nc" id="L266">              event.getTechnicalPresenters().toArray(new String[event.getTechnicalPresenters().size()]), false);</span>
    }

<span class="nc" id="L269">    return metadata;</span>
  }

  private static void addObjectStringToMap(HashMap&lt;String, Object&gt; map, String key, Object value) {
<span class="nc bnc" id="L273" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L274">      map.put(key, &quot;&quot;);</span>
    } else {
<span class="nc" id="L276">      map.put(key, value.toString());</span>
    }
<span class="nc" id="L278">  }</span>

  /**
   * Generate the document structure for the publication element
   *
   * @param publication
   *          the source publication element
   * @return a map representing the ES document structure of the publication element
   */
  private static HashMap&lt;String, Object&gt; generatePublicationDoc(Publication publication) {
<span class="nc" id="L288">    HashMap&lt;String, Object&gt; pMap = new HashMap&lt;String, Object&gt;();</span>

    // Add first level elements
<span class="nc" id="L291">    pMap.put(PublicationIndexSchema.CHANNEL, publication.getChannel());</span>
<span class="nc" id="L292">    addObjectStringToMap(pMap, PublicationIndexSchema.MIMETYPE, publication.getMimeType());</span>

    // Attachments
<span class="nc" id="L295">    Attachment[] attachments = publication.getAttachments();</span>
<span class="nc" id="L296">    HashMap&lt;String, Object&gt;[] attachmentsArray = new HashMap[attachments.length];</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">    for (int i = 0; i &lt; attachmentsArray.length; i++) {</span>
<span class="nc" id="L298">      Attachment attachment = attachments[i];</span>
<span class="nc" id="L299">      HashMap&lt;String, Object&gt; element = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L300">      element.put(PublicationIndexSchema.ELEMENT_ID, attachment.getIdentifier());</span>
<span class="nc" id="L301">      addObjectStringToMap(element, PublicationIndexSchema.ELEMENT_MIMETYPE, attachment.getMimeType());</span>
<span class="nc" id="L302">      addObjectStringToMap(element, PublicationIndexSchema.ELEMENT_TYPE, attachment.getElementType());</span>
<span class="nc" id="L303">      element.put(PublicationIndexSchema.ELEMENT_TAG, attachment.getTags());</span>
<span class="nc" id="L304">      addObjectStringToMap(element, PublicationIndexSchema.ELEMENT_URL, attachment.getURI());</span>
<span class="nc" id="L305">      element.put(PublicationIndexSchema.ELEMENT_SIZE, attachment.getSize());</span>
<span class="nc" id="L306">      attachmentsArray[i] = element;</span>
    }
<span class="nc" id="L308">    pMap.put(PublicationIndexSchema.ATTACHMENT, attachmentsArray);</span>

    // Catalogs
<span class="nc" id="L311">    Catalog[] catalogs = publication.getCatalogs();</span>
<span class="nc" id="L312">    HashMap&lt;String, Object&gt;[] catalogsArray = new HashMap[catalogs.length];</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">    for (int i = 0; i &lt; catalogsArray.length; i++) {</span>
<span class="nc" id="L314">      Catalog catalog = catalogs[i];</span>
<span class="nc" id="L315">      HashMap&lt;String, Object&gt; element = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L316">      element.put(PublicationIndexSchema.ELEMENT_ID, catalog.getIdentifier());</span>
<span class="nc" id="L317">      addObjectStringToMap(element, PublicationIndexSchema.ELEMENT_MIMETYPE, catalog.getMimeType());</span>
<span class="nc" id="L318">      addObjectStringToMap(element, PublicationIndexSchema.ELEMENT_TYPE, catalog.getElementType());</span>
<span class="nc" id="L319">      element.put(PublicationIndexSchema.ELEMENT_TAG, catalog.getTags());</span>
<span class="nc" id="L320">      addObjectStringToMap(element, PublicationIndexSchema.ELEMENT_URL, catalog.getURI());</span>
<span class="nc" id="L321">      element.put(PublicationIndexSchema.ELEMENT_SIZE, catalog.getSize());</span>
<span class="nc" id="L322">      catalogsArray[i] = element;</span>
    }
<span class="nc" id="L324">    pMap.put(PublicationIndexSchema.CATALOG, catalogsArray);</span>

    // Tracks
<span class="nc" id="L327">    Track[] tracks = publication.getTracks();</span>
<span class="nc" id="L328">    HashMap&lt;String, Object&gt;[] tracksArray = new HashMap[tracks.length];</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">    for (int i = 0; i &lt; tracksArray.length; i++) {</span>
<span class="nc" id="L330">      Track track = tracks[i];</span>
<span class="nc" id="L331">      HashMap&lt;String, Object&gt; element = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L332">      element.put(PublicationIndexSchema.ELEMENT_ID, track.getIdentifier());</span>
<span class="nc" id="L333">      addObjectStringToMap(element, PublicationIndexSchema.ELEMENT_MIMETYPE, track.getMimeType());</span>
<span class="nc" id="L334">      addObjectStringToMap(element, PublicationIndexSchema.ELEMENT_TYPE, track.getElementType());</span>
<span class="nc" id="L335">      element.put(PublicationIndexSchema.ELEMENT_TAG, track.getTags());</span>
<span class="nc" id="L336">      addObjectStringToMap(element, PublicationIndexSchema.ELEMENT_URL, track.getURI());</span>
<span class="nc" id="L337">      element.put(PublicationIndexSchema.ELEMENT_SIZE, track.getSize());</span>
<span class="nc" id="L338">      element.put(PublicationIndexSchema.TRACK_DURATION, track.getDuration());</span>
<span class="nc" id="L339">      tracksArray[i] = element;</span>
    }
<span class="nc" id="L341">    pMap.put(PublicationIndexSchema.TRACK, tracksArray);</span>

<span class="nc" id="L343">    return pMap;</span>
  }

  /**
   * Adds extended metadata fields to the input document
   *
   * @param doc
   *          the input document
   * @param extendedMetadata
   *          the extended metadata map
   */
  private static void addExtendedMetadata(SearchMetadataCollection doc, Map&lt;String, Map&lt;String,
          List&lt;String&gt;&gt;&gt; extendedMetadata) {
<span class="nc bnc" id="L356" title="All 2 branches missed.">    for (String type: extendedMetadata.keySet()) {</span>
<span class="nc" id="L357">      Map&lt;String, List&lt;String&gt;&gt; extendedMetadataByType = extendedMetadata.get(type);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">      for (String name: extendedMetadataByType.keySet()) {</span>
<span class="nc" id="L359">        List&lt;String&gt; values = extendedMetadataByType.get(name);</span>
<span class="nc" id="L360">        String fieldName = SeriesIndexSchema.EXTENDED_METADATA_PREFIX.concat(type + &quot;_&quot; + name);</span>
<span class="nc" id="L361">        doc.addField(fieldName, values, true);</span>
<span class="nc" id="L362">      }</span>
<span class="nc" id="L363">    }</span>
<span class="nc" id="L364">  }</span>

  /**
   * Adds authorization fields to the input document.
   *
   * @param doc
   *          the input document
   * @param aclString
   *          the access control list string
   */
  private static void addAuthorization(SearchMetadataCollection doc, String aclString,
      String eventId, ListProvidersService listProvidersService) {
<span class="nc" id="L376">    Map&lt;String, List&lt;String&gt;&gt; permissions = new HashMap&lt;&gt;();</span>

    // Define containers for common permissions
<span class="nc bnc" id="L379" title="All 2 branches missed.">    for (Action action : Permissions.Action.values()) {</span>
<span class="nc" id="L380">      permissions.put(action.toString(), new ArrayList&lt;&gt;());</span>
    }

    // Add roles from acl
<span class="nc" id="L384">    AccessControlList acl = AccessControlParser.parseAclSilent(aclString);</span>
<span class="nc" id="L385">    List&lt;AccessControlEntry&gt; entries = acl.getEntries();</span>

    // Add special action roles for episode id roles
<span class="nc" id="L388">    Set&lt;AccessControlEntry&gt; customEntries = new HashSet&lt;&gt;();</span>
<span class="nc" id="L389">    customEntries.add(new AccessControlEntry(getEpisodeRoleId(eventId, &quot;READ&quot;), &quot;read&quot;, true));</span>
<span class="nc" id="L390">    customEntries.add(new AccessControlEntry(getEpisodeRoleId(eventId, &quot;WRITE&quot;), &quot;write&quot;, true));</span>

<span class="nc" id="L392">    ResourceListQuery query = new ResourceListQueryImpl();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">    if (listProvidersService.hasProvider(&quot;ACL.ACTIONS&quot;)) {</span>
<span class="nc" id="L394">      Map&lt;String, String&gt; actions = new HashMap&lt;&gt;();</span>
      try {
<span class="nc" id="L396">        actions = listProvidersService.getList(&quot;ACL.ACTIONS&quot;, query, true);</span>
<span class="nc" id="L397">      } catch (ListProviderException e) {</span>
<span class="nc" id="L398">        logger.error(&quot;Listproviders not loaded. &quot; + e);</span>
<span class="nc" id="L399">      }</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">      for (String action : actions.keySet()) {</span>
<span class="nc" id="L401">        customEntries.add(new AccessControlEntry(getEpisodeRoleId(eventId, action), action, true));</span>
<span class="nc" id="L402">      }</span>
    }

<span class="nc" id="L405">    entries.addAll(customEntries);</span>

    // Convert roles to permission blocks
<span class="nc bnc" id="L408" title="All 2 branches missed.">    for (AccessControlEntry entry : entries) {</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">      if (!entry.isAllow()) {</span>
<span class="nc" id="L410">        logger.info(&quot;Event index does not support denial via ACL, ignoring {}&quot;, entry);</span>
<span class="nc" id="L411">        continue;</span>
      }
<span class="nc" id="L413">      List&lt;String&gt; actionPermissions = permissions.get(entry.getAction());</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">      if (actionPermissions == null) {</span>
<span class="nc" id="L415">        actionPermissions = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L416">        permissions.put(entry.getAction(), actionPermissions);</span>
      }
<span class="nc" id="L418">      actionPermissions.add(entry.getRole());</span>
<span class="nc" id="L419">    }</span>

    // Write the permissions to the input document
<span class="nc bnc" id="L422" title="All 2 branches missed.">    for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : permissions.entrySet()) {</span>
<span class="nc" id="L423">      String fieldName = EventIndexSchema.ACL_PERMISSION_PREFIX.concat(entry.getKey());</span>
<span class="nc" id="L424">      doc.addField(fieldName, entry.getValue(), false);</span>
<span class="nc" id="L425">    }</span>
<span class="nc" id="L426">  }</span>

  /**
   * Update extended metadata for event from dublin core catalog.
   *
   * @param event
   *         The event
   * @param dc
   *         The dublin core catalog with extended metadata
   * @param flavor
   *         The flavor of the extended metadata
   * @return
   *         The updated event
   */
  public static Event updateEventExtendedMetadata(Event event, DublinCoreCatalog dc, MediaPackageElementFlavor flavor) {
<span class="nc" id="L441">    Map&lt;String, List&lt;String&gt;&gt; map = new HashMap();</span>
<span class="nc" id="L442">    Set&lt;EName&gt; eNames = dc.getProperties();</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">    for (EName eName: eNames) {</span>
<span class="nc" id="L444">      String name = eName.getLocalName();</span>
<span class="nc" id="L445">      List&lt;String&gt; values = dc.get(eName, DublinCore.LANGUAGE_ANY);</span>
<span class="nc" id="L446">      map.put(name, values);</span>
<span class="nc" id="L447">    }</span>
<span class="nc" id="L448">    event.setExtendedMetadata(flavor.toString(), map);</span>
<span class="nc" id="L449">    return event;</span>
  }

  /**
   * Update the given {@link Event} with the given {@link DublinCore}.
   *
   * @param event
   *          the event to update
   * @param dc
   *          the catalog with the metadata for the update
   * @return the updated event
   */
  public static Event updateEvent(Event event, DublinCore dc) {
<span class="fc" id="L462">    event.setTitle(dc.getFirst(DublinCore.PROPERTY_TITLE));</span>
<span class="fc" id="L463">    event.setDescription(dc.getFirst(DublinCore.PROPERTY_DESCRIPTION));</span>
<span class="fc" id="L464">    event.setSubject(dc.getFirst(DublinCore.PROPERTY_SUBJECT));</span>
<span class="fc" id="L465">    event.setLocation(dc.getFirst(DublinCore.PROPERTY_SPATIAL));</span>
<span class="fc" id="L466">    event.setLanguage(dc.getFirst(DublinCore.PROPERTY_LANGUAGE));</span>
<span class="fc" id="L467">    event.setSource(dc.getFirst(DublinCore.PROPERTY_SOURCE));</span>
<span class="fc" id="L468">    event.setSeriesId(dc.getFirst(DublinCore.PROPERTY_IS_PART_OF));</span>
<span class="fc" id="L469">    event.setLicense(dc.getFirst(DublinCore.PROPERTY_LICENSE));</span>
<span class="fc" id="L470">    event.setRights(dc.getFirst(DublinCore.PROPERTY_RIGHTS_HOLDER));</span>
<span class="fc" id="L471">    event.setPublisher(dc.getFirst(DublinCore.PROPERTY_PUBLISHER));</span>
    Date created;
<span class="fc" id="L473">    String encodedDate = dc.getFirst(DublinCore.PROPERTY_CREATED);</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">    if (StringUtils.isBlank(encodedDate)) {</span>
<span class="nc" id="L475">      created = new Date();</span>
    } else {
<span class="fc" id="L477">      created = EncodingSchemeUtils.decodeDate(encodedDate);</span>
    }
<span class="fc" id="L479">    event.setCreated(DateTimeSupport.toUTC(created.getTime()));</span>
<span class="fc" id="L480">    String strPeriod = dc.getFirst(DublinCore.PROPERTY_TEMPORAL);</span>
    try {
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(strPeriod)) {</span>
<span class="fc" id="L483">        DCMIPeriod period = EncodingSchemeUtils.decodeMandatoryPeriod(strPeriod);</span>
<span class="fc" id="L484">        event.setRecordingStartDate(DateTimeSupport.toUTC(period.getStart().getTime()));</span>
<span class="fc" id="L485">        event.setRecordingEndDate(DateTimeSupport.toUTC(period.getEnd().getTime()));</span>
<span class="fc" id="L486">        event.setDuration(period.getEnd().getTime() - period.getStart().getTime());</span>
<span class="fc" id="L487">      } else {</span>
<span class="nc" id="L488">        event.setRecordingStartDate(DateTimeSupport.toUTC(created.getTime()));</span>
      }
<span class="nc" id="L490">    } catch (Exception e) {</span>
<span class="nc" id="L491">      logger.warn(&quot;Invalid start and end date/time for event {}: {}&quot;, event.getIdentifier(), strPeriod);</span>
<span class="nc" id="L492">      event.setRecordingStartDate(DateTimeSupport.toUTC(created.getTime()));</span>
<span class="fc" id="L493">    }</span>

<span class="fc" id="L495">    updateTechnicalDate(event);</span>

    // TODO: Add support for language
<span class="fc" id="L498">    event.setContributors(dc.get(DublinCore.PROPERTY_CONTRIBUTOR, DublinCore.LANGUAGE_ANY));</span>
<span class="fc" id="L499">    event.setPresenters(dc.get(DublinCore.PROPERTY_CREATOR, DublinCore.LANGUAGE_ANY));</span>
<span class="fc" id="L500">    return event;</span>
  }

  public static Event updateTechnicalDate(Event event) {
<span class="pc bpc" id="L504" title="3 of 4 branches missed.">    if (event.isScheduledEvent() &amp;&amp; event.hasRecordingStarted()) {</span>
      // Override technical dates from recording if already started
<span class="nc" id="L506">      event.setTechnicalStartTime(event.getRecordingStartDate());</span>
<span class="nc" id="L507">      event.setTechnicalEndTime(event.getRecordingEndDate());</span>
    } else {
      // If this is an upload where the start time is not set, set the start time to same as dublin core
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">      if (StringUtils.isBlank(event.getTechnicalStartTime())) {</span>
<span class="fc" id="L511">        event.setTechnicalStartTime(event.getRecordingStartDate());</span>
      }
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">      if (StringUtils.isBlank(event.getTechnicalEndTime())) {</span>
<span class="fc" id="L514">        event.setTechnicalEndTime(event.getRecordingEndDate());</span>
      }
    }
<span class="fc" id="L517">    return event;</span>
  }

  /**
   * Update the given {@link Event} with the given {@link MediaPackage}.
   *
   * @param event
   *          the event to update
   * @param mp
   *          the mediapackage containing the metadata for the update
   * @return the updated event
   */
  public static Event updateEvent(Event event, MediaPackage mp) {
<span class="nc" id="L530">    event.setPublications(Arrays.asList(mp.getPublications()));</span>
<span class="nc" id="L531">    event.setSeriesName(mp.getSeriesTitle());</span>
<span class="nc" id="L532">    return event;</span>
  }

  /**
   * A function to update the series title within an event. Uses the default number of attempts to get the series title
   * and the default amount of time to sleep between attempts.
   *
   * @param event
   *          The event to update the series name in
   * @param organization
   *          The organization for this event and series
   * @param user
   *          The user
   * @param searchIndex
   *          The index to search for the series
   */
  public static void updateSeriesName(Event event, String organization, User user, ElasticsearchIndex searchIndex)
          throws SearchIndexException {
<span class="fc" id="L550">    updateSeriesName(event, organization, user, searchIndex, DEFAULT_ATTEMPTS, DEFAULT_SLEEP);</span>
<span class="fc" id="L551">  }</span>

  /**
   * A function to update the series title within an event.
   *
   * @param event
   *          The event to update the series name in
   * @param organization
   *          The organization for this event and series
   * @param user
   *          The user
   * @param searchIndex
   *          The index to search for the series
   * @param tries
   *          The number of attempts to try to get the series title
   * @param sleep
   *          The amount of time in ms to sleep between attempts to get the series title.
   */
  public static void updateSeriesName(Event event, String organization, User user, ElasticsearchIndex searchIndex,
          int tries, long sleep) throws SearchIndexException {
<span class="fc bfc" id="L571" title="All 2 branches covered.">    if (event.getSeriesId() != null) {</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">      for (int i = 1; i &lt;= tries; i++) {</span>
<span class="fc" id="L573">        SearchResult&lt;Series&gt; result = searchIndex.getByQuery(</span>
<span class="fc" id="L574">                new SeriesSearchQuery(organization, user).withoutActions().withIdentifier(event.getSeriesId()));</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (result.getHitCount() &gt; 0) {</span>
<span class="fc" id="L576">          event.setSeriesName(result.getItems()[0].getSource().getTitle());</span>
<span class="fc" id="L577">          break;</span>
        } else {
<span class="fc" id="L579">          Integer triesLeft = tries - i;</span>
<span class="fc" id="L580">          logger.debug(&quot;Not able to find the series {} in the search index for the event {}. Will try {} more times.&quot;,</span>
<span class="fc" id="L581">                  event.getSeriesId(), event.getIdentifier(), triesLeft);</span>
          try {
<span class="fc" id="L583">            Thread.sleep(sleep);</span>
<span class="nc" id="L584">          } catch (InterruptedException e) {</span>
<span class="nc" id="L585">            logger.warn(&quot;Interrupted while sleeping before checking for the series being added to the index&quot;, e);</span>
<span class="fc" id="L586">          }</span>
        }

      }
    }
<span class="fc" id="L591">  }</span>

 /**
   * Gets all of the MediaPackageElement's flavors.
   *
   * @param publications
   *          The list of publication elements to get the flavors from.
   * @return An array of {@link String} representation of the MediaPackageElementFlavors
   */
  private static String[] getPublicationFlavors(List&lt;Publication&gt; publications) {
<span class="nc" id="L601">    Set&lt;String&gt; allPublicationFlavors = new TreeSet&lt;String&gt;();</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">    for (Publication p : publications) {</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">      for (Attachment attachment : p.getAttachments()) {</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if (attachment.getFlavor() != null) {</span>
<span class="nc" id="L605">          allPublicationFlavors.add(attachment.getFlavor().toString());</span>
        }
      }
<span class="nc bnc" id="L608" title="All 2 branches missed.">      for (Catalog catalog : p.getCatalogs()) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (catalog.getFlavor() != null) {</span>
<span class="nc" id="L610">          allPublicationFlavors.add(catalog.getFlavor().toString());</span>
        }
      }
<span class="nc bnc" id="L613" title="All 2 branches missed.">      for (Track track : p.getTracks()) {</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (track.getFlavor() != null) {</span>
<span class="nc" id="L615">          allPublicationFlavors.add(track.getFlavor().toString());</span>
        }
      }
<span class="nc" id="L618">    }</span>
<span class="nc" id="L619">    return allPublicationFlavors.toArray(new String[allPublicationFlavors.size()]);</span>
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if the previewSubtype matches any of the publicationFlavors.
   *
   * @param publications
   * @param previewSubtype
   * @return
   */
  public static Boolean subflavorMatches(List&lt;Publication&gt; publications, String previewSubtype) {
<span class="nc" id="L630">    String[] publicationFlavors = getPublicationFlavors(publications);</span>
<span class="nc bnc" id="L631" title="All 4 branches missed.">    if (publicationFlavors != null &amp;&amp; previewSubtype != null) {</span>
<span class="nc" id="L632">      final String subtype = &quot;/&quot; + previewSubtype;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">      for (String flavor : publicationFlavors) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">        if (flavor.endsWith(subtype)) {</span>
<span class="nc" id="L635">          return true;</span>
        }
      }
    }
<span class="nc" id="L639">    return false;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>