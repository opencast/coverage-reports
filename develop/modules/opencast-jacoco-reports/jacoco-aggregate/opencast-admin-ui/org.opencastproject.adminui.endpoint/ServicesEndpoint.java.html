<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ServicesEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-admin-ui</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.adminui.endpoint</a> &gt; <span class="el_source">ServicesEndpoint.java</span></div><h1>ServicesEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.adminui.endpoint;

import static org.opencastproject.index.service.util.JSONUtils.safeString;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;

import org.opencastproject.index.service.resources.list.query.ServicesListQuery;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.serviceregistry.api.HostRegistration;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceState;
import org.opencastproject.serviceregistry.api.ServiceStatistics;
import org.opencastproject.util.SmartIterator;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.util.requests.SortCriterion;
import org.opencastproject.util.requests.SortCriterion.Order;

import com.google.gson.JsonObject;

import org.apache.commons.lang3.StringUtils;
import org.json.simple.JSONAware;
import org.json.simple.JSONObject;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path(&quot;/admin-ng/services&quot;)
@RestService(name = &quot;ServicesProxyService&quot;, title = &quot;UI Services&quot;,
  abstractText = &quot;This service provides the services data for the UI.&quot;,
  notes = { &quot;These Endpoints deliver informations about the services required for the UI.&quot;,
            &quot;&lt;strong&gt;Important:&lt;/strong&gt; &quot;
              + &quot;&lt;em&gt;This service is for exclusive use by the module admin-ui. Its API might change &quot;
              + &quot;anytime without prior notice. Any dependencies other than the admin UI will be strictly ignored. &quot;
              + &quot;DO NOT use this for integration of third-party applications.&lt;em&gt;&quot;})
@Component(
  immediate = true,
  service = ServicesEndpoint.class,
  property = {
    &quot;service.description=Admin UI - Services facade Endpoint&quot;,
    &quot;opencast.service.type=org.opencastproject.adminui.endpoint.ServicesEndpoint&quot;,
    &quot;opencast.service.path=/admin-ng/services&quot;
  }
)
@JaxrsResource
<span class="fc" id="L89">public class ServicesEndpoint {</span>
<span class="fc" id="L90">  private static final Logger logger = LoggerFactory.getLogger(ServicesEndpoint.class);</span>
  private ServiceRegistry serviceRegistry;

  private static final String SERVICE_STATUS_TRANSLATION_PREFIX = &quot;SYSTEMS.SERVICES.STATUS.&quot;;


  @GET
  @Path(&quot;services.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(description = &quot;Returns the list of services&quot;, name = &quot;services&quot;, restParameters = {
          @RestParameter(name = &quot;limit&quot;, description = &quot;The maximum number of items to return per page&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;offset&quot;, description = &quot;The offset&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;filter&quot;, description = &quot;Filter results by name, host, actions, status or free text query&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;sort&quot;, description = &quot;The sort order.  May include any &quot;
                  + &quot;of the following: host, name, running, queued, completed,  meanRunTime, meanQueueTime, &quot;
                  + &quot;status. The sort suffix must be :asc for ascending sort order and :desc for descending.&quot;, isRequired = false, type = STRING)
  }, responses = { @RestResponse(description = &quot;Returns the list of services from Opencast&quot;, responseCode = HttpServletResponse.SC_OK) }, returnDescription = &quot;The list of services&quot;)
  public Response getServices(@QueryParam(&quot;limit&quot;) final int limit, @QueryParam(&quot;offset&quot;) final int offset,
          @QueryParam(&quot;filter&quot;) String filter, @QueryParam(&quot;sort&quot;) String sort) throws Exception {

<span class="fc" id="L110">    Option&lt;String&gt; sortOpt = Option.option(StringUtils.trimToNull(sort));</span>
<span class="fc" id="L111">    ServicesListQuery query = new ServicesListQuery();</span>
<span class="fc" id="L112">    EndpointUtil.addRequestFiltersToQuery(filter, query);</span>

<span class="fc" id="L114">    String fName = null;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">    if (query.getName().isSome())</span>
<span class="fc" id="L116">      fName = StringUtils.trimToNull(query.getName().get());</span>
<span class="fc" id="L117">    String fHostname = null;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">    if (query.getHostname().isSome())</span>
<span class="fc" id="L119">      fHostname = StringUtils.trimToNull(query.getHostname().get());</span>
<span class="fc" id="L120">    String fNodeName = null;</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">    if (query.getNodeName().isSome())</span>
<span class="nc" id="L122">      fNodeName = StringUtils.trimToNull(query.getNodeName().get());</span>
<span class="fc" id="L123">    String fStatus = null;</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">    if (query.getStatus().isSome())</span>
<span class="nc" id="L125">      fStatus = StringUtils.trimToNull(query.getStatus().get());</span>
<span class="fc" id="L126">    String fFreeText = null;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">    if (query.getFreeText().isSome())</span>
<span class="fc" id="L128">      fFreeText = StringUtils.trimToNull(query.getFreeText().get());</span>

<span class="fc" id="L130">    List&lt;HostRegistration&gt; servers = serviceRegistry.getHostRegistrations();</span>
<span class="fc" id="L131">    List&lt;Service&gt; services = new ArrayList&lt;Service&gt;();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">    for (ServiceStatistics stats : serviceRegistry.getServiceStatistics()) {</span>
<span class="fc" id="L133">      Service service = new Service(stats, findServerByHost(stats.getServiceRegistration().getHost(), servers));</span>
<span class="fc bfc" id="L134" title="All 4 branches covered.">      if (fName != null &amp;&amp; !StringUtils.equalsIgnoreCase(service.getName(), fName))</span>
<span class="fc" id="L135">        continue;</span>

<span class="fc bfc" id="L137" title="All 4 branches covered.">      if (fHostname != null &amp;&amp; !StringUtils.equalsIgnoreCase(service.getHost(), fHostname))</span>
<span class="fc" id="L138">        continue;</span>

<span class="pc bpc" id="L140" title="3 of 4 branches missed.">      if (fNodeName != null &amp;&amp; !StringUtils.equalsIgnoreCase(service.getNodeName(), fNodeName))</span>
<span class="nc" id="L141">        continue;</span>

<span class="pc bpc" id="L143" title="3 of 4 branches missed.">      if (fStatus != null &amp;&amp; !StringUtils.equalsIgnoreCase(service.getStatus().toString(), fStatus))</span>
<span class="nc" id="L144">        continue;</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">      if (query.getActions().isSome()) {</span>
<span class="fc" id="L147">        ServiceState serviceState = service.getStatus();</span>

<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (query.getActions().get()) {</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">          if (ServiceState.NORMAL == serviceState)</span>
<span class="fc" id="L151">            continue;</span>
        } else {
<span class="fc bfc" id="L153" title="All 2 branches covered.">          if (ServiceState.NORMAL != serviceState)</span>
<span class="fc" id="L154">            continue;</span>
        }
      }

<span class="fc bfc" id="L158" title="All 4 branches covered.">      if (fFreeText != null &amp;&amp; !StringUtils.containsIgnoreCase(service.getName(), fFreeText)</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">                &amp;&amp; !StringUtils.containsIgnoreCase(service.getHost(), fFreeText)</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">                &amp;&amp; !StringUtils.containsIgnoreCase(service.getNodeName(), fFreeText)</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">                &amp;&amp; !StringUtils.containsIgnoreCase(service.getStatus().toString(), fFreeText))</span>
<span class="fc" id="L162">        continue;</span>

<span class="fc" id="L164">      services.add(service);</span>
<span class="fc" id="L165">    }</span>
<span class="fc" id="L166">    int total = services.size();</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">    if (sortOpt.isSome()) {</span>
<span class="fc" id="L169">      ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(sortOpt.get());</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">      if (!sortCriteria.isEmpty()) {</span>
        try {
<span class="fc" id="L172">          SortCriterion sortCriterion = sortCriteria.iterator().next();</span>
<span class="fc" id="L173">          Collections.sort(services, new ServiceStatisticsComparator(</span>
<span class="fc" id="L174">                  sortCriterion.getFieldName(),</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">                  sortCriterion.getOrder() == Order.Ascending));</span>
<span class="nc" id="L176">        } catch (Exception ex) {</span>
<span class="nc" id="L177">          logger.warn(&quot;Failed to sort services collection.&quot;, ex);</span>
<span class="fc" id="L178">        }</span>
      }
    }

<span class="fc" id="L182">    List&lt;JsonObject&gt; jsonList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L183">    List&lt;Service&gt; limitedServices = new SmartIterator&lt;Service&gt;(limit, offset).applyLimitAndOffset(services);</span>

<span class="fc bfc" id="L185" title="All 2 branches covered.">    for (Service s : limitedServices) {</span>
<span class="fc" id="L186">      jsonList.add(s.toJSON());</span>
<span class="fc" id="L187">    }</span>

<span class="fc" id="L189">    return RestUtils.okJsonList(jsonList, offset, limit, total);</span>
  }

  /**
   * Service UI model. Wrapper class for a {@code ServiceStatistics} class.
   */
  class Service implements JSONAware {
    /** Completed model field name. */
    public static final String COMPLETED_NAME = &quot;completed&quot;;
    /** Host model field name. */
    public static final String HOST_NAME = &quot;hostname&quot;;
    /** Node name model field name. */
    public static final String NODE_NAME = &quot;nodeName&quot;;
    /** MeanQueueTime model field name. */
    public static final String MEAN_QUEUE_TIME_NAME = &quot;meanQueueTime&quot;;
    /** MeanRunTime model field name. */
    public static final String MEAN_RUN_TIME_NAME = &quot;meanRunTime&quot;;
    /** (Service-) Name model field name. */
    public static final String NAME_NAME = &quot;name&quot;;
    /** Queued model field name. */
    public static final String QUEUED_NAME = &quot;queued&quot;;
    /** Running model field name. */
    public static final String RUNNING_NAME = &quot;running&quot;;
    /** Status model field name. */
    public static final String STATUS_NAME = &quot;status&quot;;
    /** Online model field name. */
    public static final String ONLINE_NAME = &quot;online&quot;;
    /** Maintenance model field name. */
    public static final String MAINTENANCE_NAME = &quot;maintenance&quot;;

    /** Wrapped {@code ServiceStatistics} instance. */
    private final ServiceStatistics serviceStatistics;

    private final Optional&lt;HostRegistration&gt; server;

    /** Constructor, set {@code ServiceStatistics} instance to a final private property. */
<span class="fc" id="L225">    Service(ServiceStatistics serviceStatistics, Optional&lt;HostRegistration&gt; server) {</span>
<span class="fc" id="L226">      this.serviceStatistics = serviceStatistics;</span>
<span class="fc" id="L227">      this.server = server;</span>
<span class="fc" id="L228">    }</span>

    /**
     * Returns completed jobs count.
     * @return completed jobs count
     */
    public int getCompletedJobs() {
<span class="fc" id="L235">      return serviceStatistics.getFinishedJobs();</span>
    }

    /**
     * Returns service host name.
     * @return service host name
     */
    public String getHost() {
<span class="fc" id="L243">      return serviceStatistics.getServiceRegistration().getHost();</span>
    }

    /**
     * Returns service host name.
     * @return service host name
     */
    public String getNodeName() {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">      return server.isPresent() ? server.get().getNodeName() : &quot;&quot;;</span>
    }

    /**
     * Returns service mean queue time in seconds.
     * @return service mean queue time in seconds
     */
    public long getMeanQueueTime() {
<span class="fc" id="L259">      return TimeUnit.MILLISECONDS.toSeconds(serviceStatistics.getMeanQueueTime());</span>
    }

    /**
     * Returns service mean run time in seconds.
     * @return service mean run time in seconds
     */
    public long getMeanRunTime() {
<span class="fc" id="L267">      return TimeUnit.MILLISECONDS.toSeconds(serviceStatistics.getMeanRunTime());</span>
    }

    /**
     * Returns service name.
     * @return service name
     */
    public String getName() {
<span class="fc" id="L275">      return serviceStatistics.getServiceRegistration().getServiceType();</span>
    }

    /**
     * Returns queued jobs count.
     * @return queued jobs count
     */
    public int getQueuedJobs() {
<span class="fc" id="L283">      return serviceStatistics.getQueuedJobs();</span>
    }

    /**
     * Returns running jobs count.
     * @return running jobs count
     */
    public int getRunningJobs() {
<span class="fc" id="L291">      return serviceStatistics.getRunningJobs();</span>
    }

    /**
     * Returns service status.
     * @return service status
     */
    public ServiceState getStatus() {
<span class="fc" id="L299">      return serviceStatistics.getServiceRegistration().getServiceState();</span>
    }

    /**
     * Returns whether the service is online.
     * @return online status
     */
    public boolean getIsOnline() {
<span class="fc" id="L307">      return serviceStatistics.getServiceRegistration().isOnline();</span>
    }

    /**
     * Returns whether the service is in maintenance.
     * @return maintenance status
     */
    public boolean getisMaintenance() {
<span class="fc" id="L315">      return serviceStatistics.getServiceRegistration().isInMaintenanceMode();</span>
    }

    /**
     * Returns a map of all service fields.
     * @return a map of all service fields
     */
    public Map&lt;String, String&gt; toMap() {
<span class="nc" id="L323">      Map&lt;String, String&gt; serviceMap = new HashMap&lt;String, String&gt;();</span>
<span class="nc" id="L324">      serviceMap.put(COMPLETED_NAME, Integer.toString(getCompletedJobs()));</span>
<span class="nc" id="L325">      serviceMap.put(HOST_NAME, getHost());</span>
<span class="nc" id="L326">      serviceMap.put(NODE_NAME, getNodeName());</span>
<span class="nc" id="L327">      serviceMap.put(MEAN_QUEUE_TIME_NAME, Long.toString(getMeanQueueTime()));</span>
<span class="nc" id="L328">      serviceMap.put(MEAN_RUN_TIME_NAME, Long.toString(getMeanRunTime()));</span>
<span class="nc" id="L329">      serviceMap.put(NAME_NAME, getName());</span>
<span class="nc" id="L330">      serviceMap.put(QUEUED_NAME, Integer.toString(getQueuedJobs()));</span>
<span class="nc" id="L331">      serviceMap.put(RUNNING_NAME, Integer.toString(getRunningJobs()));</span>
<span class="nc" id="L332">      serviceMap.put(STATUS_NAME, getStatus().name());</span>
<span class="nc" id="L333">      serviceMap.put(ONLINE_NAME, Boolean.toString(getIsOnline()));</span>
<span class="nc" id="L334">      serviceMap.put(MAINTENANCE_NAME, Boolean.toString(getisMaintenance()));</span>
<span class="nc" id="L335">      return serviceMap;</span>
    }

    /**
     * Returns a json representation of a service as {@code String}.
     * @return a json representation of a service as {@code String}
     */
    @Override
    public String toJSONString() {
<span class="nc" id="L344">      return JSONObject.toJSONString(toMap());</span>
    }

    /**
     * Returns a json representation of a service as {@code JValue}.
     * @return a json representation of a service as {@code JValue}
     */
    public JsonObject toJSON() {
<span class="fc" id="L352">      JsonObject json = new JsonObject();</span>
<span class="fc" id="L353">      json.addProperty(COMPLETED_NAME, getCompletedJobs());</span>
<span class="fc" id="L354">      json.addProperty(HOST_NAME, safeString(getHost()));</span>
<span class="fc" id="L355">      json.addProperty(NODE_NAME, safeString(getNodeName()));</span>
<span class="fc" id="L356">      json.addProperty(MEAN_QUEUE_TIME_NAME, getMeanQueueTime());</span>
<span class="fc" id="L357">      json.addProperty(MEAN_RUN_TIME_NAME, getMeanRunTime());</span>
<span class="fc" id="L358">      json.addProperty(NAME_NAME, safeString(getName()));</span>
<span class="fc" id="L359">      json.addProperty(QUEUED_NAME, getQueuedJobs());</span>
<span class="fc" id="L360">      json.addProperty(RUNNING_NAME, getRunningJobs());</span>
<span class="fc" id="L361">      json.addProperty(STATUS_NAME, SERVICE_STATUS_TRANSLATION_PREFIX + getStatus().name());</span>
<span class="fc" id="L362">      json.addProperty(ONLINE_NAME, getIsOnline());</span>
<span class="fc" id="L363">      json.addProperty(MAINTENANCE_NAME, getisMaintenance());</span>
<span class="fc" id="L364">      return json;</span>
    }
  }

  /**
   * {@code Service} comparator. Can compare service instances based on the given sort criterion and sort order.
   */
  class ServiceStatisticsComparator implements Comparator&lt;Service&gt; {

    /** Sort criterion. */
    private final String sortBy;
    /** Sort order (true if ascending, false otherwise). */
    private final boolean ascending;

    /** Constructor. */
<span class="fc" id="L379">    ServiceStatisticsComparator(String sortBy, boolean ascending) {</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">      if (StringUtils.equalsIgnoreCase(Service.COMPLETED_NAME, sortBy)) {</span>
<span class="fc" id="L381">        this.sortBy = Service.COMPLETED_NAME;</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.HOST_NAME, sortBy)) {</span>
<span class="fc" id="L383">        this.sortBy = Service.HOST_NAME;</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">      } else if (StringUtils.equalsIgnoreCase(Service.NODE_NAME, sortBy)) {</span>
<span class="nc" id="L385">        this.sortBy = Service.NODE_NAME;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.MEAN_QUEUE_TIME_NAME, sortBy)) {</span>
<span class="fc" id="L387">        this.sortBy = Service.MEAN_QUEUE_TIME_NAME;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.MEAN_RUN_TIME_NAME, sortBy)) {</span>
<span class="fc" id="L389">        this.sortBy = Service.MEAN_RUN_TIME_NAME;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.NAME_NAME, sortBy)) {</span>
<span class="fc" id="L391">        this.sortBy = Service.NAME_NAME;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.QUEUED_NAME, sortBy)) {</span>
<span class="fc" id="L393">        this.sortBy = Service.QUEUED_NAME;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.RUNNING_NAME, sortBy)) {</span>
<span class="fc" id="L395">        this.sortBy = Service.RUNNING_NAME;</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">      } else if (StringUtils.equalsIgnoreCase(Service.STATUS_NAME, sortBy)) {</span>
<span class="fc" id="L397">        this.sortBy = Service.STATUS_NAME;</span>
      } else {
<span class="nc" id="L399">        throw new IllegalArgumentException(String.format(&quot;Can't sort services by %s.&quot;, sortBy));</span>
      }
<span class="fc" id="L401">      this.ascending = ascending;</span>
<span class="fc" id="L402">    }</span>

    /**
     * Compare two service instances.
     * @param s1 first {@code Service} instance to compare
     * @param s2 second {@code Service} instance to compare
     * @return
     */
    @Override
    public int compare(Service s1, Service s2) {
<span class="fc" id="L412">      int result = 0;</span>
<span class="pc bpc" id="L413" title="1 of 9 branches missed.">      switch (sortBy) {</span>
        case Service.COMPLETED_NAME:
<span class="fc" id="L415">          result = s1.getCompletedJobs() - s2.getCompletedJobs();</span>
<span class="fc" id="L416">          break;</span>
        case Service.HOST_NAME:
<span class="fc" id="L418">          result = s1.getHost().compareToIgnoreCase(s2.getHost());</span>
<span class="fc" id="L419">          break;</span>
        case Service.NODE_NAME:
<span class="nc" id="L421">          result = s1.getNodeName().compareToIgnoreCase(s2.getNodeName());</span>
<span class="nc" id="L422">          break;</span>
        case Service.MEAN_QUEUE_TIME_NAME:
<span class="fc" id="L424">          result = (int) (s1.getMeanQueueTime() - s2.getMeanQueueTime());</span>
<span class="fc" id="L425">          break;</span>
        case Service.MEAN_RUN_TIME_NAME:
<span class="fc" id="L427">          result = (int) (s1.getMeanRunTime() - s2.getMeanRunTime());</span>
<span class="fc" id="L428">          break;</span>
        case Service.QUEUED_NAME:
<span class="fc" id="L430">          result = s1.getQueuedJobs() - s2.getQueuedJobs();</span>
<span class="fc" id="L431">          break;</span>
        case Service.RUNNING_NAME:
<span class="fc" id="L433">          result = s1.getRunningJobs() - s2.getRunningJobs();</span>
<span class="fc" id="L434">          break;</span>
        case Service.STATUS_NAME:
<span class="fc" id="L436">          result = s1.getStatus().compareTo(s2.getStatus());</span>
<span class="fc" id="L437">          break;</span>
        case Service.NAME_NAME: // default sorting criterium
        default:
<span class="fc" id="L440">          result = s1.getName().compareToIgnoreCase(s2.getName());</span>
      }
<span class="fc bfc" id="L442" title="All 2 branches covered.">      return ascending ? result : 0 - result;</span>
    }
  }

  /** OSGI activate method. */
  @Activate
  public void activate() {
<span class="fc" id="L449">    logger.info(&quot;ServicesEndpoint is activated!&quot;);</span>
<span class="fc" id="L450">  }</span>

  /**
   * @param serviceRegistry
   *          the serviceRegistry to set
   */
  @Reference
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L458">    this.serviceRegistry = serviceRegistry;</span>
<span class="fc" id="L459">  }</span>

  /**
   * @param hostname of server to find in list
   * @param servers, list of known servers
   */
  private Optional&lt;HostRegistration&gt; findServerByHost(String hostname, List&lt;HostRegistration&gt; servers) {
<span class="fc" id="L466">    return servers.stream().filter(o -&gt; o.getBaseUrl().equals(hostname)).findFirst();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>