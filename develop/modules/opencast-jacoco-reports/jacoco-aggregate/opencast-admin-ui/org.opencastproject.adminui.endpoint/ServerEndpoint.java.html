<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ServerEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-admin-ui</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.adminui.endpoint</a> &gt; <span class="el_source">ServerEndpoint.java</span></div><h1>ServerEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.adminui.endpoint;

import static org.opencastproject.util.doc.rest.RestParameter.Type.INTEGER;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;

import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.serviceregistry.api.HostRegistration;
import org.opencastproject.serviceregistry.api.HostStatistics;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.util.requests.SortCriterion;
import org.opencastproject.util.requests.SortCriterion.Order;

import com.google.gson.Gson;

import org.apache.commons.lang3.StringUtils;
import org.osgi.framework.BundleContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path(&quot;/admin-ng/server&quot;)
@RestService(name = &quot;ServerProxyService&quot;, title = &quot;UI Servers&quot;,
  abstractText = &quot;This service provides the server data for the UI.&quot;,
  notes = { &quot;These Endpoints deliver informations about the server required for the UI.&quot;,
            &quot;&lt;strong&gt;Important:&lt;/strong&gt; &quot;
              + &quot;&lt;em&gt;This service is for exclusive use by the module admin-ui. Its API might change &quot;
              + &quot;anytime without prior notice. Any dependencies other than the admin UI will be strictly ignored. &quot;
              + &quot;DO NOT use this for integration of third-party applications.&lt;em&gt;&quot;})
@Component(
  immediate = true,
  service = ServerEndpoint.class,
  property = {
    &quot;service.description=Admin UI - Server facade Endpoint&quot;,
    &quot;opencast.service.type=org.opencastproject.adminui.endpoint.ServerEndpoint&quot;,
    &quot;opencast.service.path=/admin-ng/server&quot;
  }
)
@JaxrsResource
<span class="fc" id="L89">public class ServerEndpoint {</span>

<span class="fc" id="L91">  private static final Gson gson = new Gson();</span>

<span class="fc" id="L93">  private enum Sort {</span>
<span class="fc" id="L94">    CORES, HOSTNAME, MAINTENANCE, NODENAME, ONLINE, QUEUED, RUNNING</span>
  }

<span class="fc" id="L97">  private enum Status {</span>
<span class="fc" id="L98">    ONLINE, OFFLINE, MAINTENANCE</span>
  }

  // List of filter keys
  private static final String KEY_HOSTNAME = &quot;hostname&quot;;
  private static final String KEY_NODE_NAME = &quot;nodeName&quot;;
  private static final String KEY_STATUS = &quot;status&quot;;
  private static final String KEY_TEXT_FILTER = &quot;textFilter&quot;;

  /** Cache time */
  private static final long CACHE_SECONDS = 60;

  /**
   * Comparator for the servers list
   */
  private class ServerComparator implements Comparator&lt;Server&gt; {

    private final Sort sortType;
    private final boolean ascending;

<span class="fc" id="L118">    ServerComparator(Sort sortType, Boolean ascending) {</span>
<span class="fc" id="L119">      this.sortType = sortType;</span>
<span class="fc" id="L120">      this.ascending = ascending;</span>
<span class="fc" id="L121">    }</span>

    @Override
    public int compare(Server host1, Server host2) {
<span class="fc bfc" id="L125" title="All 2 branches covered.">      return (ascending ? 1 : -1) * compareByType(host1, host2);</span>
    }

    private int compareByType(final Server host1, final Server host2) {
<span class="pc bpc" id="L129" title="4 of 7 branches missed.">      switch (sortType) {</span>
        case ONLINE:
<span class="fc" id="L131">          return Boolean.compare(host1.online, host2.online);</span>
        case CORES:
<span class="fc" id="L133">          return Long.compare(host1.cores, host2.cores);</span>
        case QUEUED:
<span class="nc" id="L135">          return Long.compare(host1.queued, host2.queued);</span>
        case MAINTENANCE:
<span class="nc" id="L137">          return Boolean.compare(host1.maintenance, host2.maintenance);</span>
        case RUNNING:
<span class="nc" id="L139">          return Long.compare(host1.running, host2.running);</span>
        case NODENAME:
<span class="nc" id="L141">          return host1.nodeName.compareTo(host2.nodeName);</span>
        case HOSTNAME:
        default:
<span class="fc" id="L144">          return host1.hostname.compareTo(host2.hostname);</span>
      }
    }
  }

<span class="fc" id="L149">  private class Server {</span>
    protected long id;
    protected boolean online;
    protected boolean maintenance;
    protected String hostname;
    protected String nodeName;
    protected long cores;
    protected long running;
    protected long queued;
  }

<span class="fc" id="L160">  private class CachedServer {</span>
    protected long running;
    protected long queued;
  }

<span class="fc" id="L165">  private static final Logger logger = LoggerFactory.getLogger(ServerEndpoint.class);</span>

  private ServiceRegistry serviceRegistry;

<span class="fc" id="L169">  private long lastUpdated = 0;</span>
<span class="fc" id="L170">  private final Map&lt;Long, CachedServer&gt; cachedServerData = new HashMap&lt;&gt;();</span>

  /** OSGi callback for the service registry. */
  @Reference
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L175">    this.serviceRegistry = serviceRegistry;</span>
<span class="fc" id="L176">  }</span>

  @Activate
  protected void activate(BundleContext bundleContext) {
<span class="fc" id="L180">    logger.info(&quot;Activate job endpoint&quot;);</span>
<span class="fc" id="L181">  }</span>

  @GET
  @Path(&quot;servers.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(description = &quot;Returns the list of servers&quot;, name = &quot;servers&quot;, restParameters = {
          @RestParameter(name = &quot;limit&quot;, description = &quot;The maximum number of items to return per page&quot;, isRequired = false, type = INTEGER),
          @RestParameter(name = &quot;offset&quot;, description = &quot;The offset&quot;, isRequired = false, type = INTEGER),
          @RestParameter(name = &quot;filter&quot;, description = &quot;Filter results by hostname, status or free text query&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;sort&quot;, description = &quot;The sort order.  May include any of the following: &quot;
                  + &quot;CORES, HOSTNAME, MAINTENANCE, ONLINE, QUEUED (jobs), RUNNING (jobs).&quot;
                  + &quot;The suffix must be :ASC for ascending or :DESC for descending sort order (e.g. HOSTNAME:DESC).&quot;, isRequired = false, type = STRING) },
          responses = { @RestResponse(description = &quot;Returns the list of jobs from Opencast&quot;, responseCode = HttpServletResponse.SC_OK) },
          returnDescription = &quot;The list of servers&quot;)
  public Response getServers(@QueryParam(&quot;limit&quot;) int limit, @QueryParam(&quot;offset&quot;) int offset,
          @QueryParam(&quot;filter&quot;) String filter, @QueryParam(&quot;sort&quot;) String sort)
          throws Exception {

    final Map&lt;String, String&gt; filters;
    try {
<span class="fc" id="L201">      filters = Arrays.stream(StringUtils.split(Objects.toString(filter, &quot;&quot;), &quot;,&quot;))</span>
<span class="fc" id="L202">          .map(f -&gt; f.split(&quot;:&quot;, 2))</span>
<span class="fc" id="L203">          .collect(Collectors.toMap(f -&gt; f[0], f -&gt; f[1]));</span>
<span class="nc" id="L204">    } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L205">      return badRequest(&quot;Invalid filter string&quot;, e);</span>
<span class="fc" id="L206">    }</span>

<span class="fc" id="L208">    List&lt;Server&gt; servers = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">    for (Server server: getServerData()) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">      if (!filters.getOrDefault(KEY_HOSTNAME, server.hostname).equalsIgnoreCase(server.hostname)) {</span>
<span class="fc" id="L211">        continue;</span>
      }

<span class="pc bpc" id="L214" title="1 of 2 branches missed.">      if (!StringUtils.equalsIgnoreCase(filters.getOrDefault(KEY_NODE_NAME, server.nodeName), server.nodeName)) {</span>
<span class="nc" id="L215">        continue;</span>
      }

<span class="fc bfc" id="L218" title="All 2 branches covered.">      if (filters.containsKey(KEY_STATUS)) {</span>
<span class="fc" id="L219">        final Status status = Status.valueOf(filters.get(KEY_STATUS).toUpperCase());</span>
<span class="fc bfc" id="L220" title="All 4 branches covered.">        if (Status.ONLINE.equals(status) &amp;&amp; !server.online) {</span>
<span class="fc" id="L221">          continue;</span>
        }
<span class="fc bfc" id="L223" title="All 4 branches covered.">        if (Status.OFFLINE.equals(status) &amp;&amp; server.online) {</span>
<span class="fc" id="L224">          continue;</span>
        }
<span class="fc bfc" id="L226" title="All 4 branches covered.">        if (Status.MAINTENANCE.equals(status) &amp;&amp; !server.maintenance) {</span>
<span class="fc" id="L227">          continue;</span>
        }
      }

<span class="fc" id="L231">      final String text = filters.getOrDefault(KEY_TEXT_FILTER, &quot;&quot;);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">      if (Stream.of(server.hostname, server.nodeName).noneMatch(v -&gt; StringUtils.containsIgnoreCase(v, text))) {</span>
<span class="fc" id="L233">        continue;</span>
      }

<span class="fc" id="L236">      servers.add(server);</span>
<span class="fc" id="L237">    }</span>

    // Sorting
<span class="fc" id="L240">    Sort sortKey = Sort.HOSTNAME;</span>
<span class="fc" id="L241">    boolean ascending = true;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">    if (StringUtils.isNotBlank(sort)) {</span>
      try {
<span class="fc" id="L244">        SortCriterion sortCriterion = RestUtils.parseSortQueryParameter(sort).iterator().next();</span>
<span class="fc" id="L245">        sortKey = Sort.valueOf(sortCriterion.getFieldName().toUpperCase());</span>
<span class="pc bpc" id="L246" title="1 of 4 branches missed.">        ascending = Order.Ascending == sortCriterion.getOrder() || Order.None == sortCriterion.getOrder();</span>
<span class="nc" id="L247">      } catch (WebApplicationException | IllegalArgumentException e) {</span>
<span class="nc" id="L248">        return badRequest(String.format(&quot;Invalid sort parameter `%s`&quot;, sort), e);</span>
<span class="fc" id="L249">      }</span>
    }
<span class="fc" id="L251">    servers.sort(new ServerComparator(sortKey, ascending));</span>

<span class="fc" id="L253">    offset = Math.min(offset, servers.size());</span>
    final List&lt;Server&gt; serverResults;
    try {
<span class="fc" id="L256">      serverResults = servers.subList(offset, Math.min(servers.size(), limit + offset));</span>
<span class="fc" id="L257">    } catch (IllegalArgumentException | IndexOutOfBoundsException e) {</span>
<span class="fc" id="L258">      return badRequest(&quot;Invalid offset and limit&quot;, e);</span>
<span class="fc" id="L259">    }</span>

<span class="fc" id="L261">    Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc" id="L262">    result.put(&quot;total&quot;, servers.size());</span>
<span class="fc" id="L263">    result.put(&quot;offset&quot;, offset);</span>
<span class="fc" id="L264">    result.put(&quot;count&quot;, serverResults.size());</span>
<span class="fc" id="L265">    result.put(&quot;limit&quot;, limit);</span>
<span class="fc" id="L266">    result.put(&quot;results&quot;, serverResults);</span>
<span class="fc" id="L267">    return Response.ok(gson.toJson(result)).build();</span>
  }

  /**
   * Get service statistics for all hosts and services
   * @return List of all servers
   * @throws ServiceRegistryException
   *          If the host data could not be retrieved
   */
  private synchronized List&lt;Server&gt; getServerData() throws ServiceRegistryException {
<span class="fc" id="L277">    List&lt;Server&gt; serverData = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L279" title="All 2 branches covered.">    for (HostRegistration host : serviceRegistry.getHostRegistrations()) {</span>
      // Calculate statistics per server
<span class="fc" id="L281">      Server server = new Server();</span>
<span class="fc" id="L282">      server.id = host.getId();</span>
<span class="fc" id="L283">      server.online = host.isOnline();</span>
<span class="fc" id="L284">      server.maintenance = host.isMaintenanceMode();</span>
<span class="fc" id="L285">      server.hostname = host.getBaseUrl();</span>
<span class="fc" id="L286">      server.nodeName = host.getNodeName();</span>
<span class="fc" id="L287">      server.cores = host.getCores();</span>
<span class="fc" id="L288">      serverData.add(server);</span>
<span class="fc" id="L289">    }</span>

    // Check if cache is still valid
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">    if (lastUpdated + CACHE_SECONDS &lt; Instant.now().getEpochSecond()) {</span>
      // Update cache
<span class="fc" id="L294">      cachedServerData.clear();</span>
<span class="fc" id="L295">      logger.debug(&quot;Updating server data&quot;);</span>
<span class="fc" id="L296">      HostStatistics statistics = serviceRegistry.getHostStatistics();</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">      for (HostRegistration host : serviceRegistry.getHostRegistrations()) {</span>
        // Calculate statistics per server
<span class="fc" id="L299">        CachedServer server = new CachedServer();</span>
<span class="fc" id="L300">        server.running = statistics.runningJobs(host.getId());</span>
<span class="fc" id="L301">        server.queued = statistics.queuedJobs(host.getId());</span>
<span class="fc" id="L302">        cachedServerData.put(host.getId(), server);</span>
<span class="fc" id="L303">      }</span>
<span class="fc" id="L304">      lastUpdated = Instant.now().getEpochSecond();</span>
    }

    // Add info from cache
<span class="fc bfc" id="L308" title="All 2 branches covered.">    for (int i = 0; i &lt; serverData.size(); i++) {</span>
<span class="fc" id="L309">      Optional&lt;CachedServer&gt; cachedServer = Optional.ofNullable(cachedServerData.get(serverData.get(i).id));</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">      if (cachedServer.isPresent()) {</span>
<span class="fc" id="L311">        Server server = serverData.get(i);</span>
<span class="fc" id="L312">        server.running = cachedServer.get().running;</span>
<span class="fc" id="L313">        server.queued = cachedServer.get().queued;</span>
<span class="fc" id="L314">        serverData.set(i, server);</span>
      }
    }

<span class="fc" id="L318">    return serverData;</span>
  }

  /**
   * Return a bad request response but log additional details in debug mode.
   *
   * @param message
   *          Message to send
   * @param e
   *          Exception to log. If &lt;pre&gt;null&lt;/pre&gt;, a new exception is created to log a stack trace.
   * @return 400 BAD REQUEST HTTP response
   */
  private Response badRequest(final String message, final Exception e) {
<span class="pc bpc" id="L331" title="3 of 4 branches missed.">    logger.debug(message, e == null &amp;&amp; logger.isDebugEnabled() ? new IllegalArgumentException(message) : e);</span>
<span class="fc" id="L332">    return Response.status(Response.Status.BAD_REQUEST)</span>
<span class="fc" id="L333">        .entity(gson.toJson(message))</span>
<span class="fc" id="L334">        .build();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>