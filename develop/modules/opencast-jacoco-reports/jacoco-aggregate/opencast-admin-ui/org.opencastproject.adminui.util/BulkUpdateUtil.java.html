<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BulkUpdateUtil.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-admin-ui</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.adminui.util</a> &gt; <span class="el_source">BulkUpdateUtil.java</span></div><h1>BulkUpdateUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.adminui.util;

import static org.opencastproject.adminui.endpoint.AbstractEventEndpoint.SCHEDULING_AGENT_ID_KEY;
import static org.opencastproject.adminui.endpoint.AbstractEventEndpoint.SCHEDULING_END_KEY;
import static org.opencastproject.adminui.endpoint.AbstractEventEndpoint.SCHEDULING_START_KEY;

import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.index.service.api.IndexService;
import org.opencastproject.index.service.catalog.adapter.events.CommonEventCatalogUIAdapter;
import org.opencastproject.mediapackage.MediaPackageElements;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.time.DayOfWeek;
import java.time.Duration;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Optional;


/**
 * This class holds utility functions which are related to the bulk update feature for events.
 */
public final class BulkUpdateUtil {

<span class="fc" id="L59">  private static final JSONParser parser = new JSONParser();</span>

  private BulkUpdateUtil() {
  }

  /**
   * Wraps the IndexService.getEvent() method to convert SearchIndexExceptions into RuntimeExceptions. Useful when
   * using Java's functional programming features.
   *
   * @param indexSvc The IndexService instance.
   * @param index The index to get the event from.
   * @param id The id of the event to get.
   * @return An optional holding the event or nothing, if not found.
   */
  public static Optional&lt;Event&gt; getEvent(
    final IndexService indexSvc,
    final ElasticsearchIndex index,
    final String id) {
    try {
<span class="nc" id="L78">      return indexSvc.getEvent(id, index);</span>
<span class="nc" id="L79">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L80">      throw new RuntimeException(e);</span>
    }
  }

  /**
   * Takes the given scheduling information and completes the event start and end dates as well as the duration for the
   * given event. If the weekday shall be changed, the start and end dates are adjusted accordingly.
   *
   * @param event The event to complete the scheduling information for.
   * @param scheduling The (yet incomplete) scheduling information to complete.
   * @return The completed scheduling information, adjusted for the given event.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static JSONObject addSchedulingDates(final Event event, final JSONObject scheduling) {
<span class="fc" id="L94">    final JSONObject result = deepCopy(scheduling);</span>
<span class="fc" id="L95">    ZonedDateTime startDate = ZonedDateTime.parse(event.getRecordingStartDate());</span>
<span class="fc" id="L96">    ZonedDateTime endDate = ZonedDateTime.parse(event.getRecordingEndDate());</span>
<span class="fc" id="L97">    final InternalDuration oldDuration = InternalDuration.of(startDate.toInstant(), endDate.toInstant());</span>
<span class="fc" id="L98">    final ZoneId timezone = ZoneId.of((String) result.get(&quot;timezone&quot;));</span>

    // The client only sends start time hours and/or minutes. We have to apply this to each event to get a full date.
<span class="fc bfc" id="L101" title="All 2 branches covered.">    if (result.containsKey(SCHEDULING_START_KEY)) {</span>
<span class="fc" id="L102">      startDate = adjustedSchedulingDate(result, SCHEDULING_START_KEY, startDate, timezone);</span>
    }
    // The client only sends end time hours and/or minutes. We have to apply this to each event to get a full date.
<span class="fc bfc" id="L105" title="All 2 branches covered.">    if (result.containsKey(SCHEDULING_END_KEY)) {</span>
<span class="fc" id="L106">      endDate = adjustedSchedulingDate(result, SCHEDULING_END_KEY, endDate, timezone);</span>
    }
<span class="fc bfc" id="L108" title="All 2 branches covered.">    if (endDate.isBefore(startDate)) {</span>
<span class="fc" id="L109">      endDate = endDate.plusDays(1);</span>
    }

    // If duration is set, we have to adjust the end or start date.
<span class="fc bfc" id="L113" title="All 2 branches covered.">    if (result.containsKey(&quot;duration&quot;)) {</span>
<span class="fc" id="L114">      final JSONObject time = (JSONObject) result.get(&quot;duration&quot;);</span>
<span class="fc" id="L115">      final InternalDuration newDuration = new InternalDuration(oldDuration);</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">      if (time.containsKey(&quot;hour&quot;)) {</span>
<span class="fc" id="L117">        newDuration.hours = (Long) time.get(&quot;hour&quot;);</span>
      }
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">      if (time.containsKey(&quot;minute&quot;)) {</span>
<span class="fc" id="L120">        newDuration.minutes = (Long) time.get(&quot;minute&quot;);</span>
      }
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">      if (time.containsKey(&quot;second&quot;)) {</span>
<span class="nc" id="L123">        newDuration.seconds = (Long) time.get(&quot;second&quot;);</span>
      }
<span class="fc bfc" id="L125" title="All 2 branches covered.">      if (result.containsKey(SCHEDULING_END_KEY)) {</span>
<span class="fc" id="L126">        startDate = endDate.minusHours(newDuration.hours)</span>
<span class="fc" id="L127">          .minusMinutes(newDuration.minutes)</span>
<span class="fc" id="L128">          .minusSeconds(newDuration.seconds);</span>
      } else {
<span class="fc" id="L130">        endDate = startDate.plusHours(newDuration.hours)</span>
<span class="fc" id="L131">          .plusMinutes(newDuration.minutes)</span>
<span class="fc" id="L132">          .plusSeconds(newDuration.seconds);</span>
      }
    }

    // Setting the weekday means that the event should be moved to the new weekday within the same week
<span class="fc bfc" id="L137" title="All 2 branches covered.">    if (result.containsKey(&quot;weekday&quot;)) {</span>
<span class="fc" id="L138">      final String weekdayAbbrev = ((String) result.get(&quot;weekday&quot;));</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">      if (weekdayAbbrev != null) {</span>
<span class="fc" id="L140">        final DayOfWeek newWeekDay = Arrays.stream(DayOfWeek.values())</span>
<span class="fc" id="L141">          .filter(d -&gt; d.name().startsWith(weekdayAbbrev.toUpperCase()))</span>
<span class="fc" id="L142">          .findAny()</span>
<span class="pc" id="L143">          .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Cannot parse weekday: &quot; + weekdayAbbrev));</span>
<span class="fc" id="L144">        final int daysDiff = newWeekDay.getValue() - startDate.getDayOfWeek().getValue();</span>
<span class="fc" id="L145">        startDate = startDate.plusDays(daysDiff);</span>
<span class="fc" id="L146">        endDate = endDate.plusDays(daysDiff);</span>
      }
    }

<span class="fc" id="L150">    result.put(SCHEDULING_START_KEY, startDate.format(DateTimeFormatter.ISO_INSTANT));</span>
<span class="fc" id="L151">    result.put(SCHEDULING_END_KEY, endDate.format(DateTimeFormatter.ISO_INSTANT));</span>
<span class="fc" id="L152">    return result;</span>
  }

  /**
   * Creates a json object containing meta data based on the given scheduling information.
   *
   * @param scheduling The scheduling information to extract meta data from.
   * @return The meta data, consisting of location, startDate, and duration.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static JSONObject toNonTechnicalMetadataJson(final JSONObject scheduling) {
<span class="fc" id="L163">    final List&lt;JSONObject&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">    if (scheduling.containsKey(SCHEDULING_AGENT_ID_KEY)) {</span>
<span class="fc" id="L165">      final JSONObject locationJson = new JSONObject();</span>
<span class="fc" id="L166">      locationJson.put(&quot;id&quot;, &quot;location&quot;);</span>
<span class="fc" id="L167">      locationJson.put(&quot;value&quot;, scheduling.get(SCHEDULING_AGENT_ID_KEY));</span>
<span class="fc" id="L168">      fields.add(locationJson);</span>
    }
<span class="pc bpc" id="L170" title="2 of 4 branches missed.">    if (scheduling.containsKey(SCHEDULING_START_KEY) &amp;&amp; scheduling.containsKey(SCHEDULING_END_KEY)) {</span>
<span class="fc" id="L171">      final JSONObject startDateJson = new JSONObject();</span>
<span class="fc" id="L172">      startDateJson.put(&quot;id&quot;, &quot;startDate&quot;);</span>
<span class="fc" id="L173">      final String startDate = Instant.parse((String) scheduling.get(SCHEDULING_START_KEY))</span>
<span class="fc" id="L174">        .atOffset(ZoneOffset.UTC)</span>
<span class="fc" id="L175">        .format(DateTimeFormatter.ISO_LOCAL_DATE_TIME) + &quot;.000Z&quot;;</span>
<span class="fc" id="L176">      startDateJson.put(&quot;value&quot;, startDate);</span>
<span class="fc" id="L177">      fields.add(startDateJson);</span>

<span class="fc" id="L179">      final JSONObject durationJson = new JSONObject();</span>
<span class="fc" id="L180">      durationJson.put(&quot;id&quot;, &quot;duration&quot;);</span>
<span class="fc" id="L181">      final Instant start = Instant.parse((String) scheduling.get(SCHEDULING_START_KEY));</span>
<span class="fc" id="L182">      final Instant end = Instant.parse((String) scheduling.get(SCHEDULING_END_KEY));</span>
<span class="fc" id="L183">      final InternalDuration duration = InternalDuration.of(start, end);</span>
<span class="fc" id="L184">      durationJson.put(&quot;value&quot;, duration.toString());</span>
<span class="fc" id="L185">      fields.add(durationJson);</span>
    }

<span class="fc" id="L188">    final JSONObject result = new JSONObject();</span>
<span class="fc" id="L189">    result.put(&quot;flavor&quot;, MediaPackageElements.EPISODE.toString());</span>
<span class="fc" id="L190">    result.put(&quot;title&quot;, CommonEventCatalogUIAdapter.EPISODE_TITLE);</span>
<span class="fc" id="L191">    result.put(&quot;fields&quot;, fields);</span>
<span class="fc" id="L192">    return result;</span>
  }

  /**
   * Merges all fields of the given meta data json objects into one object.
   *
   * @param first The first meta data json object.
   * @param second The second meta data json object.
   * @return A new json meta data object, containing the field of both input objects.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static JSONObject mergeMetadataFields(final JSONObject first, final JSONObject second) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (first == null) {</span>
<span class="fc" id="L205">      return second;</span>
    }
<span class="fc bfc" id="L207" title="All 2 branches covered.">    if (second == null) {</span>
<span class="fc" id="L208">      return first;</span>
    }
<span class="fc" id="L210">    final JSONObject result = deepCopy(first);</span>
<span class="fc" id="L211">    final Collection fields = (Collection) result.get(&quot;fields&quot;);</span>
<span class="fc" id="L212">    fields.addAll((Collection) second.get(&quot;fields&quot;));</span>
<span class="fc" id="L213">    return result;</span>
  }

  private static JSONObject deepCopy(final JSONObject o) {
    try {
<span class="fc" id="L218">      return (JSONObject) parser.parse(o.toJSONString());</span>
<span class="nc" id="L219">    } catch (ParseException e) {</span>
<span class="nc" id="L220">      throw new IllegalArgumentException(e);</span>
    }
  }

  private static class InternalDuration {
    private long hours;
    private long minutes;
    private long seconds;

<span class="fc" id="L229">    InternalDuration() {</span>
<span class="fc" id="L230">    }</span>

<span class="fc" id="L232">    InternalDuration(final InternalDuration other) {</span>
<span class="fc" id="L233">      this.hours = other.hours;</span>
<span class="fc" id="L234">      this.minutes = other.minutes;</span>
<span class="fc" id="L235">      this.seconds = other.seconds;</span>
<span class="fc" id="L236">    }</span>

    public static InternalDuration of(final Instant start, final Instant end) {
<span class="fc" id="L239">      final InternalDuration result = new InternalDuration();</span>
<span class="fc" id="L240">      final Duration duration = Duration.between(start, end);</span>
<span class="fc" id="L241">      result.hours = duration.toHours();</span>
<span class="fc" id="L242">      result.minutes = duration.minusHours(result.hours).toMinutes();</span>
<span class="fc" id="L243">      result.seconds = duration.minusHours(result.hours).minusMinutes(result.minutes).getSeconds();</span>
<span class="fc" id="L244">      return result;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L249">      return String.format(&quot;%02d:%02d:%02d&quot;, hours, minutes, seconds);</span>
    }
  }

  private static ZonedDateTime adjustedSchedulingDate(
    final JSONObject scheduling,
    final String dateKey,
    final ZonedDateTime date,
    final ZoneId timezone) {
<span class="fc" id="L258">    final JSONObject time = (JSONObject) scheduling.get(dateKey);</span>
<span class="fc" id="L259">    ZonedDateTime result = date.withZoneSameInstant(timezone);</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">    if (time.containsKey(&quot;hour&quot;)) {</span>
<span class="fc" id="L261">      final int hour = Math.toIntExact((Long) time.get(&quot;hour&quot;));</span>
<span class="fc" id="L262">      result = result.withHour(hour);</span>
    }
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">    if (time.containsKey(&quot;minute&quot;)) {</span>
<span class="fc" id="L265">      final int minute = Math.toIntExact((Long) time.get(&quot;minute&quot;));</span>
<span class="fc" id="L266">      result = result.withMinute(minute);</span>
    }
<span class="fc" id="L268">    return result.withZoneSameInstant(ZoneOffset.UTC);</span>
  }

  /**
   * Model class for one group of update instructions
   */
  public static class BulkUpdateInstructionGroup {
    private final List&lt;String&gt; eventIds;
    private final JSONObject metadata;
    private final JSONObject scheduling;

    /**
     * Create a new group from parsed JSON data
     *
     * @param eventIds Event IDs in this group
     * @param metadata Metadata for this group
     * @param scheduling Scheduling for this group
     */
<span class="fc" id="L286">    public BulkUpdateInstructionGroup(final List&lt;String&gt; eventIds, final JSONObject metadata, final JSONObject scheduling) {</span>
<span class="fc" id="L287">      this.eventIds = eventIds;</span>
<span class="fc" id="L288">      this.metadata = metadata;</span>
<span class="fc" id="L289">      this.scheduling = scheduling;</span>
<span class="fc" id="L290">    }</span>

    /**
     * Get the list of IDs of events to apply the bulk update to.
     *
     * @return The list of IDs of the events to apply the bulk update to.
     */
    public List&lt;String&gt; getEventIds() {
<span class="fc" id="L298">      return eventIds;</span>
    }

    /**
     * Get the meta data update to apply.
     *
     * @return The meta data update to apply.
     */
    public JSONObject getMetadata() {
<span class="fc" id="L307">      return metadata;</span>
    }

    /**
     *  Get the scheduling information update to apply.
     *
     * @return The scheduling information update to apply.
     */
    public JSONObject getScheduling() {
<span class="fc" id="L316">      return scheduling;</span>
    }
  }

  /**
   * Model class for the bulk update instructions which are sent by the UI.
   */
  public static class BulkUpdateInstructions {
    private static final String KEY_EVENTS = &quot;events&quot;;
    private static final String KEY_METADATA = &quot;metadata&quot;;
    private static final String KEY_SCHEDULING = &quot;scheduling&quot;;

    private final List&lt;BulkUpdateInstructionGroup&gt; groups;

    /**
     * Create a new instance by parsing the given json String.
     *
     * @param json The json serialized version of the bulk update instructions sent by the UI.
     *
     * @throws IllegalArgumentException If the json string cannot be parsed.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L338">    public BulkUpdateInstructions(final String json) throws IllegalArgumentException {</span>
      try {
<span class="fc" id="L340">        final JSONArray root = (JSONArray) parser.parse(json);</span>
<span class="fc" id="L341">        groups = new ArrayList&lt;&gt;(root.size());</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">        for (final Object jsonGroup : root) {</span>
<span class="fc" id="L343">          final JSONObject jsonObject = (JSONObject) jsonGroup;</span>
<span class="fc" id="L344">          final JSONArray eventIds = (JSONArray) jsonObject.get(KEY_EVENTS);</span>
<span class="fc" id="L345">          final JSONObject metadata = (JSONObject) jsonObject.get(KEY_METADATA);</span>
<span class="fc" id="L346">          final JSONObject scheduling = (JSONObject) jsonObject.get(KEY_SCHEDULING);</span>
<span class="fc" id="L347">          groups.add(new BulkUpdateInstructionGroup(eventIds, metadata, scheduling));</span>
<span class="fc" id="L348">        }</span>
<span class="fc" id="L349">      } catch (final ParseException e) {</span>
<span class="fc" id="L350">        throw new IllegalArgumentException(e);</span>
<span class="fc" id="L351">      }</span>
<span class="fc" id="L352">    }</span>

    public List&lt;BulkUpdateInstructionGroup&gt; getGroups() {
<span class="fc" id="L355">      return groups;</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>