<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IngestDownloadServiceImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-ingest-download-service-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.ingestdownloadservice.impl</a> &gt; <span class="el_source">IngestDownloadServiceImpl.java</span></div><h1>IngestDownloadServiceImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.ingestdownloadservice.impl;

import org.opencastproject.ingestdownloadservice.api.IngestDownloadService;
import org.opencastproject.job.api.AbstractJobProducer;
import org.opencastproject.job.api.Job;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.MediaPackageParser;
import org.opencastproject.mediapackage.selector.AbstractMediaPackageElementSelector;
import org.opencastproject.mediapackage.selector.SimpleElementSelector;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.TrustedHttpClient;
import org.opencastproject.security.api.TrustedHttpClientException;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.serviceregistry.api.ServiceRegistration;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.workingfilerepository.api.WorkingFileRepository;
import org.opencastproject.workspace.api.Workspace;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.client.methods.HttpDelete;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * A simple tutorial class to learn about Opencast Services
 */
@Component(
    immediate = true,
    service = IngestDownloadService.class,
    property = {
        &quot;service.description=Ingest download service&quot;,
        &quot;service.pid=org.opencastproject.ingestdownloadservice.impl.IngestDownloadServiceImpl&quot;
    }
)
public class IngestDownloadServiceImpl extends AbstractJobProducer implements IngestDownloadService {

<span class="fc" id="L78">  public enum Operation {</span>
<span class="fc" id="L79">    Download</span>
  }

  /**
   * The module specific logger
   */
<span class="fc" id="L85">  private static final Logger logger = LoggerFactory.getLogger(IngestDownloadServiceImpl.class);</span>

  /**
   * Reference to the receipt service
   */
<span class="fc" id="L90">  private ServiceRegistry serviceRegistry = null;</span>

  /**
   * The security service
   */
<span class="fc" id="L95">  private SecurityService securityService = null;</span>

  /**
   * The user directory service
   */
<span class="fc" id="L100">  private UserDirectoryService userDirectoryService = null;</span>

  /**
   * The organization directory service
   */
<span class="fc" id="L105">  private OrganizationDirectoryService organizationDirectoryService = null;</span>

  /**
   * The workspace service
   */
  private Workspace workspace;

  /**
   * The http client to use when connecting to remote servers
   */
<span class="fc" id="L115">  private TrustedHttpClient client = null;</span>

  /**
   * Creates a new abstract job producer for jobs of the given type.
   *
   */
  public IngestDownloadServiceImpl() {
<span class="fc" id="L122">    super(JOB_TYPE);</span>
<span class="fc" id="L123">  }</span>

  /**
   * Sets the workspace to use.
   *
   * @param workspace the workspace
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="fc" id="L132">    this.workspace = workspace;</span>
<span class="fc" id="L133">  }</span>

  /**
   * Sets the receipt service
   *
   * @param serviceRegistry the service registry
   */
  @Reference
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L142">    this.serviceRegistry = serviceRegistry;</span>
<span class="fc" id="L143">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.job.api.AbstractJobProducer#getServiceRegistry()
   */
  @Override
  protected ServiceRegistry getServiceRegistry() {
<span class="nc" id="L152">    return serviceRegistry;</span>
  }

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.job.api.AbstractJobProducer#getSecurityService()
   */
  @Override
  protected SecurityService getSecurityService() {
<span class="nc" id="L162">    return securityService;</span>
  }

  /**
   * Callback for setting the security service.
   *
   * @param securityService the securityService to set
   */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="nc" id="L172">    this.securityService = securityService;</span>
<span class="nc" id="L173">  }</span>

  /**
   * Callback for setting the user directory service.
   *
   * @param userDirectoryService the userDirectoryService to set
   */
  @Reference
  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {
<span class="nc" id="L182">    this.userDirectoryService = userDirectoryService;</span>
<span class="nc" id="L183">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.job.api.AbstractJobProducer#getUserDirectoryService()
   */
  @Override
  protected UserDirectoryService getUserDirectoryService() {
<span class="nc" id="L192">    return userDirectoryService;</span>
  }

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.job.api.AbstractJobProducer#getOrganizationDirectoryService()
   */
  @Override
  protected OrganizationDirectoryService getOrganizationDirectoryService() {
<span class="nc" id="L202">    return organizationDirectoryService;</span>
  }

  /**
   * Sets a reference to the organization directory service.
   *
   * @param organizationDirectory the organization directory
   */
  @Reference
  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectory) {
<span class="nc" id="L212">    this.organizationDirectoryService = organizationDirectory;</span>
<span class="nc" id="L213">  }</span>

  @Override
  public Job ingestDownload(MediaPackage mediaPackage, String sourceFlavors, String sourceTags, boolean deleteExternal,
          boolean tagsAndFlavor) throws ServiceRegistryException {

<span class="fc" id="L219">    final List&lt;String&gt; paramList = new ArrayList&lt;&gt;(5);</span>
<span class="fc" id="L220">    paramList.add(MediaPackageParser.getAsXml(mediaPackage));</span>
<span class="fc" id="L221">    paramList.add(sourceFlavors);</span>
<span class="fc" id="L222">    paramList.add(sourceTags);</span>
<span class="fc" id="L223">    paramList.add(Boolean.toString(deleteExternal));</span>
<span class="fc" id="L224">    paramList.add(Boolean.toString(tagsAndFlavor));</span>

<span class="fc" id="L226">    return serviceRegistry.createJob(JOB_TYPE, Operation.Download.toString(), paramList);</span>

  }

  @Override
  protected String process(Job job) throws MediaPackageException, IOException {
<span class="fc" id="L232">    final List&lt;String&gt; arguments = new ArrayList&lt;&gt;(job.getArguments());</span>

<span class="fc" id="L234">    final MediaPackage mediaPackage = MediaPackageParser.getFromXml(arguments.get(0));</span>
<span class="fc" id="L235">    final String sourceFlavors = arguments.get(1);</span>
<span class="fc" id="L236">    final String sourceTags = arguments.get(2);</span>
<span class="fc" id="L237">    final boolean deleteExternal = Boolean.parseBoolean(arguments.get(3));</span>
<span class="fc" id="L238">    final boolean tagsAndFlavor = Boolean.parseBoolean(arguments.get(4));</span>

    // building elementSelector with tags and flavors
<span class="fc" id="L241">    AbstractMediaPackageElementSelector&lt;MediaPackageElement&gt; elementSelector = new SimpleElementSelector();</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">    for (String tag : StringUtils.split(sourceTags, &quot;, &quot;)) {</span>
<span class="fc" id="L243">      elementSelector.addTag(tag);</span>
    }
<span class="fc bfc" id="L245" title="All 2 branches covered.">    for (String flavor : StringUtils.split(sourceFlavors, &quot;, &quot;)) {</span>
<span class="fc" id="L246">      elementSelector.addFlavor(flavor);</span>
    }

<span class="fc" id="L249">    final String baseUrl = workspace.getBaseUri().toString();</span>

<span class="fc" id="L251">    List&lt;URI&gt; externalUris = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">    for (MediaPackageElement element : elementSelector.select(mediaPackage, tagsAndFlavor)) {</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">      if (element.getURI() == null) {</span>
<span class="nc" id="L254">        continue;</span>
      }

<span class="pc bpc" id="L257" title="1 of 2 branches missed.">      if (element.getElementType() == MediaPackageElement.Type.Publication) {</span>
<span class="nc" id="L258">        logger.debug(&quot;Skipping publication {} from media package {}&quot;, element.getIdentifier(),</span>
<span class="nc" id="L259">                     mediaPackage.getIdentifier());</span>
<span class="nc" id="L260">        continue;</span>
      }

<span class="pc bpc" id="L263" title="1 of 2 branches missed.">      if (element.getURI().toString().startsWith(baseUrl)) {</span>
<span class="nc" id="L264">        logger.info(&quot;Skipping already existing element {}&quot;, element.getURI());</span>
<span class="nc" id="L265">        continue;</span>
      }

      // Download the external URI
      File file;
      try {
<span class="fc" id="L271">        file = workspace.get(element.getURI());</span>
<span class="nc" id="L272">      } catch (NotFoundException e) {</span>
<span class="nc" id="L273">        logger.warn(&quot;Unable to download the external element {}&quot;, element.getURI());</span>
<span class="nc" id="L274">        continue;</span>
<span class="fc" id="L275">      }</span>

      // Put to working file repository and rewrite URI on element
<span class="fc" id="L278">      final URI originalUri = element.getURI();</span>
<span class="fc" id="L279">      try (InputStream in = new FileInputStream(file)) {</span>
<span class="fc" id="L280">        final String filename = FilenameUtils.getName(element.getURI().getPath());</span>
<span class="fc" id="L281">        final URI uri = workspace.put(mediaPackage.getIdentifier().toString(), element.getIdentifier(), filename, in);</span>
<span class="fc" id="L282">        element.setURI(uri);</span>
      } finally {
        try {
<span class="fc" id="L285">          workspace.delete(originalUri);</span>
<span class="nc" id="L286">        } catch (Exception e) {</span>
<span class="nc" id="L287">          logger.warn(&quot;Unable to delete ingest-downloaded element {}&quot;, element.getURI(), e);</span>
<span class="fc" id="L288">        }</span>
      }

<span class="fc" id="L291">      logger.info(&quot;Downloaded the external element {}&quot;, originalUri);</span>

      // Store original URI for deletion
<span class="fc" id="L294">      externalUris.add(originalUri);</span>
<span class="fc" id="L295">    }</span>

<span class="pc bpc" id="L297" title="1 of 4 branches missed.">    if (!deleteExternal || externalUris.size() == 0)</span>
<span class="fc" id="L298">      return MediaPackageParser.getAsXml(mediaPackage);</span>

    // Find all external working file repository base Urls
<span class="fc" id="L301">    logger.debug(&quot;Assembling list of external working file repositories&quot;);</span>
<span class="fc" id="L302">    List&lt;String&gt; externalWfrBaseUrls = new ArrayList&lt;&gt;();</span>
    try {
<span class="fc" id="L304">      final String wfrServiceType = WorkingFileRepository.SERVICE_TYPE;</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">      for (ServiceRegistration reg : serviceRegistry.getServiceRegistrationsByType(wfrServiceType)) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (baseUrl.startsWith(reg.getHost())) {</span>
<span class="nc" id="L307">          logger.trace(&quot;Skipping local working file repository&quot;);</span>
<span class="nc" id="L308">          continue;</span>
        }
<span class="nc" id="L310">        externalWfrBaseUrls.add(UrlSupport.concat(reg.getHost(), reg.getPath()));</span>
<span class="nc" id="L311">      }</span>
<span class="fc" id="L312">      logger.debug(&quot;{} external working file repositories found&quot;, externalWfrBaseUrls.size());</span>
<span class="nc" id="L313">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L314">      logger.error(&quot;Unable to load WFR services from service registry&quot;, e);</span>
<span class="fc" id="L315">    }</span>

    // try deleting files from external working file reposities
<span class="fc bfc" id="L318" title="All 2 branches covered.">    for (URI uri : externalUris) {</span>

<span class="fc" id="L320">      String elementUri = uri.toString();</span>

      // Delete external working file repository URI's
<span class="fc" id="L323">      Optional&lt;String&gt; wfrBaseUrl = externalWfrBaseUrls.parallelStream().filter(elementUri::startsWith).findAny();</span>

<span class="pc bpc" id="L325" title="1 of 2 branches missed.">      if (!wfrBaseUrl.isPresent()) {</span>
<span class="fc" id="L326">        logger.debug(&quot;Unable to delete {}, no working file repository found for this URI&quot;, elementUri);</span>
<span class="fc" id="L327">        continue;</span>
      }

      final String deleteUrl;
<span class="nc bnc" id="L331" title="All 2 branches missed.">      if (uri.getPath().startsWith(WorkingFileRepository.MEDIAPACKAGE_PATH_PREFIX)) {</span>
<span class="nc" id="L332">        deleteUrl = elementUri.substring(0, elementUri.lastIndexOf(&quot;/&quot;));</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">      } else if (uri.getPath().startsWith(WorkingFileRepository.COLLECTION_PATH_PREFIX)) {</span>
<span class="nc" id="L334">        deleteUrl = elementUri;</span>
      } else {
<span class="nc" id="L336">        logger.info(&quot;Unable to handle working file repository URI {}&quot;, elementUri);</span>
<span class="nc" id="L337">        continue;</span>
      }
<span class="nc" id="L339">      HttpDelete delete = new HttpDelete(deleteUrl);</span>

<span class="nc" id="L341">      HttpResponse response = null;</span>
      try {
<span class="nc" id="L343">        response = client.execute(delete);</span>
<span class="nc" id="L344">        final int statusCode = response.getStatusLine().getStatusCode();</span>
<span class="nc bnc" id="L345" title="All 4 branches missed.">        if (statusCode == HttpStatus.SC_NO_CONTENT || statusCode == HttpStatus.SC_OK) {</span>
<span class="nc" id="L346">          logger.info(&quot;Successfully deleted external URI {}&quot;, delete.getURI());</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        } else if (statusCode == HttpStatus.SC_NOT_FOUND) {</span>
<span class="nc" id="L348">          logger.debug(&quot;External URI {} has already been deleted&quot;, delete.getURI());</span>
        } else {
<span class="nc" id="L350">          logger.warn(&quot;Unable to delete external URI {}, status code '{}' returned&quot;, delete.getURI(), statusCode);</span>
        }
<span class="nc" id="L352">      } catch (TrustedHttpClientException e) {</span>
<span class="nc" id="L353">        logger.warn(&quot;Unable to execute DELETE request on external URI {}&quot;, delete.getURI());</span>
      } finally {
<span class="nc" id="L355">        client.close(response);</span>
      }
<span class="nc" id="L357">    }</span>

<span class="fc" id="L359">    return MediaPackageParser.getAsXml(mediaPackage);</span>

  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>