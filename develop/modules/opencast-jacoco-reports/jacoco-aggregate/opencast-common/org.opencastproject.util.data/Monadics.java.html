<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Monadics.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.util.data</a> &gt; <span class="el_source">Monadics.java</span></div><h1>Monadics.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.util.data;

import static java.lang.StrictMath.min;
import static java.util.Arrays.asList;
import static org.opencastproject.util.data.Collections.appendTo;
import static org.opencastproject.util.data.Collections.appendToA;
import static org.opencastproject.util.data.Collections.appendToM;
import static org.opencastproject.util.data.Collections.forc;
import static org.opencastproject.util.data.Collections.list;
import static org.opencastproject.util.data.Collections.toList;
import static org.opencastproject.util.data.Option.none;
import static org.opencastproject.util.data.Option.some;
import static org.opencastproject.util.data.Tuple.tuple;

import org.apache.commons.lang3.ArrayUtils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

public final class Monadics {

  private Monadics() {
  }

  // we need to define a separate interface for each container type
  // since Java lacks higher-order polymorphism (higher-kinded type) so we cannot
  // abstract over the container type like this
  //
  // interface Functor&lt;F&lt;_&gt;&gt; {
  // &lt;A, B&gt; F&lt;B&gt; fmap(F&lt;A&gt; a, Function&lt;A, B&gt; f);
  // }
  //
  // or
  //
  // interface Functor&lt;A, F&lt;A&gt;&gt; {
  // &lt;B&gt; F&lt;B&gt; fmap(Function&lt;A, B&gt; f);
  // }

  /** The list monad. */
  public abstract static class ListMonadic&lt;A&gt; implements Iterable&lt;A&gt; {

    private ListMonadic() {
    }

    /** Alias for {@link #fmap(Function) fmap}. */
    public final &lt;B&gt; ListMonadic&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L72">      return fmap(f);</span>
    }

    /**
     * Apply &lt;code&gt;f&lt;/code&gt; to each elements building a new list. This is the list functor.
     *
     * @see #map(Function)
     */
    public abstract &lt;B&gt; ListMonadic&lt;B&gt; fmap(Function&lt;? super A, ? extends B&gt; f);

    /** Alias for {@link #bind(Function)}. */
    public final &lt;B&gt; ListMonadic&lt;B&gt; flatMap(Function&lt;? super A, ? extends Iterable&lt;B&gt;&gt; f) {
<span class="fc" id="L84">      return bind(f);</span>
    }

    /**
     * Monadic bind &lt;code&gt;m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/code&gt;. Apply &lt;code&gt;f&lt;/code&gt; to each elements concatenating
     * the results into a new list.
     */
    public abstract &lt;B&gt; ListMonadic&lt;B&gt; bind(Function&lt;? super A, ? extends Iterable&lt;B&gt;&gt; f);

    /** Fold the list from left to right applying binary operator &lt;code&gt;f&lt;/code&gt; starting with &lt;code&gt;zero&lt;/code&gt;. */
    public abstract &lt;B&gt; B foldl(B zero, Function2&lt;? super B, ? super A, ? extends B&gt; f);

    /** Reduce the list from left to right applying binary operator &lt;code&gt;f&lt;/code&gt;. The list must not be empty. */
    public abstract A reducel(Function2&lt;? super A, ? super A, ? extends A&gt; f);

    /** Append &lt;code&gt;a&lt;/code&gt; to the list. */
    public abstract &lt;M extends Iterable&lt;A&gt;&gt; ListMonadic&lt;A&gt; concat(M m);

    /** Construct a new list by prepending &lt;code&gt;a&lt;/code&gt;. */
    public abstract &lt;X extends A&gt; ListMonadic&lt;A&gt; cons(X a);

    /** Retain all elements satisfying predicate &lt;code&gt;p&lt;/code&gt;. */
    public abstract ListMonadic&lt;A&gt; filter(Function&lt;? super A, Boolean&gt; p);

    /** Return the first element satisfying predicate &lt;code&gt;p&lt;/code&gt;. */
    public abstract Option&lt;A&gt; find(Function&lt;? super A, Boolean&gt; p);

    /** Check if at least one element satisfies predicate &lt;code&gt;p&lt;/code&gt;. */
    public abstract boolean exists(Function&lt;? super A, Boolean&gt; p);

    /** Apply side effect &lt;code&gt;e&lt;/code&gt; to each element. */
    public abstract ListMonadic&lt;A&gt; each(Function&lt;? super A, Void&gt; e);

    public abstract &lt;B, M extends Iterable&lt;B&gt;&gt; ListMonadic&lt;Tuple&lt;A, B&gt;&gt; zip(M bs);

    public abstract ListMonadic&lt;A&gt; sort(Comparator&lt;A&gt; c);

    /** Return the head of the list. */
    public abstract Option&lt;A&gt; headOpt();

    /** Limit the list to the first &lt;code&gt;n&lt;/code&gt; elements. */
    public abstract ListMonadic&lt;A&gt; take(int n);

    /** Drop the first &lt;code&gt;n&lt;/code&gt; elements of the list. */
    public abstract ListMonadic&lt;A&gt; drop(int n);

    public abstract String mkString(String sep);

    /** Return the wrapped, unmodifiable list. */
    public abstract List&lt;A&gt; value();
  }

  /** The iterator monad. */
  public abstract static class IteratorMonadic&lt;A&gt; implements Iterable&lt;A&gt; {

    private IteratorMonadic() {
    }

    /** Alias for {@link #fmap(Function)}. */
    public final &lt;B&gt; IteratorMonadic&lt;B&gt; map(Function&lt;A, B&gt; f) {
<span class="fc" id="L144">      return fmap(f);</span>
    }

    /** Apply &lt;code&gt;f&lt;/code&gt; to each element. */
    public abstract &lt;B&gt; IteratorMonadic&lt;B&gt; fmap(Function&lt;A, B&gt; f);

    /** Apply &lt;code&gt;f&lt;/code&gt; to each element. The function also receives the element's index. */
    public abstract &lt;B&gt; IteratorMonadic&lt;B&gt; mapIndex(Function2&lt;A, Integer, B&gt; f);

    /** Alias for {@link #bind(Function)}. */
    public final &lt;B&gt; IteratorMonadic&lt;B&gt; flatMap(Function&lt;A, Iterator&lt;B&gt;&gt; f) {
<span class="fc" id="L155">      return bind(f);</span>
    }

    /** Monadic bind. Apply &lt;code&gt;f&lt;/code&gt; to each elements concatenating the results. */
    public abstract &lt;B&gt; IteratorMonadic&lt;B&gt; bind(Function&lt;A, Iterator&lt;B&gt;&gt; f);

    // /**
    // * Apply &lt;code&gt;f&lt;/code&gt; to each elements concatenating the results into a new list.
    // */
    // &lt;B, BB extends Collection&lt;B&gt;&gt; IteratorMonadic&lt;B&gt; flatMap(Function&lt;A, BB&gt; f);

    // /**
    // * Append &lt;code&gt;a&lt;/code&gt; to the list.
    // */
    // &lt;M extends Collection&lt;A&gt;&gt; ListMonadic&lt;A&gt; concat(M a);

    /** Retain all elements satisfying predicate &lt;code&gt;p&lt;/code&gt;. */
    public abstract IteratorMonadic&lt;A&gt; filter(Function&lt;A, Boolean&gt; p);

    /** Check if at least one element satisfies predicate &lt;code&gt;p&lt;/code&gt;. */
    public abstract boolean exists(Function&lt;A, Boolean&gt; p);

    /** Limit iteration to the first &lt;code&gt;n&lt;/code&gt; elements. */
    public abstract IteratorMonadic&lt;A&gt; take(int n);

    /** Apply side effect &lt;code&gt;e&lt;/code&gt; to each element. */
    public abstract IteratorMonadic&lt;A&gt; each(Function&lt;A, Void&gt; e);

    /** Apply side effect &lt;code&gt;e&lt;/code&gt; to each element. Indexed version of {@link #each(Function)}. */
    public abstract IteratorMonadic&lt;A&gt; eachIndex(Function2&lt;A, Integer, Void&gt; e);

    /** Return the wrapped iterator. */
    public abstract Iterator&lt;A&gt; value();

    /** Evaluate to a list. */
    public abstract List&lt;A&gt; eval();
  }

  private static &lt;A&gt; List&lt;A&gt; newListBuilder() {
<span class="fc" id="L194">    return new ArrayList&lt;A&gt;();</span>
  }

  private static &lt;A&gt; List&lt;A&gt; newListBuilder(int size) {
<span class="fc" id="L198">    return new ArrayList&lt;A&gt;(size);</span>
  }

  // -- matchers and constructors

  // -- constructors

  /** Constructor for collections. */
  public static &lt;A&gt; ListMonadic&lt;A&gt; mlist(final Collection&lt;A&gt; as) {
<span class="fc" id="L207">    return mlist(new ArrayList&lt;A&gt;(as));</span>
  }

  /** Constructor function optimized for lists. */
  public static &lt;A&gt; ListMonadic&lt;A&gt; mlist(final List&lt;A&gt; as) {
<span class="fc" id="L212">    return new ListMonadic&lt;A&gt;() {</span>
      @Override
      public &lt;B&gt; ListMonadic&lt;B&gt; fmap(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L215">        final List&lt;B&gt; target = newListBuilder(as.size());</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (A a : as) target.add(f.apply(a));</span>
<span class="fc" id="L217">        return mlist(target);</span>
      }

      @Override
      public &lt;B&gt; ListMonadic&lt;B&gt; bind(Function&lt;? super A, ? extends Iterable&lt;B&gt;&gt; f) {
<span class="fc" id="L222">        final List&lt;B&gt; target = newListBuilder();</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        for (A a : as)</span>
<span class="fc" id="L224">          appendTo(target, f.apply(a));</span>
<span class="fc" id="L225">        return mlist(target);</span>
      }

      @Override
      public ListMonadic&lt;A&gt; filter(Function&lt;? super A, Boolean&gt; p) {
<span class="fc" id="L230">        final List&lt;A&gt; target = newListBuilder(as.size());</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        for (A a : as) {</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">          if (p.apply(a)) {</span>
<span class="fc" id="L233">            target.add(a);</span>
          }
<span class="fc" id="L235">        }</span>
<span class="fc" id="L236">        return mlist(target);</span>
      }

      @Override
      public Option&lt;A&gt; find(Function&lt;? super A, Boolean&gt; p) {
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        for (A a : as) {</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">          if (p.apply(a))</span>
<span class="fc" id="L243">            return some(a);</span>
<span class="fc" id="L244">        }</span>
<span class="nc" id="L245">        return none();</span>
      }

      @Override
      public boolean exists(Function&lt;? super A, Boolean&gt; p) {
<span class="fc bfc" id="L250" title="All 2 branches covered.">        for (A a : as) {</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">          if (p.apply(a))</span>
<span class="fc" id="L252">            return true;</span>
<span class="fc" id="L253">        }</span>
<span class="fc" id="L254">        return false;</span>
      }

      @Override
      public &lt;B&gt; B foldl(B zero, Function2&lt;? super B, ? super A, ? extends B&gt; f) {
<span class="fc" id="L259">        B fold = zero;</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">        for (A a : as) {</span>
<span class="fc" id="L261">          fold = f.apply(fold, a);</span>
<span class="fc" id="L262">        }</span>
<span class="fc" id="L263">        return fold;</span>
      }

      @Override
      public A reducel(Function2&lt;? super A, ? super A, ? extends A&gt; f) {
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">        if (as.size() == 0) {</span>
<span class="nc" id="L269">          throw new RuntimeException(&quot;Cannot reduce an empty list&quot;);</span>
        } else {
<span class="fc" id="L271">          A fold = as.get(0);</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">          for (int i = 1; i &lt; as.size(); i++) {</span>
<span class="fc" id="L273">            fold = f.apply(fold, as.get(i));</span>
          }
<span class="fc" id="L275">          return fold;</span>
        }
      }

      @Override
      public Option&lt;A&gt; headOpt() {
<span class="fc bfc" id="L281" title="All 2 branches covered.">        return !as.isEmpty() ? some(head()) : Option.&lt;A&gt; none();</span>
      }

      private A head() {
<span class="fc" id="L285">        return as.get(0);</span>
      }

      @Override
      public ListMonadic&lt;A&gt; take(int n) {
<span class="fc" id="L290">        return mlist(as.subList(0, min(as.size(), n)));</span>
      }

      @Override
      public ListMonadic&lt;A&gt; drop(int n) {
<span class="nc" id="L295">        return mlist(as.subList(min(as.size(), n), as.size()));</span>
      }

      @Override
      public &lt;M extends Iterable&lt;A&gt;&gt; ListMonadic&lt;A&gt; concat(M bs) {
<span class="nc" id="L300">        return mlist(appendToM(Monadics.&lt;A&gt; newListBuilder(), as, bs));</span>
      }

      @Override
      public &lt;X extends A&gt; ListMonadic&lt;A&gt; cons(X a) {
<span class="fc" id="L305">        return mlist(Collections.&lt;A&gt; cons(a, as));</span>
      }

      @Override
      public ListMonadic&lt;A&gt; each(Function&lt;? super A, Void&gt; e) {
<span class="nc bnc" id="L310" title="All 2 branches missed.">        for (A a : as)</span>
<span class="nc" id="L311">          e.apply(a);</span>
<span class="nc" id="L312">        return this;</span>
      }

      @Override
      public &lt;B, M extends Iterable&lt;B&gt;&gt; ListMonadic&lt;Tuple&lt;A, B&gt;&gt; zip(M m) {
<span class="fc" id="L317">        final List&lt;Tuple&lt;A, B&gt;&gt; target = newListBuilder();</span>
<span class="fc" id="L318">        final Iterator&lt;A&gt; asi = as.iterator();</span>
<span class="fc" id="L319">        final Iterator&lt;B&gt; mi = m.iterator();</span>
<span class="pc bpc" id="L320" title="1 of 4 branches missed.">        while (asi.hasNext() &amp;&amp; mi.hasNext()) {</span>
<span class="fc" id="L321">          target.add(tuple(asi.next(), mi.next()));</span>
        }
<span class="fc" id="L323">        return mlist(target);</span>
      }

      @Override
      public ListMonadic&lt;A&gt; sort(Comparator&lt;A&gt; c) {
<span class="nc" id="L328">        final List&lt;A&gt; target = newListBuilder(as.size());</span>
<span class="nc" id="L329">        target.addAll(as);</span>
<span class="nc" id="L330">        java.util.Collections.sort(target, c);</span>
<span class="nc" id="L331">        return mlist(target);</span>
      }

      @Override
      public String mkString(String sep) {
<span class="nc" id="L336">        return Collections.mkString(as, sep);</span>
      }

      @Override
      public Iterator&lt;A&gt; iterator() {
<span class="nc" id="L341">        return as.iterator();</span>
      }

      @Override
      public List&lt;A&gt; value() {
<span class="fc" id="L346">        return java.util.Collections.unmodifiableList(as);</span>
      }
    };
  }

  /** Constructor function optimized for arrays. */
  public static &lt;A&gt; ListMonadic&lt;A&gt; mlist(final A... as) {
<span class="fc" id="L353">    return new ListMonadic&lt;A&gt;() {</span>
      @Override
      public &lt;B&gt; ListMonadic&lt;B&gt; fmap(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L356">        final List&lt;B&gt; target = newListBuilder(as.length);</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        for (A a : as)</span>
<span class="fc" id="L358">          target.add(f.apply(a));</span>
<span class="fc" id="L359">        return mlist(target);</span>
      }

      @Override
      public &lt;B&gt; ListMonadic&lt;B&gt; bind(Function&lt;? super A, ? extends Iterable&lt;B&gt;&gt; f) {
<span class="fc" id="L364">        final List&lt;B&gt; target = newListBuilder();</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        for (A a : as)</span>
<span class="fc" id="L366">          appendTo(target, f.apply(a));</span>
<span class="fc" id="L367">        return mlist(target);</span>
      }

      @Override
      public ListMonadic&lt;A&gt; filter(Function&lt;? super A, Boolean&gt; p) {
<span class="fc" id="L372">        List&lt;A&gt; target = newListBuilder(as.length);</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">        for (A a : as) {</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">          if (p.apply(a)) {</span>
<span class="fc" id="L375">            target.add(a);</span>
          }
        }
<span class="fc" id="L378">        return mlist(target);</span>
      }

      @Override
      public Option&lt;A&gt; find(Function&lt;? super A, Boolean&gt; p) {
<span class="nc bnc" id="L383" title="All 2 branches missed.">        for (A a : as) {</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">          if (p.apply(a))</span>
<span class="nc" id="L385">            return some(a);</span>
        }
<span class="nc" id="L387">        return none();</span>
      }

      @Override
      public boolean exists(Function&lt;? super A, Boolean&gt; p) {
<span class="nc bnc" id="L392" title="All 2 branches missed.">        for (A a : as) {</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">          if (p.apply(a))</span>
<span class="nc" id="L394">            return true;</span>
        }
<span class="nc" id="L396">        return false;</span>
      }

      @Override
      public &lt;B&gt; B foldl(B zero, Function2&lt;? super B, ? super A, ? extends B&gt; f) {
<span class="fc" id="L401">        B fold = zero;</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">        for (A a : as) {</span>
<span class="fc" id="L403">          fold = f.apply(fold, a);</span>
        }
<span class="fc" id="L405">        return fold;</span>
      }

      @Override
      public A reducel(Function2&lt;? super A, ? super A, ? extends A&gt; f) {
<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (as.length == 0) {</span>
<span class="fc" id="L411">          throw new RuntimeException(&quot;Cannot reduce an empty list&quot;);</span>
        } else {
<span class="fc" id="L413">          A fold = as[0];</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">          for (int i = 1; i &lt; as.length; i++) {</span>
<span class="fc" id="L415">            fold = f.apply(fold, as[i]);</span>
          }
<span class="fc" id="L417">          return fold;</span>
        }
      }

      @Override
      public Option&lt;A&gt; headOpt() {
<span class="nc bnc" id="L423" title="All 2 branches missed.">        return as.length != 0 ? some(as[0]) : Option.&lt;A&gt; none();</span>
      }

      @Override
      public ListMonadic&lt;A&gt; take(int n) {
<span class="fc" id="L428">        return (ListMonadic&lt;A&gt;) mlist(ArrayUtils.subarray(as, 0, n));</span>
      }

      @Override
      public ListMonadic&lt;A&gt; drop(int n) {
<span class="fc" id="L433">        return (ListMonadic&lt;A&gt;) mlist(ArrayUtils.subarray(as, n, as.length));</span>
      }

      @Override
      public &lt;M extends Iterable&lt;A&gt;&gt; ListMonadic&lt;A&gt; concat(M bs) {
<span class="fc" id="L438">        final List&lt;A&gt; t = newListBuilder(as.length);</span>
<span class="fc" id="L439">        return mlist(appendTo(appendToA(t, as), bs));</span>
      }

      @Override
      public &lt;X extends A&gt; ListMonadic&lt;A&gt; cons(X a) {
<span class="nc" id="L444">        return mlist(Collections.&lt;A, List&gt; concat(Collections.&lt;A&gt; list(a), Collections.&lt;A&gt; list(as)));</span>
      }

      @Override
      public ListMonadic&lt;A&gt; each(Function&lt;? super A, Void&gt; e) {
<span class="nc bnc" id="L449" title="All 2 branches missed.">        for (A a : as) {</span>
<span class="nc" id="L450">          e.apply(a);</span>
        }
<span class="nc" id="L452">        return mlist(as);</span>
      }

      @Override
      public &lt;B, M extends Iterable&lt;B&gt;&gt; ListMonadic&lt;Tuple&lt;A, B&gt;&gt; zip(M m) {
<span class="fc" id="L457">        final List&lt;Tuple&lt;A, B&gt;&gt; target = newListBuilder();</span>
<span class="fc" id="L458">        int i = 0;</span>
<span class="fc" id="L459">        final Iterator&lt;B&gt; mi = m.iterator();</span>
<span class="fc bfc" id="L460" title="All 4 branches covered.">        while (i &lt; as.length &amp;&amp; mi.hasNext()) {</span>
<span class="fc" id="L461">          target.add(tuple(as[i++], mi.next()));</span>
        }
<span class="fc" id="L463">        return mlist(target);</span>
      }

      @Override
      public ListMonadic&lt;A&gt; sort(Comparator&lt;A&gt; c) {
<span class="nc" id="L468">        final List&lt;A&gt; target = list(as);</span>
<span class="nc" id="L469">        java.util.Collections.sort(target, c);</span>
<span class="nc" id="L470">        return mlist(target);</span>
      }

      @Override
      public String mkString(String sep) {
<span class="nc" id="L475">        return Arrays.mkString(as, sep);</span>
      }

      @Override
      public Iterator&lt;A&gt; iterator() {
<span class="nc" id="L480">        return Collections.iterator(as);</span>
      }

      @Override
      public List&lt;A&gt; value() {
<span class="fc" id="L485">        return asList(as);</span>
      }
    };
  }

  /** Constructor function optimized for iterators. */
  public static &lt;A&gt; ListMonadic&lt;A&gt; mlist(final Iterator&lt;A&gt; as) {
<span class="fc" id="L492">    return new ListMonadic&lt;A&gt;() {</span>
      @Override
      public &lt;B&gt; ListMonadic&lt;B&gt; fmap(Function&lt;? super A, ? extends B&gt; f) {
<span class="fc" id="L495">        final List&lt;B&gt; target = newListBuilder();</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        while (as.hasNext()) {</span>
<span class="fc" id="L497">          target.add(f.apply(as.next()));</span>
        }
<span class="fc" id="L499">        return mlist(target);</span>
      }

      @Override
      public &lt;B&gt; ListMonadic&lt;B&gt; bind(Function&lt;? super A, ? extends Iterable&lt;B&gt;&gt; f) {
<span class="nc" id="L504">        final List&lt;B&gt; target = newListBuilder();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        while (as.hasNext())</span>
<span class="nc" id="L506">          appendTo(target, f.apply(as.next()));</span>
<span class="nc" id="L507">        return mlist(target);</span>
      }

      @Override
      public ListMonadic&lt;A&gt; filter(Function&lt;? super A, Boolean&gt; p) {
<span class="nc" id="L512">        final List&lt;A&gt; target = newListBuilder();</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        while (as.hasNext()) {</span>
<span class="nc" id="L514">          A a = as.next();</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">          if (p.apply(a)) {</span>
<span class="nc" id="L516">            target.add(a);</span>
          }
<span class="nc" id="L518">        }</span>
<span class="nc" id="L519">        return mlist(target);</span>
      }

      @Override
      public Option&lt;A&gt; find(Function&lt;? super A, Boolean&gt; p) {
<span class="nc bnc" id="L524" title="All 2 branches missed.">        for (A a : forc(as)) {</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">          if (p.apply(a))</span>
<span class="nc" id="L526">            return some(a);</span>
<span class="nc" id="L527">        }</span>
<span class="nc" id="L528">        return none();</span>
      }

      @Override
      public boolean exists(Function&lt;? super A, Boolean&gt; p) {
<span class="nc bnc" id="L533" title="All 2 branches missed.">        for (A a : forc(as)) {</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">          if (p.apply(a))</span>
<span class="nc" id="L535">            return true;</span>
<span class="nc" id="L536">        }</span>
<span class="nc" id="L537">        return false;</span>
      }

      @Override
      public &lt;B&gt; B foldl(B zero, Function2&lt;? super B, ? super A, ? extends B&gt; f) {
<span class="nc" id="L542">        B fold = zero;</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">        while (as.hasNext()) {</span>
<span class="nc" id="L544">          fold = f.apply(fold, as.next());</span>
        }
<span class="nc" id="L546">        return fold;</span>
      }

      @Override
      public A reducel(Function2&lt;? super A, ? super A, ? extends A&gt; f) {
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (!as.hasNext()) {</span>
<span class="nc" id="L552">          throw new RuntimeException(&quot;Cannot reduce an empty iterator&quot;);</span>
        } else {
<span class="nc" id="L554">          A fold = as.next();</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">          while (as.hasNext()) {</span>
<span class="nc" id="L556">            fold = f.apply(fold, as.next());</span>
          }
<span class="nc" id="L558">          return fold;</span>
        }
      }

      @Override
      public Option&lt;A&gt; headOpt() {
<span class="nc" id="L564">        throw new UnsupportedOperationException();</span>
      }

      @Override
      public ListMonadic&lt;A&gt; take(final int n) {
<span class="fc" id="L569">        return mlist(new Iter&lt;A&gt;() {</span>
<span class="fc" id="L570">          private int count = 0;</span>

          @Override
          public boolean hasNext() {
<span class="fc bfc" id="L574" title="All 4 branches covered.">            return count &lt; n &amp;&amp; as.hasNext();</span>
          }

          @Override
          public A next() {
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">            if (count &lt; n) {</span>
<span class="fc" id="L580">              count++;</span>
<span class="fc" id="L581">              return as.next();</span>
            } else {
<span class="nc" id="L583">              throw new NoSuchElementException();</span>
            }
          }
        });
      }

      @Override
      public ListMonadic&lt;A&gt; drop(int n) {
<span class="nc" id="L591">        int count = n;</span>
<span class="nc bnc" id="L592" title="All 4 branches missed.">        while (as.hasNext() &amp;&amp; count &gt; 0) {</span>
<span class="nc" id="L593">          as.next();</span>
<span class="nc" id="L594">          count--;</span>
        }
<span class="nc" id="L596">        return mlist(as);</span>
      }

      @Override
      public &lt;M extends Iterable&lt;A&gt;&gt; ListMonadic&lt;A&gt; concat(M bs) {
<span class="nc" id="L601">        throw new UnsupportedOperationException();</span>
      }

      @Override
      public &lt;X extends A&gt; ListMonadic&lt;A&gt; cons(X a) {
<span class="nc" id="L606">        return null; // todo</span>
      }

      @Override
      public ListMonadic&lt;A&gt; each(Function&lt;? super A, Void&gt; e) {
<span class="nc bnc" id="L611" title="All 2 branches missed.">        while (as.hasNext()) e.apply(as.next());</span>
<span class="nc" id="L612">        return this;</span>
      }

      @Override
      public &lt;B, M extends Iterable&lt;B&gt;&gt; ListMonadic&lt;Tuple&lt;A, B&gt;&gt; zip(M m) {
<span class="fc" id="L617">        final List&lt;Tuple&lt;A, B&gt;&gt; target = newListBuilder();</span>
<span class="fc" id="L618">        final Iterator&lt;B&gt; mi = m.iterator();</span>
<span class="fc bfc" id="L619" title="All 4 branches covered.">        while (as.hasNext() &amp;&amp; mi.hasNext()) {</span>
<span class="fc" id="L620">          target.add(tuple(as.next(), mi.next()));</span>
        }
<span class="fc" id="L622">        return mlist(target);</span>
      }

      @Override
      public Iterator&lt;A&gt; iterator() {
<span class="nc" id="L627">        return as;</span>
      }

      @Override
      public ListMonadic&lt;A&gt; sort(Comparator&lt;A&gt; c) {
<span class="nc" id="L632">        throw new UnsupportedOperationException();</span>
      }

      @Override
      public String mkString(String sep) {
<span class="nc" id="L637">        return Collections.mkString(toList(as), sep);</span>
      }

      @Override
      public List&lt;A&gt; value() {
<span class="fc" id="L642">        return java.util.Collections.unmodifiableList(toList(as));</span>
      }
    };
  }

  /** Constructor function optimized for iterators. */
  public static &lt;A&gt; IteratorMonadic&lt;A&gt; mlazy(final Iterator&lt;A&gt; as) {
<span class="fc" id="L649">    return new IteratorMonadic&lt;A&gt;() {</span>
      @Override
      public &lt;B&gt; IteratorMonadic&lt;B&gt; fmap(final Function&lt;A, B&gt; f) {
<span class="fc" id="L652">        return mlazy(new Iter&lt;B&gt;() {</span>
          @Override
          public boolean hasNext() {
<span class="fc" id="L655">            return as.hasNext();</span>
          }

          @Override
          public B next() {
<span class="fc" id="L660">            return f.apply(as.next());</span>
          }
        });
      }

      @Override
      public &lt;B&gt; IteratorMonadic&lt;B&gt; mapIndex(final Function2&lt;A, Integer, B&gt; f) {
<span class="fc" id="L667">        return mlazy(new Iter&lt;B&gt;() {</span>
<span class="fc" id="L668">          private int i = 0;</span>

          @Override
          public boolean hasNext() {
<span class="fc" id="L672">            return as.hasNext();</span>
          }

          @Override
          public B next() {
<span class="fc" id="L677">            return f.apply(as.next(), i++);</span>
          }
        });
      }

      @Override
      public &lt;B&gt; IteratorMonadic&lt;B&gt; bind(final Function&lt;A, Iterator&lt;B&gt;&gt; f) {
<span class="fc" id="L684">        return mlazy(new Iter&lt;B&gt;() {</span>
          @Override
          public boolean hasNext() {
<span class="fc bfc" id="L687" title="All 4 branches covered.">            return step.hasNext() || step().hasNext();</span>
          }

          @Override
          public B next() {
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">            if (step.hasNext()) {</span>
<span class="fc" id="L693">              return step.next();</span>
            } else {
<span class="nc" id="L695">              return step().next();</span>
            }
          }

          // iterator state management
<span class="fc" id="L700">          private Iterator&lt;B&gt; step = Monadics.emptyIter();</span>

          private Iterator&lt;B&gt; step() {
<span class="fc bfc" id="L703" title="All 4 branches covered.">            while (!step.hasNext() &amp;&amp; as.hasNext()) {</span>
<span class="fc" id="L704">              step = f.apply(as.next());</span>
            }
<span class="fc" id="L706">            return step;</span>
          }
        });
      }

      @Override
      public boolean exists(Function&lt;A, Boolean&gt; p) {
<span class="fc bfc" id="L713" title="All 2 branches covered.">        for (A a : forc(as)) {</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">          if (p.apply(a))</span>
<span class="fc" id="L715">            return true;</span>
<span class="fc" id="L716">        }</span>
<span class="fc" id="L717">        return false;</span>
      }

      @Override
      public IteratorMonadic&lt;A&gt; filter(final Function&lt;A, Boolean&gt; p) {
<span class="fc" id="L722">        return mlazy(new Iter&lt;A&gt;() {</span>
<span class="fc" id="L723">          private A next = null;</span>

          @Override
          public boolean hasNext() {
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">            if (next != null) {</span>
<span class="nc" id="L728">              return true;</span>
            } else {
<span class="fc bfc" id="L730" title="All 2 branches covered.">              for (A a : forc(as)) {</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">                if (p.apply(a)) {</span>
<span class="fc" id="L732">                  next = a;</span>
<span class="fc" id="L733">                  return true;</span>
                }
<span class="fc" id="L735">              }</span>
<span class="fc" id="L736">              return false;</span>
            }
          }

          @Override
          public A next() {
            try {
<span class="pc bpc" id="L743" title="3 of 4 branches missed.">              if (next != null || hasNext()) {</span>
<span class="fc" id="L744">                return next;</span>
              } else {
<span class="nc" id="L746">                throw new NoSuchElementException();</span>
              }
            } finally {
<span class="fc" id="L749">              next = null;</span>
            }
          }
        });
      }

      @Override
      public IteratorMonadic&lt;A&gt; take(final int n) {
<span class="fc" id="L757">        return mlazy(new Iter&lt;A&gt;() {</span>
<span class="fc" id="L758">          private int count = 0;</span>

          @Override
          public boolean hasNext() {
<span class="fc bfc" id="L762" title="All 4 branches covered.">            return count &lt; n &amp;&amp; as.hasNext();</span>
          }

          @Override
          public A next() {
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">            if (count &lt; n) {</span>
<span class="fc" id="L768">              count++;</span>
<span class="fc" id="L769">              return as.next();</span>
            } else {
<span class="nc" id="L771">              throw new NoSuchElementException();</span>
            }
          }
        });
      }

      @Override
      public IteratorMonadic&lt;A&gt; each(final Function&lt;A, Void&gt; e) {
<span class="fc" id="L779">        return mlazy(new Iter&lt;A&gt;() {</span>
          @Override
          public boolean hasNext() {
<span class="fc" id="L782">            return as.hasNext();</span>
          }

          @Override
          public A next() {
<span class="fc" id="L787">            final A a = as.next();</span>
<span class="fc" id="L788">            e.apply(a);</span>
<span class="fc" id="L789">            return a;</span>
          }
        });
      }

      @Override
      public IteratorMonadic&lt;A&gt; eachIndex(final Function2&lt;A, Integer, Void&gt; e) {
<span class="fc" id="L796">        return mlazy(new Iter&lt;A&gt;() {</span>
<span class="fc" id="L797">          private int i = 0;</span>

          @Override
          public boolean hasNext() {
<span class="fc" id="L801">            return as.hasNext();</span>
          }

          @Override
          public A next() {
<span class="fc" id="L806">            final A a = as.next();</span>
<span class="fc" id="L807">            e.apply(a, i++);</span>
<span class="fc" id="L808">            return a;</span>
          }
        });
      }

      @Override
      public Iterator&lt;A&gt; iterator() {
<span class="nc" id="L815">        return as;</span>
      }

      @Override
      public Iterator&lt;A&gt; value() {
<span class="fc" id="L820">        return as;</span>
      }

      @Override
      public List&lt;A&gt; eval() {
<span class="fc" id="L825">        return toList(as);</span>
      }
    };
  }

  /** Constructor function optimized for lists. */
  public static &lt;A&gt; IteratorMonadic&lt;A&gt; mlazy(final List&lt;A&gt; as) {
<span class="fc" id="L832">    return mlazy(as.iterator());</span>
  }

  private abstract static class Iter&lt;A&gt; implements Iterator&lt;A&gt; {
    @Override
    public final void remove() {
<span class="nc" id="L838">      throw new UnsupportedOperationException();</span>
    }
  }

  private static &lt;A&gt; Iterator&lt;A&gt; emptyIter() {
<span class="fc" id="L843">    return new Iter&lt;A&gt;() {</span>
      @Override
      public boolean hasNext() {
<span class="fc" id="L846">        return false;</span>
      }

      @Override
      public A next() {
<span class="nc" id="L851">        throw new NoSuchElementException();</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>