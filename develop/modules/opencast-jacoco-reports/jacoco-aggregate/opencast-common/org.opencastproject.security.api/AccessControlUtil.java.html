<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AccessControlUtil.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.security.api</a> &gt; <span class="el_source">AccessControlUtil.java</span></div><h1>AccessControlUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.security.api;

import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;
import static org.opencastproject.security.util.SecurityUtil.getEpisodeRoleId;
import static org.opencastproject.util.EqualsUtil.bothNotNull;
import static org.opencastproject.util.EqualsUtil.eqListUnsorted;
import static org.opencastproject.util.data.Either.left;
import static org.opencastproject.util.data.Either.right;
import static org.opencastproject.util.data.Monadics.mlist;

import org.opencastproject.util.Checksum;
import org.opencastproject.util.data.Either;
import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Function2;
import org.opencastproject.util.data.Tuple;

import org.apache.commons.lang3.StringUtils;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Provides common functions helpful in dealing with {@link AccessControlList}s.
 */
public final class AccessControlUtil {

  /** Disallow construction of this utility class */
  private AccessControlUtil() {
  }

  /**
   * Determines whether the {@link AccessControlList} permits a user to perform an action.
   *
   * There are three ways a user can be allowed to perform an action:
   * &lt;ol&gt;
   * &lt;li&gt;They have the superuser role&lt;/li&gt;
   * &lt;li&gt;They have their local organization's admin role&lt;/li&gt;
   * &lt;li&gt;They have a role listed in the series ACL, with write permission&lt;/li&gt;
   * &lt;/ol&gt;
   *
   * @param acl
   *          the {@link AccessControlList}
   * @param user
   *          the user
   * @param org
   *          the organization
   * @param action
   *          The action to perform. &lt;code&gt;action&lt;/code&gt; may be an arbitrary object. The authorization check is done on
   *          the string representation of the object (&lt;code&gt;#toString()&lt;/code&gt;). This allows to group actions as enums
   *          and use them without converting them to a string manually. See
   *          {@link org.opencastproject.security.api.Permissions.Action}.
   * @return whether this action should be allowed
   * @throws IllegalArgumentException
   *           if any of the arguments are null
   */
  public static boolean isAuthorized(AccessControlList acl, User user, Organization org, Object action) {
<span class="fc" id="L86">    return isAuthorized(acl, user, org, action, null);</span>
  }

  /**
   * Determines whether the {@link AccessControlList} permits a user to perform an action.
   *
   * There are three ways a user can be allowed to perform an action:
   * &lt;ol&gt;
   * &lt;li&gt;They have the superuser role&lt;/li&gt;
   * &lt;li&gt;They have their local organization's admin role&lt;/li&gt;
   * &lt;li&gt;They have a role listed in the series ACL, with write permission&lt;/li&gt;
   * &lt;/ol&gt;
   *
   * @param acl
   *          the {@link AccessControlList}
   * @param user
   *          the user
   * @param org
   *          the organization
   * @param action
   *          The action to perform. &lt;code&gt;action&lt;/code&gt; may be an arbitrary object. The authorization check is done on
   *          the string representation of the object (&lt;code&gt;#toString()&lt;/code&gt;). This allows to group actions as enums
   *          and use them without converting them to a string manually. See
   *          {@link org.opencastproject.security.api.Permissions.Action}.
   * @param mediaPackageId
   *          Only required if episodeRoleId is true.
   * @return whether this action should be allowed
   * @throws IllegalArgumentException
   *           if any of the arguments are null
   */
  public static boolean isAuthorized(AccessControlList acl, User user, Organization org, Object action,
      String mediaPackageId) {
<span class="pc bpc" id="L118" title="4 of 8 branches missed.">    if (action == null || user == null || acl == null || org == null) {</span>
<span class="nc" id="L119">      throw new IllegalArgumentException();</span>
    }

    // Check for the global and local admin role
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">    if (user.hasRole(GLOBAL_ADMIN_ROLE) || user.hasRole(org.getAdminRole())) {</span>
<span class="fc" id="L124">      return true;</span>
    }

    // Check for episode role ids, if activated
<span class="pc bpc" id="L128" title="3 of 4 branches missed.">    if (mediaPackageId != null &amp;&amp; user.hasRole(getEpisodeRoleId(mediaPackageId, action.toString()))) {</span>
<span class="nc" id="L129">        return true;</span>
    }

<span class="fc" id="L132">    Set&lt;Role&gt; userRoles = user.getRoles();</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">    for (AccessControlEntry entry : acl.getEntries()) {</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">      if (action.toString().equals(entry.getAction())) {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (Role role : userRoles) {</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">          if (role.getName().equals(entry.getRole())) {</span>
<span class="fc" id="L137">            return entry.isAllow();</span>
          }
<span class="fc" id="L139">        }</span>
      }
<span class="fc" id="L141">    }</span>

<span class="fc" id="L143">    return false;</span>
  }

  /**
   * {@link AccessControlUtil#isAuthorized(org.opencastproject.security.api.AccessControlList, org.opencastproject.security.api.User, org.opencastproject.security.api.Organization, Object)}
   * as a predicate function.
   */
  private static Predicate&lt;Object&gt; isAuthorizedFn(final AccessControlList acl, final User user, final Organization org) {
<span class="fc" id="L151">    return action -&gt; isAuthorized(acl, user, org, action);</span>
  }

  /**
   * Returns true only if &lt;em&gt;all&lt;/em&gt; actions are authorized.
   *
   * @see #isAuthorized(AccessControlList, User, Organization, Object)
   */
  public static boolean isAuthorizedAll(AccessControlList acl, User user, Organization org, Object... actions) {
<span class="fc" id="L160">    Predicate&lt;Object&gt; isAuthorized = isAuthorizedFn(acl, user, org);</span>
<span class="fc" id="L161">    return Arrays.stream(actions).allMatch(isAuthorized);</span>
  }

  /**
   * Returns true if at least &lt;em&gt;one&lt;/em&gt; action is authorized.
   *
   * @see #isAuthorized(AccessControlList, User, Organization, Object)
   */
  public static boolean isAuthorizedOne(AccessControlList acl, User user, Organization org, Object... actions) {
<span class="fc" id="L170">    Predicate&lt;Object&gt; isAuthorized = isAuthorizedFn(acl, user, org);</span>
<span class="fc" id="L171">    return Arrays.stream(actions).anyMatch(isAuthorized);</span>
  }

  /**
   * Returns true if &lt;em&gt;all&lt;/em&gt; actions are prohibited.
   *
   * @see #isAuthorized(AccessControlList, User, Organization, Object)
   */
  public static boolean isProhibitedAll(AccessControlList acl, User user, Organization org, Object... actions) {
<span class="fc" id="L180">    Predicate&lt;Object&gt; isAuthorized = isAuthorizedFn(acl, user, org);</span>
<span class="fc" id="L181">    return Arrays.stream(actions).noneMatch(isAuthorized);</span>
  }

  /**
   * Returns true if at least &lt;em&gt;one&lt;/em&gt; action is prohibited.
   *
   * @see #isAuthorized(AccessControlList, User, Organization, Object)
   */
  public static boolean isProhibitedOne(AccessControlList acl, User user, Organization org, Object... actions) {
<span class="fc" id="L190">    Predicate&lt;Object&gt; isAuthorized = isAuthorizedFn(acl, user, org);</span>
<span class="fc" id="L191">    return Arrays.stream(actions).anyMatch(isAuthorized.negate());</span>
  }

  /**
   * Extends an access control list with an access control entry
   *
   * @param acl
   *          the access control list to extend
   * @param role
   *          the access control entry role
   * @param action
   *          the access control entry action
   * @param allow
   *          whether this access control entry role is allowed to take this action
   * @return the extended access control list or the same if already contained
   */
  public static AccessControlList extendAcl(AccessControlList acl, String role, String action, boolean allow) {
<span class="fc" id="L208">    AccessControlList newAcl = new AccessControlList();</span>
<span class="fc" id="L209">    boolean foundAce = false;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">    for (AccessControlEntry ace : acl.getEntries()) {</span>
<span class="fc bfc" id="L211" title="All 4 branches covered.">      if (ace.getAction().equalsIgnoreCase(action) &amp;&amp; ace.getRole().equalsIgnoreCase(role)) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (ace.isAllow() == allow) {</span>
          // Entry is already the same so just return the acl
<span class="fc" id="L214">          return acl;</span>
        } else {
          // We need to change the allow on the one entry.
<span class="fc" id="L217">          foundAce = true;</span>
<span class="fc" id="L218">          newAcl.getEntries().add(new AccessControlEntry(role, action, allow));</span>
        }
      } else {
<span class="fc" id="L221">        newAcl.getEntries().add(ace);</span>
      }
<span class="fc" id="L223">    }</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">    if (!foundAce)</span>
<span class="fc" id="L225">      newAcl.getEntries().add(new AccessControlEntry(role, action, allow));</span>

<span class="fc" id="L227">    return newAcl;</span>
  }

  /**
   * Reduces an access control list by an access control entry
   *
   * @param acl
   *          the access control list to reduce
   * @param role
   *          the role of the access control entry to remove
   * @param action
   *          the action of the access control entry to remove
   * @return the reduced access control list or the same if already contained
   */
  public static AccessControlList reduceAcl(AccessControlList acl, String role, String action) {
<span class="fc" id="L242">    AccessControlList newAcl = new AccessControlList();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">    for (AccessControlEntry ace : acl.getEntries()) {</span>
<span class="fc bfc" id="L244" title="All 4 branches covered.">      if (!ace.getAction().equalsIgnoreCase(action) || !ace.getRole().equalsIgnoreCase(role)) {</span>
<span class="fc" id="L245">        newAcl.getEntries().add(ace);</span>
      }
<span class="fc" id="L247">    }</span>
<span class="fc" id="L248">    return newAcl;</span>
  }

  /**
   * Constructor function for ACLs.
   *
   * @see #entry(String, String, boolean)
   * @see #entries(String, org.opencastproject.util.data.Tuple[])
   */
  public static AccessControlList acl(Either&lt;AccessControlEntry, List&lt;AccessControlEntry&gt;&gt;... entries) {
    // sequence entries
<span class="fc" id="L259">    final List&lt;AccessControlEntry&gt; seq = mlist(entries)</span>
<span class="fc" id="L260">            .foldl(new ArrayList&lt;AccessControlEntry&gt;(),</span>
<span class="fc" id="L261">                    new Function2&lt;List&lt;AccessControlEntry&gt;, Either&lt;AccessControlEntry, List&lt;AccessControlEntry&gt;&gt;, List&lt;AccessControlEntry&gt;&gt;() {</span>
                      @Override
                      public List&lt;AccessControlEntry&gt; apply(List&lt;AccessControlEntry&gt; sum,
                              Either&lt;AccessControlEntry, List&lt;AccessControlEntry&gt;&gt; current) {
<span class="fc bfc" id="L265" title="All 2 branches covered.">                        if (current.isLeft())</span>
<span class="fc" id="L266">                          sum.add(current.left().value());</span>
                        else
<span class="fc" id="L268">                          sum.addAll(current.right().value());</span>
<span class="fc" id="L269">                        return sum;</span>
                      }
                    });
<span class="fc" id="L272">    return new AccessControlList(seq);</span>
  }

  /** Create a single access control entry. */
  public static Either&lt;AccessControlEntry, List&lt;AccessControlEntry&gt;&gt; entry(String role, String action, boolean allow) {
<span class="fc" id="L277">    return left(new AccessControlEntry(role, action, allow));</span>
  }

  /** Create a list of access control entries for a given role. */
  public static Either&lt;AccessControlEntry, List&lt;AccessControlEntry&gt;&gt; entries(final String role,
          Tuple&lt;String, Boolean&gt;... actions) {
<span class="fc" id="L283">    final List&lt;AccessControlEntry&gt; entries = mlist(actions).map(</span>
<span class="fc" id="L284">            new Function&lt;Tuple&lt;String, Boolean&gt;, AccessControlEntry&gt;() {</span>
              @Override
              public AccessControlEntry apply(Tuple&lt;String, Boolean&gt; action) {
<span class="fc" id="L287">                return new AccessControlEntry(role, action.getA(), action.getB());</span>
              }
<span class="fc" id="L289">            }).value();</span>
<span class="fc" id="L290">    return right(entries);</span>
  }

  /**
   * Define equality on AccessControlLists. Two AccessControlLists are considered equal if they contain the exact same
   * entries no matter in which order.
   * &lt;p&gt;
   * This has not been implemented in terms of #equals and #hashCode because the list of entries is not immutable and
   * therefore not suitable to be put in a set.
   */
  public static boolean equals(AccessControlList a, AccessControlList b) {
<span class="pc bpc" id="L301" title="1 of 4 branches missed.">    return bothNotNull(a, b) &amp;&amp; eqListUnsorted(a.getEntries(), b.getEntries());</span>
  }

  /** Calculate an MD5 checksum for an {@link AccessControlList}. */
  public static Checksum calculateChecksum(AccessControlList acl) {
    // Use 0 as a word separator. This is safe since none of the UTF-8 code points
    // except \u0000 contains a null byte when converting to a byte array.
<span class="fc" id="L308">    final byte[] sep = new byte[] { 0 };</span>

    // Sort ACL entries
<span class="fc" id="L311">    List&lt;AccessControlEntry&gt; sortedEntries = acl.getEntries().stream()</span>
<span class="fc" id="L312">        .sorted(sortAcl)</span>
<span class="fc" id="L313">        .collect(Collectors.toList());</span>

<span class="fc" id="L315">    MessageDigest digest = mkMd5MessageDigest();</span>

<span class="fc bfc" id="L317" title="All 2 branches covered.">    for (AccessControlEntry entry : sortedEntries) {</span>
<span class="fc" id="L318">      String[] fields = {</span>
<span class="fc" id="L319">          entry.getRole(),</span>
<span class="fc" id="L320">          entry.getAction(),</span>
<span class="fc" id="L321">          Boolean.toString(entry.isAllow())</span>
      };
<span class="fc bfc" id="L323" title="All 2 branches covered.">      for (String field : fields) {</span>
<span class="fc" id="L324">        digest.update(field.getBytes(StandardCharsets.UTF_8));</span>
        // add separator byte (see definition above)
<span class="fc" id="L326">        digest.update(sep);</span>
      }
<span class="fc" id="L328">    }</span>

    try {
<span class="fc" id="L331">      return Checksum.create(&quot;md5&quot;, Checksum.convertToHex(digest.digest()));</span>
<span class="nc" id="L332">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L333">      throw new RuntimeException(e);</span>
    }
  }

  private static MessageDigest mkMd5MessageDigest() {
    try {
<span class="fc" id="L339">      return MessageDigest.getInstance(&quot;MD5&quot;);</span>
<span class="nc" id="L340">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L341">      throw new RuntimeException(e);</span>
    }
  }

<span class="fc" id="L345">  private static Comparator&lt;AccessControlEntry&gt; sortAcl = new Comparator&lt;AccessControlEntry&gt;() {</span>
    @Override
    public int compare(AccessControlEntry o1, AccessControlEntry o2) {
      // compare role
<span class="fc" id="L349">      int compareTo = StringUtils.trimToEmpty(o1.getRole()).compareTo(StringUtils.trimToEmpty(o2.getRole()));</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">      if (compareTo != 0)</span>
<span class="fc" id="L351">        return compareTo;</span>

      // compare action
<span class="fc" id="L354">      compareTo = StringUtils.trimToEmpty(o1.getAction()).compareTo(StringUtils.trimToEmpty(o2.getAction()));</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">      if (compareTo != 0)</span>
<span class="fc" id="L356">        return compareTo;</span>

      // compare allow
<span class="nc" id="L359">      return Boolean.valueOf(o1.isAllow()).compareTo(o2.isAllow());</span>
    }
  };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>