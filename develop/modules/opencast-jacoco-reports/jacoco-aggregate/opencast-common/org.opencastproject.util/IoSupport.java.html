<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IoSupport.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.util</a> &gt; <span class="el_source">IoSupport.java</span></div><h1>IoSupport.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.util;

import static org.opencastproject.util.PathSupport.path;
import static org.opencastproject.util.data.Either.left;
import static org.opencastproject.util.data.Either.right;
import static org.opencastproject.util.data.Option.none;
import static org.opencastproject.util.data.Option.option;
import static org.opencastproject.util.data.Option.some;
import static org.opencastproject.util.data.functions.Misc.chuck;

import org.opencastproject.security.api.TrustedHttpClient;
import org.opencastproject.security.api.TrustedHttpClientException;
import org.opencastproject.util.data.Effect0;
import org.opencastproject.util.data.Either;
import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Function0;
import org.opencastproject.util.data.Function2;
import org.opencastproject.util.data.Option;

import com.google.common.io.Resources;

import org.apache.commons.io.IOUtils;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.Serializable;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.channels.FileLock;
import java.nio.charset.Charset;
import java.util.Properties;

import de.schlichtherle.io.FileWriter;

/**
 * Contains operations concerning IO.
 */
public final class IoSupport {

  /**
   * the logging facility provided by log4j
   */
<span class="fc" id="L79">  private static Logger logger = LoggerFactory.getLogger(IoSupport.class.getName());</span>

  public static String getSystemTmpDir() {
<span class="fc" id="L82">    String tmpdir = System.getProperty(&quot;java.io.tmpdir&quot;);</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">    if (tmpdir == null) {</span>
<span class="nc" id="L84">      tmpdir = File.separator + &quot;tmp&quot; + File.separator;</span>
    } else {
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">      if (!tmpdir.endsWith(File.separator)) {</span>
<span class="fc" id="L87">        tmpdir += File.separator;</span>
      }
    }
<span class="fc" id="L90">    return tmpdir;</span>
  }

  private IoSupport() {
  }

  /**
   * Closes a &lt;code&gt;Closable&lt;/code&gt; quietly so that no exceptions are thrown.
   *
   * @param s
   *          maybe null
   */
  public static boolean closeQuietly(final Closeable s) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">    if (s == null) {</span>
<span class="fc" id="L104">      return false;</span>
    }
    try {
<span class="fc" id="L107">      s.close();</span>
<span class="fc" id="L108">      return true;</span>
<span class="nc" id="L109">    } catch (IOException e) {</span>
<span class="nc" id="L110">      return false;</span>
    }
  }

  /**
   * Closes the processes input, output and error streams.
   *
   * @param process
   *          the process
   * @return &lt;code&gt;true&lt;/code&gt; if the streams were closed
   */
  public static boolean closeQuietly(final Process process) {
<span class="fc bfc" id="L122" title="All 2 branches covered.">    if (process != null) {</span>
<span class="fc" id="L123">      closeQuietly(process.getInputStream());</span>
<span class="fc" id="L124">      closeQuietly(process.getErrorStream());</span>
<span class="fc" id="L125">      closeQuietly(process.getOutputStream());</span>
<span class="fc" id="L126">      return true;</span>
    }
<span class="fc" id="L128">    return false;</span>
  }

  /**
   * Writes the contents variable to the {@code URL}. Note that the URL must be a local {@code URL}.
   *
   * @param file
   *          The {@code URL} of the local file you wish to write to.
   * @param contents
   *          The contents of the file you wish to create.
   * @throws IOException
   */
  public static void writeUTF8File(URL file, String contents) throws IOException {
    try {
<span class="fc" id="L142">      writeUTF8File(new File(file.toURI()), contents);</span>
<span class="nc" id="L143">    } catch (URISyntaxException e) {</span>
<span class="nc" id="L144">      throw new IOException(&quot;Couldn't parse the URL&quot;, e);</span>
<span class="fc" id="L145">    }</span>
<span class="fc" id="L146">  }</span>

  /**
   * Writes the contents variable to the {@code File}.
   *
   * @param file
   *          The {@code File} of the local file you wish to write to.
   * @param contents
   *          The contents of the file you wish to create.
   */
  public static void writeUTF8File(File file, String contents) throws IOException {
<span class="fc" id="L157">    writeUTF8File(file.getAbsolutePath(), contents);</span>
<span class="fc" id="L158">  }</span>

  /**
   * Writes the contents variable to the {@code File} located at the filename.
   *
   * @param filename
   *          The {@code File} of the local file you wish to write to.
   * @param contents
   *          The contents of the file you wish to create.
   */
  public static void writeUTF8File(String filename, String contents) throws IOException {
<span class="fc" id="L169">    FileWriter out = new FileWriter(filename);</span>
    try {
<span class="fc" id="L171">      out.write(contents);</span>
    } finally {
<span class="fc" id="L173">      closeQuietly(out);</span>
    }
<span class="fc" id="L175">  }</span>

  /**
   * Convenience method to read in a file from a local source.
   *
   * @param url
   *          The {@code URL} to read the source data from.
   * @return A String containing the source data or null in the case of an error.
   * @deprecated this method doesn't support UTF8 or handle HTTP response codes
   */
  @Deprecated
  public static String readFileFromURL(URL url) {
<span class="nc" id="L187">    return readFileFromURL(url, null);</span>
  }

  /**
   * Convenience method to read in a file from either a remote or local source.
   *
   * @param url
   *          The {@code URL} to read the source data from.
   * @param trustedClient
   *          The {@code TrustedHttpClient} which should be used to communicate with the remote server. This can be null
   *          for local file reads.
   * @return A String containing the source data or null in the case of an error.
   * @deprecated this method doesn't support UTF8 or handle HTTP response codes
   */
  @Deprecated
  public static String readFileFromURL(URL url, TrustedHttpClient trustedClient) {
<span class="nc" id="L203">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L204">    DataInputStream in = null;</span>
<span class="nc" id="L205">    HttpResponse response = null;</span>
    try {
      // Do different things depending on what we're reading...
<span class="nc bnc" id="L208" title="All 2 branches missed.">      if (&quot;file&quot;.equals(url.getProtocol())) {</span>
<span class="nc" id="L209">        in = new DataInputStream(url.openStream());</span>
      } else {
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (trustedClient == null) {</span>
<span class="nc" id="L212">          logger.error(&quot;Unable to read from remote source {} because trusted client is null!&quot;, url.getFile());</span>
<span class="nc" id="L213">          return null;</span>
        }
<span class="nc" id="L215">        HttpGet get = new HttpGet(url.toURI());</span>
        try {
<span class="nc" id="L217">          response = trustedClient.execute(get);</span>
<span class="nc" id="L218">        } catch (TrustedHttpClientException e) {</span>
<span class="nc" id="L219">          logger.warn(&quot;Unable to fetch file from {}.&quot;, url, e);</span>
<span class="nc" id="L220">          trustedClient.close(response);</span>
<span class="nc" id="L221">          return null;</span>
<span class="nc" id="L222">        }</span>
<span class="nc" id="L223">        in = new DataInputStream(response.getEntity().getContent());</span>
      }
<span class="nc" id="L225">      int c = 0;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">      while ((c = in.read()) != -1) {</span>
<span class="nc" id="L227">        sb.append((char) c);</span>
      }
<span class="nc" id="L229">    } catch (IOException e) {</span>
<span class="nc" id="L230">      logger.warn(&quot;IOException attempting to get file from {}.&quot;, url);</span>
<span class="nc" id="L231">      return null;</span>
<span class="nc" id="L232">    } catch (URISyntaxException e) {</span>
<span class="nc" id="L233">      logger.warn(&quot;URI error attempting to get file from {}.&quot;, url);</span>
<span class="nc" id="L234">      return null;</span>
<span class="nc" id="L235">    } catch (NullPointerException e) {</span>
<span class="nc" id="L236">      logger.warn(&quot;Nullpointer attempting to get file from {}.&quot;, url);</span>
<span class="nc" id="L237">      return null;</span>
    } finally {
<span class="nc" id="L239">      IOUtils.closeQuietly(in);</span>

<span class="nc bnc" id="L241" title="All 2 branches missed.">      if (response != null) {</span>
        try {
<span class="nc" id="L243">          trustedClient.close(response);</span>
<span class="nc" id="L244">        } catch (IOException e) {</span>
<span class="nc" id="L245">        }</span>
      }
    }

<span class="nc" id="L249">    return sb.toString();</span>
  }

  public static Properties loadPropertiesFromUrl(final URL url) {
    try {
<span class="nc" id="L254">      return loadPropertiesFromStream(url.openStream());</span>
<span class="nc" id="L255">    } catch (IOException e) {</span>
<span class="nc" id="L256">      return chuck(e);</span>
    }
  }

  /** Load properties from a stream. Close the stream after reading. */
  public static Properties loadPropertiesFromStream(final InputStream stream) {
<span class="nc" id="L262">    return withResource(stream, new Function.X&lt;InputStream, Properties&gt;() {</span>
      @Override
      public Properties xapply(InputStream in) throws Exception {
<span class="nc" id="L265">        final Properties p = new Properties();</span>
<span class="nc" id="L266">        p.load(in);</span>
<span class="nc" id="L267">        return p;</span>
      }
    });
  }

  /**
   * Handle a closeable resource inside &lt;code&gt;f&lt;/code&gt; and ensure it gets closed properly.
   */
  public static &lt;A, B extends Closeable&gt; A withResource(B b, Function&lt;B, A&gt; f) {
    try {
<span class="fc" id="L277">      return f.apply(b);</span>
    } finally {
<span class="fc" id="L279">      IoSupport.closeQuietly(b);</span>
    }
  }

  /**
   * Handle a closeable resource inside &lt;code&gt;f&lt;/code&gt; and ensure it gets closed properly.
   */
  public static &lt;A, B extends Closeable&gt; A withResource(B b, java.util.function.Function&lt;B, A&gt; f) {
    try {
<span class="nc" id="L288">      return f.apply(b);</span>
    } finally {
<span class="nc" id="L290">      IoSupport.closeQuietly(b);</span>
    }
  }

  /**
   * Open a classpath resource using the class loader of the given class.
   *
   * @return an input stream to the resource wrapped in a Some or none if the resource cannot be found
   */
  public static Option&lt;InputStream&gt; openClassPathResource(String resource, Class&lt;?&gt; clazz) {
<span class="fc" id="L300">    return option(clazz.getResourceAsStream(resource));</span>
  }

  /**
   * Open a classpath resource using the class loader of {@link IoSupport}.
   *
   * @see #openClassPathResource(String, Class)
   */
  public static Option&lt;InputStream&gt; openClassPathResource(String resource) {
<span class="fc" id="L309">    return openClassPathResource(resource, IoSupport.class);</span>
  }

  /** Get a classpath resource as a file using the class loader of {@link IoSupport}. */
  public static Option&lt;File&gt; classPathResourceAsFile(String resource) {
    try {
<span class="fc" id="L315">      final URL res = IoSupport.class.getResource(resource);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">      if (res != null) {</span>
<span class="fc" id="L317">        return Option.some(new File(res.toURI()));</span>
      } else {
<span class="nc" id="L319">        return Option.none();</span>
      }
<span class="nc" id="L321">    } catch (URISyntaxException e) {</span>
<span class="nc" id="L322">      return Option.none();</span>
    }
  }

  /**
   * Load a classpath resource into a string using UTF-8 encoding and the class loader of the given class.
   *
   * @return the content of the resource wrapped in a Some or none in case of any error
   */
  public static Option&lt;String&gt; loadFileFromClassPathAsString(String resource, Class&lt;?&gt; clazz) {
    try {
<span class="fc" id="L333">      final URL url = clazz.getResource(resource);</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">      return url != null ? some(Resources.toString(clazz.getResource(resource), Charset.forName(&quot;UTF-8&quot;)))</span>
<span class="nc" id="L335">              : none(String.class);</span>
<span class="nc" id="L336">    } catch (IOException e) {</span>
<span class="nc" id="L337">      return none();</span>
    }
  }

  /**
   * Load a classpath resource into a string using the class loader of {@link IoSupport}.
   *
   * @see #loadFileFromClassPathAsString(String, Class)
   */
  public static Option&lt;String&gt; loadFileFromClassPathAsString(String resource) {
<span class="fc" id="L347">    return loadFileFromClassPathAsString(resource, IoSupport.class);</span>
  }

  /**
   * Handle a stream inside &lt;code&gt;f&lt;/code&gt; and ensure that &lt;code&gt;s&lt;/code&gt; gets closed properly.
   * &lt;p&gt;
   * &lt;strong&gt;Please note:&lt;/strong&gt; The outcome of &lt;code&gt;f&lt;/code&gt; is wrapped into a some. Therefore &lt;code&gt;f&lt;/code&gt; is
   * &lt;em&gt;not&lt;/em&gt; allowed to return &lt;code&gt;null&lt;/code&gt;. Use an &lt;code&gt;Option&lt;/code&gt; instead and flatten the overall
   * result.
   *
   * @return none, if the file does not exist
   */
  public static &lt;A&gt; Option&lt;A&gt; withFile(File file, Function2&lt;InputStream, File, A&gt; f) {
<span class="fc" id="L360">    InputStream s = null;</span>
    try {
<span class="fc" id="L362">      s = new FileInputStream(file);</span>
<span class="fc" id="L363">      return some(f.apply(s, file));</span>
<span class="fc" id="L364">    } catch (FileNotFoundException ignore) {</span>
<span class="fc" id="L365">      return none();</span>
    } finally {
<span class="fc" id="L367">      IoSupport.closeQuietly(s);</span>
    }
  }

  /**
   * Handle a stream inside &lt;code&gt;f&lt;/code&gt; and ensure that &lt;code&gt;s&lt;/code&gt; gets closed properly.
   *
   * @param s
   *          the stream creation function
   * @param toErr
   *          error handler transforming an exception into something else
   * @param f
   *          stream handler
   * @deprecated use
   *             {@link #withResource(org.opencastproject.util.data.Function0, org.opencastproject.util.data.Function, org.opencastproject.util.data.Function)}
   *             instead
   */
  @Deprecated
  public static &lt;A, Err&gt; Either&lt;Err, A&gt; withStream(Function0&lt;InputStream&gt; s, Function&lt;Exception, Err&gt; toErr,
          Function&lt;InputStream, A&gt; f) {
<span class="nc" id="L387">    InputStream in = null;</span>
    try {
<span class="nc" id="L389">      in = s.apply();</span>
<span class="nc" id="L390">      return right(f.apply(in));</span>
<span class="nc" id="L391">    } catch (Exception e) {</span>
<span class="nc" id="L392">      return left(toErr.apply(e));</span>
    } finally {
<span class="nc" id="L394">      IoSupport.closeQuietly(in);</span>
    }
  }

  /**
   * Handle a closeable resource inside &lt;code&gt;f&lt;/code&gt; and ensure that &lt;code&gt;r&lt;/code&gt; gets closed properly.
   *
   * @param r
   *          resource creation function
   * @param toErr
   *          error handler transforming an exception into something else
   * @param f
   *          resource handler
   */
  public static &lt;A, Err, B extends Closeable&gt; Either&lt;Err, A&gt; withResource(Function0&lt;B&gt; r,
          Function&lt;Exception, Err&gt; toErr, Function&lt;B, A&gt; f) {
<span class="fc" id="L410">    B b = null;</span>
    try {
<span class="nc" id="L412">      b = r.apply();</span>
<span class="nc" id="L413">      return right(f.apply(b));</span>
<span class="fc" id="L414">    } catch (Exception e) {</span>
<span class="fc" id="L415">      return left(toErr.apply(e));</span>
    } finally {
<span class="fc" id="L417">      IoSupport.closeQuietly(b);</span>
    }
  }

  /**
   * Handle a stream inside &lt;code&gt;f&lt;/code&gt; and ensure that &lt;code&gt;s&lt;/code&gt; gets closed properly.
   *
   * @deprecated use {@link #withResource(java.io.Closeable, org.opencastproject.util.data.Function)} instead
   */
  @Deprecated
  public static &lt;A&gt; A withStream(OutputStream s, Function&lt;OutputStream, A&gt; f) {
    try {
<span class="nc" id="L429">      return f.apply(s);</span>
    } finally {
<span class="nc" id="L431">      IoSupport.closeQuietly(s);</span>
    }
  }

  /** Function that reads an input stream into a string using utf-8 encoding. Stream does not get closed. */
<span class="fc" id="L436">  public static final Function&lt;InputStream, String&gt; readToString = new Function.X&lt;InputStream, String&gt;() {</span>
    @Override
    public String xapply(InputStream in) throws IOException {
<span class="nc" id="L439">      return IOUtils.toString(in, &quot;utf-8&quot;);</span>
    }
  };

  /** Create a function that creates a {@link java.io.FileInputStream}. */
  public static Function0&lt;InputStream&gt; fileInputStream(final File a) {
<span class="fc" id="L445">    return new Function0.X&lt;InputStream&gt;() {</span>
      @Override
      public InputStream xapply() throws Exception {
<span class="nc" id="L448">        return new FileInputStream(a);</span>
      }
    };
  }

  /** Create a file from the list of path elements. */
  public static File file(String... pathElems) {
<span class="fc" id="L455">    return new File(path(pathElems));</span>
  }

  /**
   * Run function &lt;code&gt;f&lt;/code&gt; having exclusive read/write access to the given file.
   * &lt;p&gt;
   * Please note that the implementation uses Java NIO {@link java.nio.channels.FileLock} which only guarantees that two
   * Java processes cannot interfere with each other.
   * &lt;p&gt;
   * The implementation blocks until a lock can be acquired.
   *
   * @throws NotFoundException
   *            if the path to the file, to create a lock for, does not exist
   * @throws IOException
   *            if the file lock can not be created due to access limitations
   */
  public static synchronized &lt;A&gt; A locked(File file, Function&lt;File, A&gt; f) throws NotFoundException, IOException {
<span class="fc" id="L472">    final Effect0 key = acquireLock(file);</span>
    try {
<span class="fc" id="L474">      return f.apply(file);</span>
    } finally {
<span class="fc" id="L476">      key.apply();</span>
    }
  }

  /**
   * Acquire a lock on a file. Return a key to release the lock.
   *
   * @return a key to release the lock
   *
   * @throws NotFoundException
   *            if the path to the file, to create a lock for, does not exist
   * @throws IOException
   *            if the file lock can not be created due to access limitations
   */
  private static Effect0 acquireLock(File file) throws NotFoundException, IOException {
    final RandomAccessFile raf;
    try {
<span class="fc" id="L493">      raf = new RandomAccessFile(file, &quot;rw&quot;);</span>
<span class="fc" id="L494">    } catch (FileNotFoundException e) {</span>
      // this exception is thrown only if the directory path to the file isn't exist
      // make sure to create all parent directories before locking the file
<span class="fc" id="L497">      throw new NotFoundException(&quot;Error acquiring lock for &quot; + file.getAbsolutePath(), e);</span>
<span class="fc" id="L498">    }</span>
<span class="fc" id="L499">    final FileLock lock = raf.getChannel().lock();</span>
<span class="fc" id="L500">    return new Effect0() {</span>
      @Override
      protected void run() {
        try {
<span class="fc" id="L504">          lock.release();</span>
<span class="nc" id="L505">        } catch (IOException ignore) {</span>
<span class="fc" id="L506">        }</span>
<span class="fc" id="L507">        IoSupport.closeQuietly(raf);</span>
<span class="fc" id="L508">      }</span>
    };
  }

  /**
   * Serialize and deserialize an object. To test serializability.
   */
  public static &lt;A extends Serializable&gt; A serializeDeserialize(final A a) {
<span class="fc" id="L516">    final ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
    try {
<span class="fc" id="L518">      withResource(</span>
          new ObjectOutputStream(out),
<span class="fc" id="L520">          new Function&lt;ObjectOutputStream, Void&gt;() {</span>
            @Override
            public Void apply(ObjectOutputStream outStream) {
              try {
<span class="fc" id="L524">                outStream.writeObject(a);</span>
<span class="nc" id="L525">              } catch (IOException e) {</span>
<span class="nc" id="L526">                throw new RuntimeException(e);</span>
<span class="fc" id="L527">              }</span>
<span class="fc" id="L528">              return null;</span>
            }
          }
      );

<span class="fc" id="L533">      return withResource(</span>
<span class="fc" id="L534">          new ObjectInputStream(new ByteArrayInputStream(out.toByteArray())),</span>
<span class="fc" id="L535">          new Function&lt;ObjectInputStream, A&gt;() {</span>
            @Override
            public A apply(ObjectInputStream inStream) {
              try {
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L540">                A obj = (A) inStream.readObject();</span>
<span class="fc" id="L541">                return obj;</span>
<span class="nc" id="L542">              } catch (IOException | ClassNotFoundException e) {</span>
<span class="nc" id="L543">                throw new RuntimeException(e);</span>
              }
            }
          }
      );

<span class="nc" id="L549">    } catch (IOException e) {</span>
<span class="nc" id="L550">      throw new RuntimeException(e);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>