<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>JobUtil.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.util</a> &gt; <span class="el_source">JobUtil.java</span></div><h1>JobUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.util;

import static org.opencastproject.util.data.Collections.map;
import static org.opencastproject.util.data.Collections.toArray;
import static org.opencastproject.util.data.Option.none;
import static org.opencastproject.util.data.Option.some;
import static org.opencastproject.util.data.Tuple.tuple;

import org.opencastproject.job.api.Job;
import org.opencastproject.job.api.Job.Status;
import org.opencastproject.job.api.JobBarrier;
import org.opencastproject.job.api.JobParser;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Option;

import org.apache.http.HttpResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/** Job related utility functions. */
public final class JobUtil {
  /** The logger */
<span class="fc" id="L54">  private static final Logger logger = LoggerFactory.getLogger(JobUtil.class);</span>

  private JobUtil() {
  }

  /**
   * Update the job from the service registry and get its payload.
   *
   * @return the payload or none, if either to job cannot be found or if the job has no or an empty payload
   */
  public static Optional&lt;String&gt; getPayload(ServiceRegistry reg, Job job)
          throws NotFoundException, ServiceRegistryException {
<span class="fc" id="L66">    Optional&lt;Job&gt; updatedOpt = update(reg, job);</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">    if (updatedOpt.isPresent()) {</span>
<span class="fc" id="L68">      return Optional.ofNullable(updatedOpt.get().getPayload());</span>
    }
<span class="fc" id="L70">    return Optional.empty();</span>
  }

  /**
   * Get the latest state of a job. Does not modify the &lt;code&gt;job&lt;/code&gt; parameter.
   *
   * @return the updated job or none, if it cannot be found
   */
  public static Optional&lt;Job&gt; update(ServiceRegistry reg, Job job) throws ServiceRegistryException {
    try {
<span class="fc" id="L80">      return Optional.of(reg.getJob(job.getId()));</span>
<span class="fc" id="L81">    } catch (NotFoundException e) {</span>
<span class="fc" id="L82">      return Optional.empty();</span>
    }
  }

  /**
   * Waits for the result of a created barrier for &lt;code&gt;jobs&lt;/code&gt;, using &lt;code&gt;registry&lt;/code&gt; to poll for the
   * outcome of the monitored jobs using the default polling interval. The
   * &lt;code&gt;waiter&lt;/code&gt; is the job which is waiting for the other jobs to finish.
   *
   * @param waiter
   *          the job waiting for the other jobs to finish
   * @param reg
   *          the service registry
   * @param pollingInterval
   *          the time in miliseconds between two polling operations
   * @param timeout
   *          the maximum amount of time to wait
   * @param jobs
   *          the jobs to monitor
   * @return the job barrier result
   */
  public static JobBarrier.Result waitForJobs(Job waiter, ServiceRegistry reg, long pollingInterval, long timeout,
          Job... jobs) {
<span class="fc" id="L105">    JobBarrier barrier = new JobBarrier(waiter, reg, pollingInterval, jobs);</span>
<span class="fc" id="L106">    return barrier.waitForJobs(timeout);</span>
  }

  /**
   * Waits for the result of a created barrier for &lt;code&gt;jobs&lt;/code&gt;, using &lt;code&gt;registry&lt;/code&gt; to poll for the
   * outcome of the monitored jobs using the default polling interval. The
   * &lt;code&gt;waiter&lt;/code&gt; is the job which is waiting for the other jobs to finish.
   *
   * @param waiter
   *          the job waiting for the other jobs to finish
   * @param reg
   *          the service registry
   * @param timeout
   *          the maximum amount of time to wait
   * @param jobs
   *          the jobs to monitor
   * @return the job barrier result
   */
  public static JobBarrier.Result waitForJobs(Job waiter, ServiceRegistry reg, long timeout, Job... jobs) {
<span class="fc" id="L125">    return waitForJobs(waiter, reg, JobBarrier.DEFAULT_POLLING_INTERVAL, timeout, jobs);</span>
  }

  /**
   * Waits for the result of a created barrier for &lt;code&gt;jobs&lt;/code&gt;, using &lt;code&gt;registry&lt;/code&gt; to poll for the
   * outcome of the monitored jobs using the default polling interval. The
   * &lt;code&gt;waiter&lt;/code&gt; is the job which is waiting for the other jobs to finish.
   *
   * @param waiter
   *          the job waiting for the other jobs to finish
   * @param reg
   *          the service registry
   * @param jobs
   *          the jobs to monitor
   * @return the job barrier result
   */
  public static JobBarrier.Result waitForJobs(Job waiter, ServiceRegistry reg, Job... jobs) {
<span class="fc" id="L142">    return waitForJobs(waiter, reg, 0L, jobs);</span>
  }

  /**
   * Waits for the result of a created barrier for &lt;code&gt;jobs&lt;/code&gt;, using &lt;code&gt;registry&lt;/code&gt; to poll for the
   * outcome of the monitored jobs using the default polling interval.
   *
   * @param reg
   *          the service registry
   * @param jobs
   *          the jobs to monitor
   * @return the job barrier result
   */
  public static JobBarrier.Result waitForJobs(ServiceRegistry reg, Job... jobs) {
<span class="nc" id="L156">    return waitForJobs(null, reg, jobs);</span>
  }

  /**
   * Waits for the result of a created barrier for &lt;code&gt;jobs&lt;/code&gt;, using &lt;code&gt;registry&lt;/code&gt; to poll for the
   * outcome of the monitored jobs using the default polling interval. The
   * &lt;code&gt;waiter&lt;/code&gt; is the job which is waiting for the other jobs to finish.
   *
   * @param waiter
   *          the job waiting for the other jobs to finish
   * @param reg
   *          the service registry
   * @param jobs
   *          the jobs to monitor
   * @return the job barrier result
   */
  public static JobBarrier.Result waitForJobs(Job waiter, ServiceRegistry reg, Collection&lt;Job&gt; jobs) {
<span class="fc" id="L173">    return waitForJobs(waiter, reg, toArray(Job.class, jobs));</span>
  }

  /**
   * Waits for the result of a created barrier for &lt;code&gt;jobs&lt;/code&gt;, using &lt;code&gt;registry&lt;/code&gt; to poll for the
   * outcome of the monitored jobs using the default polling interval.
   *
   * @param reg
   *          the service registry
   * @param jobs
   *          the jobs to monitor
   * @return the job barrier result
   */
  public static JobBarrier.Result waitForJobs(ServiceRegistry reg, Collection&lt;Job&gt; jobs) {
<span class="fc" id="L187">    return waitForJobs(null, reg, jobs);</span>
  }

  /** Check if &lt;code&gt;job&lt;/code&gt; is not done yet and wait in case. */
  public static JobBarrier.Result waitForJob(Job waiter, ServiceRegistry reg, Option&lt;Long&gt; timeout, Job job) {
<span class="fc" id="L192">    final Job.Status status = job.getStatus();</span>
    // only create a barrier if the job is not done yet
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">    switch (status) {</span>
      case CANCELLED:
      case DELETED:
      case FAILED:
      case FINISHED:
<span class="fc" id="L199">        return new JobBarrier.Result(map(tuple(job, status)));</span>
      default:
<span class="nc bnc" id="L201" title="All 2 branches missed.">        for (Long t : timeout)</span>
<span class="nc" id="L202">          return waitForJobs(waiter, reg, t, job);</span>
<span class="nc" id="L203">        return waitForJobs(waiter, reg, job);</span>
    }
  }

  /** Check if &lt;code&gt;job&lt;/code&gt; is not done yet and wait in case. */
  public static JobBarrier.Result waitForJob(ServiceRegistry reg, Option&lt;Long&gt; timeout, Job job) {
<span class="fc" id="L209">    return waitForJob(null, reg, timeout, job);</span>
  }

  /**
   * Check if &lt;code&gt;job&lt;/code&gt; is not done yet and wait in case.
   *
   * @param waiter
   *          the job waiting for the other jobs to finish
   * @param reg
   *          the service registry
   * @param job
   *          the job to monitor
   * @return the job barrier result
   */
  public static JobBarrier.Result waitForJob(Job waiter, ServiceRegistry reg, Job job) {
<span class="fc" id="L224">    return waitForJob(waiter, reg, none(0L), job);</span>
  }

  /** Check if &lt;code&gt;job&lt;/code&gt; is not done yet and wait in case. */
  public static JobBarrier.Result waitForJob(ServiceRegistry reg, Job job) {
<span class="fc" id="L229">    return waitForJob(null, reg, none(0L), job);</span>
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if the job is ready to be dispatched.
   *
   * @param job
   *          the job
   * @return &lt;code&gt;true&lt;/code&gt; whether the job is ready to be dispatched
   * @throws IllegalStateException
   *           if the job status is unknown
   */
  public static boolean isReadyToDispatch(Job job) throws IllegalStateException {
<span class="pc bpc" id="L242" title="1 of 3 branches missed.">    switch (job.getStatus()) {</span>
      case CANCELLED:
      case DELETED:
      case FAILED:
      case FINISHED:
<span class="fc" id="L247">        return false;</span>
      case DISPATCHING:
      case INSTANTIATED:
      case PAUSED:
      case QUEUED:
      case RESTART:
      case RUNNING:
      case WAITING:
<span class="fc" id="L255">        return true;</span>
      default:
<span class="nc" id="L257">        throw new IllegalStateException(&quot;Found job in unknown state '&quot; + job.getStatus() + &quot;'&quot;);</span>
    }
  }

  /** Wait for the job to complete and return the success value. */
  public static Function&lt;Job, Boolean&gt; waitForJobSuccess(final Job waiter, final ServiceRegistry reg,
          final Option&lt;Long&gt; timeout) {
<span class="fc" id="L264">    return new Function&lt;Job, Boolean&gt;() {</span>
      @Override
      public Boolean apply(Job job) {
<span class="fc" id="L267">        return waitForJob(waiter, reg, timeout, job).isSuccess();</span>
      }
    };
  }

  /**
   * Interpret the payload of a completed {@link Job} as a {@link MediaPackageElement}. Wait for the job to complete if
   * necessary.
   *
   */
  public static Function&lt;Job, MediaPackageElement&gt; payloadAsMediaPackageElement(final Job waiter,
          final ServiceRegistry reg) {
<span class="fc" id="L279">    return new Function.X&lt;Job, MediaPackageElement&gt;() {</span>
      @Override
      public MediaPackageElement xapply(Job job) throws MediaPackageException {
<span class="fc" id="L282">        waitForJob(waiter, reg, none(0L), job);</span>
<span class="fc" id="L283">        return MediaPackageElementParser.getFromXml(job.getPayload());</span>
      }
    };
  }

  /**
   * Interpret the payload of a completed {@link Job} as a {@link MediaPackageElement}. Wait for the job to complete if
   * necessary.
   */
  public static Function&lt;Job, MediaPackageElement&gt; payloadAsMediaPackageElement(final ServiceRegistry reg) {
<span class="fc" id="L293">    return payloadAsMediaPackageElement(null, reg);</span>
  }

<span class="fc" id="L296">  public static final Function&lt;HttpResponse, Option&lt;Job&gt;&gt; jobFromHttpResponse = new Function&lt;HttpResponse, Option&lt;Job&gt;&gt;() {</span>
    @Override
    public Option&lt;Job&gt; apply(HttpResponse response) {
      try {
<span class="fc" id="L300">        return some(JobParser.parseJob(response.getEntity().getContent()));</span>
<span class="fc" id="L301">      } catch (Exception e) {</span>
<span class="fc" id="L302">        logger.error(&quot;Error parsing Job from HTTP response&quot;, e);</span>
<span class="fc" id="L303">        return none();</span>
      }
    }
  };

  /** Sum up the queue time of a list of jobs. */
  public static long sumQueueTime(List&lt;Job&gt; jobs) {
<span class="fc" id="L310">    return jobs.stream()</span>
<span class="fc" id="L311">        .mapToLong(Job::getQueueTime)</span>
<span class="fc" id="L312">        .sum();</span>
  }

  /** Get all jobs that are not in state {@link org.opencastproject.job.api.Job.Status#FINISHED}. */
  public static List&lt;Job&gt; getNonFinished(List&lt;Job&gt; jobs) {
<span class="fc" id="L317">    return jobs.stream()</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">        .filter(job -&gt; !job.getStatus().equals(Status.FINISHED))</span>
<span class="fc" id="L319">        .collect(Collectors.toList());</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>