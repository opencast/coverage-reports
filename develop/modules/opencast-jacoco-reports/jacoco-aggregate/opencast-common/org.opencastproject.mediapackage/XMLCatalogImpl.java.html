<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>XMLCatalogImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.mediapackage</a> &gt; <span class="el_source">XMLCatalogImpl.java</span></div><h1>XMLCatalogImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.mediapackage;

import static java.lang.String.format;
import static javax.xml.XMLConstants.DEFAULT_NS_PREFIX;
import static javax.xml.XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI;
import static javax.xml.XMLConstants.XMLNS_ATTRIBUTE;
import static javax.xml.XMLConstants.XML_NS_URI;
import static org.opencastproject.util.EqualsUtil.hash;

import org.opencastproject.util.RequireUtil;
import org.opencastproject.util.XmlNamespaceBinding;
import org.opencastproject.util.XmlNamespaceContext;
import org.opencastproject.util.XmlSafeParser;

import org.apache.commons.lang3.StringUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.bootstrap.DOMImplementationRegistry;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSOutput;
import org.w3c.dom.ls.LSSerializer;
import org.xml.sax.Attributes;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

/**
 * This is a basic implementation for handling simple catalogs of metadata. It provides utility methods to store
 * key-value data.
 * &lt;p&gt;
 * For a definition of the terms &lt;dfn&gt;expanded name&lt;/dfn&gt;, &lt;dfn&gt;qualified name&lt;/dfn&gt; or &lt;dfn&gt;QName&lt;/dfn&gt;, &lt;dfn&gt;namespace
 * prefix&lt;/dfn&gt;, &lt;dfn&gt;local part&lt;/dfn&gt; and &lt;dfn&gt;local name&lt;/dfn&gt;, please see &lt;a
 * href=&quot;http://www.w3.org/TR/REC-xml-names&quot;&gt;http://www.w3.org/TR/REC-xml-names&lt;/a&gt;
 * &lt;p&gt;
 * By default the following namespace prefixes are bound:
 * &lt;ul&gt;
 * &lt;li&gt;xml - http://www.w3.org/XML/1998/namespace
 * &lt;li&gt;xmlns - http://www.w3.org/2000/xmlns/
 * &lt;li&gt;xsi - http://www.w3.org/2001/XMLSchema-instance
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;h2&gt;Limitations&lt;/h2&gt;
 * XMLCatalog supports only &lt;em&gt;one&lt;/em&gt; prefix binding per namespace name, so you cannot create documents like the
 * following using XMLCatalog:
 *
 * &lt;pre&gt;
 * &amp;lt;root xmlns:x=&amp;quot;http://x.demo.org&amp;quot; xmlns:y=&amp;quot;http://x.demo.org&amp;quot;&amp;gt;
 *   &amp;lt;x:elem&amp;gt;value&amp;lt;/x:elem&amp;gt;
 *   &amp;lt;y:elem&amp;gt;value&amp;lt;/y:elem&amp;gt;
 * &amp;lt;/root&amp;gt;
 * &lt;/pre&gt;
 *
 * However, reading of those documents is supported.
 */
public abstract class XMLCatalogImpl extends CatalogImpl implements XMLCatalog {
  private static final long serialVersionUID = -7580292199527168951L;

  /** Expanded name of the XML language attribute &lt;code&gt;xml:lang&lt;/code&gt;. */
<span class="fc" id="L98">  public static final EName XML_LANG_ATTR = new EName(XML_NS_URI, &quot;lang&quot;);</span>

  /** Namespace prefix for XML schema instance. */
  public static final String XSI_NS_PREFIX = &quot;xsi&quot;;

  /** To marshaling empty fields to remove existing values during merge, default is not to marshal empty elements */
<span class="fc" id="L104">  protected boolean includeEmpty = false;</span>

  /**
   * Expanded name of the XSI type attribute.
   * &lt;p&gt;
   * See &lt;a href=&quot;http://www.w3.org/TR/xmlschema-1/#xsi_type&quot;&gt;http://www.w3.org/TR/xmlschema-1/#xsi_type&lt;/a&gt; for the
   * definition.
   */
<span class="fc" id="L112">  public static final EName XSI_TYPE_ATTR = new EName(W3C_XML_SCHEMA_INSTANCE_NS_URI, &quot;type&quot;);</span>

  /** Key (QName) value meta data */
<span class="fc" id="L115">  protected final Map&lt;EName, List&lt;CatalogEntry&gt;&gt; data = new HashMap&lt;&gt;();</span>

  /** Namespace - prefix bindings */
  protected XmlNamespaceContext bindings;

  /**
   * Create an empty catalog and register the {@link javax.xml.XMLConstants#W3C_XML_SCHEMA_INSTANCE_NS_URI}
   * namespace.
   */
  protected XMLCatalogImpl() {
<span class="fc" id="L125">    super();</span>
<span class="fc" id="L126">    bindings = XmlNamespaceContext.mk(XSI_NS_PREFIX, W3C_XML_SCHEMA_INSTANCE_NS_URI);</span>
<span class="fc" id="L127">  }</span>

  protected void addBinding(XmlNamespaceBinding binding) {
<span class="nc" id="L130">    bindings = bindings.add(binding);</span>
<span class="nc" id="L131">  }</span>

  protected XmlNamespaceContext getBindings() {
<span class="nc" id="L134">    return bindings;</span>
  }

  /**
   * Clears the catalog.
   */
  protected void clear() {
<span class="nc" id="L141">    data.clear();</span>
<span class="nc" id="L142">  }</span>

  /**
   * Adds the element to the metadata collection.
   *
   * @param element
   *          the expanded name of the element
   * @param value
   *          the value
   */
  protected void addElement(EName element, String value) {
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">    if (element == null)</span>
<span class="nc" id="L154">      throw new IllegalArgumentException(&quot;Expanded name must not be null&quot;);</span>

<span class="fc" id="L156">    addElement(new CatalogEntry(element, value, NO_ATTRIBUTES));</span>
<span class="fc" id="L157">  }</span>

  /**
   * Adds the element with the &lt;code&gt;xml:lang&lt;/code&gt; attribute to the metadata collection.
   *
   * @param element
   *          the expanded name of the element
   * @param value
   *          the value
   * @param language
   *          the language identifier (two letter ISO 639)
   */
  protected void addLocalizedElement(EName element, String value, String language) {
<span class="fc" id="L170">    RequireUtil.notNull(element, &quot;expanded name&quot;);</span>
<span class="fc" id="L171">    RequireUtil.notNull(language, &quot;language&quot;);</span>

<span class="fc" id="L173">    Map&lt;EName, String&gt; attributes = new HashMap&lt;&gt;(1);</span>
<span class="fc" id="L174">    attributes.put(XML_LANG_ATTR, language);</span>
<span class="fc" id="L175">    addElement(new CatalogEntry(element, value, attributes));</span>
<span class="fc" id="L176">  }</span>

  /**
   * Adds the element with the &lt;code&gt;xsi:type&lt;/code&gt; attribute to the metadata collection.
   *
   * @param value
   *          the value
   * @param type
   *          the element type
   */
  protected void addTypedElement(EName element, String value, EName type) {
<span class="fc" id="L187">    RequireUtil.notNull(element, &quot;expanded name&quot;);</span>
<span class="fc" id="L188">    RequireUtil.notNull(type, &quot;type&quot;);</span>

<span class="fc" id="L190">    Map&lt;EName, String&gt; attributes = new HashMap&lt;&gt;(1);</span>
<span class="fc" id="L191">    attributes.put(XSI_TYPE_ATTR, toQName(type));</span>
<span class="fc" id="L192">    addElement(new CatalogEntry(element, value, attributes));</span>
<span class="fc" id="L193">  }</span>

  /**
   * Adds an element with the &lt;code&gt;xml:lang&lt;/code&gt; and &lt;code&gt;xsi:type&lt;/code&gt; attributes to the metadata collection.
   *
   * @param element
   *          the expanded name of the element
   * @param value
   *          the value
   * @param language
   *          the language identifier (two letter ISO 639)
   * @param type
   *          the element type
   */
  protected void addTypedLocalizedElement(EName element, String value, String language, EName type) {
<span class="nc bnc" id="L208" title="All 2 branches missed.">    if (element == null)</span>
<span class="nc" id="L209">      throw new IllegalArgumentException(&quot;EName name must not be null&quot;);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">    if (type == null)</span>
<span class="nc" id="L211">      throw new IllegalArgumentException(&quot;Type must not be null&quot;);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">    if (language == null)</span>
<span class="nc" id="L213">      throw new IllegalArgumentException(&quot;Language must not be null&quot;);</span>

<span class="nc" id="L215">    Map&lt;EName, String&gt; attributes = new HashMap&lt;&gt;(2);</span>
<span class="nc" id="L216">    attributes.put(XML_LANG_ATTR, language);</span>
<span class="nc" id="L217">    attributes.put(XSI_TYPE_ATTR, toQName(type));</span>
<span class="nc" id="L218">    addElement(new CatalogEntry(element, value, attributes));</span>
<span class="nc" id="L219">  }</span>

  /**
   * Adds an element with attributes to the catalog.
   *
   * @param element
   *          the expanded name of the element
   * @param value
   *          the element's value
   * @param attributes
   *          the attributes. May be null
   */
  protected void addElement(EName element, String value, Attributes attributes) {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">    if (element == null)</span>
<span class="nc" id="L233">      throw new IllegalArgumentException(&quot;Expanded name must not be null&quot;);</span>

<span class="fc" id="L235">    Map&lt;EName, String&gt; attributeMap = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">    if (attributes != null) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">      for (int i = 0; i &lt; attributes.getLength(); i++) {</span>
<span class="fc" id="L238">        attributeMap.put(new EName(attributes.getURI(i), attributes.getLocalName(i)), attributes.getValue(i));</span>
      }
    }
<span class="fc" id="L241">    addElement(new CatalogEntry(element, value, attributeMap));</span>
<span class="fc" id="L242">  }</span>

  /**
   * Adds the catalog element to the list of elements.
   *
   * @param element
   *          the element
   */
  private void addElement(CatalogEntry element) {

    // Option includeEmpty allows marshaling empty elements
    // for deleting existing values during a catalog merge
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">    if (element == null)</span>
<span class="nc" id="L255">      return;</span>
<span class="fc bfc" id="L256" title="All 4 branches covered.">    if (StringUtils.trimToNull(element.getValue()) == null &amp;&amp; !includeEmpty)</span>
<span class="fc" id="L257">      return;</span>
<span class="fc" id="L258">    List&lt;CatalogEntry&gt; values = data.get(element.getEName());</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">    if (values == null) {</span>
<span class="fc" id="L260">      values = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L261">      data.put(element.getEName(), values);</span>
    }
<span class="fc" id="L263">    values.add(element);</span>
<span class="fc" id="L264">  }</span>

  /**
   * Completely removes an element.
   *
   * @param element
   *          the expanded name of the element
   */
  protected void removeElement(EName element) {
<span class="fc" id="L273">    removeValues(element, null, true);</span>
<span class="fc" id="L274">  }</span>

  /**
   * Removes all entries in a certain language from an element.
   *
   * @param element
   *          the expanded name of the element
   * @param language
   *          the language code (two letter ISO 639) or null to &lt;em&gt;only&lt;/em&gt; remove entries without an
   *          &lt;code&gt;xml:lang&lt;/code&gt; attribute
   */
  protected void removeLocalizedValues(EName element, String language) {
<span class="fc" id="L286">    removeValues(element, language, false);</span>
<span class="fc" id="L287">  }</span>

  /**
   * Removes values from an element or the complete element from the catalog.
   *
   * @param element
   *          the expanded name of the element
   * @param language
   *          the language code (two letter ISO 639) to remove or null to remove entries without language code
   * @param all
   *          true - remove all entries for that element. This parameter overrides the language parameter.
   */
  private void removeValues(EName element, String language, boolean all) {
<span class="fc bfc" id="L300" title="All 2 branches covered.">    if (all) {</span>
<span class="fc" id="L301">      data.remove(element);</span>
    } else {
<span class="fc" id="L303">      List&lt;CatalogEntry&gt; entries = data.get(element);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">      if (entries != null) {</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        for (Iterator&lt;CatalogEntry&gt; i = entries.iterator(); i.hasNext();) {</span>
<span class="fc" id="L306">          CatalogEntry entry = i.next();</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">          if (equal(language, entry.getAttribute(XML_LANG_ATTR))) {</span>
<span class="fc" id="L308">            i.remove();</span>
          }
<span class="fc" id="L310">        }</span>
      }
    }
<span class="fc" id="L313">  }</span>

  /**
   * Returns the values that are associated with the specified key.
   *
   * @param element
   *          the expanded name of the element
   * @return the elements
   */
  protected CatalogEntry[] getValues(EName element) {
<span class="fc" id="L323">    List&lt;CatalogEntry&gt; values = data.get(element);</span>
<span class="pc bpc" id="L324" title="2 of 4 branches missed.">    if (values != null &amp;&amp; values.size() &gt; 0) {</span>
<span class="fc" id="L325">      return values.toArray(new CatalogEntry[values.size()]);</span>
    }
<span class="nc" id="L327">    return new CatalogEntry[] {};</span>
  }

  protected List&lt;CatalogEntry&gt; getEntriesSorted() {
<span class="fc" id="L331">    return data.values().stream()</span>
<span class="fc" id="L332">        .flatMap(List::stream)</span>
<span class="fc" id="L333">        .sorted(catalogEntryComparator)</span>
<span class="fc" id="L334">        .collect(Collectors.toList());</span>
  }

  /**
   * Returns the values that are associated with the specified key.
   *
   * @param element
   *          the expanded name of the element
   * @return all values of the element or an empty list if this element does not exist or does not have any values
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  protected List&lt;CatalogEntry&gt; getValuesAsList(EName element) {
<span class="fc" id="L346">    List&lt;CatalogEntry&gt; values = data.get(element);</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">    return values != null ? values : Collections.EMPTY_LIST;</span>
  }

  /**
   * Returns the values that are associated with the specified key.
   *
   * @param element
   *          the expandend name of the element
   * @param language
   *          a language code or null to get values without &lt;code&gt;xml:lang&lt;/code&gt; attribute
   * @return all values of the element
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  protected List&lt;CatalogEntry&gt; getLocalizedValuesAsList(EName element, String language) {
<span class="fc" id="L361">    List&lt;CatalogEntry&gt; values = data.get(element);</span>

<span class="pc bpc" id="L363" title="1 of 2 branches missed.">    if (values != null) {</span>
<span class="fc" id="L364">      List&lt;CatalogEntry&gt; filtered = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">      for (CatalogEntry value : values) {</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (equal(language, value.getAttribute(XML_LANG_ATTR))) {</span>
<span class="fc" id="L367">          filtered.add(value);</span>
        }
<span class="fc" id="L369">      }</span>
<span class="fc" id="L370">      return filtered;</span>
    } else {
<span class="nc" id="L372">      return Collections.EMPTY_LIST;</span>
    }
  }

  /**
   * Returns the first value that is associated with the specified name.
   *
   * @param element
   *          the expanded name of the element
   * @return the first value
   */
  protected CatalogEntry getFirstValue(EName element) {
<span class="nc" id="L384">    List&lt;CatalogEntry&gt; elements = data.get(element);</span>
<span class="nc bnc" id="L385" title="All 4 branches missed.">    if (elements != null &amp;&amp; elements.size() &gt; 0) {</span>
<span class="nc" id="L386">      return elements.get(0);</span>
    }
<span class="nc" id="L388">    return null;</span>
  }

  /**
   * Returns the first element that is associated with the specified name and attribute.
   *
   * @param element
   *          the expanded name of the element
   * @param attributeEName
   *          the expanded attribute name
   * @param attributeValue
   *          the attribute value
   * @return the first value
   */
  protected CatalogEntry getFirstValue(EName element, EName attributeEName, String attributeValue) {
<span class="fc" id="L403">    List&lt;CatalogEntry&gt; elements = data.get(element);</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">    if (elements != null) {</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">      for (CatalogEntry entry : elements) {</span>
<span class="fc" id="L406">        String v = entry.getAttribute(attributeEName);</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (equal(attributeValue, v))</span>
<span class="fc" id="L408">          return entry;</span>
<span class="fc" id="L409">      }</span>
    }
<span class="fc" id="L411">    return null;</span>
  }

  /**
   * Returns the first value that is associated with the specified name and language.
   *
   * @param element
   *          the expanded name of the element
   * @param language
   *          the language identifier or null to get only elements without &lt;code&gt;xml:lang&lt;/code&gt; attribute
   * @return the first value
   */
  protected CatalogEntry getFirstLocalizedValue(EName element, String language) {
<span class="fc" id="L424">    return getFirstValue(element, XML_LANG_ATTR, language);</span>
  }

  /**
   * Returns the first value that is associated with the specified name and language.
   *
   * @param element
   *          the expanded name of the element
   * @param type
   *          the &lt;code&gt;xsi:type&lt;/code&gt; value
   * @return the element
   */
  protected CatalogEntry getFirstTypedValue(EName element, String type) {
<span class="nc" id="L437">    return getFirstValue(element, XSI_TYPE_ATTR, type);</span>
  }

  /**
   * Tests two objects for equality.
   */
  protected boolean equal(Object a, Object b) {
<span class="fc bfc" id="L444" title="All 8 branches covered.">    return (a == null &amp;&amp; b == null) || (a != null &amp;&amp; a.equals(b));</span>
  }

  /**
   * Creates an xml document root and returns it.
   *
   * @return the document
   * @throws ParserConfigurationException
   *           If the xml parser environment is not correctly configured
   */
  protected Document newDocument() throws ParserConfigurationException {
<span class="nc" id="L455">    DocumentBuilderFactory docBuilderFactory = XmlSafeParser.newDocumentBuilderFactory();</span>
<span class="nc" id="L456">    docBuilderFactory.setNamespaceAware(true);</span>
<span class="nc" id="L457">    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();</span>
<span class="nc" id="L458">    return docBuilder.newDocument();</span>
  }

  /**
   * @see org.opencastproject.mediapackage.AbstractMediaPackageElement#toManifest(org.w3c.dom.Document,
   *      org.opencastproject.mediapackage.MediaPackageSerializer)
   */
  @Override
  public Node toManifest(Document document, MediaPackageSerializer serializer) throws MediaPackageException {
<span class="nc" id="L467">    return super.toManifest(document, serializer);</span>
  }

  /**
   * Get a prefix from {@link #bindings} but throw a {@link NamespaceBindingException} if none found.
   */
  protected String getPrefix(String namespaceURI) {
<span class="fc" id="L474">    final String prefix = bindings.getPrefix(namespaceURI);</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">    if (prefix != null) {</span>
<span class="fc" id="L476">      return prefix;</span>
    } else {
<span class="fc" id="L478">      throw new NamespaceBindingException(format(&quot;Namespace URI %s is not bound to a prefix&quot;, namespaceURI));</span>
    }
  }

  /**
   * @see org.opencastproject.mediapackage.XMLCatalog#includeEmpty(boolean)
   */
  @Override
  public
  void includeEmpty(boolean includeEmpty) {
<span class="fc" id="L488">    this.includeEmpty = includeEmpty;</span>
<span class="fc" id="L489">  }</span>

  /**
   * Transform an expanded name to a qualified name based on the registered binding.
   *
   * @param eName
   *          the expanded name to transform
   * @return the qualified name, e.g. &lt;code&gt;dcterms:title&lt;/code&gt;
   * @throws NamespaceBindingException
   *           if the namespace name is not bound to a prefix
   */
  protected String toQName(EName eName) {
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">    if (eName.hasNamespace()) {</span>
<span class="fc" id="L502">      return toQName(getPrefix(eName.getNamespaceURI()), eName.getLocalName());</span>
    } else {
<span class="nc" id="L504">      return eName.getLocalName();</span>
    }
  }

  /**
   * Transform an qualified name consisting of prefix and local part to an expanded name, based on the registered
   * binding.
   *
   * @param prefix
   *          the prefix
   * @param localName
   *          the local part
   * @return the expanded name
   * @throws NamespaceBindingException
   *           if the namespace name is not bound to a prefix
   */
  protected EName toEName(String prefix, String localName) {
<span class="nc" id="L521">    return new EName(bindings.getNamespaceURI(prefix), localName);</span>
  }

  /**
   * Transform a qualified name to an expanded name, based on the registered binding.
   *
   * @param qName
   *          the qualified name, e.g. &lt;code&gt;dcterms:title&lt;/code&gt; or &lt;code&gt;title&lt;/code&gt;
   * @return the expanded name
   * @throws NamespaceBindingException
   *           if the namespace name is not bound to a prefix
   */
  protected EName toEName(String qName) {
<span class="fc" id="L534">    String[] parts = splitQName(qName);</span>
<span class="fc" id="L535">    return new EName(bindings.getNamespaceURI(parts[0]), parts[1]);</span>
  }

  /**
   * Splits a QName into its parts.
   *
   * @param qName
   *          the qname to split
   * @return an array of prefix (0) and local part (1). The prefix is &quot;&quot; if the qname belongs to the default namespace.
   */
  private static String[] splitQName(String qName) {
<span class="fc" id="L546">    final String[] parts = qName.split(&quot;:&quot;, 3);</span>
<span class="pc bpc" id="L547" title="1 of 3 branches missed.">    switch (parts.length) {</span>
      case 1:
<span class="fc" id="L549">        return new String[] { DEFAULT_NS_PREFIX, parts[0] };</span>
      case 2:
<span class="fc" id="L551">        return parts;</span>
      default:
<span class="nc" id="L553">        throw new IllegalArgumentException(&quot;Local name must not contain ':'&quot;);</span>
    }
  }

  /**
   * Returns a &quot;prefixed name&quot; consisting of namespace prefix and local name.
   *
   * @param prefix
   *          the namespace prefix, may be &lt;code&gt;null&lt;/code&gt;
   * @param localName
   *          the local name
   * @return the &quot;prefixed name&quot; &lt;code&gt;prefix:localName&lt;/code&gt;
   */
  private static String toQName(String prefix, String localName) {
<span class="fc" id="L567">    final StringBuilder b = new StringBuilder();</span>
<span class="pc bpc" id="L568" title="1 of 4 branches missed.">    if (prefix != null &amp;&amp; !DEFAULT_NS_PREFIX.equals(prefix)) {</span>
<span class="fc" id="L569">      b.append(prefix);</span>
<span class="fc" id="L570">      b.append(&quot;:&quot;);</span>
    }
<span class="fc" id="L572">    b.append(localName);</span>
<span class="fc" id="L573">    return b.toString();</span>
  }

  // --------------------------------------------------------------------------------------------

<span class="fc" id="L578">  private static final Map&lt;EName, String&gt; NO_ATTRIBUTES = new HashMap&lt;&gt;();</span>

  CatalogEntry mkCatalogEntry(EName name, String value, Map&lt;EName, String&gt; attributes) {
<span class="fc" id="L581">    return new CatalogEntry(name, value, attributes);</span>
  }

  /**
   * Element representation.
   */
  public final class CatalogEntry implements XmlElement, Comparable&lt;CatalogEntry&gt;, Serializable {

    /** The serial version UID */
    private static final long serialVersionUID = 7195298081966562710L;

    private final EName name;

    private final String value;

    /** The attributes of this element */
    private final Map&lt;EName, String&gt; attributes;

    /**
     * Creates a new catalog element representation with name, value and attributes.
     *
     * @param value
     *          the element value
     * @param attributes
     *          the element attributes
     */
<span class="fc" id="L607">    public CatalogEntry(EName name, String value, Map&lt;EName, String&gt; attributes) {</span>
<span class="fc" id="L608">      this.name = name;</span>
<span class="fc" id="L609">      this.value = value;</span>
<span class="fc" id="L610">      this.attributes = new HashMap&lt;&gt;(attributes);</span>
<span class="fc" id="L611">    }</span>

    /**
     * Returns the qualified name of the entry as a string. The namespace of the entry has to be bound to a prefix for
     * this method to succeed.
     */
    public String getQName() {
<span class="nc" id="L618">      return toQName(name);</span>
    }

    /**
     * Returns the expanded name of the entry.
     */
    public EName getEName() {
<span class="fc" id="L625">      return name;</span>
    }

    /**
     * Returns the element value.
     *
     * @return the value
     */
    public String getValue() {
<span class="fc" id="L634">      return value;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the element contains attributes.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the element contains attributes
     */
    public boolean hasAttributes() {
<span class="nc bnc" id="L643" title="All 2 branches missed.">      return attributes.size() &gt; 0;</span>
    }

    /**
     * Returns the element's attributes.
     *
     * @return the attributes
     */
    public Map&lt;EName, String&gt; getAttributes() {
<span class="fc" id="L652">      return Collections.unmodifiableMap(attributes);</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the element contains an attribute with the given name.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the element contains the attribute
     */
    public boolean hasAttribute(EName name) {
<span class="fc" id="L661">      return attributes.containsKey(name);</span>
    }

    /**
     * Returns the attribute value for the given attribute.
     *
     * @return the attribute or null
     */
    public String getAttribute(EName name) {
<span class="fc" id="L670">      return attributes.get(name);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L675">      return hash(name, value);</span>
    }

    @Override
    public boolean equals(Object that) {
<span class="pc bpc" id="L680" title="2 of 6 branches missed.">      return (this == that) || (that instanceof CatalogEntry &amp;&amp; eqFields((CatalogEntry) that));</span>
    }

    private boolean eqFields(CatalogEntry that) {
<span class="fc bfc" id="L684" title="All 2 branches covered.">      return this.compareTo(that) == 0;</span>
    }

    /**
     * Returns the XML representation of this entry.
     *
     * @param document
     *          the document
     * @return the xml node
     */
    @Override
    public Node toXml(Document document) {
<span class="fc" id="L696">      Element node = document.createElement(toQName(name));</span>
      // Write prefix binding to document root element
<span class="fc" id="L698">      bindNamespaceFor(document, name);</span>

<span class="fc" id="L700">      List&lt;EName&gt; keySet = new ArrayList&lt;&gt;(attributes.keySet());</span>
<span class="fc" id="L701">      Collections.sort(keySet);</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">      for (EName attrEName : keySet) {</span>
<span class="fc" id="L703">        String value = attributes.get(attrEName);</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        if (attrEName.hasNamespace()) {</span>
          // Write prefix binding to document root element
<span class="fc" id="L706">          bindNamespaceFor(document, attrEName);</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">          if (XSI_TYPE_ATTR.equals(attrEName)) {</span>
            // Special treatment for xsi:type attributes
            try {
<span class="fc" id="L710">              EName typeName = toEName(value);</span>
<span class="fc" id="L711">              bindNamespaceFor(document, typeName);</span>
<span class="nc" id="L712">            } catch (NamespaceBindingException ignore) {</span>
              // Type is either not a QName or its namespace is not bound.
              // We decide to gently ignore those cases.
<span class="fc" id="L715">            }</span>
          }
        }
<span class="fc" id="L718">        node.setAttribute(toQName(attrEName), value);</span>
<span class="fc" id="L719">      }</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">      if (value != null) {</span>
<span class="fc" id="L721">        node.appendChild(document.createTextNode(value));</span>
      }
<span class="fc" id="L723">      return node;</span>
    }

    /**
     * Compare two catalog entries. Comparison order:
     * - e_name
     * - number of attributes (less come first)
     * - attribute comparison (e_name -&amp;gt; value)
     */
    @Override
    public int compareTo(CatalogEntry o) {
<span class="fc" id="L734">      int c = getEName().compareTo(o.getEName());</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">      if (c != 0) {</span>
<span class="fc" id="L736">        return c;</span>
      }

<span class="fc" id="L739">      c = Integer.compare(attributes.size(), o.attributes.size());</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">      if (c != 0) {</span>
<span class="fc" id="L741">        return c;</span>
      }

      // Sort attribute entries by attributeComparator
<span class="fc" id="L745">      List&lt;Entry&lt;EName, String&gt;&gt; thisAttrs = attributes.entrySet().stream()</span>
<span class="fc" id="L746">          .sorted(attributeComparator)</span>
<span class="fc" id="L747">          .toList();</span>

<span class="fc" id="L749">      List&lt;Entry&lt;EName, String&gt;&gt; otherAttrs = o.attributes.entrySet().stream()</span>
<span class="fc" id="L750">          .sorted(attributeComparator)</span>
<span class="fc" id="L751">          .toList();</span>

      // Compare entries pairwise
<span class="fc bfc" id="L754" title="All 2 branches covered.">      for (int i = 0; i &lt; thisAttrs.size(); i++) {</span>
<span class="fc" id="L755">        c = attributeComparator.compare(thisAttrs.get(i), otherAttrs.get(i));</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">        if (c != 0) {</span>
<span class="fc" id="L757">          return c;</span>
        }
      }

<span class="fc" id="L761">      return 0; // all equal</span>
    }

    /**
     * Writes a namespace binding for catalog entry &lt;code&gt;name&lt;/code&gt; to the documents root element.
     * &lt;code&gt;xmlns:prefix=&quot;namespace&quot;&lt;/code&gt;
     */
    private void bindNamespaceFor(Document document, EName name) {
<span class="fc" id="L769">      Element root = (Element) document.getFirstChild();</span>
<span class="fc" id="L770">      String namespace = name.getNamespaceURI();</span>
      // Do not bind the &quot;xml&quot; namespace. It is bound by default
<span class="fc bfc" id="L772" title="All 2 branches covered.">      if (!XML_NS_URI.equals(namespace)) {</span>
<span class="fc" id="L773">        root.setAttribute(XMLNS_ATTRIBUTE + &quot;:&quot; + XMLCatalogImpl.this.getPrefix(name.getNamespaceURI()),</span>
<span class="fc" id="L774">                name.getNamespaceURI());</span>
      }
<span class="fc" id="L776">    }</span>

    @Override
    public String toString() {
<span class="fc" id="L780">      return value;</span>
    }
  }

  static int doCompareTo(EName k1, String v1, EName k2, String v2) {
<span class="fc" id="L785">    final int c = k1.compareTo(k2);</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">    return c != 0 ? c : v1.compareTo(v2);</span>
  }

<span class="fc" id="L789">  private static final Comparator&lt;Map.Entry&lt;EName, String&gt;&gt; attributeComparator =</span>
<span class="fc" id="L790">      new Comparator&lt;Map.Entry&lt;EName, String&gt;&gt;() {</span>
        @Override public int compare(Entry&lt;EName, String&gt; o1, Entry&lt;EName, String&gt; o2) {
<span class="fc" id="L792">          return doCompareTo(o1.getKey(), o1.getValue(), o2.getKey(), o2.getValue());</span>
        }
      };

<span class="fc" id="L796">  private static final Comparator&lt;CatalogEntry&gt; catalogEntryComparator =</span>
<span class="fc" id="L797">      new Comparator&lt;CatalogEntry&gt;() {</span>
        @Override public int compare(CatalogEntry o1, CatalogEntry o2) {
<span class="fc" id="L799">          return o1.compareTo(o2);</span>
        }
      };

  // --------------------------------------------------------------------------------------------

  // --

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.mediapackage.XMLCatalog#toXml(java.io.OutputStream, boolean)
   */
  @Override
  public void toXml(OutputStream out, boolean format) throws IOException {
    try {
<span class="fc" id="L815">      Document doc = this.toXml();</span>
<span class="fc" id="L816">      DOMImplementationRegistry reg = DOMImplementationRegistry.newInstance();</span>
<span class="fc" id="L817">      DOMImplementationLS impl = (DOMImplementationLS) reg.getDOMImplementation(&quot;LS&quot;);</span>
<span class="fc" id="L818">      LSSerializer serializer = impl.createLSSerializer();</span>
<span class="fc" id="L819">      serializer.getDomConfig().setParameter(&quot;format-pretty-print&quot;, format);</span>
<span class="fc" id="L820">      LSOutput output = impl.createLSOutput();</span>
<span class="fc" id="L821">      output.setByteStream(out);</span>
<span class="fc" id="L822">      serializer.write(doc, output);</span>
<span class="nc" id="L823">    } catch (ParserConfigurationException e) {</span>
<span class="nc" id="L824">      throw new IOException(&quot;unable to parse document&quot;);</span>
<span class="nc" id="L825">    } catch (TransformerException e) {</span>
<span class="nc" id="L826">      throw new IOException(&quot;unable to transform dom to a stream&quot;);</span>
<span class="nc" id="L827">    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {</span>
<span class="nc" id="L828">      throw new IOException(&quot;unable to serialize DOM&quot;);</span>
<span class="fc" id="L829">    }</span>
<span class="fc" id="L830">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.mediapackage.XMLCatalog#toXmlString()
   */
  @Override
  public String toXmlString() throws IOException {
<span class="fc" id="L839">    ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
<span class="fc" id="L840">    toXml(out, true);</span>
<span class="fc" id="L841">    return new String(out.toByteArray(), StandardCharsets.UTF_8);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>