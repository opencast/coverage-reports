<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AdaptivePlaylist.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.mediapackage</a> &gt; <span class="el_source">AdaptivePlaylist.java</span></div><h1>AdaptivePlaylist.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.mediapackage;


import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.data.Function2;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * HLS-VOD
 *
 * This interface describes methods and fields for an adaptive manifest playlist. as defined in
 * https://tools.ietf.org/html/draft-pantos-http-live-streaming-20 This is text file which references media tracks or
 * playlists in the same mediapackage using relative path names (usual) or absolute URI. Master Playlist tags MUST NOT
 * appear in a Media Playlist; Media Segment tag MUST NOT appear in a Master Playlist.
 */
public interface AdaptivePlaylist extends Track {

  /**
   * Media package element type.
   */
  // String COLLECTION = &quot;AdaptivePlaylist&quot;;
<span class="fc" id="L77">  Logger logger = LoggerFactory.getLogger(AdaptivePlaylist.class);</span>

<span class="fc" id="L79">  Pattern uriPatt = Pattern.compile(&quot;URI=\&quot;([^\&quot;]+)\&quot;&quot;);</span>
<span class="fc" id="L80">  Pattern filePatt = Pattern.compile(&quot;([a-zA-Z0-9_.\\-\\/]+)\\.(\\w+)$&quot;);</span>
  // Known tags that references other files include the following - but we only use EXT-X-MAP here
  // &quot;#EXT-X-MAP:&quot;, &quot;#EXT-X-MEDIA:&quot;, &quot;#EXT-X-I-FRAME-STREAM-INF:&quot;, &quot;#EXT-X-SESSION-DATA:&quot;,
  // Variant tags: see Section 4.4.2 in draft
<span class="fc" id="L84">  List&lt;String&gt; extVariant = Arrays.asList(&quot;#EXT-X-MAP:&quot;, &quot;#EXT-X-TARGETDURATION:&quot;, &quot;EXTINF&quot;, &quot;#EXT-X-BYTERANGE:&quot;);</span>
  // Master tags: see Section 4.4.4
<span class="fc" id="L86">  List&lt;String&gt; extMaster = Arrays.asList(&quot;#EXT-X-MEDIA:&quot;, &quot;#EXT-X-STREAM-INF:&quot;, &quot;#EXT-X-I-FRAME-STREAM-INF:&quot;,</span>
          &quot;#EXT-X-SESSION-DATA:&quot;);
<span class="fc" id="L88">  Pattern masterPatt = Pattern.compile(String.join(&quot;|&quot;, extMaster), Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L89">  Pattern variantPatt = Pattern.compile(String.join(&quot;|&quot;, extVariant), Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L90">  Predicate&lt;File&gt; isHLSFilePred = f -&gt; &quot;m3u8&quot;.equalsIgnoreCase(FilenameUtils.getExtension(f.getName()));</span>
<span class="fc" id="L91">  Predicate&lt;String&gt; isPlaylistPred = f -&gt; &quot;m3u8&quot;.equalsIgnoreCase(FilenameUtils.getExtension(f));</span>
<span class="fc" id="L92">  Predicate&lt;Track&gt; isHLSTrackPred = f -&gt; &quot;m3u8&quot;.equalsIgnoreCase(FilenameUtils.getExtension(f.getURI().getPath()));</span>

  static boolean isPlaylist(String filename) {
<span class="pc bpc" id="L95" title="1 of 4 branches missed.">    return filename != null &amp;&amp; isPlaylistPred.test(filename);</span>
  }

  static boolean isPlaylist(File file) {
<span class="pc bpc" id="L99" title="1 of 4 branches missed.">    return file != null &amp;&amp; isHLSFilePred.test(file);</span>
  }

  static boolean isPlaylist(Track track) {
<span class="pc bpc" id="L103" title="1 of 4 branches missed.">    return track != null &amp;&amp; isHLSTrackPred.test(track);</span>
  }

  // Return true if any elements in a collection is a m3u8 playlist
  static boolean hasHLSPlaylist(Collection&lt;MediaPackageElement&gt; elements) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">    return elements.stream().filter(e -&gt; e.getElementType() == MediaPackageElement.Type.Track)</span>
<span class="fc" id="L109">            .anyMatch(t -&gt; isHLSTrackPred.test((Track) t));</span>
  }

  static List&lt;Track&gt; getSortedTracks(List&lt;Track&gt; files, boolean segmentsOnly) {
<span class="nc" id="L113">    List&lt;Track&gt; fmp4 = files;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">    if (segmentsOnly) {</span>
<span class="nc" id="L115">      fmp4 = files.stream().filter(isHLSTrackPred.negate()).collect(Collectors.toList());</span>
    }
<span class="nc" id="L117">    fmp4.sort(Comparator.comparing(track -&gt; FilenameUtils.getBaseName(track.getURI().getPath())));</span>
<span class="nc" id="L118">    return fmp4;</span>
  }

  /**
   * Return true if this is a master manifest (contains variants manifest and no media segments)
   *
   * @param file
   *          - media file
   * @return true if is a master manifest
   * @throws IOException
   *           if bad file
   */
  static boolean checkForMaster(File file) throws IOException {
<span class="fc bfc" id="L131" title="All 2 branches covered.">    if (!isPlaylist(file))</span>
<span class="fc" id="L132">      return false;</span>
<span class="fc" id="L133">    try (Stream&lt;String&gt; lines = Files.lines(file.toPath())) {</span>
<span class="fc" id="L134">      return lines.map(masterPatt::matcher).anyMatch(Matcher::find);</span>
    }
  }

  /**
   * Return true if this is a variant manifest (contains media segments only)
   *
   * @param file
   *          - media file
   * @return true if is a HLS playlist but not master
   * @throws IOException
   *           if bad file - can't access or otherwise
   */
  static boolean checkForVariant(File file) throws IOException {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">    if (!isPlaylist(file))</span>
<span class="nc" id="L149">      return false;</span>
<span class="fc" id="L150">    try (Stream&lt;String&gt; lines = Files.lines(file.toPath())) {</span>
<span class="fc" id="L151">      return lines.map(variantPatt::matcher).anyMatch(Matcher::find);</span>
    }
  }

  /**
   * Given a master or variant playlist/manifest - get referenced files. This does not deal with files referenced by
   * tags yet.
   *
   * @param file
   *          to parse
   * @return Set of names referenced
   * @throws IOException
   *           if can't access file
   */
  static Set&lt;String&gt; getVariants(File file) throws IOException {
<span class="fc" id="L166">    Set&lt;String&gt; files = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L167">    try (BufferedReader br = Files.newBufferedReader(file.toPath())) {</span>
<span class="fc" id="L168">      files = (br.lines().map(l -&gt; {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (!l.startsWith(&quot;#&quot;)) {</span>
<span class="fc" id="L170">          Matcher m = filePatt.matcher(l);</span>
<span class="pc bpc" id="L171" title="1 of 4 branches missed.">          if (m != null &amp;&amp; m.matches())</span>
<span class="fc" id="L172">            return m.group(0);</span>
        }
<span class="fc" id="L174">        return null;</span>
<span class="fc" id="L175">      }).collect(Collectors.toSet()));</span>
<span class="nc" id="L176">    } catch (IOException e) {</span>
<span class="nc" id="L177">      throw new IOException(&quot;Cannot read file &quot; + file + e.getMessage());</span>
<span class="fc" id="L178">    }</span>
<span class="fc" id="L179">    files.remove(null);</span>
<span class="fc" id="L180">    return files;</span>
  }

  /**
   * Given a playlist - recursively get all referenced files in the same filesystem with relative links
   *
   * @param file
   *          media file
   * @return Set of names referenced
   * @throws IOException
   *           if can't access file
   */
  static Set&lt;String&gt; getReferencedFiles(File file, boolean segmentsOnly) throws IOException {
<span class="fc" id="L193">    Set&lt;String&gt; allFiles = new HashSet&lt;String&gt;(); // don't include playlist variants</span>
<span class="fc" id="L194">    Set&lt;String&gt; segments = getVariants(file).stream().filter(isPlaylistPred.negate())</span>
<span class="fc" id="L195">            .collect(Collectors.toSet());</span>
<span class="fc" id="L196">    Set&lt;String&gt; variants = getVariants(file).stream().filter(isPlaylistPred).collect(Collectors.toSet());</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">    if (!segmentsOnly)</span>
<span class="fc" id="L199">      allFiles.addAll(variants); // include the playlist</span>
<span class="fc" id="L200">    allFiles.addAll(segments);</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">    for (String f : variants) {</span>
      try {
<span class="nc" id="L204">        new URL(f); // ignore external paths</span>
<span class="fc" id="L205">      } catch (MalformedURLException e) {</span>
        // is relative path - read the variant playlist
<span class="fc" id="L207">        String name = FilenameUtils.concat(FilenameUtils.getFullPath(file.getAbsolutePath()), f);</span>
<span class="fc" id="L208">        allFiles.addAll(getReferencedFiles(new File(name), true));</span>
<span class="nc" id="L209">      }</span>
<span class="fc" id="L210">    }</span>
<span class="fc" id="L211">    return allFiles;</span>
  }

  /***
   * Set the path of the url as the logical name
   *
   * @param track
   *          - tag with name
   */
  static void setLogicalName(Track track) {
<span class="fc" id="L221">    track.setLogicalName(FilenameUtils.getName(track.getURI().getPath()));</span>
<span class="fc" id="L222">  }</span>

  /**
   * Set HLS Tracks references to point to immediate parent, post inspection
   *
   * @param tracks
   *          - all tracks in an HLS adaptive playlist
   * @param getFileFromURI
   *          - a way to map uri to file
   * @throws IOException
   *           if failed to read files
   */
  static void hlsSetReferences(List&lt;Track&gt; tracks, Function&lt;URI, File&gt; getFileFromURI) throws IOException {
<span class="nc" id="L235">    final Optional&lt;Track&gt; master = tracks.stream().filter(t -&gt; t.isMaster()).findAny();</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">    final List&lt;Track&gt; variants = tracks.stream().filter(t -&gt; t.getElementType() == MediaPackageElement.Type.Manifest)</span>
<span class="nc" id="L237">            .collect(Collectors.toList());</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">    final List&lt;Track&gt; segments = tracks.stream().filter(t -&gt; t.getElementType() != MediaPackageElement.Type.Manifest)</span>
<span class="nc" id="L239">            .collect(Collectors.toList());</span>
<span class="nc" id="L240">    tracks.forEach(track -&gt; setLogicalName(track));</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">    if (master.isPresent())</span>
<span class="nc" id="L242">      variants.forEach(t -&gt; t.referTo(master.get())); // variants refer to master</span>
<span class="nc" id="L243">    HashMap&lt;String, Track&gt; map = new HashMap&lt;String, Track&gt;();</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">    for (Track t : variants) {</span>
<span class="nc" id="L245">      File f = getFileFromURI.apply(t.getURI());</span>
<span class="nc" id="L246">      Set&lt;String&gt; seg = getReferencedFiles(f, true); // Find segment</span>
      // Should be one only
<span class="nc" id="L248">      seg.forEach(s -&gt; map.put(s, t));</span>
<span class="nc" id="L249">    }</span>
<span class="nc" id="L250">    segments.forEach(t -&gt; { // segments refer to variants</span>
<span class="nc" id="L251">      t.referTo(map.get(t.getLogicalName()));</span>
<span class="nc" id="L252">    });</span>
<span class="nc" id="L253">  }</span>

  /**
   * Fix all the playlists locations and references based on a file map from old name to new name.
   *
   * @param hlsFiles
   *          - List of all files in a playlist including playlists
   * @param map
   *          - the mapping of the references to the actual file location
   * @return the fixed files
   * @throws IOException
   *           if failed to read files
   */
  static List&lt;File&gt; hlsRenameAllFiles(List&lt;File&gt; hlsFiles, Map&lt;File, File&gt; map) throws IOException {
<span class="fc bfc" id="L267" title="All 2 branches covered.">    for (Map.Entry&lt;File, File&gt; entry : map.entrySet()) {</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">      if (entry.getKey().toPath() != entry.getValue().toPath()) { // if different</span>
<span class="fc" id="L269">        logger.debug(&quot;Move file from &quot; + entry.getKey() + &quot; to &quot; + entry.getValue());</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (entry.getValue().exists())</span>
<span class="nc" id="L271">          FileUtils.forceDelete(entry.getValue()); // can redo this</span>
<span class="fc" id="L272">        FileUtils.moveFile(entry.getKey(), entry.getValue());</span>
      }
<span class="fc" id="L274">    }</span>
    // rename all files to new names if needed
<span class="fc" id="L276">    HashMap&lt;String, String&gt; nameMap = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L277">    map.forEach((k, v) -&gt; nameMap.put(k.getName(), v.getName()));</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">    for (File f : map.values()) {</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">      if (isPlaylist(f))</span>
<span class="fc" id="L280">        hlsRewriteFileReference(f, nameMap); // fix references</span>
<span class="fc" id="L281">    }</span>
<span class="fc" id="L282">    return new ArrayList&lt;File&gt;(map.values());</span>
  }


  /**
   * Fix all the HLS file references in a manifest when a referenced file is renamed
   *
   * @param srcFile
   *          - srcFile to be rewritten
   * @param mapNames
   *          - mapped from old name to new name
   * @throws IOException
   *           if failed
   */
  static void hlsRewriteFileReference(File srcFile, Map&lt;String, String&gt; mapNames) throws IOException {
<span class="fc" id="L297">    File tmpFile = new File(srcFile.getAbsolutePath() + UUID.randomUUID() + &quot;.tmp&quot;);</span>
    try { // rewrite src file
<span class="fc" id="L299">      FileUtils.moveFile(srcFile, tmpFile);</span>
<span class="fc" id="L300">      hlsRewriteFileReference(tmpFile, srcFile, mapNames); // fix references</span>
<span class="nc" id="L301">    } catch (IOException e) {</span>
<span class="nc" id="L302">      throw new IOException(&quot;Cannot rewrite &quot; + srcFile + &quot; &quot; + e.getMessage());</span>
    } finally {
<span class="fc" id="L304">      FileUtils.deleteQuietly(tmpFile); // delete temp file</span>
<span class="fc" id="L305">      tmpFile = null;</span>
    }
<span class="fc" id="L307">  }</span>

  /**
   * Fix all the HLS file references in a manifest when a referenced file is renamed All the mapped files should be in
   * the same directory, make sure they are not workspace files (no md5)
   *
   * @param srcFile
   *          - source file to change
   * @param destFile
   *          - dest file to hold results
   * @param mapNames
   *          - mapping from oldName to newName
   * @throws IOException
   *           if failed
   */
  static void hlsRewriteFileReference(File srcFile, File destFile, Map&lt;String, String&gt; mapNames) throws IOException {
    // Many tags reference URIs - not all are dealt with in this code, eg:
    // &quot;#EXT-X-MAP:&quot;, &quot;#EXT-X-MEDIA:&quot;, &quot;#EXT-X-I-FRAME-STREAM-INF:&quot;, &quot;#EXT-X-SESSION-DATA:&quot;, &quot;#EXT-X-KEY:&quot;,
    // &quot;#EXT-X-SESSION-DATA:&quot;
<span class="fc" id="L326">    try (FileWriter hlsReWriter = new FileWriter(destFile.getAbsoluteFile(), false);</span>
<span class="fc" id="L327">         BufferedReader br = new BufferedReader(new FileReader(srcFile))) {</span>
      String line;
<span class="fc bfc" id="L329" title="All 2 branches covered.">      while ((line = br.readLine()) != null) {</span>
        // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20
        // Each line is a URI, blank, or starts with the character #
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (!line.trim().isEmpty()) {</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">          if (line.startsWith(&quot;#&quot;)) {</span>
            // eg: #EXT-X-MAP:URI=&quot;39003_segment_0.mp4&quot;,BYTERANGE=&quot;1325@0&quot;
<span class="pc bpc" id="L335" title="1 of 4 branches missed.">            if (line.startsWith(&quot;#EXT-X-MAP:&quot;) || line.startsWith(&quot;#EXT-X-MEDIA:&quot;)) {</span>
<span class="fc" id="L336">              String tmpLine = line;</span>
<span class="fc" id="L337">              Matcher matcher = uriPatt.matcher(line);</span>
              // replace iff file is mapped
<span class="pc bpc" id="L339" title="1 of 4 branches missed.">              if (matcher.find() &amp;&amp; mapNames.containsKey(matcher.group(1))) {</span>
<span class="fc" id="L340">                tmpLine = line.replaceFirst(matcher.group(1), mapNames.get(matcher.group(1)));</span>
              }
<span class="fc" id="L342">              hlsReWriter.write(tmpLine);</span>
<span class="fc" id="L343">            } else</span>
<span class="fc" id="L344">              hlsReWriter.write(line);</span>
          } else {
<span class="fc" id="L346">            line = line.trim();</span>
<span class="fc" id="L347">            String filename = FilenameUtils.getName(line);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">            if (mapNames.containsKey(line)) {</span>
<span class="fc" id="L349">              hlsReWriter.write(mapNames.get(line));</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            } else if (mapNames.containsKey(filename)) {</span>
<span class="nc" id="L351">              String newFileName = mapNames.get(FilenameUtils.getName(filename));</span>
<span class="nc" id="L352">              String newPath = FilenameUtils.getPath(line);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">              if (newPath.isEmpty())</span>
<span class="nc" id="L354">                hlsReWriter.write(newFileName);</span>
              else
<span class="nc" id="L356">                hlsReWriter.write(FilenameUtils.concat(newPath, newFileName));</span>
<span class="nc" id="L357">            } else</span>
<span class="fc" id="L358">              hlsReWriter.write(line);</span>
          }
        }
<span class="fc" id="L361">        hlsReWriter.write(System.lineSeparator()); // new line</span>
      }
<span class="nc" id="L363">    } catch (Exception e) {</span>
<span class="nc" id="L364">      logger.error(&quot;Failed to rewrite hls references &quot; + e.getMessage());</span>
<span class="nc" id="L365">      throw new IOException(e);</span>
<span class="fc" id="L366">    }</span>
<span class="fc" id="L367">  }</span>

  /**
   * Return logical name mapped to file
   *
   * @param tracks
   *          from a HLS manifest
   * @param getFileFromURI
   *          is a function to get file from an URI
   * @return names mapped to file
   */
  static Map&lt;String, File&gt; logicalNameFileMap(List&lt;Track&gt; tracks, Function&lt;URI, File&gt; getFileFromURI) {
<span class="fc" id="L379">    Map&lt;String, File&gt; nameMap = tracks.stream().collect(Collectors.&lt;Track, String, File&gt; toMap(</span>
<span class="fc" id="L380">            track -&gt; track.getLogicalName(), track -&gt; getFileFromURI.apply(track.getURI())));</span>
<span class="fc" id="L381">    return nameMap;</span>
  }

  static Map&lt;String, URI&gt; logicalNameURLMap(List&lt;Track&gt; tracks) {
<span class="nc" id="L385">    HashMap&lt;String, URI&gt; nameMap = new HashMap&lt;String, URI&gt;();</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">    for (Track track : tracks) {</span>
<span class="nc" id="L387">      nameMap.put(track.getLogicalName(), track.getURI());</span>
<span class="nc" id="L388">    }</span>
<span class="nc" id="L389">    return nameMap;</span>
  }

  /**
   *
   * Return track urls as relative to the master playlist (only one in the list)
   *
   * @param tracks
   *          from an HLS playlist
   * @return track urls as relative to the master playlist
   */
  static HashMap&lt;String, String&gt; urlRelativeToMasterMap(List&lt;Track&gt; tracks) {
<span class="nc" id="L401">    HashMap&lt;String, String&gt; nameMap = new HashMap&lt;String, String&gt;();</span>
<span class="nc" id="L402">    Optional&lt;Track&gt; master = tracks.stream().filter(t -&gt; t.isMaster()).findAny();</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">    List&lt;Track&gt; others = tracks.stream().filter(t -&gt; !t.isMaster()).collect(Collectors.toList());</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">    if (master.isPresent()) // Relativize all the files from the master playlist</span>
<span class="nc" id="L405">      others.forEach(track -&gt; {</span>
<span class="nc" id="L406">        nameMap.put(track.getLogicalName(), track.getURI().relativize(master.get().getURI()).toString());</span>
<span class="nc" id="L407">      });</span>
<span class="nc" id="L408">    return nameMap;</span>
  }

  // Representation of a track/playlist for internal use only
  class Rep {
    private Track track;
    private String name; // reference name
<span class="fc" id="L415">    private boolean isPlaylist = false;</span>
<span class="fc" id="L416">    private boolean isMaster = false;</span>
    private File origMpfile;
    private String newfileName;
    private URI origMpuri;
<span class="fc" id="L420">    private URI newMpuri = null;</span>
    private String relPath;

    // Get file relative to the mediapackage directory
<span class="fc" id="L424">    Rep(Track track, File mpdir) throws NotFoundException, IOException {</span>
<span class="fc" id="L425">      this.track = track;</span>
<span class="fc" id="L426">      origMpuri = track.getURI();</span>
<span class="fc" id="L427">      origMpfile = getFilePath(origMpuri, mpdir);</span>
<span class="fc" id="L428">      name = FilenameUtils.getName(origMpuri.getPath()).trim();</span>
<span class="fc" id="L429">      isPlaylist = AdaptivePlaylist.isPlaylist(track.getURI().getPath()); // check suffix</span>
<span class="fc" id="L430">    }</span>

    // Get file based on a look up, eg: workspace.get()
<span class="fc" id="L433">    Rep(Track track, Function&lt;URI, File&gt; getFileFromURI) {</span>
<span class="fc" id="L434">      this.track = track;</span>
<span class="fc" id="L435">      origMpuri = track.getURI();</span>
<span class="fc" id="L436">      origMpfile = getFileFromURI.apply(origMpuri);</span>
<span class="fc" id="L437">      name = FilenameUtils.getName(origMpfile.getPath());</span>
<span class="fc" id="L438">      isPlaylist = AdaptivePlaylist.isPlaylist(track.getURI().getPath());</span>
<span class="fc" id="L439">    }</span>

    private File getFilePath(URI uri, File mpDir) {
<span class="fc" id="L442">      String mpid = mpDir.getName();</span>
<span class="fc" id="L443">      String path = uri.getPath();</span>
<span class="fc" id="L444">      final Matcher matcher = Pattern.compile(mpid).matcher(path);</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">      if (matcher.find()) {</span>
<span class="fc" id="L446">        return new File(mpDir, path.substring(matcher.end()).trim());</span>
      }
      // If there is no mpDir, it may be a relative path
<span class="nc" id="L449">      return new File(mpDir, path);</span>
    }

    public boolean isMaster() {
<span class="nc" id="L453">      return this.track.isMaster();</span>
    }

    public boolean parseForMaster() {
      try {
<span class="fc" id="L458">        setMaster(checkForMaster(origMpfile));</span>
<span class="nc" id="L459">      } catch (IOException e) {</span>
<span class="nc" id="L460">        logger.error(&quot;Cannot open file for check for master:{}&quot;, origMpfile);</span>
<span class="fc" id="L461">      }</span>
<span class="fc" id="L462">      return isMaster;</span>
    }

    public void setMaster(boolean isMaster) {
<span class="fc" id="L466">      this.isMaster = isMaster;</span>
<span class="fc" id="L467">      this.track.setMaster(isMaster);</span>
<span class="fc" id="L468">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L472">      return track.toString();</span>
    }
  }

  /**
   * Replace the content of a playlist file in place, use in composer only - not in workspace
   *
   * @param file
   *          as playlist
   * @param map
   *          - mapping from reference/logical name to new path
   * @return playlist with changed file names based on the map
   * @throws IOException
   *           if can't access file
   * @throws NotFoundException
   *           if file not found
   */
  static File replaceTrackFileInPlace(File file, Map&lt;String, String&gt; map) throws IOException, NotFoundException {
<span class="fc" id="L490">    File newFile = new File(file.getAbsolutePath() + UUID.randomUUID() + &quot;.tmp&quot;);</span>
    try {
      // move old file to tmp
<span class="fc" id="L493">      FileUtils.moveFile(file, newFile);</span>
      // Write over old file with fixed references
<span class="fc" id="L495">      hlsRewriteFileReference(newFile, file, map);</span>
<span class="nc" id="L496">    } catch (IOException e) {</span>
<span class="nc" id="L497">      logger.error(&quot;Cannot rewrite &quot; + file + &quot;: &quot; + e.getMessage());</span>
<span class="nc" id="L498">      throw (e);</span>
    } finally {
<span class="fc" id="L500">      FileUtils.deleteQuietly(newFile); // not needed anymore</span>
<span class="fc" id="L501">      newFile = null;</span>
    }
<span class="fc" id="L503">    return file;</span>

  }

  /**
   * Find relative path to referee URL if a link is in the referer page
   *
   * @param referer
   *          - pointer to file
   * @param referee
   *          - pointee
   * @return referee path as a relative path from referer URL
   * @throws URISyntaxException
   *           if bad URI
   */

  static String relativize(URI referer, URI referee) throws URISyntaxException {
<span class="fc" id="L520">    URI u1 = referer.normalize();</span>
<span class="fc" id="L521">    URI u2 = referee.normalize();</span>
<span class="fc" id="L522">    File f = relativizeF(u1.getPath(), u2.getPath());</span>
<span class="fc" id="L523">    return f.getPath(); // relative name to use in manifest</span>
  }

  // They should all be relative paths at this point in the working file repo
  static File relativizeF(String s1, String s2) throws URISyntaxException {
<span class="fc" id="L528">    String fp = new File(s1).getParent(); // get s1 folder</span>
<span class="fc" id="L529">    Path p2 = Paths.get(s2);</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">    if (fp != null) {</span>
<span class="fc" id="L531">      Path p1 = Paths.get(fp);</span>
      try {
<span class="fc" id="L533">        Path rp = p1.relativize(p2);</span>
<span class="fc" id="L534">        return rp.toFile();</span>
<span class="nc" id="L535">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L536">        logger.info(&quot;Not a relative path &quot; + p1 + &quot; to &quot; + p2);</span>
<span class="nc" id="L537">        return p2.toFile();</span>
      }
    } else
<span class="nc" id="L540">      return p2.toFile();</span>
  }

  /**
   * Fix the playlist references in a publication. The playlist files are replaced in place using relative link instead
   * of the filename
   *
   * @param tracks
   *          - tracks that represent a HLS playlist
   * @param mpDir
   *          - distribution media package file directory which represents the file storage of the URI used in the
   *          tracks
   * @return the tracks with the files updated
   * @throws MediaPackageException
   *           if files do not conform to HLS spec.
   * @throws NotFoundException
   *           if files are missing
   * @throws IOException
   *           if can't read
   * @throws URISyntaxException
   *           if bad URI
   */
  static List&lt;Track&gt; fixReferences(List&lt;Track&gt; tracks, File mpDir)
          throws MediaPackageException, NotFoundException, IOException, URISyntaxException {
<span class="fc" id="L564">    HashMap&lt;String, Rep&gt; nameMap = new HashMap&lt;String, Rep&gt;();</span>
<span class="fc" id="L565">    Rep master = null;</span>
<span class="fc" id="L566">    Rep segment = null;</span>
<span class="fc" id="L567">    List&lt;Track&gt; newTracks = new ArrayList&lt;Track&gt;();</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">    if (tracks.size() &lt; 2) {</span>
<span class="nc" id="L569">      logger.debug(&quot;At least 2 files in an HLS distribution&quot;);</span>
<span class="nc" id="L570">      throw new MediaPackageException(&quot;Not enough files in a playlist&quot;);</span>
    }
    // map logical name to track representation
<span class="fc bfc" id="L573" title="All 2 branches covered.">    for (Track track : tracks) {</span>
<span class="fc" id="L574">      Rep rep = new Rep(track, mpDir);</span>
<span class="fc" id="L575">      nameMap.put(track.getLogicalName(), rep); // add all to nameMap</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">      if (track.isMaster())</span>
<span class="fc" id="L577">        master = rep; // track.getLogicalname();</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">      if (!rep.isPlaylist)</span>
<span class="fc" id="L579">        segment = rep; // find any segment</span>
<span class="fc" id="L580">    }</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">    if (segment == null) { // must have at least one segment</span>
<span class="nc" id="L582">      throw new MediaPackageException(&quot;No playable media segment in mediapackage&quot;);</span>

    }
    // Try to find master or use any playlist, if not found, throw exception
<span class="fc" id="L586">    Optional&lt;Rep&gt; oprep = nameMap.values().stream().filter(r -&gt; r.parseForMaster()).findFirst();</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">    if (!oprep.isPresent())</span>
<span class="fc" id="L588">      oprep = nameMap.values().parallelStream().filter(r -&gt; r.isPlaylist).findFirst();</span>
<span class="pc" id="L589">    oprep.orElseThrow(() -&gt; new MediaPackageException(&quot;No playlist found, not HLS distribution&quot;));</span>
<span class="fc" id="L590">    master = oprep.get();</span>

<span class="fc" id="L592">    HashMap&lt;String, String&gt; newNames = new HashMap&lt;String, String&gt;();</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">    for (String logName : nameMap.keySet()) { // map original name</span>
<span class="fc" id="L594">      Rep rep = nameMap.get(logName);</span>
      // segments are fixed, fix variant references to segments based on segments
      String relPath;
<span class="fc bfc" id="L597" title="All 2 branches covered.">      if (!segment.origMpuri.equals(rep.origMpuri)) { // not itself</span>
<span class="fc" id="L598">        relPath = relativize(segment.origMpuri, rep.origMpuri);</span>
      } else { // only element id is different
<span class="fc" id="L600">        relPath = relativize(master.origMpuri, rep.origMpuri);</span>
      }
<span class="fc" id="L602">      newNames.put(logName, relPath);</span>
<span class="fc" id="L603">    }</span>
    // on variant playlists, rewrite references to segments
<span class="fc bfc" id="L605" title="All 2 branches covered.">    for (String logName : nameMap.keySet()) {</span>
<span class="fc" id="L606">      Rep rep = nameMap.get(logName);</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">      if (rep == master) // deal with master later</span>
<span class="fc" id="L608">        continue;</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">      if (!rep.isPlaylist) {</span>
<span class="fc" id="L610">        newTracks.add(rep.track); // segments are unchanged</span>
<span class="fc" id="L611">        continue;</span>
      }
<span class="fc" id="L613">      replaceTrackFileInPlace(rep.origMpfile, newNames);</span>
<span class="fc" id="L614">      rep.newMpuri = rep.origMpuri;</span>
<span class="fc" id="L615">      newTracks.add(rep.track); // add changed variants</span>
<span class="fc" id="L616">    }</span>
    // remap logical name to the new id for the variant files from above
<span class="fc bfc" id="L618" title="All 2 branches covered.">    for (String logName : nameMap.keySet()) {</span>
<span class="fc" id="L619">      Rep rep = nameMap.get(logName);</span>
<span class="fc bfc" id="L620" title="All 4 branches covered.">      if (!rep.isPlaylist || rep == master)</span>
<span class="fc" id="L621">        continue;</span>
<span class="fc" id="L622">      String relPath = relativize(segment.origMpuri, rep.newMpuri);</span>
<span class="fc" id="L623">      newNames.put(logName, relPath);</span>
<span class="fc" id="L624">    }</span>
    // on master, fix references to variant playlists
<span class="fc" id="L626">    replaceTrackFileInPlace(master.origMpfile, newNames);</span>
<span class="fc" id="L627">    master.newMpuri = master.track.getURI();</span>
<span class="fc" id="L628">    newTracks.add(master.track);</span>
    // Update the logical names to keep referential integrity
<span class="fc bfc" id="L630" title="All 2 branches covered.">    for (Track track : newTracks) {</span>
<span class="fc" id="L631">      String newpath = newNames.get(track.getLogicalName());</span>
<span class="pc bpc" id="L632" title="2 of 4 branches missed.">      if (newpath != null &amp;&amp; track != master) // no file refers to master</span>
<span class="fc" id="L633">        track.setLogicalName(newpath);</span>
<span class="fc" id="L634">    }</span>
<span class="fc" id="L635">    newNames = null;</span>
<span class="fc" id="L636">    return newTracks;</span>
  }

  /**
   * Fix HLS playlists/media already in the workspace as the result of an ingest This builds the hierarchies of a HLS
   * playlist with masters as the roots. This is useful if mixed files are ingested into a mediapackage. HLS files with
   * relative links will fail in an inspection unless the relative paths are fixed. Logical names should be preserved if
   * they exists.
   */
  class HLSMediaPackageCheck {
<span class="fc" id="L646">    private HashMap&lt;String, String&gt; fileMap = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L647">    private HashMap&lt;String, Rep&gt; repMap = new HashMap&lt;String, Rep&gt;();;</span>
    private List&lt;Rep&gt; reps;
    private List&lt;Rep&gt; playlists;
    private List&lt;Rep&gt; segments;
<span class="fc" id="L651">    private List&lt;Rep&gt; masters = new ArrayList&lt;Rep&gt;();</span>

    /**
     * Builds a map of files in the mediapackage so that it can be analyzed and fixed if needed
     *
     * @param tracks
     *          - list of tracks from a media package
     * @param getFileFromURI
     *          - a function to get files from the media package by URI
     * @throws IOException
     *           if can't read file
     * @throws URISyntaxException
     *           if bad URI
     * @throws MediaPackageException
     *           - if mediapackage is incomplete and missing segments
     */
    public HLSMediaPackageCheck(List&lt;Track&gt; tracks, Function&lt;URI, File&gt; getFileFromURI)
<span class="fc" id="L668">            throws IOException, MediaPackageException, URISyntaxException {</span>
<span class="fc" id="L669">      this.reps = tracks.stream().map(t -&gt; new Rep(t, getFileFromURI)).collect(Collectors.toList());</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">      for (Rep rep : reps)</span>
<span class="fc" id="L671">        repMap.put(rep.name, rep);</span>
<span class="fc" id="L672">      this.playlists = reps.stream().filter(r -&gt; r.isPlaylist).collect(Collectors.toList());</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">      for (Rep trackRep : playlists) {</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">        if (checkForMaster(trackRep.origMpfile)) {</span>
<span class="fc" id="L675">          this.masters.add(trackRep);</span>
<span class="fc" id="L676">          trackRep.setMaster(true); // Track.master is set by inspection</span>
        }
<span class="fc" id="L678">        mapTracks(trackRep); // find relationships of playlist segments</span>
<span class="fc" id="L679">      }</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">      this.segments = reps.stream().filter(r -&gt; !r.isPlaylist).collect(Collectors.toList());</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">      if (this.segments.size() &lt; 1)</span>
<span class="nc" id="L682">        throw new MediaPackageException(&quot;No media segments&quot;);</span>
<span class="fc" id="L683">    }</span>

    // File references need to be fixed
    public boolean needsRewriting() {
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">      if (this.playlists.size() == 0) // not HLS</span>
<span class="nc" id="L688">        return false;</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">      for (String s : fileMap.keySet()) { // paths are already corrected</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">        if (!s.equals(fileMap.get(s)))</span>
<span class="fc" id="L691">          return true;</span>
<span class="fc" id="L692">      }</span>
<span class="fc" id="L693">      return false;</span>
    }

    /**
     * Rewrite the playlist file from master on down, this has to be done in multiple steps because the act of putting a
     * file into a collection changes the path and new path is not known in advance. The two functions are passed in to
     * this function to manage the tracks in its storage
     *
     * @param mp
     *          to be rewrittem
     * @param replaceTrackFileInWS
     *          A function that creates a new track with the file using the metadata in the track, returning a new track
     *          in the media package.
     * @param removeFromWS
     *          A function that removes() the track from the media package in the workspace
     * @return old tracks that are removed from the media package
     * @throws MediaPackageException
     *           if bad mp
     */

    public List&lt;Track&gt; rewriteHLS(MediaPackage mp, Function2&lt;File, Track, Track&gt; replaceTrackFileInWS,
            Function&lt;Track, Void&gt; removeFromWS) throws MediaPackageException {
      /* rewrite variants first, * segments are unchanged */
<span class="fc bfc" id="L716" title="All 2 branches covered.">      List&lt;Rep&gt; variants = playlists.stream().filter(i -&gt; !masters.contains(i)).collect(Collectors.toList());</span>
<span class="fc" id="L717">      List&lt;File&gt; newFiles = new ArrayList&lt;File&gt;();</span>
<span class="fc" id="L718">      List&lt;Track&gt; oldTracks = new ArrayList&lt;Track&gt;();</span>
<span class="fc" id="L719">      List&lt;Track&gt; newTracks = new ArrayList&lt;Track&gt;();</span>
<span class="fc" id="L720">      Rep rep = segments.get(0); // use segment dir as temp space</span>


      // Lambda to rewrite a track using the passed in functions, using closure
<span class="fc" id="L724">      Function&lt;Rep, Boolean&gt; rewriteTrack = (trackRep) -&gt; {</span>
<span class="fc" id="L725">        File srcFile = trackRep.origMpfile;</span>
        // Use first segment's folder as temp space
<span class="fc" id="L727">        File destFile = new File(rep.origMpfile.getAbsoluteFile().getParent(),</span>
<span class="fc" id="L728">                FilenameUtils.getName(srcFile.getName()));</span>
        try {
<span class="fc" id="L730">          hlsRewriteFileReference(srcFile, destFile, fileMap);</span>
<span class="nc" id="L731">        } catch (IOException e) {</span>
<span class="nc" id="L732">          logger.error(&quot;HLS Rewrite {} to {} failed&quot;, srcFile, destFile);</span>
<span class="nc" id="L733">          return false;</span>
<span class="fc" id="L734">        }</span>
<span class="fc" id="L735">        newFiles.add(destFile);</span>
<span class="fc" id="L736">        oldTracks.add(trackRep.track);</span>
<span class="fc" id="L737">        Track copyTrack = (Track) trackRep.track.clone(); // get all the properties, id, etc</span>
<span class="fc" id="L738">        mp.add(copyTrack); // add to mp and get new elementID</span>
<span class="fc" id="L739">        Track newTrack = replaceTrackFileInWS.apply(destFile, copyTrack);</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">        if (newTrack == null) {</span>
<span class="nc" id="L741">          logger.error(&quot;Cannot add HLS track tp MP: {}&quot;, trackRep.track);</span>
<span class="nc" id="L742">          return false;</span>
        }
<span class="fc" id="L744">        newTracks.add(newTrack);</span>

        try { // Keep track of the new file's relative URI
<span class="fc" id="L747">          fileMap.put(trackRep.relPath, relativize(rep.origMpuri, newTrack.getURI()));</span>
<span class="nc" id="L748">        } catch (URISyntaxException e) {</span>
<span class="nc" id="L749">          logger.error(&quot;Cannot rewrite relativize track name: {}&quot;, trackRep.track);</span>
<span class="nc" id="L750">          return false;</span>
<span class="fc" id="L751">        }</span>
<span class="fc" id="L752">        newTrack.setLogicalName(fileMap.get(trackRep.name)); // set logical name for publication</span>
<span class="fc" id="L753">        return true;</span>
      };


      try {
        // Rewrite the variants and masters tracks in order and throw exception if there are any failures
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">        if (!(variants.stream().map(t -&gt; rewriteTrack.apply(t)).allMatch(Boolean::valueOf)</span>
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">                &amp;&amp; masters.stream().map(t -&gt; rewriteTrack.apply(t)).allMatch(Boolean::valueOf)))</span>
<span class="nc" id="L761">          throw new IOException(&quot;Cannot rewrite track&quot;);</span>

        // if segments are referenced by variant - set the logical name used
<span class="fc bfc" id="L764" title="All 2 branches covered.">        for (Rep segment : segments) {</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">          if (fileMap.containsValue(segment.newfileName)) {</span>
<span class="fc" id="L766">            segment.track.setLogicalName(segment.newfileName);</span>
          }
<span class="fc" id="L768">        }</span>

<span class="fc" id="L770">        oldTracks.forEach(t -&gt; {</span>
<span class="fc" id="L771">          mp.remove(t);</span>
<span class="fc" id="L772">          removeFromWS.apply(t);</span>
<span class="fc" id="L773">        }); // remove old tracks if successful</span>

<span class="nc" id="L775">      } catch (IOException /* | URISyntaxException */ e) {</span>

<span class="nc" id="L777">        logger.error(&quot;Cannot rewrite HLS tracks files:&quot;, e);</span>
<span class="nc" id="L778">        newTracks.forEach(t -&gt; {</span>
<span class="nc" id="L779">          mp.remove(t);</span>
<span class="nc" id="L780">          removeFromWS.apply(t);</span>
<span class="nc" id="L781">        }); // remove new Tracks if any of them failed</span>
<span class="nc" id="L782">        throw new MediaPackageException(&quot;Cannot rewrite HLS tracks files&quot;, e);</span>

      } finally {
<span class="fc" id="L785">        newFiles.forEach(f -&gt; f.delete()); // temp files not needed anymore</span>
      }
<span class="fc" id="L787">      return oldTracks;</span>
    }

    /**
     * Look for track by filename, assuming that all the variant playlists and segments are uniquely named. It is
     * possible that someone ingests a set of published playlists so the paths are nested. Then referenced names are
     * mapped to tracks.
     *
     * @param trackRep
     *          - playlist to examine
     * @throws IOException
     *           - bad files
     * @throws URISyntaxException
     */
    private void mapTracks(Rep trackRep) throws IOException, URISyntaxException {
<span class="fc" id="L802">      Set&lt;String&gt; paths = getVariants(trackRep.origMpfile); // Get all tracks it points to by path</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">      for (String path : paths) { // Check each file name</span>
<span class="fc" id="L804">        String name = FilenameUtils.getName(path);</span>
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">        if (repMap.containsKey(name)) {</span>
<span class="fc" id="L806">          Rep rep = repMap.get(name);</span>
<span class="fc" id="L807">          rep.newMpuri = trackRep.track.getURI().relativize(rep.origMpuri);</span>
<span class="fc" id="L808">          rep.newfileName = relativize(trackRep.origMpuri, rep.origMpuri);</span>
<span class="fc" id="L809">          fileMap.put(path, rep.newfileName);</span>
<span class="fc" id="L810">          rep.relPath = path; // for reverse lookup</span>
<span class="fc" id="L811">        } else {</span>
<span class="nc" id="L812">          logger.warn(&quot;Adaptive Playlist referenced track not found in mediapackage&quot;);</span>
        }
<span class="fc" id="L814">      }</span>
<span class="fc" id="L815">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>