<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>UserDirectoryPersistenceUtil.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-userdirectory</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.userdirectory</a> &gt; <span class="el_source">UserDirectoryPersistenceUtil.java</span></div><h1>UserDirectoryPersistenceUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.userdirectory;

import static org.opencastproject.db.Queries.namedQuery;

import org.opencastproject.security.api.Role;
import org.opencastproject.security.impl.jpa.JpaGroup;
import org.opencastproject.security.impl.jpa.JpaOrganization;
import org.opencastproject.security.impl.jpa.JpaRole;
import org.opencastproject.security.impl.jpa.JpaUser;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.function.ThrowingConsumer;
import org.opencastproject.util.requests.SortCriterion;

import org.apache.commons.lang3.tuple.Pair;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;

import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Join;
import javax.persistence.criteria.JoinType;
import javax.persistence.criteria.Order;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;

/**
 * Utility class for user directory persistence methods
 */
public final class UserDirectoryPersistenceUtil {

  private UserDirectoryPersistenceUtil() {
  }

  /**
   * Persist a set of roles
   *
   * @param roles
   *          the roles to persist
   * @return the persisted roles
   */
  public static Function&lt;EntityManager, Set&lt;JpaRole&gt;&gt; saveRolesQuery(Set&lt;? extends Role&gt; roles) {
<span class="fc" id="L73">    return em -&gt; {</span>
<span class="fc" id="L74">      Set&lt;JpaRole&gt; updatedRoles = new HashSet&lt;&gt;();</span>
      // Save or update roles
<span class="fc bfc" id="L76" title="All 2 branches covered.">      for (Role role : roles) {</span>
<span class="fc" id="L77">        JpaRole jpaRole = (JpaRole) role;</span>
<span class="fc" id="L78">        saveOrganizationQuery(jpaRole.getJpaOrganization()).apply(em);</span>
<span class="fc" id="L79">        Optional&lt;JpaRole&gt; findRole = findRoleQuery(jpaRole.getName(), jpaRole.getOrganizationId()).apply(em);</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (findRole.isEmpty()) {</span>
<span class="fc" id="L81">          em.persist(jpaRole);</span>
<span class="fc" id="L82">          updatedRoles.add(jpaRole);</span>
        } else {
<span class="fc" id="L84">          findRole.get().setDescription(jpaRole.getDescription());</span>
<span class="fc" id="L85">          updatedRoles.add(em.merge(findRole.get()));</span>
        }
<span class="fc" id="L87">      }</span>
<span class="fc" id="L88">      return updatedRoles;</span>
    };
  }

  /**
   * Persist an organization
   *
   * @param organization
   *          the organization to persist
   * @return the persisted organization
   */
  public static Function&lt;EntityManager, JpaOrganization&gt; saveOrganizationQuery(JpaOrganization organization) {
<span class="fc" id="L100">    return em -&gt; {</span>
<span class="fc" id="L101">      Optional&lt;JpaOrganization&gt; dbOrganization = findOrganizationQuery(organization).apply(em);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">      if (dbOrganization.isEmpty()) {</span>
<span class="fc" id="L103">        em.persist(organization);</span>
<span class="fc" id="L104">        return organization;</span>
      } else {
<span class="fc" id="L106">        return em.merge(dbOrganization.get());</span>
      }
    };
  }

  /**
   * Persist an user
   *
   * @param user
   *          the user to persist
   * @return the persisted organization
   */
  public static Function&lt;EntityManager, JpaUser&gt; saveUserQuery(JpaUser user) {
<span class="fc" id="L119">    return em -&gt; {</span>
<span class="fc" id="L120">      Optional&lt;JpaUser&gt; dbUser = findUserQuery(user.getUsername(), user.getOrganization().getId()).apply(em);</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">      if (dbUser.isEmpty()) {</span>
<span class="nc" id="L122">        em.persist(user);</span>
<span class="nc" id="L123">        return user;</span>
      } else {
<span class="fc" id="L125">        user.setId(dbUser.get().getId());</span>
<span class="fc" id="L126">        return em.merge(user);</span>
      }
    };
  }

  /**
   * Returns all groups from the persistence unit as a list
   *
   * @param organization
   *          the organization
   * @param limit
   *          the limit
   * @param offset
   *          the offset
   * @return the group list
   */
  public static Function&lt;EntityManager, List&lt;JpaGroup&gt;&gt; findGroupsQuery(String organization, int limit, int offset) {
<span class="fc" id="L143">    return em -&gt; {</span>
<span class="fc" id="L144">      TypedQuery&lt;JpaGroup&gt; query = em.createNamedQuery(&quot;Group.findAll&quot;, JpaGroup.class)</span>
<span class="fc" id="L145">          .setMaxResults(limit)</span>
<span class="fc" id="L146">          .setFirstResult(offset);</span>
<span class="fc" id="L147">      query.setParameter(&quot;organization&quot;, organization);</span>
<span class="fc" id="L148">      return query.getResultList();</span>
    };
  }

  /**
   * Count how many groups there are in total fitting the filter criteria.
   *
   * @param orgId
   *          the organization id
   * @param nameFilter
   *          filter by group name (optional)
   * @param textFilter
   *          fulltext filter (optional)
   * @return the group list
   * @throws IllegalArgumentException
   */
  public static Function&lt;EntityManager, Long&gt; countTotalGroupsQuery(String orgId, Optional&lt;String&gt; nameFilter,
      Optional&lt;String&gt; roleFilter, Optional&lt;String&gt; textFilter) {
<span class="nc" id="L166">    return em -&gt; {</span>
<span class="nc" id="L167">      CriteriaBuilder cb = em.getCriteriaBuilder();</span>
<span class="nc" id="L168">      final CriteriaQuery&lt;Long&gt; query = cb.createQuery(Long.class);</span>
<span class="nc" id="L169">      Root&lt;JpaGroup&gt; group = query.from(JpaGroup.class);</span>
<span class="nc" id="L170">      query.select(cb.count(group));</span>

<span class="nc" id="L172">      addWhereToQuery(query, cb, group, orgId, nameFilter, roleFilter, textFilter);</span>

<span class="nc" id="L174">      TypedQuery&lt;Long&gt; typedQuery = em.createQuery(query);</span>
<span class="nc" id="L175">      return typedQuery.getSingleResult();</span>
    };
  }

  /**
   * Add where clauses to groups query.
   *
   * @param query
   *         the query
   * @param cb
   *          the criteria builder
   * @param group
   *          the table
   * @param orgId
   *          the organization id
   * @param nameFilter
   *          filter by group name (optional)
   * @param textFilter
   *          fulltext filter (optional)
   */
  private static &lt;E&gt; void addWhereToQuery(CriteriaQuery&lt;E&gt; query, CriteriaBuilder cb, Root&lt;JpaGroup&gt; group,
          String orgId, Optional&lt;String&gt; nameFilter, Optional&lt;String&gt; roleFilter, Optional&lt;String&gt; textFilter) {
<span class="nc" id="L197">    List&lt;Predicate&gt; conditions = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L198">    conditions.add(cb.equal(group.join(&quot;organization&quot;).get(&quot;id&quot;), orgId));</span>

    // exact match, case sensitive
<span class="nc bnc" id="L201" title="All 2 branches missed.">    if (nameFilter.isPresent()) {</span>
<span class="nc" id="L202">      conditions.add(cb.equal(group.get(&quot;name&quot;), nameFilter.get()));</span>
    }
<span class="nc bnc" id="L204" title="All 2 branches missed.">    if (roleFilter.isPresent()) {</span>
<span class="nc" id="L205">      Join&lt;JpaGroup, JpaRole&gt; roleJoin = group.joinSet(&quot;roles&quot;, JoinType.LEFT);</span>
<span class="nc" id="L206">      conditions.add(cb.equal(roleJoin.get(&quot;name&quot;), roleFilter.get()));</span>
    }
    // not exact match, case-insensitive, each token needs to match at least one field
<span class="nc bnc" id="L209" title="All 2 branches missed.">    if (textFilter.isPresent()) {</span>
<span class="nc" id="L210">      List&lt;Predicate&gt; fulltextConditions = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L211">      String[] tokens = textFilter.get().split(&quot;\\s+&quot;);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">      for (String token: tokens) {</span>
<span class="nc" id="L213">        List&lt;Predicate&gt; fieldConditions = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L214">        Expression&lt;String&gt; literal = cb.literal(&quot;%&quot; + token + &quot;%&quot;);</span>

<span class="nc" id="L216">        fieldConditions.add(cb.like(cb.lower(group.get(&quot;groupId&quot;)), cb.lower(literal)));</span>
<span class="nc" id="L217">        fieldConditions.add(cb.like(cb.lower(group.get(&quot;name&quot;)), cb.lower(literal)));</span>
<span class="nc" id="L218">        fieldConditions.add(cb.like(cb.lower(group.get(&quot;description&quot;)), cb.lower(literal)));</span>
<span class="nc" id="L219">        fieldConditions.add(cb.like(cb.lower(group.get(&quot;role&quot;)), cb.lower(literal)));</span>
<span class="nc" id="L220">        fieldConditions.add(cb.like(cb.lower(group.&lt;JpaGroup, String&gt;joinSet(&quot;members&quot;, JoinType.LEFT)),</span>
<span class="nc" id="L221">                cb.lower(literal)));</span>
<span class="nc" id="L222">        fieldConditions.add(cb.like(cb.lower(group.&lt;JpaGroup, JpaRole&gt;joinSet(&quot;roles&quot;, JoinType.LEFT).get(&quot;name&quot;)),</span>
<span class="nc" id="L223">                cb.lower(literal)));</span>

        // token needs to match at least one field
<span class="nc" id="L226">        fulltextConditions.add(cb.or(fieldConditions.toArray(new Predicate[0])));</span>
      }
      // all token have to match something
      // (different to fulltext search for Elasticsearch, where only one token has to match!)
<span class="nc" id="L230">      conditions.add(cb.and(fulltextConditions.toArray(new Predicate[0])));</span>
    }
<span class="nc" id="L232">    query.where(cb.and(conditions.toArray(new Predicate[0])));</span>
<span class="nc" id="L233">  }</span>

  /**
   * Get group list by criteria.
   *
   * @param orgId
   *          the organization id
   * @param limit
   *          the limit (optional)
   * @param offset
   *          the offset (optional)
   * @param nameFilter
   *          filter by group name (optional)
   * @param textFilter
   *          fulltext filter (optional)
   * @param sortCriteria
   *          the sorting criteria (name, role or description)
   * @return the group list
   */
  public static Function&lt;EntityManager, List&lt;JpaGroup&gt;&gt; findGroupsQuery(String orgId, Optional&lt;Integer&gt; limit,
      Optional&lt;Integer&gt; offset, Optional&lt;String&gt; nameFilter, Optional&lt;String&gt; roleFilter, Optional&lt;String&gt; textFilter,
      ArrayList&lt;SortCriterion&gt; sortCriteria) {
<span class="nc" id="L255">    return em -&gt; {</span>
<span class="nc" id="L256">      CriteriaBuilder cb = em.getCriteriaBuilder();</span>
<span class="nc" id="L257">      final CriteriaQuery&lt;JpaGroup&gt; query = cb.createQuery(JpaGroup.class);</span>
<span class="nc" id="L258">      Root&lt;JpaGroup&gt; group = query.from(JpaGroup.class);</span>
<span class="nc" id="L259">      query.select(group);</span>
<span class="nc" id="L260">      query.distinct(true);</span>

      // filter
<span class="nc" id="L263">      addWhereToQuery(query, cb, group, orgId, nameFilter, roleFilter, textFilter);</span>

      // sort
<span class="nc" id="L266">      List&lt;Order&gt; orders = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">      for (SortCriterion criterion : sortCriteria) {</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        switch(criterion.getFieldName()) {</span>
          case &quot;name&quot;:
          case &quot;description&quot;:
          case &quot;role&quot;:
<span class="nc" id="L272">            Expression expression = group.get(criterion.getFieldName());</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (criterion.getOrder() == SortCriterion.Order.Ascending) {</span>
<span class="nc" id="L274">              orders.add(cb.asc(expression));</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            } else if (criterion.getOrder() == SortCriterion.Order.Descending) {</span>
<span class="nc" id="L276">              orders.add(cb.desc(expression));</span>
            }
            break;
          default:
<span class="nc" id="L280">            throw new IllegalArgumentException(&quot;Sorting criterion &quot; + criterion.getFieldName() + &quot; is not supported &quot;</span>
                + &quot;for groups.&quot;);
        }
<span class="nc" id="L283">      }</span>
<span class="nc" id="L284">      query.orderBy(orders);</span>

<span class="nc" id="L286">      TypedQuery&lt;JpaGroup&gt; typedQuery = em.createQuery(query);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">      if (limit.isPresent()) {</span>
<span class="nc" id="L288">        typedQuery.setMaxResults(limit.get());</span>
      }
<span class="nc bnc" id="L290" title="All 2 branches missed.">      if (offset.isPresent()) {</span>
<span class="nc" id="L291">        typedQuery.setFirstResult(offset.get());</span>
      }

<span class="nc" id="L294">      return typedQuery.getResultList();</span>
    };
  }

  /**
   * Returns all roles from the persistence unit as a list
   *
   * @param organization
   *          the organization
   * @param limit
   *          the limit
   * @param offset
   *          the offset
   * @return the roles list
   */
  public static Function&lt;EntityManager, List&lt;JpaRole&gt;&gt; findRolesQuery(String organization, int limit, int offset) {
<span class="nc" id="L310">    return em -&gt; {</span>
<span class="nc" id="L311">      TypedQuery&lt;JpaRole&gt; q = em.createNamedQuery(&quot;Role.findAll&quot;, JpaRole.class)</span>
<span class="nc" id="L312">          .setMaxResults(limit)</span>
<span class="nc" id="L313">          .setFirstResult(offset);</span>
<span class="nc" id="L314">      q.setParameter(&quot;org&quot;, organization);</span>
<span class="nc" id="L315">      return q.getResultList();</span>
    };
  }

  /**
   * Returns a list of roles by a search query if set or all roles if search query is &lt;code&gt;null&lt;/code&gt;
   *
   * @param orgId
   *          the organization identifier
   * @param query
   *          the query to search
   * @param limit
   *          the limit
   * @param offset
   *          the offset
   * @return the roles list
   */
  public static Function&lt;EntityManager, List&lt;JpaRole&gt;&gt; findRolesByQuery(String orgId, String query, int limit,
      int offset) {
<span class="nc" id="L334">    return em -&gt; {</span>
<span class="nc" id="L335">      TypedQuery&lt;JpaRole&gt; q = em.createNamedQuery(&quot;Role.findByQuery&quot;, JpaRole.class)</span>
<span class="nc" id="L336">          .setMaxResults(limit)</span>
<span class="nc" id="L337">          .setFirstResult(offset);</span>
<span class="nc" id="L338">      q.setParameter(&quot;query&quot;, query.toUpperCase());</span>
<span class="nc" id="L339">      q.setParameter(&quot;org&quot;, orgId);</span>
<span class="nc" id="L340">      return q.getResultList();</span>
    };
  }

  /**
   * Returns all user groups from the persistence unit as a list
   *
   * @param userName
   *          the user name
   * @param orgId
   *          the user's organization
   * @return the group list
   */
  public static Function&lt;EntityManager, List&lt;JpaGroup&gt;&gt; findGroupsByUserQuery(String userName, String orgId) {
<span class="fc" id="L354">    return namedQuery.findAll(</span>
        &quot;Group.findByUser&quot;,
        JpaGroup.class,
<span class="fc" id="L357">        Pair.of(&quot;username&quot;, userName),</span>
<span class="fc" id="L358">        Pair.of(&quot;organization&quot;, orgId)</span>
    );
  }

  /**
   * Returns the persisted organization by the given organization
   *
   * @param organization
   *          the organization
   * @return the organization or &lt;code&gt;null&lt;/code&gt; if not found
   */
  public static Function&lt;EntityManager, Optional&lt;JpaOrganization&gt;&gt; findOrganizationQuery(JpaOrganization organization) {
<span class="fc" id="L370">    return namedQuery.findOpt(</span>
        &quot;Organization.findById&quot;,
        JpaOrganization.class,
<span class="fc" id="L373">        Pair.of(&quot;id&quot;, organization.getId())</span>
    );
  }

  /**
   * Return specific users by their user names
   * @param userNames list of user names
   * @param organizationId organization to search for
   * @return the list of users that was found
   */
  public static Function&lt;EntityManager, List&lt;JpaUser&gt;&gt; findUsersByUserNameQuery(Collection&lt;String&gt; userNames,
      String organizationId) {
<span class="nc" id="L385">    return em -&gt; {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">      if (userNames.isEmpty()) {</span>
<span class="nc" id="L387">        return Collections.emptyList();</span>
      }
<span class="nc" id="L389">      TypedQuery&lt;JpaUser&gt; q = em.createNamedQuery(&quot;User.findAllByUserNames&quot;, JpaUser.class);</span>
<span class="nc" id="L390">      q.setParameter(&quot;names&quot;, userNames);</span>
<span class="nc" id="L391">      q.setParameter(&quot;org&quot;, organizationId);</span>
<span class="nc" id="L392">      return q.getResultList();</span>
    };
  }

  /**
   * Returns the persisted user by the user name and organization id
   *
   * @param userName
   *          the user name
   * @param organizationId
   *          the organization id
   * @return the user or &lt;code&gt;null&lt;/code&gt; if not found
   */
  public static Function&lt;EntityManager, Optional&lt;JpaUser&gt;&gt; findUserQuery(String userName, String organizationId) {
<span class="fc" id="L406">    return namedQuery.findOpt(</span>
        &quot;User.findByUsername&quot;,
        JpaUser.class,
<span class="fc" id="L409">        Pair.of(&quot;u&quot;, userName),</span>
<span class="fc" id="L410">        Pair.of(&quot;org&quot;, organizationId)</span>
    );
  }

  /**
   * Returns the persisted user by the user id and organization id
   *
   * @param id
   *          the user's unique id
   * @param organizationId
   *          the organization id
   * @return the user or &lt;code&gt;null&lt;/code&gt; if not found
   */
  public static Function&lt;EntityManager, Optional&lt;JpaUser&gt;&gt; findUserQuery(long id, String organizationId) {
<span class="nc" id="L424">    return namedQuery.findOpt(</span>
        &quot;User.findByIdAndOrg&quot;,
        JpaUser.class,
<span class="nc" id="L427">        Pair.of(&quot;id&quot;, id),</span>
<span class="nc" id="L428">        Pair.of(&quot;org&quot;, organizationId)</span>
    );
  }

  /**
   * Returns the total of users
   *
   * @param organizationId
   *          the organization id
   * @return the total number of users
   */
  public static Function&lt;EntityManager, Long&gt; countUsersQuery(String organizationId) {
<span class="nc" id="L440">    return namedQuery.find(</span>
        &quot;User.countAllByOrg&quot;,
        Long.class,
<span class="nc" id="L443">        Pair.of(&quot;org&quot;, organizationId)</span>
    );
  }

  /**
   * Returns the total number of users
   *
   * @return the total number of users
   */
  public static Function&lt;EntityManager, Long&gt; countUsersQuery() {
<span class="nc" id="L453">    return namedQuery.find(&quot;User.countAll&quot;, Long.class);</span>
  }

  /**
   * Returns a list of users by a search query if set or all users if search query is &lt;code&gt;null&lt;/code&gt;
   *
   * @param orgId
   *          the organization identifier
   * @param query
   *          the query to search
   * @param limit
   *          the limit
   * @param offset
   *          the offset
   * @return the users list
   */
  public static Function&lt;EntityManager, List&lt;JpaUser&gt;&gt; findUsersByQuery(String orgId, String query, int limit,
      int offset) {
<span class="fc" id="L471">    return em -&gt; {</span>
<span class="fc" id="L472">      TypedQuery&lt;JpaUser&gt; q = em.createNamedQuery(&quot;User.findByQuery&quot;, JpaUser.class)</span>
<span class="fc" id="L473">          .setMaxResults(limit)</span>
<span class="fc" id="L474">          .setFirstResult(offset);</span>
<span class="fc" id="L475">      q.setParameter(&quot;query&quot;, query.toUpperCase());</span>
<span class="fc" id="L476">      q.setParameter(&quot;org&quot;, orgId);</span>
<span class="fc" id="L477">      return q.getResultList();</span>
    };
  }

  /**
   * Returns a list of users by a search query if set or all users if search query is &lt;code&gt;null&lt;/code&gt;
   *
   * @param orgId,
   *          the organization id
   * @param limit
   *          the limit
   * @param offset
   *          the offset
   * @return the users list
   */
  public static Function&lt;EntityManager, List&lt;JpaUser&gt;&gt; findUsersQuery(String orgId, int limit, int offset) {
<span class="fc" id="L493">    return em -&gt; {</span>
<span class="fc" id="L494">      TypedQuery&lt;JpaUser&gt; q = em.createNamedQuery(&quot;User.findAll&quot;, JpaUser.class)</span>
<span class="fc" id="L495">          .setMaxResults(limit)</span>
<span class="fc" id="L496">          .setFirstResult(offset);</span>
<span class="fc" id="L497">      q.setParameter(&quot;org&quot;, orgId);</span>
<span class="fc" id="L498">      return q.getResultList();</span>
    };
  }

  /**
   * Returns the persisted role by the name and organization id
   *
   * @param name
   *          the role name
   * @param organization
   *          the organization id
   * @return the user or &lt;code&gt;null&lt;/code&gt; if not found
   */
  public static Function&lt;EntityManager, Optional&lt;JpaRole&gt;&gt; findRoleQuery(String name, String organization) {
<span class="fc" id="L512">    return namedQuery.findOpt(</span>
        &quot;Role.findByName&quot;,
        JpaRole.class,
<span class="fc" id="L515">        Pair.of(&quot;name&quot;, name),</span>
<span class="fc" id="L516">        Pair.of(&quot;org&quot;, organization)</span>
    );
  }

  /**
   * Returns the persisted group by the group id and organization id
   *
   * @param groupId
   *          the group id
   * @param orgId
   *          the organization id
   * @return the group or &lt;code&gt;null&lt;/code&gt; if not found
   */
  public static Function&lt;EntityManager, Optional&lt;JpaGroup&gt;&gt; findGroupQuery(String groupId, String orgId) {
<span class="fc" id="L530">    return namedQuery.findOpt(</span>
        &quot;Group.findById&quot;,
        JpaGroup.class,
<span class="fc" id="L533">        Pair.of(&quot;groupId&quot;, groupId),</span>
<span class="fc" id="L534">        Pair.of(&quot;organization&quot;, orgId)</span>
    );
  }

  /**
   * Returns the persisted group by the group role name and organization id
   *
   * @param role
   *          the role name
   * @param orgId
   *          the organization id
   * @return the group or &lt;code&gt;null&lt;/code&gt; if not found
   */
  public static Function&lt;EntityManager, Optional&lt;JpaGroup&gt;&gt; findGroupByRoleQuery(String role, String orgId) {
<span class="nc" id="L548">    return namedQuery.findOpt(</span>
        &quot;Group.findByRole&quot;,
        JpaGroup.class,
<span class="nc" id="L551">        Pair.of(&quot;role&quot;, role),</span>
<span class="nc" id="L552">        Pair.of(&quot;organization&quot;, orgId)</span>
    );
  }

  public static ThrowingConsumer&lt;EntityManager, NotFoundException&gt; removeGroupQuery(String groupId, String orgId) {
<span class="nc" id="L557">    return em -&gt; {</span>
<span class="nc" id="L558">      Optional&lt;JpaGroup&gt; group = findGroupQuery(groupId, orgId).apply(em);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">      if (group.isEmpty()) {</span>
<span class="nc" id="L560">        throw new NotFoundException(&quot;Group with ID &quot; + groupId + &quot; does not exist&quot;);</span>
      }
<span class="nc" id="L562">      em.remove(em.merge(group.get()));</span>
<span class="nc" id="L563">    };</span>
  }

  /**
   * Delete the user with given name in the given organization
   *
   * @param username
   *          the name of the user to delete
   * @param orgId
   *          the organization id
   */
  public static ThrowingConsumer&lt;EntityManager, NotFoundException&gt; deleteUserQuery(String username, String orgId) {
<span class="fc" id="L575">    return em -&gt; {</span>
<span class="fc" id="L576">      Optional&lt;JpaUser&gt; user = findUserQuery(username, orgId).apply(em);</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">      if (user.isEmpty()) {</span>
<span class="fc" id="L578">        throw new NotFoundException(&quot;User with name &quot; + username + &quot; does not exist&quot;);</span>
      }
<span class="fc" id="L580">      em.remove(em.merge(user.get()));</span>
<span class="fc" id="L581">    };</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>