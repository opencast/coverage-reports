<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AssetManagerImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-asset-manager-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.assetmanager.impl</a> &gt; <span class="el_source">AssetManagerImpl.java</span></div><h1>AssetManagerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.assetmanager.impl;

import static java.lang.String.format;
import static org.opencastproject.mediapackage.MediaPackageSupport.Filters.hasNoChecksum;
import static org.opencastproject.mediapackage.MediaPackageSupport.Filters.isNotPublication;
import static org.opencastproject.mediapackage.MediaPackageSupport.getFileName;
import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;
import static org.opencastproject.security.api.SecurityConstants.GLOBAL_CAPTURE_AGENT_ROLE;
import static org.opencastproject.security.util.SecurityUtil.getEpisodeRoleId;

import org.opencastproject.assetmanager.api.Asset;
import org.opencastproject.assetmanager.api.AssetId;
import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.AssetManagerException;
import org.opencastproject.assetmanager.api.Availability;
import org.opencastproject.assetmanager.api.Property;
import org.opencastproject.assetmanager.api.PropertyId;
import org.opencastproject.assetmanager.api.Snapshot;
import org.opencastproject.assetmanager.api.Value;
import org.opencastproject.assetmanager.api.Version;
import org.opencastproject.assetmanager.api.storage.AssetStore;
import org.opencastproject.assetmanager.api.storage.DeletionSelector;
import org.opencastproject.assetmanager.api.storage.RemoteAssetStore;
import org.opencastproject.assetmanager.api.storage.Source;
import org.opencastproject.assetmanager.api.storage.StoragePath;
import org.opencastproject.assetmanager.impl.persistence.Database;
import org.opencastproject.assetmanager.impl.persistence.SnapshotDto;
import org.opencastproject.authorization.xacml.manager.api.AclServiceFactory;
import org.opencastproject.authorization.xacml.manager.api.ManagedAcl;
import org.opencastproject.authorization.xacml.manager.util.AccessInformationUtil;
import org.opencastproject.db.DBSessionFactory;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.objects.event.EventIndexUtils;
import org.opencastproject.elasticsearch.index.rebuild.AbstractIndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildException;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildService;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildService.DataType;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.MediaPackageParser;
import org.opencastproject.mediapackage.MediaPackageSupport;
import org.opencastproject.message.broker.api.assetmanager.AssetManagerItem;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.metadata.dublincore.EventCatalogUIAdapter;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.security.api.DefaultOrganization;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.Role;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.api.User;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.util.Checksum;
import org.opencastproject.util.ChecksumType;
import org.opencastproject.util.MimeTypes;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RequireUtil;
import org.opencastproject.util.data.functions.Functions;
import org.opencastproject.workspace.api.Workspace;

import com.google.common.collect.Sets;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.checkerframework.checker.units.qual.A;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import javax.persistence.EntityManagerFactory;

/**
 * The Asset Manager implementation.
 */
@Component(
    property = {
        &quot;service.description=Opencast Asset Manager&quot;
    },
    immediate = true,
    service = { AssetManager.class, IndexProducer.class }
)
<span class="fc" id="L140">public class AssetManagerImpl extends AbstractIndexProducer implements AssetManager {</span>

<span class="fc" id="L142">  private static final Logger logger = LoggerFactory.getLogger(AssetManagerImpl.class);</span>

  private static final int PAGE_SIZE = 1000;

<span class="fc" id="L146">  enum AdminRole {</span>
<span class="fc" id="L147">    GLOBAL, ORGANIZATION, NONE</span>
  }

  public static final String WRITE_ACTION = &quot;write&quot;;
  public static final String READ_ACTION = &quot;read&quot;;
  public static final String SECURITY_NAMESPACE = &quot;org.opencastproject.assetmanager.security&quot;;

  private static final String MANIFEST_DEFAULT_NAME = &quot;manifest&quot;;

  private SecurityService securityService;
  private AuthorizationService authorizationService;
  private OrganizationDirectoryService orgDir;
  private Workspace workspace;
  private AssetStore assetStore;
  private HttpAssetProvider httpAssetProvider;
  private String systemUserName;
  private Database db;
  private DBSessionFactory dbSessionFactory;
  private EntityManagerFactory emf;
  private AclServiceFactory aclServiceFactory;
  private ElasticsearchIndex index;
<span class="fc" id="L168">  private Map&lt;String, List&lt;EventCatalogUIAdapter&gt;&gt; extendedEventCatalogUIAdapters = new HashMap&lt;&gt;();</span>

  // Settings for role filter
  private boolean includeAPIRoles;
  private boolean includeCARoles;
  private boolean includeUIRoles;


<span class="fc" id="L176">  public static final Set&lt;MediaPackageElement.Type&gt; MOVABLE_TYPES = Sets.newHashSet(</span>
          MediaPackageElement.Type.Attachment,
          MediaPackageElement.Type.Catalog,
          MediaPackageElement.Type.Track
  );

<span class="fc" id="L182">  private final HashMap&lt;String, RemoteAssetStore&gt; remoteStores = new LinkedHashMap&lt;&gt;();</span>

  /**
   * OSGi callback.
   */
  @Activate
  public synchronized void activate(ComponentContext cc) {
<span class="nc" id="L189">    logger.info(&quot;Activating AssetManager.&quot;);</span>
<span class="nc" id="L190">    db = new Database(dbSessionFactory.createSession(emf));</span>
<span class="nc" id="L191">    db.setHttpAssetProvider(getHttpAssetProvider());</span>
<span class="nc" id="L192">    systemUserName = SecurityUtil.getSystemUserName(cc);</span>

<span class="nc" id="L194">    includeAPIRoles = BooleanUtils.toBoolean(Objects.toString(cc.getProperties().get(&quot;includeAPIRoles&quot;), null));</span>
<span class="nc" id="L195">    includeCARoles = BooleanUtils.toBoolean(Objects.toString(cc.getProperties().get(&quot;includeCARoles&quot;), null));</span>
<span class="nc" id="L196">    includeUIRoles = BooleanUtils.toBoolean(Objects.toString(cc.getProperties().get(&quot;includeUIRoles&quot;), null));</span>
<span class="nc" id="L197">  }</span>

  /**
   * OSGi dependencies
   */

  @Reference(target = &quot;(osgi.unit.name=org.opencastproject.assetmanager.impl)&quot;)
  public void setEntityManagerFactory(EntityManagerFactory emf) {
<span class="nc" id="L205">    this.emf = emf;</span>
<span class="nc" id="L206">  }</span>

  @Reference
  public void setDBSessionFactory(DBSessionFactory dbSessionFactory) {
<span class="nc" id="L210">    this.dbSessionFactory = dbSessionFactory;</span>
<span class="nc" id="L211">  }</span>

  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L215">    this.securityService = securityService;</span>
<span class="fc" id="L216">  }</span>

  @Reference
  public void setAuthorizationService(AuthorizationService authorizationService) {
<span class="fc" id="L220">    this.authorizationService = authorizationService;</span>
<span class="fc" id="L221">  }</span>

  @Reference
  public void setOrgDir(OrganizationDirectoryService orgDir) {
<span class="nc" id="L225">    this.orgDir = orgDir;</span>
<span class="nc" id="L226">  }</span>

  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="fc" id="L230">    this.workspace = workspace;</span>
<span class="fc" id="L231">  }</span>

  @Reference
  public void setAssetStore(AssetStore assetStore) {
<span class="fc" id="L235">    this.assetStore = assetStore;</span>
<span class="fc" id="L236">  }</span>

  @Reference(
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeRemoteAssetStore&quot;
  )
  public synchronized void addRemoteAssetStore(RemoteAssetStore assetStore) {
<span class="fc" id="L244">    remoteStores.put(assetStore.getStoreType(), assetStore);</span>
<span class="fc" id="L245">  }</span>

  public void removeRemoteAssetStore(RemoteAssetStore store) {
<span class="nc" id="L248">    remoteStores.remove(store.getStoreType());</span>
<span class="nc" id="L249">  }</span>

  @Reference
  public void setHttpAssetProvider(HttpAssetProvider httpAssetProvider) {
<span class="fc" id="L253">    this.httpAssetProvider = httpAssetProvider;</span>
<span class="fc" id="L254">  }</span>

  @Reference
  public void setAclServiceFactory(AclServiceFactory aclServiceFactory) {
<span class="nc" id="L258">    this.aclServiceFactory = aclServiceFactory;</span>
<span class="nc" id="L259">  }</span>

  @Reference
  public void setIndex(ElasticsearchIndex index) {
<span class="fc" id="L263">    this.index = index;</span>
<span class="fc" id="L264">  }</span>

  @Reference(cardinality = ReferenceCardinality.MULTIPLE, policy = ReferencePolicy.DYNAMIC,
          target = &quot;(common-metadata=false)&quot;)
  public synchronized void addCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L269">    List&lt;EventCatalogUIAdapter&gt; list = extendedEventCatalogUIAdapters.computeIfAbsent(</span>
<span class="nc" id="L270">            catalogUIAdapter.getOrganization(), k -&gt; new ArrayList());</span>
<span class="nc" id="L271">    list.add(catalogUIAdapter);</span>
<span class="nc" id="L272">  }</span>

  public synchronized void removeCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="nc bnc" id="L275" title="All 2 branches missed.">    if (extendedEventCatalogUIAdapters.containsKey(catalogUIAdapter.getOrganization())) {</span>
<span class="nc" id="L276">      extendedEventCatalogUIAdapters.get(catalogUIAdapter.getOrganization()).remove(catalogUIAdapter);</span>
    }
<span class="nc" id="L278">  }</span>

  /**
   * AssetManager implementation
   */

  @Override
  public Optional&lt;MediaPackage&gt; getMediaPackage(String mediaPackageId) {
<span class="fc" id="L286">    String orgId = securityService.getOrganization().getId();</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L289">        return getDatabase().getMediaPackage(mediaPackageId);</span>
      default:
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (isAuthorized(mediaPackageId, READ_ACTION)) {</span>
<span class="nc" id="L292">          return getDatabase().getMediaPackage(mediaPackageId, orgId);</span>
        }
<span class="nc" id="L294">        return Optional.empty();</span>
    }
  }

  @Override
  public List&lt;Snapshot&gt; getLatestSnapshots(Collection mediaPackageIds) {
<span class="fc" id="L300">    String orgId = securityService.getOrganization().getId();</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L303">        return getDatabase().getLatestSnapshotsByMediaPackageIds(mediaPackageIds, null);</span>
      default:
<span class="nc" id="L305">        mediaPackageIds = isAuthorized(mediaPackageIds.stream().toList(), READ_ACTION);</span>
<span class="nc" id="L306">        return getDatabase().getLatestSnapshotsByMediaPackageIds(mediaPackageIds, orgId);</span>
    }
  }

  @Override
  public Optional&lt;Snapshot&gt; getLatestSnapshot(String mediaPackageId) {
<span class="fc" id="L312">    String orgId = securityService.getOrganization().getId();</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L315">        return getDatabase().getLatestSnapshot(mediaPackageId);</span>
      default:
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (isAuthorized(mediaPackageId, READ_ACTION)) {</span>
<span class="nc" id="L318">          return getDatabase().getLatestSnapshot(mediaPackageId, orgId);</span>
        }
<span class="nc" id="L320">        return Optional.empty();</span>
    }
  }

  @Override
  public Optional&lt;Asset&gt; getAsset(Version version, String mpId, String mpElementId) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">    if (isAuthorized(mpId, READ_ACTION)) {</span>
      // try to fetch the asset
<span class="fc" id="L328">      var asset = getDatabase().getAsset(RuntimeTypes.convert(version), mpId, mpElementId);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">      if (asset.isPresent()) {</span>
<span class="fc" id="L330">        var storageId = getSnapshotStorageLocation(version, mpId);</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (storageId.isPresent()) {</span>
<span class="fc" id="L332">          var store = getAssetStore(storageId.get());</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">          if (store.isPresent()) {</span>
<span class="fc" id="L334">            var assetStream = store.get().get(StoragePath.mk(</span>
<span class="fc" id="L335">                asset.get().getOrganizationId(),</span>
                mpId,
                version,
                mpElementId
            ));
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">            if (assetStream.isPresent()) {</span>

<span class="fc" id="L342">              Checksum checksum = null;</span>
              try {
<span class="fc" id="L344">                checksum = Checksum.fromString(asset.get().getAssetDto().getChecksum());</span>
<span class="nc" id="L345">              } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L346">                logger.warn(&quot;Invalid checksum for asset {} of media package {}&quot;, mpElementId, mpId, e);</span>
<span class="fc" id="L347">              }</span>

<span class="fc" id="L349">              final Asset a = new AssetImpl(</span>
<span class="fc" id="L350">                      AssetId.mk(version, mpId, mpElementId),</span>
<span class="fc" id="L351">                      assetStream.get(),</span>
<span class="fc" id="L352">                      asset.get().getAssetDto().getMimeType(),</span>
<span class="fc" id="L353">                      asset.get().getAssetDto().getSize(),</span>
<span class="fc" id="L354">                      asset.get().getStorageId(),</span>
<span class="fc" id="L355">                      asset.get().getAvailability(),</span>
                      checksum);
<span class="fc" id="L357">              return Optional.of(a);</span>
            }
          }
        }
      }
<span class="fc" id="L362">      return Optional.empty();</span>
    }
<span class="fc" id="L364">    throw new RuntimeException(new UnauthorizedException(</span>
<span class="fc" id="L365">            format(&quot;Not allowed to read assets of snapshot %s, version=%s&quot;, mpId, version)</span>
    ));
  }

  @Override
  public Optional&lt;AssetStore&gt; getAssetStore(String storeId) {
<span class="fc bfc" id="L371" title="All 2 branches covered.">    if (assetStore.getStoreType().equals(storeId)) {</span>
<span class="fc" id="L372">      return Optional.of(assetStore);</span>
    } else {
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">      if (remoteStores.containsKey(storeId)) {</span>
<span class="fc" id="L375">        return Optional.of(remoteStores.get(storeId));</span>
      } else {
<span class="nc" id="L377">        return Optional.empty();</span>
      }
    }
  }

  @Override
  public AssetStore getLocalAssetStore() {
<span class="fc" id="L384">    return assetStore;</span>
  }

  @Override
  public List&lt;AssetStore&gt; getRemoteAssetStores() {
<span class="fc" id="L389">    return new ArrayList&lt;&gt;(remoteStores.values());</span>
  }

  /** Snapshots */

  @Override
  public boolean snapshotExists(final String mediaPackageId) {
<span class="fc" id="L396">    return getDatabase().snapshotExists(mediaPackageId);</span>
  }

  @Override
  public boolean snapshotExists(final String mediaPackageId, final String organization) {
<span class="fc" id="L401">    return getDatabase().snapshotExists(mediaPackageId, organization);</span>
  }

  @Override
  public Snapshot takeSnapshot(MediaPackage mp) {
<span class="nc" id="L406">    return takeSnapshot(null, mp);</span>
  }

  @Override
  public Snapshot takeSnapshot(String owner, MediaPackage mp) {

<span class="fc" id="L412">    final String mediaPackageId = mp.getIdentifier().toString();</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">    final boolean firstSnapshot = !snapshotExists(mediaPackageId);</span>

    // Allow this if:
    //  - no previous snapshot exists
    //  - the user has write access to the previous snapshot
<span class="fc bfc" id="L418" title="All 2 branches covered.">    if (firstSnapshot) {</span>
      // if it's the first snapshot, ensure that old, leftover properties are removed
<span class="fc" id="L420">      deleteProperties(mediaPackageId);</span>
    }
<span class="pc bpc" id="L422" title="1 of 4 branches missed.">    if (firstSnapshot || isAuthorized(mediaPackageId, WRITE_ACTION)) {</span>
      final Snapshot snapshot;
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">      if (owner == null) {</span>
<span class="nc" id="L425">        snapshot = takeSnapshotInternal(mp);</span>
      } else {
<span class="fc" id="L427">        snapshot = takeSnapshotInternal(owner, mp);</span>
      }

<span class="fc" id="L430">      final AccessControlList acl = authorizationService.getActiveAcl(mp).getA();</span>
      // store acl as properties
      // Drop old ACL rules
<span class="fc" id="L433">      deleteProperties(mediaPackageId, SECURITY_NAMESPACE);</span>
      // Set new ACL rules
<span class="fc bfc" id="L435" title="All 2 branches covered.">      for (final AccessControlEntry ace : acl.getEntries()) {</span>
<span class="fc" id="L436">        getDatabase().saveProperty(Property.mk(PropertyId.mk(mediaPackageId, SECURITY_NAMESPACE,</span>
<span class="fc" id="L437">                mkPropertyName(ace.getRole(), ace.getAction())), Value.mk(ace.isAllow())));</span>
<span class="fc" id="L438">      }</span>

<span class="fc" id="L440">      updateEventInIndex(snapshot);</span>

<span class="fc" id="L442">      return snapshot;</span>
    }
<span class="nc" id="L444">    throw new RuntimeException(new UnauthorizedException(</span>
        &quot;Not allowed to take snapshot of media package &quot; + mediaPackageId));
  }

  private Snapshot takeSnapshotInternal(MediaPackage mediaPackage) {
<span class="nc" id="L449">    final String mediaPackageId = mediaPackage.getIdentifier().toString();</span>
<span class="nc" id="L450">    String orgId = securityService.getOrganization().getId();</span>
    Optional&lt;Snapshot&gt; snapshot;
<span class="nc bnc" id="L452" title="All 2 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="nc" id="L454">        snapshot = getDatabase().getLatestSnapshot(mediaPackageId);</span>
<span class="nc" id="L455">        break;</span>
      default:
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (isAuthorized(mediaPackageId, WRITE_ACTION)) {</span>
<span class="nc" id="L458">          snapshot = getDatabase().getLatestSnapshot(mediaPackageId, orgId);</span>
        } else {
<span class="nc" id="L460">          snapshot = Optional.empty();</span>
        }
        break;
    }
<span class="nc bnc" id="L464" title="All 2 branches missed.">    if (snapshot.isPresent()) {</span>
<span class="nc" id="L465">      return takeSnapshotInternal(snapshot.get().getOwner(), mediaPackage);</span>
    }
<span class="nc" id="L467">    return takeSnapshotInternal(DEFAULT_OWNER, mediaPackage);</span>
  }

  private Snapshot takeSnapshotInternal(final String owner, final MediaPackage mp) {
    try {
<span class="fc" id="L472">      Snapshot archived = addInternal(owner, MediaPackageSupport.copy(mp)).toSnapshot();</span>
<span class="fc" id="L473">      return getHttpAssetProvider().prepareForDelivery(archived);</span>
<span class="nc" id="L474">    } catch (Exception e) {</span>
<span class="nc" id="L475">      logger.error(&quot;An error occurred&quot;, e);</span>
<span class="nc" id="L476">      throw unwrapExceptionUntil(AssetManagerException.class, e).orElse(new AssetManagerException(e));</span>
    }
  }

  /**
   * Create a {@link AssetManagerItem.TakeSnapshot} message.
   * &lt;p&gt;
   * Do not call outside of a security context.
   */
  private AssetManagerItem.TakeSnapshot mkTakeSnapshotMessage(Snapshot snapshot) {
<span class="nc" id="L486">    final MediaPackage mp = snapshot.getMediaPackage();</span>

    long version;
    try {
<span class="nc" id="L490">      version = Long.parseLong(snapshot.getVersion().toString());</span>
<span class="nc" id="L491">    } catch (NumberFormatException e) {</span>
      // The index requires a version to be a long value.
      // Since the asset manager default implementation uses long values that should be not a problem.
      // However, a decent exception message is helpful if a different implementation of the asset manager
      // is used.
<span class="nc" id="L496">      throw new RuntimeException(&quot;The current implementation of the index requires versions being of type 'long'.&quot;);</span>
<span class="nc" id="L497">    }</span>

<span class="nc" id="L499">    return AssetManagerItem.add(workspace, mp, authorizationService.getActiveAcl(mp).getA(),</span>
<span class="nc" id="L500">            version, snapshot.getArchivalDate());</span>
  }

  @Override
  public void triggerIndexUpdate(String mediaPackageId) throws NotFoundException, UnauthorizedException {

<span class="nc bnc" id="L506" title="All 2 branches missed.">    if (!securityService.getUser().hasRole(&quot;ROLE_ADMIN&quot;)) {</span>
<span class="nc" id="L507">      throw new UnauthorizedException(&quot;Only global administrators may trigger manual event updates.&quot;);</span>
    }
<span class="nc" id="L509">    Optional&lt;Snapshot&gt; snapshot = getDatabase().getLatestSnapshot(mediaPackageId);</span>

<span class="nc bnc" id="L511" title="All 2 branches missed.">    if (snapshot.isEmpty()) {</span>
<span class="nc" id="L512">      throw new NotFoundException(&quot;No event with ID `&quot; + mediaPackageId + &quot;`&quot;);</span>
    }

    // Update event index with latest snapshot
<span class="nc" id="L516">    updateEventInIndex(snapshot.get());</span>
<span class="nc" id="L517">  }</span>

  /**
   * Update the event in the Elasticsearch index.
   *
   * @param snapshot
   *         The newest snapshot of the event to update
   */
  private void updateEventInIndex(Snapshot snapshot) {
<span class="fc" id="L526">    final MediaPackage mp = snapshot.getMediaPackage();</span>
<span class="fc" id="L527">    String eventId = mp.getIdentifier().toString();</span>
<span class="fc" id="L528">    final String organization = securityService.getOrganization().getId();</span>
<span class="fc" id="L529">    final User user = securityService.getUser();</span>
<span class="fc" id="L530">    logger.debug(&quot;Updating event {} in the {} index.&quot;, eventId, index.getIndexName());</span>

<span class="fc" id="L532">    Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; updateFunction = (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
<span class="nc" id="L533">      Event event = eventOpt.orElse(new Event(eventId, organization));</span>

<span class="nc" id="L535">      AccessControlList acl = authorizationService.getActiveAcl(mp).getA();</span>
<span class="nc" id="L536">      List&lt;ManagedAcl&gt; acls = aclServiceFactory.serviceFor(securityService.getOrganization()).getAcls();</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">      for (final ManagedAcl managedAcl : AccessInformationUtil.matchAcls(acls, acl)) {</span>
<span class="nc" id="L538">        event.setManagedAcl(managedAcl.getName());</span>
<span class="nc" id="L539">      }</span>
<span class="nc" id="L540">      event.setAccessPolicy(AccessControlParser.toJsonSilent(acl));</span>
<span class="nc" id="L541">      event.setArchiveVersion(Long.parseLong(snapshot.getVersion().toString()));</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">      if (StringUtils.isBlank(event.getCreator())) {</span>
<span class="nc" id="L543">        event.setCreator(securityService.getUser().getName());</span>
      }
<span class="nc" id="L545">      EventIndexUtils.updateEvent(event, mp);</span>

      // common metadata
<span class="nc bnc" id="L548" title="All 2 branches missed.">      for (Catalog catalog: mp.getCatalogs(MediaPackageElements.EPISODE)) {</span>
<span class="nc" id="L549">        try (InputStream in = workspace.read(catalog.getURI())) {</span>
<span class="nc" id="L550">          EventIndexUtils.updateEvent(event, DublinCores.read(in));</span>
<span class="nc" id="L551">        } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L552">          throw new IllegalStateException(String.format(&quot;Unable to load common dublin core catalog for event '%s'&quot;,</span>
<span class="nc" id="L553">                  mp.getIdentifier()), e);</span>
<span class="nc" id="L554">        }</span>
      }

      // extended metadata
<span class="nc" id="L558">      event.resetExtendedMetadata();  // getting rid of old data</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">      for (EventCatalogUIAdapter extendedCatalogUIAdapter : extendedEventCatalogUIAdapters.getOrDefault(organization,</span>
<span class="nc" id="L560">              Collections.emptyList())) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        for (Catalog catalog: mp.getCatalogs(extendedCatalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L562">          try (InputStream in = workspace.read(catalog.getURI())) {</span>
<span class="nc" id="L563">            EventIndexUtils.updateEventExtendedMetadata(event, DublinCores.read(in),</span>
<span class="nc" id="L564">                    extendedCatalogUIAdapter.getFlavor());</span>
<span class="nc" id="L565">          } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L566">            throw new IllegalStateException(String.format(&quot;Unable to load extended dublin core catalog '%s' for event &quot;</span>
<span class="nc" id="L567">                            + &quot;'%s'&quot;, catalog.getFlavor(), mp.getIdentifier()), e);</span>
<span class="nc" id="L568">          }</span>
        }
<span class="nc" id="L570">      }</span>

      // Update series name if not already done
      try {
<span class="nc" id="L574">        EventIndexUtils.updateSeriesName(event, organization, user, index);</span>
<span class="nc" id="L575">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L576">        logger.error(&quot;Error updating the series name of the event {} in the {} index.&quot;, eventId, index.getIndexName(),</span>
                e);
<span class="nc" id="L578">      }</span>
<span class="nc" id="L579">      return Optional.of(event);</span>
    };

    // Persist the scheduling event
    try {
<span class="fc" id="L584">      index.addOrUpdateEvent(eventId, updateFunction, organization, user);</span>
<span class="fc" id="L585">      logger.debug(&quot;Event {} updated in the {} index.&quot;, eventId, index.getIndexName());</span>
<span class="nc" id="L586">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L587">      logger.error(&quot;Error updating the event {} in the {} index.&quot;, eventId, index.getIndexName(), e);</span>
<span class="fc" id="L588">    }</span>
<span class="fc" id="L589">  }</span>

  /**
   * Remove the event from the Elasticsearch index
   *
   * @param eventId
   *         The id of the event to remove
   */
  private void removeArchivedVersionFromIndex(String eventId) {
<span class="nc" id="L598">    final String orgId = securityService.getOrganization().getId();</span>
<span class="nc" id="L599">    final User user = securityService.getUser();</span>
<span class="nc" id="L600">    logger.debug(&quot;Received AssetManager delete episode message {}&quot;, eventId);</span>

<span class="nc" id="L602">    Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; updateFunction = (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">      if (eventOpt.isEmpty()) {</span>
<span class="nc" id="L604">        logger.warn(&quot;Event {} not found for deletion&quot;, eventId);</span>
<span class="nc" id="L605">        return Optional.empty();</span>
      }
<span class="nc" id="L607">      Event event = eventOpt.get();</span>
<span class="nc" id="L608">      event.setArchiveVersion(null);</span>
<span class="nc" id="L609">      return Optional.of(event);</span>
    };

    try {
<span class="nc" id="L613">      index.addOrUpdateEvent(eventId, updateFunction, orgId, user);</span>
<span class="nc" id="L614">      logger.debug(&quot;Event {} removed from the {} index&quot;, eventId, index.getIndexName());</span>
<span class="nc" id="L615">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L616">      logger.error(&quot;Error deleting the event {} from the {} index.&quot;, eventId, index.getIndexName(), e);</span>
<span class="nc" id="L617">    }</span>
<span class="nc" id="L618">  }</span>

  @Override
  public List&lt;Snapshot&gt; getSnapshotsById(final String mpId) {
<span class="fc" id="L622">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>

<span class="fc" id="L624">    String orgId = securityService.getOrganization().getId();</span>

<span class="pc bpc" id="L626" title="1 of 2 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L628">        return getDatabase().getSnapshots(mpId);</span>
      default:
<span class="nc bnc" id="L630" title="All 2 branches missed.">        if (isAuthorized(mpId, READ_ACTION)) {</span>
<span class="nc" id="L631">          return getDatabase().getSnapshots(mpId, orgId);</span>
        }
<span class="nc" id="L633">        return new ArrayList&lt;&gt;();</span>
    }
  }

  @Override
  public List&lt;Snapshot&gt; getSnapshotsByIdOrderedByVersion(String mpId, boolean asc) {
<span class="fc" id="L639">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>

    String order;
<span class="fc bfc" id="L642" title="All 2 branches covered.">    if (asc) {</span>
<span class="fc" id="L643">      order = &quot;ASC&quot;;</span>
    } else {
<span class="fc" id="L645">      order = &quot;DESC&quot;;</span>
    }

<span class="fc" id="L648">    String orgId = securityService.getOrganization().getId();</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L651">        return getDatabase().getSnapshots(mpId, null, order);</span>
      default:
<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (isAuthorized(mpId, READ_ACTION)) {</span>
<span class="nc" id="L654">          return getDatabase().getSnapshots(mpId, orgId);</span>
        }
<span class="nc" id="L656">        return new ArrayList&lt;&gt;();</span>
    }
  }

  @Override
  public List&lt;Snapshot&gt; getSnapshotsByIdAndVersion(final String mpId, final Version version) {
<span class="fc" id="L662">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L663">    RequireUtil.notNull(version, &quot;version&quot;);</span>

<span class="fc" id="L665">    String orgId = securityService.getOrganization().getId();</span>
    // TODO: Simplify the version class?
<span class="fc" id="L667">    Long v = Long.parseLong(version.toString());</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L670">        return getDatabase().getSnapshotsByMpIdAndVersion(mpId, v, null);</span>
      default:
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        if (isAuthorized(mpId, READ_ACTION)) {</span>
<span class="fc" id="L673">          return getDatabase().getSnapshotsByMpIdAndVersion(mpId, v, orgId);</span>
        }
<span class="nc" id="L675">        return new ArrayList&lt;&gt;();</span>
    }
  }

  @Override
  public List&lt;Snapshot&gt; getSnapshotsByDateOrderedById(Date start, Date end) {
<span class="fc" id="L681">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="fc" id="L682">    RequireUtil.notNull(end, &quot;end&quot;);</span>

<span class="fc" id="L684">    String orgId = securityService.getOrganization().getId();</span>
<span class="pc bpc" id="L685" title="2 of 3 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L687">        return getDatabase().getSnapshotsByDateOrderByMpId(start, end, null);</span>
      case ORGANIZATION:
<span class="nc" id="L689">        return getDatabase().getSnapshotsByDateOrderByMpId(start, end, orgId);</span>
      default:
<span class="nc" id="L691">        List&lt;Snapshot&gt; snapshots = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L692">        List&lt;Snapshot&gt; snaps = getDatabase().getSnapshotsByDateOrderByMpId(start, end, orgId);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">        for (int i = 0; i &lt; snaps.size(); i++) {</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">          if (isAuthorized(snaps.get(i).getMediaPackage().getIdentifier().toString(), READ_ACTION)) {</span>
<span class="nc" id="L695">            snapshots.add(snaps.get(i));</span>
          }
        }
<span class="nc" id="L698">        return snapshots;</span>
    }
  }

  @Override
  public List&lt;Snapshot&gt; getSnapshotsByIdAndDate(final String mpId, final Date start, final Date end) {
<span class="fc" id="L704">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L705">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="fc" id="L706">    RequireUtil.notNull(end, &quot;end&quot;);</span>

<span class="fc" id="L708">    String orgId = securityService.getOrganization().getId();</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L711">        return getDatabase().getSnapshotsByMpdIdAndDate(mpId, start, end, null);</span>
      default:
<span class="nc bnc" id="L713" title="All 2 branches missed.">        if (isAuthorized(mpId, READ_ACTION)) {</span>
<span class="nc" id="L714">          return getDatabase().getSnapshotsByMpdIdAndDate(mpId, start, end, orgId);</span>
        }
<span class="nc" id="L716">        return new ArrayList&lt;&gt;();</span>
    }
  }

  @Override
  public List&lt;Snapshot&gt; getSnapshotsByIdAndDateOrderedByVersion(String mpId, Date start, Date end, boolean asc) {
<span class="fc" id="L722">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L723">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="fc" id="L724">    RequireUtil.notNull(end, &quot;end&quot;);</span>

    String order;
<span class="fc bfc" id="L727" title="All 2 branches covered.">    if (asc) {</span>
<span class="fc" id="L728">      order = &quot;ASC&quot;;</span>
    } else {
<span class="fc" id="L730">      order = &quot;DESC&quot;;</span>
    }

<span class="fc" id="L733">    String orgId = securityService.getOrganization().getId();</span>
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L736">        return getDatabase().getSnapshotsByMpdIdAndDate(mpId, start, end, null, order);</span>
      default:
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (isAuthorized(mpId, READ_ACTION)) {</span>
<span class="nc" id="L739">          return getDatabase().getSnapshotsByMpdIdAndDate(mpId, start, end, orgId, order);</span>
        }
<span class="nc" id="L741">        return new ArrayList&lt;&gt;();</span>
    }
  }

  @Override
  public List&lt;Snapshot&gt; getLatestSnapshotsBySeriesId(final String seriesId) {
<span class="fc" id="L747">    RequireUtil.requireNotBlank(seriesId, &quot;seriesId&quot;);</span>

<span class="fc" id="L749">    String orgId = securityService.getOrganization().getId();</span>

<span class="pc bpc" id="L751" title="2 of 3 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L753">        return getDatabase().getSnapshotsBySeries(seriesId, null);</span>
      case ORGANIZATION:
<span class="nc" id="L755">        return getDatabase().getSnapshotsBySeries(seriesId, orgId);</span>
      default:
<span class="nc" id="L757">        List&lt;Snapshot&gt; snapshots = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L758">        List&lt;Snapshot&gt; snaps = getDatabase().getSnapshotsBySeries(seriesId, orgId);</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">        for (int i = 0; i &lt; snaps.size(); i++) {</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">          if (isAuthorized(snaps.get(i).getMediaPackage().getIdentifier().toString(), READ_ACTION)) {</span>
<span class="nc" id="L761">            snapshots.add(snaps.get(i));</span>
          }
        }
<span class="nc" id="L764">        return snapshots;</span>
    }
  }

  @Override
  public Optional&lt;Snapshot&gt; getSnapshotByMpIdOrgIdAndVersion(String mpId, String orgId, Version version) {
<span class="fc" id="L770">    return getDatabase().getSnapshot(mpId, orgId, Long.parseLong(version.toString()));</span>
  }

  @Override
  public int deleteSnapshots(String mpId) {
<span class="fc" id="L775">    String orgId = securityService.getOrganization().getId();</span>
<span class="fc" id="L776">    int numberOfDeletedSnapshots = 0;</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L779">        numberOfDeletedSnapshots = getDatabase().deleteSnapshots(mpId, null);</span>
<span class="fc" id="L780">        break;</span>
      default:
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (isAuthorized(mpId, WRITE_ACTION)) {</span>
<span class="nc" id="L783">          numberOfDeletedSnapshots = getDatabase().deleteSnapshots(mpId, orgId);</span>
        }
        break;
    }

    // delete from store
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">    if (numberOfDeletedSnapshots &gt; 0) {</span>
<span class="fc" id="L790">      final DeletionSelector deletionSelector = DeletionSelector.deleteAll(orgId, mpId);</span>
<span class="fc" id="L791">      getLocalAssetStore().delete(deletionSelector);</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">      for (AssetStore as : getRemoteAssetStores()) {</span>
<span class="fc" id="L793">        as.delete(deletionSelector);</span>
<span class="fc" id="L794">      }</span>
    }

<span class="fc" id="L797">    return numberOfDeletedSnapshots;</span>
  }

  @Override
  public int deleteAllButLatestSnapshot(String mpId) {
<span class="fc" id="L802">    String orgId = securityService.getOrganization().getId();</span>
<span class="fc" id="L803">    int numberOfDeletedSnapshots = 0;</span>
<span class="fc" id="L804">    List&lt;Long&gt; versions = getDatabase().getVersionsByMediaPackage(mpId, null);</span>

<span class="pc bpc" id="L806" title="1 of 2 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L808">        numberOfDeletedSnapshots = getDatabase().deleteAllButLatestSnapshot(mpId, null);</span>
<span class="fc" id="L809">        break;</span>
      default:
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (isAuthorized(mpId, WRITE_ACTION)) {</span>
<span class="nc" id="L812">          numberOfDeletedSnapshots = getDatabase().deleteAllButLatestSnapshot(mpId, orgId);</span>
        }
        break;
    }

    // delete from store
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">    if (numberOfDeletedSnapshots &gt; 0) {</span>
      // Skip last version
<span class="fc bfc" id="L820" title="All 2 branches covered.">      for (int i = 0; i &lt; versions.size() - 1; i++) {</span>
<span class="fc" id="L821">        final DeletionSelector deletionSelector = DeletionSelector.delete(orgId, mpId,</span>
<span class="fc" id="L822">            new VersionImpl(versions.get(i)));</span>
<span class="fc" id="L823">        getLocalAssetStore().delete(deletionSelector);</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">        for (AssetStore as : getRemoteAssetStores()) {</span>
<span class="fc" id="L825">          as.delete(deletionSelector);</span>
<span class="fc" id="L826">        }</span>
      }
    }

<span class="fc" id="L830">    return numberOfDeletedSnapshots;</span>
  }

  @Override
  public void moveSnapshotsById(final String mpId, final String targetStore) throws NotFoundException {
<span class="nc" id="L835">    List&lt;Snapshot&gt; snapshots = getSnapshotsById(mpId);</span>

<span class="nc bnc" id="L837" title="All 2 branches missed.">    if (snapshots.isEmpty()) {</span>
<span class="nc" id="L838">      throw new NotFoundException(&quot;Mediapackage &quot; + mpId + &quot; not found!&quot;);</span>
    }

<span class="nc" id="L841">    processOperations(snapshots, targetStore);</span>
<span class="nc" id="L842">  }</span>

  @Override
  public void moveSnapshotsByIdAndVersion(final String mpId, final Version version, final String targetStore)
          throws NotFoundException {
<span class="nc" id="L847">    List&lt;Snapshot&gt; snapshots = getSnapshotsByIdAndVersion(mpId, version);</span>

<span class="nc bnc" id="L849" title="All 2 branches missed.">    if (snapshots.isEmpty()) {</span>
<span class="nc" id="L850">      throw new NotFoundException(&quot;Mediapackage &quot; + mpId + &quot;@&quot; + version.toString() + &quot; not found!&quot;);</span>
    }

<span class="nc" id="L853">    processOperations(snapshots, targetStore);</span>
<span class="nc" id="L854">  }</span>

  @Override
  public void moveSnapshotsByDate(final Date start, final Date end, final String targetStore)
          throws NotFoundException {
<span class="nc" id="L859">    String orgId = securityService.getOrganization().getId();</span>
<span class="nc" id="L860">    List&lt;Snapshot&gt; snapshots = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L861" title="All 3 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="nc" id="L863">        snapshots = getDatabase().getSnapshotsByNotStorageAndDate(targetStore, start, end, null);</span>
<span class="nc" id="L864">        break;</span>
      case ORGANIZATION:
<span class="nc" id="L866">        snapshots = getDatabase().getSnapshotsByNotStorageAndDate(targetStore, start, end, orgId);</span>
<span class="nc" id="L867">        break;</span>
      default:
<span class="nc" id="L869">        List&lt;Snapshot&gt; snaps = getDatabase().getSnapshotsByNotStorageAndDate(targetStore, start, end, orgId);</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">        for (int i = 0; i &lt; snaps.size(); i++) {</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">          if (isAuthorized(snaps.get(i).getMediaPackage().getIdentifier().toString(), READ_ACTION)) {</span>
<span class="nc" id="L872">            snapshots.add(snaps.get(i));</span>
          }
        }
        break;
    }

<span class="nc bnc" id="L878" title="All 2 branches missed.">    if (snapshots.isEmpty()) {</span>
<span class="nc" id="L879">      throw new NotFoundException(&quot;No media packages found between &quot; + start + &quot; and &quot; + end);</span>
    }

<span class="nc" id="L882">    processOperations(snapshots, targetStore);</span>
<span class="nc" id="L883">  }</span>

  @Override
  public void moveSnapshotsByIdAndDate(final String mpId, final Date start, final Date end, final String targetStore)
          throws NotFoundException {
<span class="nc" id="L888">    List&lt;Snapshot&gt; snapshots = getSnapshotsByIdAndDate(mpId, start, end);</span>

<span class="nc bnc" id="L890" title="All 2 branches missed.">    if (snapshots.isEmpty()) {</span>
<span class="nc" id="L891">      throw new NotFoundException(&quot;No media package with id &quot; + mpId + &quot; found between &quot; + start + &quot; and &quot; + end);</span>
    }

<span class="nc" id="L894">    processOperations(snapshots, targetStore);</span>
<span class="nc" id="L895">  }</span>

  @Override
  public void moveSnapshotToStore(final Version version, final String mpId, final String storeId)
          throws NotFoundException {

    //Find the snapshot
<span class="fc" id="L902">    List&lt;Snapshot&gt; snapshots = getSnapshotsByIdAndVersion(mpId, version);</span>

<span class="fc bfc" id="L904" title="All 2 branches covered.">    if (snapshots.isEmpty()) {</span>
<span class="fc" id="L905">      throw new NotFoundException(&quot;Mediapackage &quot; + mpId + &quot;@&quot; + version.toString() + &quot; not found!&quot;);</span>
    }
<span class="fc" id="L907">    processOperations(snapshots, storeId);</span>
<span class="fc" id="L908">  }</span>

  //Do the actual moving
  //TODO: Compare this to AssetManagerJobProducer.moveSnapshots. Check if they can be combined.
  private void processOperations(List&lt;Snapshot&gt; snapshots, final String targetStoreId) {
<span class="fc" id="L913">    snapshots.forEach(s -&gt; {</span>
//      Snapshot s = record.getSnapshot().get();
<span class="fc" id="L915">      Optional&lt;String&gt; currentStoreId = getSnapshotStorageLocation(s);</span>

<span class="pc bpc" id="L917" title="1 of 2 branches missed.">      if (currentStoreId.isEmpty()) {</span>
<span class="nc" id="L918">        logger.warn(&quot;IsNone store ID&quot;);</span>
<span class="nc" id="L919">        return;</span>
      }

      //If this snapshot is already stored in the desired store
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">      if (currentStoreId.get().equals(targetStoreId)) {</span>
        //return, since we don't need to move anything
<span class="nc" id="L925">        return;</span>
      }

      AssetStore currentStore;
      AssetStore targetStore;

<span class="fc" id="L931">      Optional&lt;AssetStore&gt; optCurrentStore = getAssetStore(currentStoreId.get());</span>
<span class="fc" id="L932">      Optional&lt;AssetStore&gt; optTargetStore = getAssetStore(targetStoreId);</span>

<span class="pc bpc" id="L934" title="1 of 2 branches missed.">      if (!optCurrentStore.isEmpty()) {</span>
<span class="fc" id="L935">        currentStore = optCurrentStore.get();</span>
      } else {
<span class="nc" id="L937">        logger.error(&quot;Unknown current store: &quot; + currentStoreId.get());</span>
<span class="nc" id="L938">        return;</span>
      }
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">      if (!optTargetStore.isEmpty()) {</span>
<span class="fc" id="L941">        targetStore = optTargetStore.get();</span>
      } else {
<span class="nc" id="L943">        logger.error(&quot;Unknown target store: &quot; + targetStoreId);</span>
<span class="nc" id="L944">        return;</span>
      }

      //If the content is already local, or is moving from a remote to the local
      // Returns true if the store id is equal to the local asset store's id
<span class="fc" id="L949">      String localAssetStoreType = getLocalAssetStore().getStoreType();</span>
<span class="pc bpc" id="L950" title="3 of 4 branches missed.">      if (localAssetStoreType.equals(currentStoreId.get()) || localAssetStoreType.equals(targetStoreId)) {</span>
<span class="fc" id="L951">        logger.debug(&quot;Moving {} from {} to {}&quot;, s, currentStoreId, targetStoreId);</span>

        try {
<span class="fc" id="L954">          copyAssetsToStore(s, targetStore);</span>
<span class="fc" id="L955">          copyManifest(s, targetStore);</span>
<span class="nc" id="L956">        } catch (Exception e) {</span>
<span class="nc" id="L957">          Functions.chuck(e);</span>
<span class="fc" id="L958">        }</span>
<span class="fc" id="L959">        getDatabase().setStorageLocation(s, targetStoreId);</span>
<span class="fc" id="L960">        currentStore.delete(DeletionSelector.delete(s.getOrganizationId(),</span>
<span class="fc" id="L961">                s.getMediaPackage().getIdentifier().toString(), s.getVersion()</span>
        ));
      } else {
        //Else, the content is *not* local and is going to a *different* remote
<span class="nc" id="L965">        String intermediateStore = getLocalAssetStore().getStoreType();</span>
<span class="nc" id="L966">        logger.debug(&quot;Moving {} from {} to {}, then to {}&quot;,</span>
                s, currentStoreId, intermediateStore, targetStoreId);
<span class="nc" id="L968">        Version version = s.getVersion();</span>
<span class="nc" id="L969">        String mpId = s.getMediaPackage().getIdentifier().toString();</span>
        try {
<span class="nc" id="L971">          moveSnapshotToStore(version, mpId, intermediateStore);</span>
<span class="nc" id="L972">          moveSnapshotToStore(version, mpId, targetStoreId);</span>
<span class="nc" id="L973">        } catch (NotFoundException e) {</span>
<span class="nc" id="L974">          Functions.chuck(e);</span>
<span class="nc" id="L975">        }</span>
      }
<span class="fc" id="L977">    });</span>
<span class="fc" id="L978">  }</span>

  // Return the asset store ID that is currently storing the snapshot
  public Optional&lt;String&gt; getSnapshotStorageLocation(final Version version, final String mpId) {
<span class="fc" id="L982">    List&lt;Snapshot&gt; snapshots = getSnapshotsByIdAndVersion(mpId, version);</span>

<span class="pc bpc" id="L984" title="1 of 2 branches missed.">    for (Snapshot snapshot : snapshots) {</span>
<span class="fc" id="L985">      return Optional.of(snapshot.getStorageId());</span>
    }

<span class="nc" id="L988">    logger.error(&quot;Mediapackage &quot; + mpId + &quot;@&quot; + version + &quot; not found!&quot;);</span>
<span class="nc" id="L989">    return Optional.empty();</span>
  }

  public Optional&lt;String&gt; getSnapshotStorageLocation(final Snapshot snap) {
<span class="fc" id="L993">    return getSnapshotStorageLocation(snap.getVersion(), snap.getMediaPackage().getIdentifier().toString());</span>
  }

  /** Properties */

  @Override
  public boolean setProperty(Property property) {
<span class="fc" id="L1000">    final String mpId = property.getId().getMediaPackageId();</span>
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">    if (isAuthorized(mpId, WRITE_ACTION)) {</span>
<span class="fc" id="L1002">      return getDatabase().saveProperty(property);</span>
    }
<span class="nc" id="L1004">    throw new RuntimeException(new UnauthorizedException(&quot;Not allowed to set property on episode &quot; + mpId));</span>
  }

  @Override
  public List&lt;Property&gt; selectProperties(final String mediaPackageId, String namespace) {
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">    if (isAuthorized(mediaPackageId, READ_ACTION)) {</span>
<span class="fc" id="L1010">      return getDatabase().selectProperties(mediaPackageId, namespace);</span>
    }
<span class="nc" id="L1012">    throw new RuntimeException(new UnauthorizedException(format(</span>
        &quot;Not allowed to read properties of event %s&quot;, mediaPackageId)));
  }

  @Override
  public int deleteProperties(final String mediaPackageId) {
<span class="fc" id="L1018">    return getDatabase().deleteProperties(mediaPackageId);</span>
  }

  @Override
  public int deleteProperties(final String mediaPackageId, final String namespace) {
<span class="fc" id="L1023">    return getDatabase().deleteProperties(mediaPackageId, namespace);</span>
  }

  @Override
  public int deletePropertiesWithCurrentUser(final String mediaPackageId, final String namespace) {
<span class="fc" id="L1028">    User user = securityService.getUser();</span>
<span class="pc bpc" id="L1029" title="2 of 3 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
<span class="fc" id="L1031">        return getDatabase().deleteProperties(mediaPackageId, namespace);</span>
      case ORGANIZATION:
<span class="nc" id="L1033">        Optional&lt;Snapshot&gt; snapshot = getDatabase().getLatestSnapshot(mediaPackageId);</span>
<span class="nc bnc" id="L1034" title="All 4 branches missed.">        if (snapshot.isPresent() &amp;&amp; snapshot.get().getOrganizationId().equals(user.getOrganization().getId())) {</span>
<span class="nc" id="L1035">          return getDatabase().deleteProperties(mediaPackageId, namespace);</span>
        }
<span class="nc" id="L1037">        return 0;</span>
      default:
<span class="nc" id="L1039">        Optional&lt;MediaPackage&gt; mediaPackage = getMediaPackage(mediaPackageId);</span>
<span class="nc bnc" id="L1040" title="All 4 branches missed.">        if (mediaPackage.isPresent() &amp;&amp; isAuthorized(mediaPackage.get().getIdentifier().toString(), WRITE_ACTION)) {</span>
<span class="nc" id="L1041">          return getDatabase().deleteProperties(mediaPackageId, namespace);</span>
        }
<span class="nc" id="L1043">        return 0;</span>
    }
  }

  /** Misc. */

  @Override
  public Optional&lt;Version&gt; toVersion(String version) {
    try {
<span class="fc" id="L1052">      return Optional.of(VersionImpl.mk(Long.parseLong(version)));</span>
<span class="nc" id="L1053">    } catch (NumberFormatException e) {</span>
<span class="nc" id="L1054">      return Optional.empty();</span>
    }
  }

  @Override
  public long countEvents(final String organization) {
<span class="fc" id="L1060">    return getDatabase().countEvents(organization);</span>
  }

  @Override
  public long countSnapshots(final String organization) {
<span class="fc" id="L1065">    return getDatabase().countSnapshots(organization);</span>
  }

  @Override
  public long countAssets() {
<span class="fc" id="L1070">    return getDatabase().countAssets();</span>
  }

  @Override
  public long countProperties() {
<span class="fc" id="L1075">    return getDatabase().countProperties();</span>
  }

  /**
   * AbstractIndexProducer Implementation
   */

  @Override
  public IndexRebuildService.Service getService() {
<span class="nc" id="L1084">    return IndexRebuildService.Service.AssetManager;</span>
  }

  @Override
  public DataType[] getSupportedDataTypes() {
<span class="nc" id="L1089">    return new DataType[]{ DataType.ALL, DataType.ACL };</span>
  }

  @Override
  public void repopulate(DataType dataType) throws IndexRebuildException {
<span class="nc" id="L1094">    final Organization originalOrg = securityService.getOrganization();</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">    final User originalUser = (originalOrg != null ? securityService.getUser() : null);</span>
    try {
<span class="nc" id="L1097">      final Organization defaultOrg = new DefaultOrganization();</span>
<span class="nc" id="L1098">      final User defaultSystemUser = SecurityUtil.createSystemUser(systemUserName, defaultOrg);</span>
<span class="nc" id="L1099">      securityService.setOrganization(defaultOrg);</span>
<span class="nc" id="L1100">      securityService.setUser(defaultSystemUser);</span>

<span class="nc" id="L1102">      int offset = 0;</span>
<span class="nc" id="L1103">      int total = (int) countEvents(null);</span>
<span class="nc" id="L1104">      int current = 0;</span>
<span class="nc" id="L1105">      logIndexRebuildBegin(logger, total, &quot;snapshot(s)&quot;);</span>
<span class="nc" id="L1106">      var updatedEventRange = new ArrayList&lt;Event&gt;();</span>
      do {
<span class="nc" id="L1108">        List&lt;Snapshot&gt; snapshots = getDatabase().getSnapshotsForIndexRebuild(offset, PAGE_SIZE);</span>
<span class="nc" id="L1109">        offset += PAGE_SIZE;</span>
<span class="nc" id="L1110">        int n = 20;</span>

<span class="nc" id="L1112">        final Map&lt;String, List&lt;Snapshot&gt;&gt; byOrg = snapshots.stream()</span>
<span class="nc" id="L1113">            .collect(Collectors.groupingBy(Snapshot::getOrganizationId));</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">        for (String orgId : byOrg.keySet()) {</span>
          final Organization snapshotOrg;
          try {
<span class="nc" id="L1117">            snapshotOrg = orgDir.getOrganization(orgId);</span>
<span class="nc" id="L1118">            User snapshotSystemUser = SecurityUtil.createSystemUser(systemUserName, snapshotOrg);</span>
<span class="nc" id="L1119">            securityService.setOrganization(snapshotOrg);</span>
<span class="nc" id="L1120">            securityService.setUser(snapshotSystemUser);</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">            for (Snapshot snapshot : byOrg.get(orgId)) {</span>
              try {
<span class="nc" id="L1123">                current++;</span>

<span class="nc" id="L1125">                var updatedEventData = index.getEvent(snapshot.getMediaPackage().getIdentifier().toString(), orgId,</span>
                    snapshotSystemUser);
<span class="nc bnc" id="L1127" title="All 2 branches missed.">                if (dataType == DataType.ALL) {</span>
                  // Reindex everything (default)
<span class="nc" id="L1129">                  updatedEventData = getEventUpdateFunction(snapshot, orgId, snapshotSystemUser)</span>
<span class="nc" id="L1130">                      .apply(updatedEventData);</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">                } else if (dataType == DataType.ACL) {</span>
                  // Only reindex ACLs
<span class="nc" id="L1133">                  updatedEventData = getEventUpdateFunctionOnlyAcl(snapshot, orgId, snapshotSystemUser)</span>
<span class="nc" id="L1134">                      .apply(updatedEventData);</span>
                } else {
<span class="nc" id="L1136">                  throw new IndexRebuildException(dataType + &quot; is not a supported data type. &quot;</span>
<span class="nc" id="L1137">                      + &quot;Accepted values are &quot; + Arrays.toString(getSupportedDataTypes()) + &quot;.&quot;);</span>
                }
<span class="nc" id="L1139">                updatedEventRange.add(updatedEventData.get());</span>

<span class="nc bnc" id="L1141" title="All 4 branches missed.">                if (updatedEventRange.size() &gt;= n || current &gt;= total) {</span>
<span class="nc" id="L1142">                  index.bulkEventUpdate(updatedEventRange);</span>
<span class="nc" id="L1143">                  logIndexRebuildProgress(logger, total, current, n);</span>
<span class="nc" id="L1144">                  updatedEventRange.clear();</span>
                }
<span class="nc" id="L1146">              } catch (Throwable t) {</span>
<span class="nc" id="L1147">                logSkippingElement(logger, &quot;event&quot;, snapshot.getMediaPackage().getIdentifier().toString(),</span>
                    snapshotOrg, t);
<span class="nc" id="L1149">              }</span>
<span class="nc" id="L1150">            }</span>
<span class="nc" id="L1151">          } catch (Throwable t) {</span>
<span class="nc" id="L1152">            logIndexRebuildError(logger, t, originalOrg);</span>
<span class="nc" id="L1153">            throw new IndexRebuildException(getService(), originalOrg, t);</span>
          } finally {
<span class="nc" id="L1155">            securityService.setOrganization(defaultOrg);</span>
<span class="nc" id="L1156">            securityService.setUser(defaultSystemUser);</span>
          }
<span class="nc" id="L1158">        }</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">      } while (offset &lt; total);</span>
    } finally {
<span class="nc" id="L1161">      securityService.setOrganization(originalOrg);</span>
<span class="nc" id="L1162">      securityService.setUser(originalUser);</span>
    }
<span class="nc" id="L1164">  }</span>

  /**
   * Used for testing
   */
  public void setAvailability(Version version, String mpId, Availability availability) {
<span class="fc bfc" id="L1170" title="All 2 branches covered.">    if (isAuthorized(mpId, WRITE_ACTION)) {</span>
<span class="fc" id="L1171">      getDatabase().setAvailability(RuntimeTypes.convert(version), mpId, availability);</span>
    } else {
<span class="fc" id="L1173">      throw new RuntimeException(new UnauthorizedException(&quot;Not allowed to set availability of episode &quot; + mpId));</span>
    }
<span class="fc" id="L1175">  }</span>

  public void setDatabase(Database database) {
<span class="fc" id="L1178">    this.db = database;</span>
<span class="fc" id="L1179">  }</span>

  public Database getDatabase() {
<span class="fc" id="L1182">    return db;</span>
  }

  public HttpAssetProvider getHttpAssetProvider() {
<span class="fc" id="L1186">    return httpAssetProvider;</span>
  }

  /*
   * Security handling
   */
  /** Check authorization based on the given predicate. */
  private boolean isAuthorized(final String mediaPackageId, final String action) {
<span class="pc bpc" id="L1194" title="1 of 3 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
        // grant general access
<span class="fc" id="L1197">        logger.debug(&quot;Access granted since user is global admin&quot;);</span>
<span class="fc" id="L1198">        return true;</span>
      case ORGANIZATION:
        // ensure that the requested assets belong to this organization
<span class="nc" id="L1201">        logger.debug(&quot;User is organization admin. Checking organization. Checking organization ID of asset.&quot;);</span>
<span class="nc" id="L1202">        return snapshotExists(mediaPackageId, securityService.getOrganization().getId());</span>
      default:
        // check organization
<span class="fc" id="L1205">        logger.debug(&quot;Non admin user. Checking organization.&quot;);</span>
<span class="fc" id="L1206">        final String org = securityService.getOrganization().getId();</span>
<span class="pc bpc" id="L1207" title="1 of 2 branches missed.">        if (!snapshotExists(mediaPackageId, org)) {</span>
<span class="nc" id="L1208">          return false;</span>
        }
        // check episode role id
<span class="fc" id="L1211">        User user = securityService.getUser();</span>
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">        if (user.hasRole(getEpisodeRoleId(mediaPackageId, action))) {</span>
<span class="nc" id="L1213">          return true;</span>
        }
        // check acl rules
<span class="fc" id="L1216">        logger.debug(&quot;Non admin user. Checking ACL rules.&quot;);</span>
        // TODO: Replace this custom ACL check with the general check from the auth service
        //   Warning: For now this will cause many difficult to track down bugs and is thus hardly possible
        // return authorizationService.hasPermission(getDatabase().getMediaPackage(mediaPackageId).get(), action);
<span class="fc" id="L1220">        final List&lt;String&gt; roles = user.getRoles().parallelStream()</span>
<span class="fc" id="L1221">                .filter(roleFilter)</span>
<span class="fc" id="L1222">                .map((role) -&gt; mkPropertyName(role.getName(), action))</span>
<span class="fc" id="L1223">                .collect(Collectors.toList());</span>
<span class="fc" id="L1224">        return getDatabase().selectProperties(mediaPackageId, SECURITY_NAMESPACE).parallelStream()</span>
<span class="fc" id="L1225">                .map(p -&gt; p.getId().getName())</span>
<span class="fc" id="L1226">                .filter(p -&gt; p.endsWith(action))</span>
<span class="fc" id="L1227">                .anyMatch(p -&gt; roles.stream().anyMatch(r -&gt; r.equals(p)));</span>
    }
  }

  private List&lt;String&gt; isAuthorized(final List&lt;String&gt; mediaPackageIds, final String action) {
<span class="nc" id="L1232">    return mediaPackageIds.stream()</span>
<span class="nc" id="L1233">        .filter(id -&gt; isAuthorized(id, action))</span>
<span class="nc" id="L1234">        .collect(Collectors.toList());</span>
  }

  private AdminRole isAdmin() {
<span class="fc" id="L1238">    final User user = securityService.getUser();</span>
<span class="fc bfc" id="L1239" title="All 2 branches covered.">    if (user.hasRole(GLOBAL_ADMIN_ROLE)) {</span>
<span class="fc" id="L1240">      return AdminRole.GLOBAL;</span>
<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">    } else if (user.hasRole(securityService.getOrganization().getAdminRole())</span>
<span class="pc bpc" id="L1242" title="1 of 2 branches missed.">            || user.hasRole(GLOBAL_CAPTURE_AGENT_ROLE)) {</span>
      // In this context, we treat capture agents the same way as organization admins, allowing them access so that
      // they can ingest new media without requiring them to be explicitly specified in the ACLs.
<span class="nc" id="L1245">      return AdminRole.ORGANIZATION;</span>
    } else {
<span class="fc" id="L1247">      return AdminRole.NONE;</span>
    }
  }

  private String mkPropertyName(String role, String action) {
<span class="fc" id="L1252">    return role + &quot; | &quot; + action;</span>
  }

  /**
   * Configurable filter for roles
   */
<span class="fc" id="L1258">  private final java.util.function.Predicate&lt;Role&gt; roleFilter = (role) -&gt; {</span>
<span class="fc" id="L1259">    final String name = role.getName();</span>
<span class="pc bpc" id="L1260" title="3 of 6 branches missed.">    return (includeAPIRoles || !name.startsWith(&quot;ROLE_API_&quot;))</span>
<span class="pc bpc" id="L1261" title="2 of 4 branches missed.">            &amp;&amp; (includeCARoles  || !name.startsWith(&quot;ROLE_CAPTURE_AGENT_&quot;))</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">            &amp;&amp; (includeUIRoles  || !name.startsWith(&quot;ROLE_UI_&quot;));</span>
  };

  /*
   * Utility
   */

  /** Move the assets for a snapshot to the target store */
  private void copyAssetsToStore(Snapshot snap, AssetStore store) {
<span class="fc" id="L1271">    final String mpId = snap.getMediaPackage().getIdentifier().toString();</span>
<span class="fc" id="L1272">    final String orgId = snap.getOrganizationId();</span>
<span class="fc" id="L1273">    final Version version = snap.getVersion();</span>
<span class="fc" id="L1274">    final String prettyMpId = mpId + &quot;@v&quot; + version;</span>
<span class="fc" id="L1275">    logger.debug(&quot;Moving assets for snapshot {} to store {}&quot;, prettyMpId, store.getStoreType());</span>
<span class="fc bfc" id="L1276" title="All 2 branches covered.">    for (final MediaPackageElement e : snap.getMediaPackage().getElements()) {</span>
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">      if (!MOVABLE_TYPES.contains(e.getElementType())) {</span>
<span class="nc" id="L1278">        logger.debug(&quot;Skipping {} because type is {}&quot;, e.getIdentifier(), e.getElementType());</span>
<span class="nc" id="L1279">        continue;</span>
      }
<span class="fc" id="L1281">      logger.debug(&quot;Moving {} to store {}&quot;, e.getIdentifier(), store.getStoreType());</span>
<span class="fc" id="L1282">      final StoragePath storagePath = StoragePath.mk(orgId, mpId, version, e.getIdentifier());</span>
<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">      if (store.contains(storagePath)) {</span>
<span class="nc" id="L1284">        logger.debug(&quot;Element {} (version {}) is already in store {} so skipping it&quot;, e.getIdentifier(),</span>
<span class="nc" id="L1285">                version, store.getStoreType());</span>
<span class="nc" id="L1286">        continue;</span>
      }

      // find asset in versions &amp; stores
<span class="fc" id="L1290">      final Optional&lt;StoragePath&gt; existingAssetOpt =</span>
<span class="fc" id="L1291">          getDatabase()</span>
<span class="fc" id="L1292">          .findAssetByChecksumAndStoreAndOrg(e.getChecksum().toString(), store.getStoreType(), orgId)</span>
<span class="fc" id="L1293">          .map(dto -&gt; StoragePath.mk(</span>
<span class="fc" id="L1294">              dto.getOrganizationId(),</span>
<span class="fc" id="L1295">              dto.getMediaPackageId(),</span>
<span class="fc" id="L1296">              dto.getVersion(),</span>
<span class="fc" id="L1297">              dto.getAssetDto().getMediaPackageElementId()</span>
          ));

<span class="fc bfc" id="L1300" title="All 2 branches covered.">      if (existingAssetOpt.isPresent()) {</span>
<span class="fc" id="L1301">        final StoragePath existingAsset = existingAssetOpt.get();</span>
<span class="fc" id="L1302">        logger.debug(&quot;Content of asset {} with checksum {} already exists in {}&quot;,</span>
<span class="fc" id="L1303">                existingAsset.getMediaPackageElementId(), e.getChecksum(), store.getStoreType());</span>
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">        if (!store.copy(existingAsset, storagePath)) {</span>
<span class="nc" id="L1305">          throw new AssetManagerException(format(</span>
                  &quot;An asset with checksum %s has already been archived but trying to copy or link asset %s to it &quot;
                          + &quot;failed&quot;,
<span class="nc" id="L1308">                  e.getChecksum(),</span>
                  existingAsset
          ));
        }
<span class="fc" id="L1312">      } else {</span>
<span class="pc bpc" id="L1313" title="1 of 2 branches missed.">        final Optional&lt;Long&gt; size = e.getSize() &gt; 0 ? Optional.of(e.getSize()) : Optional.empty();</span>
<span class="fc" id="L1314">        store.put(storagePath, Source.mk(e.getURI(), size, Optional.ofNullable(e.getMimeType())));</span>
      }
<span class="fc" id="L1316">      getDatabase().setAssetStorageLocation(VersionImpl.mk(version), mpId, e.getIdentifier(), store.getStoreType());</span>
    }
<span class="fc" id="L1318">  }</span>

  private void copyManifest(Snapshot snap, AssetStore targetStore) throws IOException, NotFoundException {
<span class="fc" id="L1321">    final String mpId = snap.getMediaPackage().getIdentifier().toString();</span>
<span class="fc" id="L1322">    final String orgId = snap.getOrganizationId();</span>
<span class="fc" id="L1323">    final Version version = snap.getVersion();</span>

<span class="fc" id="L1325">    AssetStore currentStore = getAssetStore(snap.getStorageId()).get();</span>
<span class="fc" id="L1326">    Optional&lt;String&gt; manifestOpt = findManifestBaseName(snap, MANIFEST_DEFAULT_NAME, currentStore);</span>
<span class="pc bpc" id="L1327" title="1 of 2 branches missed.">    if (manifestOpt.isEmpty()) {</span>
<span class="nc" id="L1328">      return; // Nothing to do, already moved to long-term storage</span>
    }

    // Copy the manifest file
<span class="fc" id="L1332">    String manifestBaseName = manifestOpt.get();</span>
<span class="fc" id="L1333">    StoragePath pathToManifest = new StoragePath(orgId, mpId, version, manifestBaseName);</span>

    // Already copied?
<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">    if (!targetStore.contains(pathToManifest)) {</span>
      Optional&lt;InputStream&gt; inputStreamOpt;
<span class="fc" id="L1338">      InputStream inputStream = null;</span>
<span class="fc" id="L1339">      String manifestFileName = null;</span>
      try {
<span class="fc" id="L1341">        inputStreamOpt = currentStore.get(pathToManifest);</span>
<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">        if (inputStreamOpt.isEmpty()) { // This should never happen because it has been tested before</span>
<span class="nc" id="L1343">          throw new NotFoundException(</span>
<span class="nc" id="L1344">                  String.format(&quot;Unexpected error. Manifest %s not found in current asset store&quot;, manifestBaseName));</span>
        }

<span class="fc" id="L1347">        inputStream = inputStreamOpt.get();</span>
<span class="fc" id="L1348">        manifestFileName = UUID.randomUUID() + &quot;.xml&quot;;</span>
<span class="fc" id="L1349">        URI manifestTmpUri = workspace.putInCollection(&quot;archive&quot;, manifestFileName, inputStream);</span>
<span class="fc" id="L1350">        targetStore.put(pathToManifest, Source.mk(manifestTmpUri, Optional.empty(), Optional.of(MimeTypes.XML)));</span>
      } finally {
<span class="fc" id="L1352">        IOUtils.closeQuietly(inputStream);</span>
        try {
          // Make sure to clean up the temporary file
<span class="fc" id="L1355">          workspace.deleteFromCollection(&quot;archive&quot;, manifestFileName);</span>
<span class="nc" id="L1356">        } catch (NotFoundException e) {</span>
          // This is OK, we are deleting it anyway
<span class="nc" id="L1358">        } catch (IOException e) {</span>
          // This usually happens when the collection directory cannot be deleted
          // because another process is running at the same time and wrote a file there
          // after it was tested but before it was actually deleted. We will consider this ok.
          // Does the error message mention the manifest file name?
<span class="nc bnc" id="L1363" title="All 2 branches missed.">          if (e.getMessage().contains(manifestFileName)) {</span>
<span class="nc" id="L1364">            logger.warn(&quot;The manifest file {} didn't get deleted from the archive collection&quot;,</span>
                    manifestBaseName, e);
          }
          // Else the error is related to the file-archive collection, which is fine
<span class="pc" id="L1368">        }</span>
      }
    }
<span class="fc" id="L1371">  }</span>

  Optional&lt;String&gt; findManifestBaseName(Snapshot snap, String manifestName, AssetStore store) {
<span class="fc" id="L1374">    StoragePath path = new StoragePath(snap.getOrganizationId(), snap.getMediaPackage().getIdentifier().toString(),</span>
<span class="fc" id="L1375">            snap.getVersion(), manifestName);</span>
    // If manifest_.xml, etc not found, return previous name (copied from the EpsiodeServiceImpl logic)
<span class="fc bfc" id="L1377" title="All 2 branches covered.">    if (!store.contains(path)) {</span>
      // If first call, manifest is not found, which probably means it has already been moved
<span class="pc bpc" id="L1379" title="1 of 2 branches missed.">      if (MANIFEST_DEFAULT_NAME.equals(manifestName)) {</span>
<span class="nc" id="L1380">        return Optional.empty(); // No manifest found in current store</span>
      } else {
<span class="fc" id="L1382">        return Optional.of(manifestName.substring(0, manifestName.length() - 1));</span>
      }
    }
    // This is the same logic as when building the manifest name: manifest, manifest_, manifest__, etc
<span class="fc" id="L1386">    return findManifestBaseName(snap, manifestName + &quot;_&quot;, store);</span>
  }

  /* -------------------------------------------------------------------------------------------------------------- */

  /**
   * Make sure each of the elements has a checksum.
   */
  void calcChecksumsForMediaPackageElements(PartialMediaPackage pmp) {
<span class="fc" id="L1395">    pmp.getElements().stream()</span>
<span class="fc" id="L1396">        .filter(mpe -&gt; hasNoChecksum.apply(mpe))</span>
<span class="fc" id="L1397">        .forEach(mpe -&gt; {</span>
<span class="fc" id="L1398">          File file = null;</span>
          try {
<span class="fc" id="L1400">            logger.trace(&quot;Calculate checksum for {}&quot;, mpe.getURI());</span>
<span class="fc" id="L1401">            file = workspace.get(mpe.getURI(), true);</span>
<span class="fc" id="L1402">            mpe.setChecksum(Checksum.create(ChecksumType.DEFAULT_TYPE, file));</span>
<span class="nc" id="L1403">          } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L1404">            throw new AssetManagerException(String.format(</span>
                &quot;Cannot calculate checksum for media package element %s&quot;,
<span class="nc" id="L1406">                mpe.getURI()</span>
            ), e);
          } finally {
<span class="pc bpc" id="L1409" title="1 of 2 branches missed.">            if (file != null) {</span>
<span class="fc" id="L1410">              FileUtils.deleteQuietly(file);</span>
            }
          }
<span class="fc" id="L1413">        });</span>
<span class="fc" id="L1414">  }</span>

  /** Mutates mp and its elements, so make sure to work on a copy. */
  private SnapshotDto addInternal(String owner, final MediaPackage mp) throws Exception {
<span class="fc" id="L1418">    final Date now = new Date();</span>
    // claim a new version for the media package
<span class="fc" id="L1420">    final String mpId = mp.getIdentifier().toString();</span>
<span class="fc" id="L1421">    final VersionImpl version = getDatabase().claimVersion(mpId);</span>
<span class="fc" id="L1422">    logger.info(&quot;Creating new version {} of media package {}&quot;, version, mp);</span>
<span class="fc" id="L1423">    final PartialMediaPackage pmp = assetsOnly(mp);</span>
    // make sure they have a checksum
<span class="fc" id="L1425">    calcChecksumsForMediaPackageElements(pmp);</span>
    // download and archive elements
<span class="fc" id="L1427">    storeAssets(pmp, version);</span>
    // store mediapackage in db
    final SnapshotDto snapshotDto;
    try {
      // rewrite URIs for archival
<span class="fc bfc" id="L1432" title="All 2 branches covered.">      for (MediaPackageElement mpe : pmp.getElements()) {</span>
<span class="fc" id="L1433">        String fileName = getFileName(mpe).orElse(&quot;unknown&quot;);</span>
<span class="fc" id="L1434">        URI archiveUri = new URI(</span>
            &quot;urn&quot;,
<span class="fc" id="L1436">            &quot;matterhorn:&quot; + mpId + &quot;:&quot; + version + &quot;:&quot; + mpe.getIdentifier() + &quot;:&quot; + fileName,</span>
            null
        );
<span class="fc" id="L1439">        mpe.setURI(archiveUri);</span>
<span class="fc" id="L1440">      }</span>

<span class="fc" id="L1442">      String currentOrgId = securityService.getOrganization().getId();</span>
<span class="fc" id="L1443">      snapshotDto = getDatabase().saveSnapshot(</span>
              currentOrgId, pmp, now, version,
<span class="fc" id="L1445">              Availability.ONLINE, getLocalAssetStore().getStoreType(), owner</span>
      );
<span class="nc" id="L1447">    } catch (AssetManagerException e) {</span>
<span class="nc" id="L1448">      logger.error(&quot;Could not take snapshot {}&quot;, mpId, e);</span>
<span class="nc" id="L1449">      throw new AssetManagerException(e);</span>
<span class="fc" id="L1450">    }</span>
    // save manifest to element store
    // this is done at the end after the media package element ids have been rewritten to neutral URNs
<span class="fc" id="L1453">    storeManifest(pmp, version);</span>
<span class="fc" id="L1454">    return snapshotDto;</span>
  }

  /**
   * Store all elements of &lt;code&gt;pmp&lt;/code&gt; under the given version.
   */
  private void storeAssets(final PartialMediaPackage pmp, final Version version) {
<span class="fc" id="L1461">    final String mpId = pmp.getMediaPackage().getIdentifier().toString();</span>
<span class="fc" id="L1462">    final String orgId = securityService.getOrganization().getId();</span>
<span class="fc bfc" id="L1463" title="All 2 branches covered.">    for (final MediaPackageElement e : pmp.getElements()) {</span>
<span class="fc" id="L1464">      logger.debug(&quot;Archiving {} {} {}&quot;, e.getFlavor(), e.getMimeType(), e.getURI());</span>
<span class="fc" id="L1465">      final StoragePath storagePath = StoragePath.mk(orgId, mpId, version, e.getIdentifier());</span>
      // find asset in versions
<span class="fc" id="L1467">      final Optional&lt;StoragePath&gt; existingAssetOpt = getDatabase()</span>
<span class="fc" id="L1468">          .findAssetByChecksumAndStoreAndOrg(e.getChecksum().toString(), getLocalAssetStore().getStoreType(), orgId)</span>
<span class="fc" id="L1469">          .map(dto -&gt; StoragePath.mk(</span>
<span class="fc" id="L1470">                  dto.getOrganizationId(),</span>
<span class="fc" id="L1471">                  dto.getMediaPackageId(),</span>
<span class="fc" id="L1472">                  dto.getVersion(),</span>
<span class="fc" id="L1473">                  dto.getAssetDto().getMediaPackageElementId()));</span>

<span class="fc bfc" id="L1475" title="All 2 branches covered.">      if (existingAssetOpt.isPresent()) {</span>
<span class="fc" id="L1476">        final StoragePath existingAsset = existingAssetOpt.get();</span>
<span class="fc" id="L1477">        logger.debug(&quot;Content of asset {} with checksum {} has been archived before&quot;,</span>
<span class="fc" id="L1478">                existingAsset.getMediaPackageElementId(), e.getChecksum());</span>
<span class="pc bpc" id="L1479" title="1 of 2 branches missed.">        if (!getLocalAssetStore().copy(existingAsset, storagePath)) {</span>
<span class="nc" id="L1480">          throw new AssetManagerException(format(</span>
                  &quot;An asset with checksum %s has already been archived but trying to copy or link asset %s to it &quot;
                          + &quot;failed&quot;,
<span class="nc" id="L1483">                  e.getChecksum(),</span>
                  existingAsset
          ));
        }
<span class="fc" id="L1487">      } else {</span>
<span class="pc bpc" id="L1488" title="1 of 2 branches missed.">        final Optional&lt;Long&gt; size = e.getSize() &gt; 0 ? Optional.of(e.getSize()) : Optional.empty();</span>
<span class="fc" id="L1489">        getLocalAssetStore().put(storagePath, Source.mk(e.getURI(), size, Optional.ofNullable(e.getMimeType())));</span>
      }
<span class="fc" id="L1491">    }</span>
<span class="fc" id="L1492">  }</span>

  private void storeManifest(final PartialMediaPackage pmp, final Version version) throws Exception {
<span class="fc" id="L1495">    final String mpId = pmp.getMediaPackage().getIdentifier().toString();</span>
<span class="fc" id="L1496">    final String orgId = securityService.getOrganization().getId();</span>
    // store the manifest.xml
    // TODO make use of checksums
<span class="fc" id="L1499">    logger.debug(&quot;Archiving manifest of media package {} version {}&quot;, mpId, version);</span>
    // temporarily save the manifest XML into the workspace to
    // Fix file not found exception when several snapshots are taken at the same time
<span class="fc" id="L1502">    final String manifestFileName = format(&quot;manifest_%s_%s.xml&quot;, pmp.getMediaPackage().getIdentifier(), version);</span>
<span class="fc" id="L1503">    final URI manifestTmpUri = workspace.putInCollection(</span>
            &quot;archive&quot;,
            manifestFileName,
<span class="fc" id="L1506">            IOUtils.toInputStream(MediaPackageParser.getAsXml(pmp.getMediaPackage()), &quot;UTF-8&quot;));</span>
    try {
<span class="fc" id="L1508">      getLocalAssetStore().put(</span>
<span class="fc" id="L1509">              StoragePath.mk(orgId, mpId, version, manifestAssetId(pmp, &quot;manifest&quot;)),</span>
<span class="fc" id="L1510">              Source.mk(manifestTmpUri, Optional.empty(), Optional.of(MimeTypes.XML)));</span>
    } finally {
      // make sure to clean up the temporary file
<span class="fc" id="L1513">      workspace.deleteFromCollection(&quot;archive&quot;, manifestFileName);</span>
    }
<span class="fc" id="L1515">  }</span>

  /**
   * Create a unique id for the manifest xml. This is to avoid an id collision
   * in the rare case that the media package contains an XML element with the id
   * used for the manifest. A UUID could also be used but this is far less
   * readable.
   *
   * @param seedId
   *          the id to start with
   */
  private String manifestAssetId(PartialMediaPackage pmp, String seedId) {
<span class="fc bfc" id="L1527" title="All 2 branches covered.">    for (MediaPackageElement element : pmp.getElements()) {</span>
<span class="pc bpc" id="L1528" title="1 of 2 branches missed.">      if (seedId.equals(element.getIdentifier())) {</span>
<span class="nc" id="L1529">        return manifestAssetId(pmp, seedId + &quot;_&quot;);</span>
      }
<span class="fc" id="L1531">    }</span>
<span class="fc" id="L1532">    return seedId;</span>
  }

  /* --------------------------------------------------------------------------------------------------------------- */

  /**
   * Walk up the stacktrace to find a cause of type &lt;code&gt;type&lt;/code&gt;. Return none if no such
   * type can be found.
   */
  static &lt;A extends Throwable&gt; Optional&lt;A&gt; unwrapExceptionUntil(Class&lt;A&gt; type, Throwable e) {
<span class="pc bpc" id="L1542" title="1 of 2 branches missed.">    if (e == null) {</span>
<span class="nc" id="L1543">      return Optional.empty();</span>
<span class="fc bfc" id="L1544" title="All 2 branches covered.">    } else if (type.isAssignableFrom(e.getClass())) {</span>
<span class="fc" id="L1545">      return Optional.of((A) e);</span>
    } else {
<span class="fc" id="L1547">      return unwrapExceptionUntil(type, e.getCause());</span>
    }
  }

  /**
   * Return a partial media package filtering assets. Assets are elements the archive is going to manager, i.e. all
   * non-publication elements.
   */
  static PartialMediaPackage assetsOnly(MediaPackage mp) {
<span class="fc" id="L1556">    Predicate&lt;MediaPackageElement&gt; isAsset = e -&gt; isNotPublication.apply(e);</span>
<span class="fc" id="L1557">    return PartialMediaPackage.mk(mp, isAsset);</span>
  }

  /**
   * Extract the file name from a media package elements URN.
   *
   * @return the file name or none if it could not be determined
   */
  public static Optional&lt;String&gt; getFileNameFromUrn(MediaPackageElement mpe) {
<span class="fc" id="L1566">    Optional&lt;URI&gt; uri = Optional.ofNullable(mpe.getURI());</span>
<span class="fc bfc" id="L1567" title="All 4 branches covered.">    if (uri.isPresent() &amp;&amp; &quot;urn&quot;.equals(uri.get().getScheme())) {</span>
<span class="fc" id="L1568">      String[] tmp = uri.get().toString().split(&quot;:&quot;);</span>
<span class="pc bpc" id="L1569" title="1 of 2 branches missed.">      if (tmp.length &lt; 1) {</span>
<span class="nc" id="L1570">        return Optional.empty();</span>
      }
<span class="fc" id="L1572">      return Optional.of(tmp[tmp.length - 1]);</span>
    }
<span class="fc" id="L1574">    return Optional.empty();</span>
  }

  /**
   * Rewrite URIs of all asset elements of a snapshot's media package.
   * This method does not mutate anything.
   */
  public static Snapshot rewriteUris(Snapshot snapshot, Function&lt;MediaPackageElement, URI&gt; uriCreator) {
<span class="fc" id="L1582">    final MediaPackage mpCopy = MediaPackageSupport.copy(snapshot.getMediaPackage());</span>
<span class="fc bfc" id="L1583" title="All 2 branches covered.">    for (final MediaPackageElement mpe : assetsOnly(mpCopy).getElements()) {</span>
<span class="fc" id="L1584">      mpe.setURI(uriCreator.apply(mpe));</span>
<span class="fc" id="L1585">    }</span>
<span class="fc" id="L1586">    return new SnapshotImpl(</span>
<span class="fc" id="L1587">            snapshot.getVersion(),</span>
<span class="fc" id="L1588">            snapshot.getOrganizationId(),</span>
<span class="fc" id="L1589">            snapshot.getArchivalDate(),</span>
<span class="fc" id="L1590">            snapshot.getAvailability(),</span>
<span class="fc" id="L1591">            snapshot.getStorageId(),</span>
<span class="fc" id="L1592">            snapshot.getOwner(),</span>
            mpCopy);
  }

  /**
   * Get the function to update a commented event in the Elasticsearch index.
   *
   * @return the function to do the update
   */
  private Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; getEventUpdateFunction(Snapshot snapshot,
          String orgId, User user) {
<span class="nc" id="L1603">    return (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
<span class="nc" id="L1604">      MediaPackage mp = snapshot.getMediaPackage();</span>
<span class="nc" id="L1605">      String eventId = mp.getIdentifier().toString();</span>
<span class="nc" id="L1606">      Event event = eventOpt.orElse(new Event(eventId, orgId));</span>

<span class="nc" id="L1608">      event = updateAclInEvent(event, mp, eventId);</span>

<span class="nc" id="L1610">      event.setArchiveVersion(Long.parseLong(snapshot.getVersion().toString()));</span>
<span class="nc bnc" id="L1611" title="All 2 branches missed.">      if (StringUtils.isBlank(event.getCreator())) {</span>
<span class="nc" id="L1612">        event.setCreator(securityService.getUser().getName());</span>
      }
<span class="nc" id="L1614">      EventIndexUtils.updateEvent(event, mp);</span>

<span class="nc bnc" id="L1616" title="All 2 branches missed.">      for (Catalog catalog: mp.getCatalogs(MediaPackageElements.EPISODE)) {</span>
<span class="nc" id="L1617">        try (InputStream in = workspace.read(catalog.getURI())) {</span>
<span class="nc" id="L1618">          EventIndexUtils.updateEvent(event, DublinCores.read(in));</span>
<span class="nc" id="L1619">        } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L1620">          throw new IllegalStateException(String.format(&quot;Unable to load dublin core catalog for event '%s'&quot;,</span>
<span class="nc" id="L1621">                  mp.getIdentifier()), e);</span>
<span class="nc" id="L1622">        }</span>
      }

      // Update series name if not already done
      try {
<span class="nc" id="L1627">        EventIndexUtils.updateSeriesName(event, orgId, user, index);</span>
<span class="nc" id="L1628">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L1629">        logger.error(&quot;Error updating the series name of the event {} in the {} index.&quot;, eventId, index.getIndexName(),</span>
                e);
<span class="nc" id="L1631">      }</span>
<span class="nc" id="L1632">      return Optional.of(event);</span>
    };
  }

  private Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; getEventUpdateFunctionOnlyAcl(Snapshot snapshot,
      String orgId, User user) {
<span class="nc" id="L1638">    return (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
<span class="nc" id="L1639">      MediaPackage mp = snapshot.getMediaPackage();</span>
<span class="nc" id="L1640">      String eventId = mp.getIdentifier().toString();</span>
<span class="nc" id="L1641">      Event event = eventOpt.orElse(new Event(eventId, orgId));</span>

<span class="nc" id="L1643">      event = updateAclInEvent(event, mp, eventId);</span>

<span class="nc" id="L1645">      return Optional.of(event);</span>
    };
  }

  private Event updateAclInEvent(Event event, MediaPackage mp, String eventId) {
<span class="nc" id="L1650">    AccessControlList acl = authorizationService.getActiveAcl(mp).getA();</span>
<span class="nc" id="L1651">    List&lt;ManagedAcl&gt; acls = aclServiceFactory.serviceFor(securityService.getOrganization()).getAcls();</span>

<span class="nc bnc" id="L1653" title="All 2 branches missed.">    for (final ManagedAcl managedAcl : AccessInformationUtil.matchAcls(acls, acl)) {</span>
<span class="nc" id="L1654">      event.setManagedAcl(managedAcl.getName());</span>
<span class="nc" id="L1655">    }</span>
<span class="nc" id="L1656">    event.setAccessPolicy(AccessControlParser.toJsonSilent(acl));</span>

<span class="nc" id="L1658">    return event;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>