<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AssetManagerJobProducer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-asset-manager-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.assetmanager.impl</a> &gt; <span class="el_source">AssetManagerJobProducer.java</span></div><h1>AssetManagerJobProducer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.assetmanager.impl;

import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.AssetManagerException;
import org.opencastproject.assetmanager.api.Snapshot;
import org.opencastproject.assetmanager.api.Version;
import org.opencastproject.assetmanager.api.storage.AssetStore;
import org.opencastproject.assetmanager.api.storage.RemoteAssetStore;
import org.opencastproject.job.api.AbstractJobProducer;
import org.opencastproject.job.api.Job;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RequireUtil;

import com.google.gson.Gson;

import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@Component(
    immediate = true,
    service = AssetManagerJobProducer.class,
    property = {
        &quot;service.description=Opencast Asset Manager Job Producer&quot;
    }
)
public class AssetManagerJobProducer extends AbstractJobProducer {

  /** The logging facility */
<span class="fc" id="L65">  private static final Logger logger = LoggerFactory.getLogger(AssetManagerJobProducer.class);</span>

  public static final String JOB_TYPE = &quot;org.opencastproject.assetmanager&quot;;
<span class="fc" id="L68">  public static final Float JOB_LOAD = 0.1f;</span>
<span class="fc" id="L69">  public static final Float NONTERMINAL_JOB_LOAD = 0.1f;</span>

<span class="fc" id="L71">  public enum Operation {</span>
<span class="fc" id="L72">    MoveById, MoveByIdAndVersion, MoveByIdAndDate, MoveByDate, MoveRecords</span>
  }

  private static final String OK = &quot;OK&quot;;

<span class="fc" id="L77">  private AssetManager tsam = null;</span>
<span class="fc" id="L78">  private ServiceRegistry serviceRegistry = null;</span>
<span class="fc" id="L79">  private SecurityService securityService = null;</span>
<span class="fc" id="L80">  private UserDirectoryService userDirectoryService = null;</span>
<span class="fc" id="L81">  private OrganizationDirectoryService organizationDirectoryService = null;</span>

  public AssetManagerJobProducer() {
<span class="fc" id="L84">    super(JOB_TYPE);</span>
<span class="fc" id="L85">  }</span>

  /**
   * OSGi callback on component activation.
   *
   * @param cc
   *          the component context
   */
  @Override
  @Activate
  public void activate(ComponentContext cc) {
<span class="nc" id="L96">    logger.info(&quot;Activating assetmanager job service&quot;);</span>
<span class="nc" id="L97">    super.activate(cc);</span>
<span class="nc" id="L98">  }</span>

  public boolean datastoreExists(String storeId) {
<span class="nc" id="L101">    Optional&lt;AssetStore&gt; store = tsam.getAssetStore(storeId);</span>
<span class="nc" id="L102">    return store.isPresent();</span>
  }

  /** Utility class to collect RecordInformation for moving larger 
   * groups of mediapackages in combined jobs.
   */
<span class="fc" id="L108">  private class MoveRecordInfo {</span>
<span class="fc" id="L109">    private final Gson gson = new Gson();</span>
<span class="fc" id="L110">    private int success = 0;</span>
<span class="fc" id="L111">    private int failed = 0;</span>
<span class="fc" id="L112">    private String currentMpId = &quot;&quot;;</span>
    public void addSuccess() {
<span class="fc" id="L114">      success++;</span>
<span class="fc" id="L115">    };</span>
    public void addFailed() {
<span class="nc" id="L117">      failed ++;</span>
<span class="nc" id="L118">    }</span>

    public boolean isNewMpId(String mpId) {
<span class="fc bfc" id="L121" title="All 2 branches covered.">      if (currentMpId.equals(mpId)) {</span>
<span class="fc" id="L122">        return false;</span>
      }
<span class="fc" id="L124">      currentMpId = mpId;</span>
<span class="fc" id="L125">      return true;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L130">      Map&lt;String,Integer&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">      if (success &gt; 0) {</span>
<span class="fc" id="L132">        result.put(&quot;OK&quot;, success);</span>
      }
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">      if (failed &gt; 0) {</span>
<span class="nc" id="L135">        result.put(&quot;FAIL&quot;, failed);</span>
      }
<span class="fc" id="L137">      return gson.toJson(result);</span>
    }
  };

  @Override
  protected String process(Job job) throws ServiceRegistryException {
<span class="fc" id="L143">    Operation op = null;</span>
<span class="fc" id="L144">    String operation = job.getOperation();</span>
<span class="fc" id="L145">    List&lt;String&gt; arguments = job.getArguments();</span>
    String id;
<span class="fc" id="L147">    String targetStore = arguments.get(0);</span>
    VersionImpl version;
    Date start;
    Date end;
    try {
<span class="fc" id="L152">      op = Operation.valueOf(operation);</span>
<span class="pc bpc" id="L153" title="4 of 5 branches missed.">      switch (op) {</span>
        case MoveById:
<span class="nc" id="L155">          id = arguments.get(1);</span>
<span class="nc" id="L156">          return internalMoveById(id, targetStore);</span>
        case MoveByIdAndVersion:
<span class="fc" id="L158">          id = arguments.get(1);</span>
<span class="fc" id="L159">          version = VersionImpl.mk(Long.parseLong(arguments.get(2)));</span>
<span class="fc" id="L160">          return internalMoveByIdAndVersion(version, id, targetStore);</span>
        case MoveByDate:
<span class="nc" id="L162">          start = new Date(Long.parseLong(arguments.get(1)));</span>
<span class="nc" id="L163">          end = new Date(Long.parseLong(arguments.get(2)));</span>
<span class="nc" id="L164">          return internalMoveByDate(start, end, targetStore);</span>
        case MoveByIdAndDate:
<span class="nc" id="L166">          id = arguments.get(1);</span>
<span class="nc" id="L167">          start = new Date(Long.parseLong(arguments.get(2)));</span>
<span class="nc" id="L168">          end = new Date(Long.parseLong(arguments.get(3)));</span>
<span class="nc" id="L169">          return internalMoveByIdAndDate(id, start, end, targetStore);</span>
        default:
<span class="nc" id="L171">          throw new IllegalArgumentException(&quot;Unknown operation '&quot; + operation + &quot;'&quot;);</span>
      }
<span class="nc" id="L173">    } catch (NotFoundException e) {</span>
<span class="nc" id="L174">      throw new ServiceRegistryException(&quot;Error running job&quot;, e);</span>
<span class="nc" id="L175">    } catch (Exception e) {</span>
<span class="nc" id="L176">      throw new ServiceRegistryException(&quot;Error handling operation '&quot; + op + &quot;'&quot;, e);</span>
    }
  }

  /**
   * Spawns a job to move a single snapshot from its current storage to a new target storage location
   *
   * @param version
   *  The {@link Version} to move
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   */
  public Job moveByIdAndVersion(final Version version, final String mpId, final String targetStorage) {
<span class="fc" id="L192">    RequireUtil.notNull(version, &quot;version&quot;);</span>
<span class="fc" id="L193">    RequireUtil.notEmpty(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L194">    RequireUtil.notEmpty(targetStorage, &quot;targetStorage&quot;);</span>
<span class="fc" id="L195">    List&lt;String&gt; args = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L196">    args.add(targetStorage);</span>
<span class="fc" id="L197">    args.add(mpId);</span>
<span class="fc" id="L198">    args.add(version.toString());</span>

    try {
<span class="fc" id="L201">      return serviceRegistry.createJob(JOB_TYPE, Operation.MoveByIdAndVersion.toString(), args, null, true, JOB_LOAD);</span>
<span class="nc" id="L202">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L203">      throw new AssetManagerException(&quot;Unable to create a job&quot;, e);</span>
    }
  }

  /**
   * Triggers the move operation inside the {@link AssetManager}
   *
   * @param version
   *  The {@link Version} to move
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The string &quot;OK&quot;
   * @throws NotFoundException
   */
  protected String internalMoveByIdAndVersion(
      final Version version,
      final String mpId,
      final String targetStorage
  ) throws NotFoundException {
<span class="fc" id="L225">    tsam.moveSnapshotToStore(version, mpId, targetStorage);</span>
<span class="fc" id="L226">    return OK;</span>
  }

  /**
   * Spawns a job to move a all snapshots of a mediapackage from their current storage to a new target storage location
   *
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The {@link Job}
   */
  public Job moveById(final String mpId, final String targetStorage) {
<span class="fc" id="L240">    RequireUtil.notEmpty(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L241">    RequireUtil.notEmpty(targetStorage, &quot;targetStorage&quot;);</span>
<span class="fc" id="L242">    List&lt;String&gt; args = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L243">    args.add(targetStorage);</span>
<span class="fc" id="L244">    args.add(mpId);</span>

    try {
<span class="fc" id="L247">      return serviceRegistry.createJob(JOB_TYPE, Operation.MoveById.toString(), args, null, true, NONTERMINAL_JOB_LOAD);</span>
<span class="nc" id="L248">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L249">      throw new AssetManagerException(&quot;Unable to create a job&quot;, e);</span>
    }
  }

  /**
   * Moves all the appropriate snapshots to their new home
   *
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The String containing the number of successful and failed moves
   *  [0 OK ][0 FAILED ]
   */
  protected String internalMoveById(final String mpId, final String targetStorage) {
<span class="fc" id="L265">    List&lt;Snapshot&gt; results = tsam.getSnapshotsByIdOrderedByVersion(mpId, true);</span>
<span class="fc" id="L266">    MoveRecordInfo result = moveSnapshots(results, targetStorage);</span>
<span class="fc" id="L267">    return result.toString();</span>
  }


  /**
   * Spawns a job to move a all snapshots taken between two points from their
   * current storage to a new target storage location
   *
   * @param start
   *  The start {@link Date}
   * @param end
   *  The end {@link Date}
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The {@link Job}
   */
  public Job moveByDate(final Date start, final Date end, final String targetStorage) {
<span class="fc" id="L285">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="fc" id="L286">    RequireUtil.notNull(end, &quot;end&quot;);</span>
<span class="fc" id="L287">    RequireUtil.notNull(targetStorage, &quot;targetStorage&quot;);</span>
<span class="fc" id="L288">    List&lt;String&gt; args = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L289">    args.add(targetStorage);</span>
<span class="fc" id="L290">    args.add(Long.toString(start.getTime()));</span>
<span class="fc" id="L291">    args.add(Long.toString(end.getTime()));</span>

    try {
<span class="fc" id="L294">      return serviceRegistry.createJob(</span>
<span class="fc" id="L295">          JOB_TYPE, Operation.MoveByDate.toString(), args, null, true, NONTERMINAL_JOB_LOAD);</span>
<span class="nc" id="L296">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L297">      throw new AssetManagerException(&quot;Unable to create a job&quot;, e);</span>
    }
  }

  /**
   * Spawns subjobs on a per-snapshot level to move the appropriate snapshots to their new home
   * Moves all the appropriate snapshots to their new home
   *
   * @param start
   *  The start {@link Date}
   * @param end
   *  The end {@link Date}
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The number of subjobs spawned
   */
  protected String internalMoveByDate(final Date start, final Date end, final String targetStorage) {
<span class="fc" id="L315">    List&lt;Snapshot&gt; snapshots = tsam.getSnapshotsByDateOrderedById(start, end);</span>
<span class="fc" id="L316">    List&lt;Job&gt; subjobs = spawnSubjobs(snapshots, start, end, targetStorage);</span>
<span class="fc" id="L317">    return Integer.toString(subjobs.size());</span>
  }

  /**
   * Spawns a job to move a all snapshots of a given mediapackage taken between
   * two points from their current storage to a new target storage location
   *
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param start
   *  The start {@link Date}
   * @param end
   *  The end {@link Date}
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The {@link Job}
   */
  public Job moveByIdAndDate(final String mpId, final Date start, final Date end, final String targetStorage) {
<span class="fc" id="L336">    RequireUtil.notNull(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L337">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="fc" id="L338">    RequireUtil.notNull(end, &quot;end&quot;);</span>
<span class="fc" id="L339">    RequireUtil.notNull(targetStorage, &quot;targetStorage&quot;);</span>
<span class="fc" id="L340">    List&lt;String&gt; args = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L341">    args.add(targetStorage);</span>
<span class="fc" id="L342">    args.add(mpId);</span>
<span class="fc" id="L343">    args.add(Long.toString(start.getTime()));</span>
<span class="fc" id="L344">    args.add(Long.toString(end.getTime()));</span>

    try {
<span class="fc" id="L347">      return serviceRegistry.createJob(</span>
<span class="fc" id="L348">          JOB_TYPE, Operation.MoveByIdAndDate.toString(), args, null, true, NONTERMINAL_JOB_LOAD);</span>
<span class="nc" id="L349">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L350">      throw new AssetManagerException(&quot;Unable to create a job&quot;, e);</span>
    }
  }

  /**
   * Moves all the appropriate snapshots to their new home
   *
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param start
   *  The start {@link Date}
   * @param end
   *  The end {@link Date}
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The JSON String containing the number of successful and failed moves
   *  {&quot;OK&quot;: 0,&quot;FAIL&quot;: 0}
   */
  protected String internalMoveByIdAndDate(
      final String mpId,
      final Date start,
      final Date end,
      final String targetStorage
  ) {
<span class="fc" id="L375">    List&lt;Snapshot&gt; snapshots = tsam.getSnapshotsByIdAndDateOrderedByVersion(mpId, start, end, true);</span>
<span class="fc" id="L376">    MoveRecordInfo result = moveSnapshots(snapshots, targetStorage);</span>
<span class="fc" id="L377">    return result.toString();</span>
  }

  /**
   * Spawns the subjobs based on the stream of records
   *
   * @param records
   *  The stream of records containing the snapshots to move to the new target storage
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The set of subjobs
   */

  private List&lt;Job&gt; spawnSubjobs(
      final List&lt;Snapshot&gt; snapshots,
      final Date start,
      final Date end,
      final String targetStorage
  ) {
<span class="fc" id="L397">    List&lt;Job&gt; jobs = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L398">    MoveRecordInfo recordInfo = new MoveRecordInfo();</span>
<span class="fc" id="L399">    snapshots.forEach(snap -&gt; {</span>
<span class="fc" id="L400">      String mediaPackageId = snap.getMediaPackage().getIdentifier().toString();</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">      if (recordInfo.isNewMpId(mediaPackageId)) {</span>
<span class="fc" id="L402">        jobs.add(moveByIdAndDate(mediaPackageId,start,end,targetStorage));</span>
      }
<span class="fc" id="L404">    });</span>
<span class="fc" id="L405">    return jobs;</span>
  }

  /**
   * Moves all snapshot based on the stream of records from its current storage to a new target storage location
   *
   * @param records
   *  The stream of records containing the snapshots to move to the new target storage
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The {@link MoveRecordInfo}
   */
  private MoveRecordInfo moveSnapshots(final List&lt;Snapshot&gt; snapshots, final String targetStorage) {
<span class="fc" id="L419">    final MoveRecordInfo result = new MoveRecordInfo();</span>
<span class="fc" id="L420">    snapshots.forEach(snap -&gt; {</span>
      try {
<span class="fc" id="L422">        logger.debug(&quot;moving Mediapackage {} Version {} from {} to {}&quot;,</span>
<span class="fc" id="L423">            snap.getMediaPackage().getIdentifier().toString(),</span>
<span class="fc" id="L424">            snap.getVersion().toString(),</span>
<span class="fc" id="L425">            snap.getStorageId(),</span>
            targetStorage
        );
<span class="fc" id="L428">        internalMoveByIdAndVersion(snap.getVersion(),</span>
<span class="fc" id="L429">            snap.getMediaPackage().getIdentifier().toString(),</span>
            targetStorage
        );
<span class="fc" id="L432">        result.addSuccess();</span>
<span class="nc" id="L433">      } catch (NotFoundException e) {</span>
<span class="nc" id="L434">        result.addFailed();</span>
<span class="nc" id="L435">        logger.warn(e.getMessage());</span>
<span class="fc" id="L436">      }</span>
<span class="fc" id="L437">    });</span>
<span class="fc" id="L438">    return result;</span>
  }

  @Reference
  protected void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L443">    this.serviceRegistry = serviceRegistry;</span>
<span class="fc" id="L444">  }</span>

  @Override
  protected ServiceRegistry getServiceRegistry() {
<span class="nc" id="L448">    return this.serviceRegistry;</span>
  }

  @Reference
  protected void setAssetManager(AssetManager assetManager) {
<span class="fc" id="L453">    this.tsam = assetManager;</span>
<span class="fc" id="L454">  }</span>

  @Reference
  protected void setSecurityService(SecurityService securityService) {
<span class="fc" id="L458">    this.securityService = securityService;</span>
<span class="fc" id="L459">  }</span>

  @Override
  protected SecurityService getSecurityService() {
<span class="nc" id="L463">    return this.securityService;</span>
  }

  @Reference
  protected void setUserDirectoryService(UserDirectoryService uds) {
<span class="fc" id="L468">    this.userDirectoryService = uds;</span>
<span class="fc" id="L469">  }</span>

  @Override
  protected UserDirectoryService getUserDirectoryService() {
<span class="nc" id="L473">    return this.userDirectoryService;</span>
  }

  @Reference
  protected void setOrganizationDirectoryService(OrganizationDirectoryService os) {
<span class="fc" id="L478">    this.organizationDirectoryService = os;</span>
<span class="fc" id="L479">  }</span>

  @Override
  protected OrganizationDirectoryService getOrganizationDirectoryService() {
<span class="nc" id="L483">    return this.organizationDirectoryService;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>