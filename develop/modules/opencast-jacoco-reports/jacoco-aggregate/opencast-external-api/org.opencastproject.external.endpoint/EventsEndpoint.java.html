<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EventsEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-external-api</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.external.endpoint</a> &gt; <span class="el_source">EventsEndpoint.java</span></div><h1>EventsEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.external.endpoint;

import static org.apache.commons.lang3.StringUtils.trimToNull;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_11_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_1_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_4_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_7_0;
import static org.opencastproject.external.util.SchedulingUtils.SchedulingInfo;
import static org.opencastproject.external.util.SchedulingUtils.convertConflictingEvents;
import static org.opencastproject.external.util.SchedulingUtils.getConflictingEvents;
import static org.opencastproject.index.service.util.JSONUtils.arrayToJsonArray;
import static org.opencastproject.index.service.util.JSONUtils.collectionToJsonArray;
import static org.opencastproject.index.service.util.JSONUtils.safeString;
import static org.opencastproject.util.RestUtil.getEndpointUrl;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;

import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.AssetManagerException;
import org.opencastproject.capture.CaptureParameters;
import org.opencastproject.capture.admin.api.CaptureAgentStateService;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.api.SearchResultItem;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.IndexObject;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.objects.event.EventIndexSchema;
import org.opencastproject.elasticsearch.index.objects.event.EventSearchQuery;
import org.opencastproject.external.common.ApiMediaType;
import org.opencastproject.external.common.ApiResponseBuilder;
import org.opencastproject.external.common.ApiVersion;
import org.opencastproject.external.util.AclUtils;
import org.opencastproject.external.util.ExternalMetadataUtils;
import org.opencastproject.index.service.api.IndexService;
import org.opencastproject.index.service.catalog.adapter.DublinCoreMetadataUtil;
import org.opencastproject.index.service.exception.IndexServiceException;
import org.opencastproject.index.service.impl.util.EventHttpServletRequest;
import org.opencastproject.index.service.impl.util.EventUtils;
import org.opencastproject.index.service.util.RequestUtils;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.ingest.api.IngestException;
import org.opencastproject.ingest.api.IngestService;
import org.opencastproject.list.impl.EmptyResourceListQuery;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.AudioStream;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Publication;
import org.opencastproject.mediapackage.Stream;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.TrackSupport;
import org.opencastproject.mediapackage.VideoStream;
import org.opencastproject.mediapackage.track.TrackImpl;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.EventCatalogUIAdapter;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.MetadataJson;
import org.opencastproject.metadata.dublincore.MetadataList;
import org.opencastproject.metadata.dublincore.MetadataList.Locked;
import org.opencastproject.rest.RestConstants;
import org.opencastproject.scheduler.api.SchedulerConflictException;
import org.opencastproject.scheduler.api.SchedulerException;
import org.opencastproject.scheduler.api.SchedulerService;
import org.opencastproject.scheduler.api.TechnicalMetadata;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.urlsigning.exception.UrlSigningException;
import org.opencastproject.security.urlsigning.service.UrlSigningService;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.util.DateTimeSupport;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RestUtil;
import org.opencastproject.util.RestUtil.R;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestParameter.Type;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.util.requests.SortCriterion;
import org.opencastproject.workflow.api.WorkflowDatabaseException;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowService;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonNull;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;

import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.lang3.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.osgi.service.cm.ConfigurationException;
import org.osgi.service.cm.ManagedService;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.URI;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Date;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@Path(&quot;/api/events&quot;)
@Produces({ ApiMediaType.JSON, ApiMediaType.VERSION_1_0_0, ApiMediaType.VERSION_1_1_0, ApiMediaType.VERSION_1_2_0,
            ApiMediaType.VERSION_1_3_0, ApiMediaType.VERSION_1_4_0, ApiMediaType.VERSION_1_5_0,
            ApiMediaType.VERSION_1_6_0, ApiMediaType.VERSION_1_7_0, ApiMediaType.VERSION_1_8_0,
            ApiMediaType.VERSION_1_9_0, ApiMediaType.VERSION_1_10_0, ApiMediaType.VERSION_1_11_0 })
@RestService(name = &quot;externalapievents&quot;, title = &quot;External API Events Service&quot;, notes = {},
             abstractText = &quot;Provides resources and operations related to the events&quot;)
@Tag(name = &quot;External API&quot;)
@Tag(name = &quot;External API - Events&quot;,
    description = &quot;The events endpoint provides resources and operations related to the events&quot;)
@Component(
    immediate = true,
    service = { EventsEndpoint.class,ManagedService.class },
    property = {
        &quot;service.description=External API - Events Endpoint&quot;,
        &quot;opencast.service.type=org.opencastproject.external.events&quot;,
        &quot;opencast.service.path=/api/events&quot;
    }
)
@JaxrsResource
<span class="fc" id="L210">public class EventsEndpoint implements ManagedService {</span>

  protected static final String URL_SIGNING_EXPIRES_DURATION_SECONDS_KEY = &quot;url.signing.expires.seconds&quot;;

  /** The default time before a piece of signed content expires. 2 Hours. */
<span class="fc" id="L215">  protected static final Long DEFAULT_URL_SIGNING_EXPIRE_DURATION = 2 * 60 * 60L;</span>

  /** Subtype of previews required by the video editor */
  private static final String PREVIEW_SUBTYPE = &quot;preview.subtype&quot;;

  /** Subtype of previews required by the video editor */
  private static final String DEFAULT_PREVIEW_SUBTYPE = &quot;preview&quot;;

  /** ID of the workflow used to retract published events */
  private static final String RETRACT_WORKFLOW = &quot;retract.workflow.id&quot;;

  /** Default ID of the workflow used to retract published events */
  private static final String DEFAULT_RETRACT_WORKFLOW = &quot;delete&quot;;

  /** The logging facility */
<span class="fc" id="L230">  private static final Logger logger = LoggerFactory.getLogger(EventsEndpoint.class);</span>

  /** Base URL of this endpoint */
  protected String endpointBaseUrl;

<span class="fc" id="L235">  private static long expireSeconds = DEFAULT_URL_SIGNING_EXPIRE_DURATION;</span>

<span class="fc" id="L237">  private String previewSubtype = DEFAULT_PREVIEW_SUBTYPE;</span>

<span class="fc" id="L239">  private Map&lt;String, MetadataField&gt; configuredMetadataFields = new TreeMap&lt;&gt;();</span>

<span class="fc" id="L241">  private String retractWorkflowId = DEFAULT_RETRACT_WORKFLOW;</span>

  /** The resolutions */
<span class="nc" id="L244">  private enum CommentResolution {</span>
<span class="nc" id="L245">    ALL, UNRESOLVED, RESOLVED;</span>
  };

  /* OSGi service references */
  private AssetManager assetManager;
  private ElasticsearchIndex elasticsearchIndex;
  private IndexService indexService;
  private IngestService ingestService;
  private SecurityService securityService;
<span class="fc" id="L254">  private final List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L255">  private final Map&lt;String, List&lt;EventCatalogUIAdapter&gt;&gt; orgCatalogUIAdaptersMap = new ConcurrentHashMap&lt;&gt;();</span>
  private UrlSigningService urlSigningService;
  private SchedulerService schedulerService;
  private CaptureAgentStateService agentStateService;
  private WorkflowService workflowService;

  /** OSGi DI */
  @Reference
  public void setAssetManager(AssetManager assetManager) {
<span class="fc" id="L264">    this.assetManager = assetManager;</span>
<span class="fc" id="L265">  }</span>

  /** OSGi DI */
  @Reference
  void setElasticsearchIndex(ElasticsearchIndex elasticsearchIndex) {
<span class="fc" id="L270">    this.elasticsearchIndex = elasticsearchIndex;</span>
<span class="fc" id="L271">  }</span>

  /** OSGi DI */
  @Reference
  public void setIndexService(IndexService indexService) {
<span class="fc" id="L276">    this.indexService = indexService;</span>
<span class="fc" id="L277">  }</span>

  /** OSGi DI */
  @Reference
  public void setIngestService(IngestService ingestService) {
<span class="fc" id="L282">    this.ingestService = ingestService;</span>
<span class="fc" id="L283">  }</span>

  /** OSGi DI */
  @Reference
  void setSecurityService(SecurityService securityService) {
<span class="fc" id="L288">    this.securityService = securityService;</span>
<span class="fc" id="L289">  }</span>

  /** OSGi DI */
  @Reference
  public void setUrlSigningService(UrlSigningService urlSigningService) {
<span class="nc" id="L294">    this.urlSigningService = urlSigningService;</span>
<span class="nc" id="L295">  }</span>

  public SecurityService getSecurityService() {
<span class="fc" id="L298">    return securityService;</span>
  }

  public SchedulerService getSchedulerService() {
<span class="nc" id="L302">    return schedulerService;</span>
  }

  @Reference
  public void setSchedulerService(SchedulerService schedulerService) {
<span class="fc" id="L307">    this.schedulerService = schedulerService;</span>
<span class="fc" id="L308">  }</span>

  /** OSGi DI. */
  @Reference(
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeCatalogUIAdapter&quot;
  )
  public void addCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="fc" id="L317">    catalogUIAdapters.add(catalogUIAdapter);</span>
<span class="fc" id="L318">    invalidateOrgCatalogUIAdaptersMapFor(catalogUIAdapter);</span>
<span class="fc" id="L319">  }</span>

  /** OSGi DI. */
  public void removeCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L323">    catalogUIAdapters.remove(catalogUIAdapter);</span>
<span class="nc" id="L324">    invalidateOrgCatalogUIAdaptersMapFor(catalogUIAdapter);</span>
<span class="nc" id="L325">  }</span>

  /**
   * Invalidates caches for organizations that are handled by given catalog.
   *
   * @param catalogUIAdapter catalog used to identify affected organizations.
   */
  private void invalidateOrgCatalogUIAdaptersMapFor(EventCatalogUIAdapter catalogUIAdapter) {
    // clean cached org to catalog map
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">    for (String orgName : orgCatalogUIAdaptersMap.keySet()) {</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">      if (catalogUIAdapter.handlesOrganization(orgName)) {</span>
<span class="nc" id="L336">        orgCatalogUIAdaptersMap.remove(orgName);</span>
      }
<span class="nc" id="L338">    }</span>
<span class="fc" id="L339">  }</span>

  /** OSGi DI */
  public CaptureAgentStateService getAgentStateService() {
<span class="nc" id="L343">    return agentStateService;</span>
  }

  /** OSGi DI */
  @Reference
  public void setAgentStateService(CaptureAgentStateService agentStateService) {
<span class="nc" id="L349">    this.agentStateService = agentStateService;</span>
<span class="nc" id="L350">  }</span>

  /** OSGi DI */
  @Reference
  public void setWorkflowService(WorkflowService workflowService) {
<span class="fc" id="L355">    this.workflowService = workflowService;</span>
<span class="fc" id="L356">  }</span>


  private List&lt;EventCatalogUIAdapter&gt; getEventCatalogUIAdapters() {
<span class="fc" id="L360">    return getEventCatalogUIAdapters(getSecurityService().getOrganization().getId());</span>
  }

  public List&lt;EventCatalogUIAdapter&gt; getEventCatalogUIAdapters(String organization) {
<span class="fc" id="L364">    List&lt;EventCatalogUIAdapter&gt; cachedCatalogUIAdapters = orgCatalogUIAdaptersMap.computeIfAbsent(organization,</span>
<span class="fc" id="L365">        org -&gt; new ArrayList&lt;&gt;(catalogUIAdapters.stream()</span>
<span class="fc" id="L366">            .filter(a -&gt; a.handlesOrganization(org))</span>
<span class="fc" id="L367">            .collect(Collectors.toList())));</span>
    // create a shallow copy as callers may change it
<span class="fc" id="L369">    return new ArrayList&lt;&gt;(cachedCatalogUIAdapters);</span>
  }

  /** OSGi activation method */
  @Activate
  void activate(ComponentContext cc) {
<span class="nc" id="L375">    logger.info(&quot;Activating External API - Events Endpoint&quot;);</span>

<span class="nc" id="L377">    final Tuple&lt;String, String&gt; endpointUrl = getEndpointUrl(cc, OpencastConstants.EXTERNAL_API_URL_ORG_PROPERTY,</span>
            RestConstants.SERVICE_PATH_PROPERTY);
<span class="nc" id="L379">    endpointBaseUrl = UrlSupport.concat(endpointUrl.getA(), endpointUrl.getB());</span>
<span class="nc" id="L380">    logger.debug(&quot;Configured service endpoint is {}&quot;, endpointBaseUrl);</span>
<span class="nc" id="L381">  }</span>

  /** OSGi callback if properties file is present */
  @Override
  public void updated(Dictionary&lt;String, ?&gt; properties) throws ConfigurationException {
    // Ensure properties is not null
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">    if (properties == null) {</span>
<span class="nc" id="L388">      properties = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L389">      logger.debug(&quot;No configuration set&quot;);</span>
    }

    // Read URL Signing Expiration duration
    // Default to DEFAULT_URL_SIGNING_EXPIRE_DURATION.toString()));
<span class="fc" id="L394">    expireSeconds = Long.parseLong(Objects.toString(</span>
<span class="fc" id="L395">        properties.get(URL_SIGNING_EXPIRES_DURATION_SECONDS_KEY),</span>
<span class="fc" id="L396">        DEFAULT_URL_SIGNING_EXPIRE_DURATION.toString()));</span>
<span class="fc" id="L397">    logger.debug(&quot;URLs signatures are configured to expire in {}.&quot;, DateTimeSupport.humanReadableTime(expireSeconds));</span>

    // Read preview subtype configuration
    // Default to DEFAULT_PREVIEW_SUBTYPE
<span class="fc" id="L401">    previewSubtype = StringUtils.defaultString((String) properties.get(PREVIEW_SUBTYPE), DEFAULT_PREVIEW_SUBTYPE);</span>
<span class="fc" id="L402">    logger.debug(&quot;Preview subtype is '{}'&quot;, previewSubtype);</span>

<span class="fc" id="L404">    configuredMetadataFields = DublinCoreMetadataUtil.getDublinCoreProperties(properties);</span>

<span class="fc" id="L406">    retractWorkflowId = StringUtils.defaultString((String) properties.get(RETRACT_WORKFLOW), DEFAULT_RETRACT_WORKFLOW);</span>
<span class="fc" id="L407">    logger.debug(&quot;Retract Workflow is '{}'&quot;, retractWorkflowId);</span>
<span class="fc" id="L408">  }</span>

  public static &lt;T&gt; boolean isNullOrEmpty(List&lt;String&gt; list) {
<span class="nc bnc" id="L411" title="All 4 branches missed.">    return list == null || list.isEmpty();</span>
  }

  @GET
  @Path(&quot;{eventId}&quot;)
  @RestQuery(name = &quot;getevent&quot;, description = &quot;Returns a single event. By setting the optional sign parameter to true, the method will pre-sign distribution urls if signing is turned on in Opencast. Remember to consider the maximum validity of signed URLs when caching this response.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;sign&quot;, isRequired = false, description = &quot;Whether public distribution urls should be signed.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withacl&quot;, isRequired = false, description = &quot;Whether the acl metadata should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withmetadata&quot;, isRequired = false, description = &quot;Whether the metadata catalogs should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withscheduling&quot;, isRequired = false, description = &quot;Whether the scheduling information should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withpublications&quot;, isRequired = false, description = &quot;Whether the publication ids and urls should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;includeInternalPublication&quot;, isRequired = false, description = &quot;Whether internal publications should be included.&quot;, type = Type.BOOLEAN)}, responses = {
                          @RestResponse(description = &quot;The event is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  @Operation(summary = &quot;Get a single event&quot;, description = &quot;Returns a single event. By setting the optional sign parameter to true, the method will pre-sign distribution urls if signing is turned on in Opencast. Remember to consider the maximum validity of signed URLs when caching this response.&quot;)
  public Response getEvent(
      @HeaderParam(&quot;Accept&quot;) String acceptHeader,
      @Parameter(description = &quot;The event id&quot;, required = true)
      @PathParam(&quot;eventId&quot;) String id,
      @Parameter(description = &quot;Whether public distribution urls should be signed.&quot;)
      @QueryParam(&quot;sign&quot;) boolean sign,
      @Parameter(description = &quot;Whether the acl metadata should be included in the response.&quot;)
      @QueryParam(&quot;withacl&quot;) Boolean withAcl,
      @Parameter(description = &quot;Whether the metadata catalogs should be included in the response.&quot;)
      @QueryParam(&quot;withmetadata&quot;) Boolean withMetadata,
      @Parameter(description = &quot;Whether the scheduling information should be included in the response.&quot;)
      @QueryParam(&quot;withscheduling&quot;) Boolean withScheduling,
      @Parameter(description = &quot;Whether the publication ids and urls should be included in the response.&quot;)
      @QueryParam(&quot;withpublications&quot;) Boolean withPublications,
      @Parameter(description = &quot;Whether internal publications should be included.&quot;)
      @QueryParam(&quot;includeInternalPublication&quot;) Boolean includeInternalPublication)
        throws Exception {
<span class="nc" id="L444">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
      // withScheduling was added in version 1.1.0 and should be ignored for smaller versions
<span class="nc" id="L447">      withScheduling = false;</span>
    }
<span class="nc" id="L449">    Optional&lt;Event&gt; eventOpt = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">    if (eventOpt.isPresent()) {</span>
<span class="nc" id="L451">      Event event = eventOpt.get();</span>
<span class="nc" id="L452">      event.updatePreview(previewSubtype);</span>
<span class="nc" id="L453">      return ApiResponseBuilder.Json.ok(</span>
<span class="nc" id="L454">          requestedVersion, eventToJSON(event, withAcl, withMetadata, withScheduling, withPublications, includeInternalPublication, sign, requestedVersion));</span>
    }
<span class="nc" id="L456">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @GET
  @Path(&quot;{eventId}/media&quot;)
  @RestQuery(name = &quot;geteventmedia&quot;, description = &quot;Returns media tracks of specific single event.&quot;, returnDescription = &quot;&quot;, pathParameters = {
      @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
      @RestResponse(description = &quot;The event's media is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  @Operation(summary = &quot;Get media tracks of a single event&quot;, description = &quot;Returns media tracks of specific single event.&quot;)
  @Parameters({
      @Parameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, required = true, in = ParameterIn.PATH),
      @Parameter(name = &quot;Accept&quot;, description = &quot;The accept header&quot;, required = true, in = ParameterIn.HEADER)
  })
  @ApiResponses(value = {
      @ApiResponse(responseCode = &quot;200&quot;, description = &quot;The event's media is returned.&quot;),
      @ApiResponse(responseCode = &quot;404&quot;, description = &quot;The specified event does not exist.&quot;)
  })
  public Response getEventMedia(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
          throws Exception {
<span class="nc" id="L476">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc" id="L477">    List&lt;TrackImpl&gt; tracks = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L479">    Optional&lt;Event&gt; eventOpt = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">    if (eventOpt.isPresent()) {</span>
<span class="nc" id="L481">      final MediaPackage mp = indexService.getEventMediapackage(eventOpt.get());</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">      for (Track track : mp.getTracks()) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (track instanceof TrackImpl) {</span>
<span class="nc" id="L484">          tracks.add((TrackImpl) track);</span>
        }
      }

<span class="nc" id="L488">      JsonArray tracksJson = new JsonArray();</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">      for (Track track : tracks) {</span>
<span class="nc" id="L490">        JsonObject trackJson = new JsonObject();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (track.getChecksum() != null)</span>
<span class="nc" id="L492">          trackJson.addProperty(&quot;checksum&quot;, track.getChecksum().toString());</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (track.getDescription() != null)</span>
<span class="nc" id="L494">          trackJson.addProperty(&quot;description&quot;, track.getDescription());</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">        if (track.getDuration() != null)</span>
<span class="nc" id="L496">          trackJson.addProperty(&quot;duration&quot;, track.getDuration());</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (track.getElementDescription() != null)</span>
<span class="nc" id="L498">          trackJson.addProperty(&quot;element-description&quot;, track.getElementDescription());</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (track.getFlavor() != null)</span>
<span class="nc" id="L500">          trackJson.addProperty(&quot;flavor&quot;, track.getFlavor().toString());</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (track.getIdentifier() != null)</span>
<span class="nc" id="L502">          trackJson.addProperty(&quot;identifier&quot;, track.getIdentifier());</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (track.getMimeType() != null)</span>
<span class="nc" id="L504">          trackJson.addProperty(&quot;mimetype&quot;, track.getMimeType().toString());</span>
<span class="nc" id="L505">        trackJson.addProperty(&quot;size&quot;, track.getSize());</span>

<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (!requestedVersion.isSmallerThan(VERSION_1_7_0)) {</span>
<span class="nc" id="L508">          trackJson.addProperty(&quot;has_video&quot;, track.hasVideo());</span>
<span class="nc" id="L509">          trackJson.addProperty(&quot;has_audio&quot;, track.hasAudio());</span>
<span class="nc" id="L510">          trackJson.addProperty(&quot;is_master_playlist&quot;, track.isMaster());</span>
<span class="nc" id="L511">          trackJson.addProperty(&quot;is_live&quot;, track.isLive());</span>
        }

<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (track.getStreams() != null) {</span>
<span class="nc" id="L515">          JsonObject streamsJson = new JsonObject();</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">          for (Stream stream : track.getStreams()) {</span>
<span class="nc" id="L517">            streamsJson.add(stream.getIdentifier(), getJsonStream(stream));</span>
          }
<span class="nc" id="L519">          trackJson.add(&quot;streams&quot;, streamsJson);</span>
        }

<span class="nc" id="L522">        trackJson.add(&quot;tags&quot;, arrayToJsonArray(track.getTags()));</span>

<span class="nc bnc" id="L524" title="All 2 branches missed.">        if (track.getURI() != null)</span>
<span class="nc" id="L525">          trackJson.addProperty(&quot;uri&quot;, track.getURI().toString());</span>

<span class="nc" id="L527">        tracksJson.add(trackJson);</span>
<span class="nc" id="L528">      }</span>

<span class="nc" id="L530">      return ApiResponseBuilder.Json.ok(acceptHeader, tracksJson);</span>
    }

<span class="nc" id="L533">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @DELETE
  @Path(&quot;{eventId}&quot;)
  @RestQuery(name = &quot;deleteevent&quot;, description = &quot;Deletes an event.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(description = &quot;The event has been deleted.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
          @RestResponse(description = &quot;The retraction of publications has started.&quot;, responseCode = HttpServletResponse.SC_ACCEPTED),
          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteEvent(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
          throws SearchIndexException, UnauthorizedException {
<span class="nc" id="L545">    final Optional&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">    if (event.isEmpty()) {</span>
<span class="nc" id="L547">      return RestUtil.R.notFound(id);</span>
    }
    final IndexService.EventRemovalResult result;
    try {
<span class="nc" id="L551">      result = indexService.removeEvent(event.get(), retractWorkflowId);</span>
<span class="nc" id="L552">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L553">      logger.error(&quot;Workflow database is not reachable. This may be a temporary problem.&quot;);</span>
<span class="nc" id="L554">      return RestUtil.R.serverError();</span>
<span class="nc" id="L555">    } catch (NotFoundException e) {</span>
<span class="nc" id="L556">      logger.error(&quot;Configured retract workflow not found. Check your configuration.&quot;);</span>
<span class="nc" id="L557">      return RestUtil.R.serverError();</span>
<span class="nc" id="L558">    }</span>
<span class="nc bnc" id="L559" title="All 5 branches missed.">    switch (result) {</span>
      case SUCCESS:
<span class="nc" id="L561">        return Response.noContent().build();</span>
      case RETRACTING:
<span class="nc" id="L563">        return Response.accepted().build();</span>
      case GENERAL_FAILURE:
<span class="nc" id="L565">        return Response.serverError().build();</span>
      case NOT_FOUND:
<span class="nc" id="L567">        return RestUtil.R.notFound(id);</span>
      default:
<span class="nc" id="L569">        throw new RuntimeException(&quot;Unknown EventRemovalResult type: &quot; + result.name());</span>
    }
  }

  @POST
  @Path(&quot;{eventId}&quot;)
  @RestQuery(name = &quot;updateeventmetadata&quot;, description = &quot;Updates an event.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;acl&quot;, isRequired = false, description = &quot;A collection of roles with their possible action&quot;, type = Type.STRING),
                  @RestParameter(name = &quot;metadata&quot;, isRequired = false, description = &quot;Event metadata as Form param&quot;, type = Type.STRING),
                  @RestParameter(name = &quot;scheduling&quot;, isRequired = false, description = &quot;Scheduling information as Form param&quot;, type = Type.STRING),
                  @RestParameter(name = &quot;presenter&quot;, isRequired = false, description = &quot;Presenter movie track&quot;, type = Type.FILE),
                  @RestParameter(name = &quot;presentation&quot;, isRequired = false, description = &quot;Presentation movie track&quot;, type = Type.FILE),
                  @RestParameter(name = &quot;audio&quot;, isRequired = false, description = &quot;Audio track&quot;, type = Type.FILE),
                  @RestParameter(name = &quot;processing&quot;, isRequired = false, description = &quot;Processing instructions task configuration&quot;, type = Type.STRING), }, responses = {
                          @RestResponse(description = &quot;The event has been updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The event could not be updated due to a scheduling conflict.&quot;, responseCode = HttpServletResponse.SC_CONFLICT),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventMetadata(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @Context HttpServletRequest request,
          @PathParam(&quot;eventId&quot;) String eventId) {
<span class="fc" id="L589">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
    try {
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">      String startDatePattern = configuredMetadataFields.containsKey(&quot;startDate&quot;) ? configuredMetadataFields.get(&quot;startDate&quot;).getPattern() : null;</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">      String startTimePattern = configuredMetadataFields.containsKey(&quot;startTime&quot;) ? configuredMetadataFields.get(&quot;startTime&quot;).getPattern() : null;</span>
<span class="fc" id="L593">      Optional&lt;Event&gt; eventOpt = indexService.getEvent(eventId, elasticsearchIndex);</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">      if (eventOpt.isPresent()) {</span>
<span class="fc" id="L595">        Event event = eventOpt.get();</span>
<span class="fc" id="L596">        EventHttpServletRequest eventHttpServletRequest = EventHttpServletRequest.updateFromHttpServletRequest(event,</span>
<span class="fc" id="L597">                request, getEventCatalogUIAdapters(), startDatePattern, startTimePattern);</span>

        // FIXME: All of these update operations should be a part of a transaction to avoid a partially updated event.
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if (eventHttpServletRequest.getMetadataList().isPresent()) {</span>
<span class="fc" id="L601">          indexService.updateEventMetadata(eventId, eventHttpServletRequest.getMetadataList().get(), elasticsearchIndex);</span>
        }

<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        if (eventHttpServletRequest.getAcl().isPresent()) {</span>
<span class="nc" id="L605">          indexService.updateEventAcl(eventId, eventHttpServletRequest.getAcl().get(), elasticsearchIndex);</span>
        }

<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (eventHttpServletRequest.getProcessing().isPresent()) {</span>

<span class="nc bnc" id="L610" title="All 4 branches missed.">          if (!event.isScheduledEvent() || event.hasRecordingStarted()) {</span>
<span class="nc" id="L611">            return RestUtil.R.badRequest(&quot;Processing can't be updated for events that are already uploaded.&quot;);</span>
          }
<span class="nc" id="L613">          JSONObject processing = eventHttpServletRequest.getProcessing().get();</span>

<span class="nc" id="L615">          String workflowId = (String) processing.get(&quot;workflow&quot;);</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">          if (workflowId == null)</span>
<span class="nc" id="L617">            throw new IllegalArgumentException(&quot;No workflow template in metadata&quot;);</span>

<span class="nc" id="L619">          Map&lt;String, String&gt; configuration = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">          if (eventHttpServletRequest.getProcessing().get().get(&quot;configuration&quot;) != null) {</span>
<span class="nc" id="L621">            configuration = new HashMap&lt;&gt;((JSONObject) eventHttpServletRequest.getProcessing().get().get(&quot;configuration&quot;));</span>
          }

<span class="nc" id="L624">          Optional&lt;Map&lt;String, String&gt;&gt; caMetadataOpt = Optional.empty();</span>
<span class="nc" id="L625">          Optional&lt;Map&lt;String, String&gt;&gt; workflowConfigOpt = Optional.empty();</span>

<span class="nc" id="L627">          Map&lt;String, String&gt; caMetadata = new HashMap&lt;&gt;(getSchedulerService().getCaptureAgentConfiguration(eventId));</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">          if (!workflowId.equals(caMetadata.get(CaptureParameters.INGEST_WORKFLOW_DEFINITION))) {</span>
<span class="nc" id="L629">            caMetadata.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, workflowId);</span>
<span class="nc" id="L630">            caMetadataOpt = Optional.of(caMetadata);</span>
          }

<span class="nc" id="L633">          Map&lt;String, String&gt; oldWorkflowConfig = new HashMap&lt;&gt;(getSchedulerService().getWorkflowConfig(eventId));</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">          if (!oldWorkflowConfig.equals(configuration))</span>
<span class="nc" id="L635">            workflowConfigOpt = Optional.of(configuration);</span>

<span class="nc bnc" id="L637" title="All 4 branches missed.">          if (!caMetadataOpt.isEmpty() || !workflowConfigOpt.isEmpty()) {</span>
<span class="nc" id="L638">            getSchedulerService().updateEvent(eventId, Optional.empty(), Optional.empty(), Optional.empty(),</span>
<span class="nc" id="L639">                    Optional.empty(), Optional.empty(), workflowConfigOpt, caMetadataOpt);</span>
          }
        }

<span class="pc bpc" id="L643" title="3 of 4 branches missed.">        if (eventHttpServletRequest.getScheduling().isPresent() &amp;&amp; !requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
          // Scheduling is only available for version 1.1.0 and above
<span class="nc" id="L645">          Optional&lt;Response&gt; clientError = updateSchedulingInformation(</span>
<span class="nc" id="L646">              eventHttpServletRequest.getScheduling().get(), eventId, requestedVersion, false);</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">          if (clientError.isPresent()) {</span>
<span class="nc" id="L648">            return clientError.get();</span>
          }
        }

<span class="fc" id="L652">        return Response.noContent().build();</span>
      }
<span class="nc" id="L654">      return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
<span class="nc" id="L655">    } catch (NotFoundException e) {</span>
<span class="nc" id="L656">      return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
<span class="nc" id="L657">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L658">      return Response.status(Status.UNAUTHORIZED).build();</span>
<span class="nc" id="L659">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L660">      logger.debug(&quot;Unable to update event '{}'&quot;, eventId, e);</span>
<span class="nc" id="L661">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L662">    } catch (IndexServiceException e) {</span>
<span class="nc" id="L663">      logger.error(&quot;Unable to get multi part fields or file for event '{}'&quot;, eventId, e);</span>
<span class="nc" id="L664">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L665">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L666">      logger.error(&quot;Unable to update event '{}'&quot;, eventId, e);</span>
<span class="nc" id="L667">      throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L668">    } catch (Exception e) {</span>
<span class="nc" id="L669">      throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @POST
  @Path(&quot;/&quot;)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @RestQuery(name = &quot;createevent&quot;, description = &quot;Creates an event by sending metadata, access control list, processing instructions and files in a multipart request.&quot;, returnDescription = &quot;&quot;, restParameters = {
          @RestParameter(name = &quot;acl&quot;, isRequired = false, description = &quot;A collection of roles with their possible action&quot;, type = STRING),
          @RestParameter(name = &quot;metadata&quot;, description = &quot;Event metadata as Form param&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;scheduling&quot;, description = &quot;Scheduling information as Form param&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;presenter&quot;, description = &quot;Presenter movie track&quot;, isRequired = false, type = Type.FILE),
          @RestParameter(name = &quot;presentation&quot;, description = &quot;Presentation movie track&quot;, isRequired = false, type = Type.FILE),
          @RestParameter(name = &quot;audio&quot;, description = &quot;Audio track&quot;, isRequired = false, type = Type.FILE),
          @RestParameter(name = &quot;processing&quot;, description = &quot;Processing instructions task configuration&quot;, isRequired = false, type = STRING) }, responses = {
                  @RestResponse(description = &quot;A new event is created and its identifier is returned in the Location header.&quot;, responseCode = HttpServletResponse.SC_CREATED),
                  @RestResponse(description = &quot;The event could not be created due to a scheduling conflict.&quot;, responseCode = HttpServletResponse.SC_CONFLICT),
                  @RestResponse(description = &quot;The request is invalid or inconsistent..&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) })
  public Response createNewEvent(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @Context HttpServletRequest request) {
<span class="nc" id="L688">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
    try {
<span class="nc bnc" id="L690" title="All 2 branches missed.">      String startDatePattern = configuredMetadataFields.containsKey(&quot;startDate&quot;) ? configuredMetadataFields.get(&quot;startDate&quot;).getPattern() : null;</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">      String startTimePattern = configuredMetadataFields.containsKey(&quot;startTime&quot;) ? configuredMetadataFields.get(&quot;startTime&quot;).getPattern() : null;</span>
<span class="nc" id="L692">      EventHttpServletRequest eventHttpServletRequest = EventHttpServletRequest.createFromHttpServletRequest(request,</span>
<span class="nc" id="L693">          ingestService, getEventCatalogUIAdapters(), startDatePattern, startTimePattern);</span>

      // If scheduling information is provided, the source has to be &quot;SCHEDULE_SINGLE&quot; or &quot;SCHEDULE_MULTIPLE&quot;.
<span class="nc bnc" id="L696" title="All 4 branches missed.">      if (eventHttpServletRequest.getScheduling().isPresent() &amp;&amp; !requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
        // Scheduling is only available for version 1.1.0 and above
<span class="nc" id="L698">        return scheduleNewEvent(eventHttpServletRequest, eventHttpServletRequest.getScheduling().get(), requestedVersion);</span>
      }

<span class="nc" id="L701">      JSONObject source = new JSONObject();</span>
<span class="nc" id="L702">      source.put(&quot;type&quot;, &quot;UPLOAD&quot;);</span>
<span class="nc" id="L703">      eventHttpServletRequest.setSource(source);</span>
<span class="nc" id="L704">      String eventId = indexService.createEvent(eventHttpServletRequest);</span>
<span class="nc" id="L705">      JsonObject json = new JsonObject();</span>
<span class="nc" id="L706">      json.addProperty(&quot;identifier&quot;, eventId);</span>
<span class="nc" id="L707">      return ApiResponseBuilder.Json.created(requestedVersion, URI.create(getEventUrl(eventId)), json);</span>
<span class="nc" id="L708">    } catch (IllegalArgumentException | DateTimeParseException e) {</span>
<span class="nc" id="L709">      logger.debug(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L710">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L711">    } catch (SchedulerException | IndexServiceException e) {</span>
<span class="nc bnc" id="L712" title="All 4 branches missed.">      if (e.getCause() != null &amp;&amp; e.getCause() instanceof NotFoundException</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">              || e.getCause() instanceof IllegalArgumentException) {</span>
<span class="nc" id="L714">        logger.debug(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L715">        return RestUtil.R.badRequest(e.getCause().getMessage());</span>
      } else {
<span class="nc" id="L717">        logger.error(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L718">        throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
      }
<span class="nc" id="L720">    } catch (Exception e) {</span>
<span class="nc" id="L721">      logger.error(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L722">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  private Response scheduleNewEvent(EventHttpServletRequest request, JSONObject scheduling, ApiVersion requestedVersion)
      throws MediaPackageException, IOException, IngestException, SchedulerException,
      NotFoundException, UnauthorizedException, SearchIndexException, java.text.ParseException {

<span class="nc" id="L730">    final SchedulingInfo schedulingInfo = SchedulingInfo.of(scheduling);</span>
<span class="nc" id="L731">    final JSONObject source = schedulingInfo.toSource();</span>
<span class="nc" id="L732">    request.setSource(source);</span>

    try {
<span class="nc" id="L735">      final String eventId = indexService.createEvent(request);</span>

<span class="nc bnc" id="L737" title="All 2 branches missed.">      if (StringUtils.isEmpty(eventId)) {</span>
<span class="nc" id="L738">        return RestUtil.R.badRequest(&quot;The date range provided did not include any events&quot;);</span>
      }

<span class="nc bnc" id="L741" title="All 2 branches missed.">      if (eventId.contains(&quot;,&quot;)) {</span>
        // This the case when SCHEDULE_MULTIPLE is performed.
<span class="nc" id="L743">        JsonArray eventArray = new JsonArray();</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">        for (String id : eventId.split(&quot;,&quot;)) {</span>
<span class="nc" id="L745">          JsonObject eventObj = new JsonObject();</span>
<span class="nc" id="L746">          eventObj.addProperty(&quot;identifier&quot;, id);</span>
<span class="nc" id="L747">          eventArray.add(eventObj);</span>
        }
<span class="nc" id="L749">        return ApiResponseBuilder.Json.ok(requestedVersion, eventArray);</span>
      }

<span class="nc" id="L752">      JsonObject eventJson = new JsonObject();</span>
<span class="nc" id="L753">      eventJson.addProperty(&quot;identifier&quot;, eventId);</span>
<span class="nc" id="L754">      return ApiResponseBuilder.Json.created(requestedVersion, URI.create(getEventUrl(eventId)), eventJson);</span>
<span class="nc" id="L755">    } catch (SchedulerConflictException e) {</span>
<span class="nc" id="L756">      List&lt;MediaPackage&gt; conflictingEvents =</span>
<span class="nc" id="L757">          getConflictingEvents(schedulingInfo, agentStateService, schedulerService);</span>
<span class="nc" id="L758">      logger.debug(&quot;Client tried to schedule conflicting event(s).&quot;);</span>
<span class="nc" id="L759">      JsonArray conflictArray = new JsonArray();</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">      for (JsonObject conflict : convertConflictingEvents(</span>
<span class="nc" id="L761">          Optional.empty(), conflictingEvents, indexService, elasticsearchIndex)) {</span>
<span class="nc" id="L762">        conflictArray.add(conflict);</span>
<span class="nc" id="L763">      }</span>
<span class="nc" id="L764">      return ApiResponseBuilder.Json.conflict(requestedVersion, conflictArray);</span>
    }
  }

  @GET
  @Path(&quot;/&quot;)
  @RestQuery(name = &quot;getevents&quot;, description = &quot;Returns a list of events. By setting the optional sign parameter to true, the method will pre-sign distribution urls if signing is turned on in Opencast. Remember to consider the maximum validity of signed URLs when caching this response.&quot;, returnDescription = &quot;&quot;, restParameters = {
          @RestParameter(name = &quot;sign&quot;, isRequired = false, description = &quot;Whether public distribution urls should be signed.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withacl&quot;, isRequired = false, description = &quot;Whether the acl metadata should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withmetadata&quot;, isRequired = false, description = &quot;Whether the metadata catalogs should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withscheduling&quot;, isRequired = false, description = &quot;Whether the scheduling information should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withpublications&quot;, isRequired = false, description = &quot;Whether the publication ids and urls should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;includeInternalPublication&quot;, description = &quot;Whether internal publications should be included.&quot;, isRequired = false, type = Type.BOOLEAN),
          @RestParameter(name = &quot;onlyWithWriteAccess&quot;, isRequired = false, description = &quot;Whether only to get the events to which we have write access.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;filter&quot;, isRequired = false, description = &quot;Usage [Filter Name]:[Value to Filter With]. Multiple filters can be used by combining them with commas \&quot;,\&quot;. Available Filters: presenters, contributors, location, textFilter, series, subject. If API ver &gt; 1.1.0 also: identifier, title, description, series_name, language, created, license, rightsholder, is_part_of, source, status, agent_id, start, technical_start.&quot;, type = STRING),
          @RestParameter(name = &quot;sort&quot;, description = &quot;Sort the results based upon a list of comma seperated sorting criteria. In the comma seperated list each type of sorting is specified as a pair such as: &lt;Sort Name&gt;:ASC or &lt;Sort Name&gt;:DESC. Adding the suffix ASC or DESC sets the order as ascending or descending order and is mandatory.&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;limit&quot;, description = &quot;The maximum number of results to return for a single request.&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;offset&quot;, description = &quot;The index of the first result to return.&quot;, isRequired = false, type = RestParameter.Type.INTEGER) }, responses = {
                  @RestResponse(description = &quot;A (potentially empty) list of events is returned.&quot;, responseCode = HttpServletResponse.SC_OK) })
  public Response getEvents(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @QueryParam(&quot;id&quot;) String id,
          @QueryParam(&quot;commentReason&quot;) String reasonFilter, @QueryParam(&quot;commentResolution&quot;) String resolutionFilter,
          @QueryParam(&quot;filter&quot;) List&lt;String&gt; filter, @QueryParam(&quot;sort&quot;) String sort, @QueryParam(&quot;offset&quot;) Integer offset,
          @QueryParam(&quot;limit&quot;) Integer limit, @QueryParam(&quot;sign&quot;) boolean sign, @QueryParam(&quot;withacl&quot;) Boolean withAcl,
          @QueryParam(&quot;withmetadata&quot;) Boolean withMetadata, @QueryParam(&quot;withscheduling&quot;) Boolean withScheduling,
          @QueryParam(&quot;onlyWithWriteAccess&quot;) Boolean onlyWithWriteAccess, @QueryParam(&quot;withpublications&quot;) Boolean withPublications, @QueryParam(&quot;includeInternalPublication&quot;) Boolean includeInternalPublication) {
<span class="nc" id="L789">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
      // withscheduling was added for version 1.1.0 and should be ignored for smaller versions.
<span class="nc" id="L792">      withScheduling = false;</span>
    }

<span class="nc" id="L795">    Option&lt;Integer&gt; optLimit = Option.option(limit);</span>
<span class="nc" id="L796">    Option&lt;Integer&gt; optOffset = Option.option(offset);</span>
<span class="nc" id="L797">    Option&lt;String&gt; optSort = Option.option(trimToNull(sort));</span>
<span class="nc" id="L798">    EventSearchQuery query = new EventSearchQuery(getSecurityService().getOrganization().getId(),</span>
<span class="nc" id="L799">            getSecurityService().getUser());</span>
    // If the limit is set to 0, this is not taken into account
<span class="nc bnc" id="L801" title="All 4 branches missed.">    if (optLimit.isSome() &amp;&amp; limit == 0) {</span>
<span class="nc" id="L802">      optLimit = Option.none();</span>
    }

    //List of all events from the filters
<span class="nc" id="L806">    List&lt;IndexObject&gt; allEvents = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L808" title="All 2 branches missed.">    if (!isNullOrEmpty(filter)) {</span>
      // API version 1.5.0: Additive filter
<span class="nc bnc" id="L810" title="All 2 branches missed.">      if (!requestedVersion.isSmallerThan(ApiVersion.VERSION_1_5_0)) {</span>
<span class="nc" id="L811">        filter = filter.subList(0,1);</span>
      }
<span class="nc bnc" id="L813" title="All 2 branches missed.">      for (String filterPart : filter) {</span>
        // Parse the filters

<span class="nc bnc" id="L816" title="All 2 branches missed.">        for (String f : filterPart.split(&quot;,&quot;)) {</span>
<span class="nc" id="L817">          String[] filterTuple = f.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">          if (filterTuple.length &lt; 2) {</span>
<span class="nc" id="L819">            logger.debug(&quot;No value for filter {} in filters list: {}&quot;, filterTuple[0], filter);</span>
<span class="nc" id="L820">            continue;</span>
          }

<span class="nc" id="L823">          String name = filterTuple[0];</span>
          String value;

<span class="nc bnc" id="L826" title="All 2 branches missed.">          if (!requestedVersion.isSmallerThan(ApiVersion.VERSION_1_1_0)) {</span>
            // MH-13038 - 1.1.0 and higher support colons in values
<span class="nc" id="L828">            value = f.substring(name.length() + 1);</span>
          } else {
<span class="nc" id="L830">            value = filterTuple[1];</span>
          }

<span class="nc bnc" id="L833" title="All 2 branches missed.">          if (&quot;presenters&quot;.equals(name)) {</span>
<span class="nc" id="L834">            query.withPresenter(value);</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">          } else if (&quot;contributors&quot;.equals(name)) {</span>
<span class="nc" id="L836">            query.withContributor(value);</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">          } else if (&quot;location&quot;.equals(name)) {</span>
<span class="nc" id="L838">            query.withLocation(value);</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">          } else if (&quot;textFilter&quot;.equals(name)) {</span>
<span class="nc" id="L840">            query.withText(value);</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">          } else if (&quot;series&quot;.equals(name)) {</span>
<span class="nc" id="L842">            query.withSeriesId(value);</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">          } else if (&quot;subject&quot;.equals(name)) {</span>
<span class="nc" id="L844">            query.withSubject(value);</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">          } else if (!requestedVersion.isSmallerThan(ApiVersion.VERSION_1_1_0)) {</span>
            // additional filters only available with Version 1.1.0 or higher
<span class="nc bnc" id="L847" title="All 2 branches missed.">            if (&quot;identifier&quot;.equals(name)) {</span>
<span class="nc" id="L848">              query.withIdentifier(value);</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">            } else if (&quot;title&quot;.equals(name)) {</span>
<span class="nc" id="L850">              query.withTitle(value);</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">            } else if (&quot;description&quot;.equals(name)) {</span>
<span class="nc" id="L852">              query.withDescription(value);</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">            } else if (&quot;series_name&quot;.equals(name)) {</span>
<span class="nc" id="L854">              query.withSeriesName(value);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">            } else if (&quot;language&quot;.equals(name)) {</span>
<span class="nc" id="L856">              query.withLanguage(value);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">            } else if (&quot;created&quot;.equals(name)) {</span>
<span class="nc" id="L858">              query.withCreated(value);</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            } else if (&quot;license&quot;.equals(name)) {</span>
<span class="nc" id="L860">              query.withLicense(value);</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">            } else if (&quot;rightsholder&quot;.equals(name)) {</span>
<span class="nc" id="L862">              query.withRights(value);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">            } else if (&quot;is_part_of&quot;.equals(name)) {</span>
<span class="nc" id="L864">              query.withSeriesId(value);</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">            } else if (&quot;source&quot;.equals(name)) {</span>
<span class="nc" id="L866">              query.withSource(value);</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">            } else if (&quot;status&quot;.equals(name)) {</span>
<span class="nc" id="L868">              query.withEventStatus(value);</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">            } else if (&quot;agent_id&quot;.equals(name)) {</span>
<span class="nc" id="L870">              query.withAgentId(value);</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">            } else if (&quot;start&quot;.equals(name)) {</span>
              try {
<span class="nc" id="L873">                Tuple&lt;Date, Date&gt; fromAndToCreationRange = RestUtils.getFromAndToDateRange(value);</span>
<span class="nc" id="L874">                query.withStartFrom(fromAndToCreationRange.getA());</span>
<span class="nc" id="L875">                query.withStartTo(fromAndToCreationRange.getB());</span>
<span class="nc" id="L876">              } catch (Exception e) {</span>
<span class="nc" id="L877">                return RestUtil.R</span>
<span class="nc" id="L878">                        .badRequest(String.format(&quot;Filter 'start' could not be parsed: %s&quot;, e.getMessage()));</span>

<span class="nc" id="L880">              }</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">            } else if (&quot;technical_start&quot;.equals(name)) {</span>
              try {
<span class="nc" id="L883">                Tuple&lt;Date, Date&gt; fromAndToCreationRange = RestUtils.getFromAndToDateRange(value);</span>
<span class="nc" id="L884">                query.withTechnicalStartFrom(fromAndToCreationRange.getA());</span>
<span class="nc" id="L885">                query.withTechnicalStartTo(fromAndToCreationRange.getB());</span>
<span class="nc" id="L886">              } catch (Exception e) {</span>
<span class="nc" id="L887">                return RestUtil.R</span>
<span class="nc" id="L888">                        .badRequest(String.format(&quot;Filter 'technical_start' could not be parsed: %s&quot;, e.getMessage()));</span>

<span class="nc" id="L890">              }</span>
            } else {
<span class="nc" id="L892">              logger.warn(&quot;Unknown filter criteria {}&quot;, name);</span>
<span class="nc" id="L893">              return RestUtil.R.badRequest(String.format(&quot;Unknown filter criterion in request: %s&quot;, name));</span>

            }
          }
        }

<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (optSort.isSome()) {</span>
<span class="nc" id="L900">          ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(optSort.get());</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">          for (SortCriterion criterion : sortCriteria) {</span>

<span class="nc bnc" id="L903" title="All 11 branches missed.">            switch (criterion.getFieldName()) {</span>
              case EventIndexSchema.TITLE:
<span class="nc" id="L905">                query.sortByTitle(criterion.getOrder());</span>
<span class="nc" id="L906">                break;</span>
              case EventIndexSchema.PRESENTER:
<span class="nc" id="L908">                query.sortByPresenter(criterion.getOrder());</span>
<span class="nc" id="L909">                break;</span>
              case EventIndexSchema.TECHNICAL_START:
              case &quot;technical_date&quot;:
<span class="nc" id="L912">                query.sortByTechnicalStartDate(criterion.getOrder());</span>
<span class="nc" id="L913">                break;</span>
              case EventIndexSchema.TECHNICAL_END:
<span class="nc" id="L915">                query.sortByTechnicalEndDate(criterion.getOrder());</span>
<span class="nc" id="L916">                break;</span>
              case EventIndexSchema.START_DATE:
              case &quot;date&quot;:
<span class="nc" id="L919">                query.sortByStartDate(criterion.getOrder());</span>
<span class="nc" id="L920">                break;</span>
              case EventIndexSchema.END_DATE:
<span class="nc" id="L922">                query.sortByEndDate(criterion.getOrder());</span>
<span class="nc" id="L923">                break;</span>
              case EventIndexSchema.WORKFLOW_STATE:
<span class="nc" id="L925">                query.sortByWorkflowState(criterion.getOrder());</span>
<span class="nc" id="L926">                break;</span>
              case EventIndexSchema.SERIES_NAME:
<span class="nc" id="L928">                query.sortBySeriesName(criterion.getOrder());</span>
<span class="nc" id="L929">                break;</span>
              case EventIndexSchema.LOCATION:
<span class="nc" id="L931">                query.sortByLocation(criterion.getOrder());</span>
<span class="nc" id="L932">                break;</span>
              // For compatibility, we mimic to support the old review_status and scheduling_status sort criteria (MH-13407)
              case &quot;review_status&quot;:
              case &quot;scheduling_status&quot;:
<span class="nc" id="L936">                break;</span>
              default:
<span class="nc" id="L938">                return RestUtil.R.badRequest(String.format(&quot;Unknown sort criterion in request: %s&quot;, criterion.getFieldName()));</span>
            }
<span class="nc" id="L940">          }</span>
        }

        // TODO: Add the comment resolution filter to the query
<span class="nc bnc" id="L944" title="All 2 branches missed.">        if (StringUtils.isNotBlank(resolutionFilter)) {</span>
          try {
<span class="nc" id="L946">            CommentResolution.valueOf(resolutionFilter);</span>
<span class="nc" id="L947">          } catch (Exception e) {</span>
<span class="nc" id="L948">            logger.debug(&quot;Unable to parse comment resolution filter {}&quot;, resolutionFilter);</span>
<span class="nc" id="L949">            return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L950">          }</span>
        }

<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (optLimit.isSome())</span>
<span class="nc" id="L954">          query.withLimit(optLimit.get());</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">        if (optOffset.isSome())</span>
<span class="nc" id="L956">          query.withOffset(offset);</span>
        // TODO: Add other filters to the query

<span class="nc" id="L959">        SearchResult&lt;Event&gt; results = null;</span>
        try {
<span class="nc" id="L961">          results = elasticsearchIndex.getByQuery(query);</span>
<span class="nc" id="L962">        } catch (SearchIndexException e) {</span>
<span class="nc" id="L963">          logger.error(&quot;The External Search Index was not able to get the events list&quot;, e);</span>
<span class="nc" id="L964">          throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L965">        }</span>

<span class="nc" id="L967">        SearchResultItem&lt;Event&gt;[] items = results.getItems();</span>
<span class="nc" id="L968">        List&lt;IndexObject&gt; events = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">        for (SearchResultItem&lt;Event&gt; item : items) {</span>
<span class="nc" id="L970">          Event source = item.getSource();</span>
<span class="nc" id="L971">          source.updatePreview(previewSubtype);</span>
<span class="nc" id="L972">          events.add(source);</span>
        }
        //Append  filtered results to the list
<span class="nc" id="L975">        allEvents.addAll(events);</span>
<span class="nc" id="L976">      }</span>
    } else {
<span class="nc bnc" id="L978" title="All 2 branches missed.">      if (optSort.isSome()) {</span>
<span class="nc" id="L979">        ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(optSort.get());</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">        for (SortCriterion criterion : sortCriteria) {</span>

<span class="nc bnc" id="L982" title="All 11 branches missed.">          switch (criterion.getFieldName()) {</span>
            case EventIndexSchema.TITLE:
<span class="nc" id="L984">              query.sortByTitle(criterion.getOrder());</span>
<span class="nc" id="L985">              break;</span>
            case EventIndexSchema.PRESENTER:
<span class="nc" id="L987">              query.sortByPresenter(criterion.getOrder());</span>
<span class="nc" id="L988">              break;</span>
            case EventIndexSchema.TECHNICAL_START:
            case &quot;technical_date&quot;:
<span class="nc" id="L991">              query.sortByTechnicalStartDate(criterion.getOrder());</span>
<span class="nc" id="L992">              break;</span>
            case EventIndexSchema.TECHNICAL_END:
<span class="nc" id="L994">              query.sortByTechnicalEndDate(criterion.getOrder());</span>
<span class="nc" id="L995">              break;</span>
            case EventIndexSchema.START_DATE:
            case &quot;date&quot;:
<span class="nc" id="L998">              query.sortByStartDate(criterion.getOrder());</span>
<span class="nc" id="L999">              break;</span>
            case EventIndexSchema.END_DATE:
<span class="nc" id="L1001">              query.sortByEndDate(criterion.getOrder());</span>
<span class="nc" id="L1002">              break;</span>
            case EventIndexSchema.WORKFLOW_STATE:
<span class="nc" id="L1004">              query.sortByWorkflowState(criterion.getOrder());</span>
<span class="nc" id="L1005">              break;</span>
            case EventIndexSchema.SERIES_NAME:
<span class="nc" id="L1007">              query.sortBySeriesName(criterion.getOrder());</span>
<span class="nc" id="L1008">              break;</span>
            case EventIndexSchema.LOCATION:
<span class="nc" id="L1010">              query.sortByLocation(criterion.getOrder());</span>
<span class="nc" id="L1011">              break;</span>
            // For compatibility, we mimic to support the old review_status and scheduling_status sort criteria (MH-13407)
            case &quot;review_status&quot;:
            case &quot;scheduling_status&quot;:
<span class="nc" id="L1015">              break;</span>
            default:
<span class="nc" id="L1017">              return RestUtil.R.badRequest(String.format(&quot;Unknown sort criterion in request: %s&quot;, criterion.getFieldName()));</span>
          }
<span class="nc" id="L1019">        }</span>
      }

      // TODO: Add the comment resolution filter to the query
<span class="nc bnc" id="L1023" title="All 2 branches missed.">      if (StringUtils.isNotBlank(resolutionFilter)) {</span>
        try {
<span class="nc" id="L1025">          CommentResolution.valueOf(resolutionFilter);</span>
<span class="nc" id="L1026">        } catch (Exception e) {</span>
<span class="nc" id="L1027">          logger.debug(&quot;Unable to parse comment resolution filter {}&quot;, resolutionFilter);</span>
<span class="nc" id="L1028">          return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L1029">        }</span>
      }

<span class="nc bnc" id="L1032" title="All 2 branches missed.">      if (optLimit.isSome())</span>
<span class="nc" id="L1033">        query.withLimit(optLimit.get());</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">      if (optOffset.isSome())</span>
<span class="nc" id="L1035">        query.withOffset(offset);</span>

<span class="nc bnc" id="L1037" title="All 4 branches missed.">      if (onlyWithWriteAccess != null &amp;&amp; onlyWithWriteAccess) {</span>
<span class="nc" id="L1038">        query.withoutActions();</span>
<span class="nc" id="L1039">        query.withAction(Permissions.Action.WRITE);</span>
      }
      // TODO: Add other filters to the query

<span class="nc" id="L1043">      SearchResult&lt;Event&gt; results = null;</span>
      try {
<span class="nc" id="L1045">        results = elasticsearchIndex.getByQuery(query);</span>
<span class="nc" id="L1046">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L1047">        logger.error(&quot;The External Search Index was not able to get the events list&quot;, e);</span>
<span class="nc" id="L1048">        throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L1049">      }</span>

<span class="nc" id="L1051">      SearchResultItem&lt;Event&gt;[] items = results.getItems();</span>
<span class="nc" id="L1052">      List&lt;IndexObject&gt; events = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">      for (SearchResultItem&lt;Event&gt; item : items) {</span>
<span class="nc" id="L1054">        Event source = item.getSource();</span>
<span class="nc" id="L1055">        source.updatePreview(previewSubtype);</span>
<span class="nc" id="L1056">        events.add(source);</span>
      }
      //Append  filtered results to the list
<span class="nc" id="L1059">      allEvents.addAll(events);</span>
    }
    try {
<span class="nc" id="L1062">      return getJsonEvents(</span>
<span class="nc" id="L1063">          acceptHeader, allEvents, withAcl, withMetadata, withScheduling, withPublications, includeInternalPublication, sign, requestedVersion);</span>
<span class="nc" id="L1064">    } catch (Exception e) {</span>
<span class="nc" id="L1065">      logger.error(&quot;Unable to get events&quot;, e);</span>
<span class="nc" id="L1066">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Render a collection of {@link Event}s into a json array.
   *
   * @param acceptHeader
   *          The accept header to return to the client.
   * @param events
   *          The {@link List} of {@link Event}s to render into json.
   * @param withAcl
   *          Whether to include the events' ACLs.
   * @param withMetadata
   *          Whether to include the events' metadata.
   * @param withScheduling
   *          Whether to include the events' scheduling information.
   * @param withPublications
   *          Whether to include the events' publications.
   * @param withSignedUrls
   *          Whether to sign the included urls.
   * @return A {@link Response} with the accept header and body as the Json array of {@link Event}s.
   * @throws IndexServiceException
   * @throws SchedulerException
   * @throws UnauthorizedException
   */
  protected Response getJsonEvents(String acceptHeader, List&lt;IndexObject&gt; events, Boolean withAcl, Boolean withMetadata,
      Boolean withScheduling, Boolean withPublications, Boolean includeInternalPublication, Boolean withSignedUrls, ApiVersion requestedVersion)
      throws IndexServiceException, UnauthorizedException, SchedulerException {
<span class="nc" id="L1095">    JsonArray eventsArray = new JsonArray();</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">    for (IndexObject item : events) {</span>
<span class="nc" id="L1097">      JsonObject jsonEvent = eventToJSON((Event) item, withAcl, withMetadata, withScheduling, withPublications,</span>
          includeInternalPublication, withSignedUrls, requestedVersion);
<span class="nc" id="L1099">      eventsArray.add(jsonEvent);</span>
<span class="nc" id="L1100">    }</span>

<span class="nc" id="L1102">    return ApiResponseBuilder.Json.ok(requestedVersion, eventsArray);</span>
  }

  /**
   * Transform an {@link Event} to Json
   *
   * @param event
   *          The event to transform into json
   * @param withAcl
   *          Whether to add the acl information for the event
   * @param withMetadata
   *          Whether to add all the metadata for the event
   * @param withScheduling
   *          Whether to add the scheduling information for the event
   * @param withPublications
   *          Whether to add the publications
   * @param withSignedUrls
   *          Whether to sign the urls if they are protected by stream security.
   * @return The event in json format.
   * @throws IndexServiceException
   *           Thrown if unable to get the metadata for the event.
   * @throws SchedulerException
   * @throws UnauthorizedException
   */
  protected JsonObject eventToJSON(Event event, Boolean withAcl, Boolean withMetadata, Boolean withScheduling,
      Boolean withPublications, Boolean includeInternalPublication, Boolean withSignedUrls,
      ApiVersion requestedVersion) throws IndexServiceException, SchedulerException, UnauthorizedException {
<span class="nc" id="L1129">    JsonObject json = new JsonObject();</span>

<span class="nc bnc" id="L1131" title="All 2 branches missed.">    if (event.getArchiveVersion() != null)</span>
<span class="nc" id="L1132">      json.addProperty(&quot;archive_version&quot;, event.getArchiveVersion());</span>
<span class="nc" id="L1133">    json.addProperty(&quot;created&quot;, safeString(event.getCreated()));</span>
<span class="nc" id="L1134">    json.addProperty(&quot;creator&quot;, safeString(event.getCreator()));</span>
<span class="nc" id="L1135">    json.add(&quot;contributor&quot;, collectionToJsonArray(event.getContributors()));</span>
<span class="nc" id="L1136">    json.addProperty(&quot;description&quot;, safeString(event.getDescription()));</span>
<span class="nc" id="L1137">    json.addProperty(&quot;has_previews&quot;, event.hasPreview());</span>
<span class="nc" id="L1138">    json.addProperty(&quot;identifier&quot;, safeString(event.getIdentifier()));</span>
<span class="nc" id="L1139">    json.addProperty(&quot;location&quot;, safeString(event.getLocation()));</span>
<span class="nc" id="L1140">    json.add(&quot;presenter&quot;, collectionToJsonArray(event.getPresenters()));</span>

<span class="nc bnc" id="L1142" title="All 2 branches missed.">    if (!requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
<span class="nc" id="L1143">      json.addProperty(&quot;language&quot;, safeString(event.getLanguage()));</span>
<span class="nc" id="L1144">      json.addProperty(&quot;rightsholder&quot;, safeString(event.getRights()));</span>
<span class="nc" id="L1145">      json.addProperty(&quot;license&quot;, safeString(event.getLicense()));</span>
<span class="nc" id="L1146">      json.addProperty(&quot;is_part_of&quot;, safeString(event.getSeriesId()));</span>
<span class="nc" id="L1147">      json.addProperty(&quot;series&quot;, safeString(event.getSeriesName()));</span>
<span class="nc" id="L1148">      json.addProperty(&quot;source&quot;, safeString(event.getSource()));</span>
<span class="nc" id="L1149">      json.addProperty(&quot;status&quot;, safeString(event.getEventStatus()));</span>
    }

<span class="nc" id="L1152">    JsonArray publicationIds = new JsonArray();</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">    if (event.getPublications() != null) {</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">      for (Publication publication : event.getPublications()) {</span>
<span class="nc" id="L1155">        publicationIds.add(new JsonPrimitive(publication.getChannel()));</span>
<span class="nc" id="L1156">      }</span>
    }
<span class="nc" id="L1158">    json.add(&quot;publication_status&quot;, publicationIds);</span>
<span class="nc" id="L1159">    json.addProperty(&quot;processing_state&quot;, safeString(event.getWorkflowState()));</span>

<span class="nc bnc" id="L1161" title="All 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_4_0)) {</span>
<span class="nc" id="L1162">      json.addProperty(&quot;start&quot;, safeString(event.getTechnicalStartTime()));</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">      if (event.getTechnicalEndTime() != null) {</span>
<span class="nc" id="L1164">        long duration = new DateTime(event.getTechnicalEndTime()).getMillis()</span>
<span class="nc" id="L1165">            - new DateTime(event.getTechnicalStartTime()).getMillis();</span>
<span class="nc" id="L1166">        json.addProperty(&quot;duration&quot;, duration);</span>
<span class="nc" id="L1167">      }</span>
    } else {
<span class="nc" id="L1169">      json.addProperty(&quot;start&quot;, safeString(event.getRecordingStartDate()));</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">      if (event.getDuration() != null) {</span>
<span class="nc" id="L1171">        json.addProperty(&quot;duration&quot;, event.getDuration());</span>
      } else {
<span class="nc" id="L1173">        json.add(&quot;duration&quot;, JsonNull.INSTANCE);</span>
      }
    }

<span class="nc bnc" id="L1177" title="All 2 branches missed.">    if (StringUtils.trimToNull(event.getSubject()) != null) {</span>
<span class="nc" id="L1178">      json.add(&quot;subjects&quot;, splitSubjectIntoArray(event.getSubject()));</span>
    } else {
<span class="nc" id="L1180">      json.add(&quot;subjects&quot;, new JsonArray());</span>
    }

<span class="nc" id="L1183">    json.addProperty(&quot;title&quot;, safeString(event.getTitle()));</span>

<span class="nc bnc" id="L1185" title="All 4 branches missed.">    if (withAcl != null &amp;&amp; withAcl) {</span>
<span class="nc" id="L1186">      AccessControlList acl = getAclFromEvent(event);</span>
<span class="nc" id="L1187">      json.add(&quot;acl&quot;, AclUtils.serializeAclToJson(acl));</span>
    }

<span class="nc bnc" id="L1190" title="All 4 branches missed.">    if (withMetadata != null &amp;&amp; withMetadata) {</span>
      try {
<span class="nc" id="L1192">        Optional&lt;MetadataList&gt; metadata = getEventMetadata(event);</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">        if (metadata.isPresent()) {</span>
<span class="nc" id="L1194">          json.add(&quot;metadata&quot;, MetadataJson.listToJson(metadata.get(), true));</span>
        }
<span class="nc" id="L1196">      } catch (Exception e) {</span>
<span class="nc" id="L1197">        logger.error(&quot;Unable to get metadata for event '{}'&quot;, event.getIdentifier(), e);</span>
<span class="nc" id="L1198">        throw new IndexServiceException(&quot;Unable to add metadata to event&quot;, e);</span>
<span class="nc" id="L1199">      }</span>
    }

<span class="nc bnc" id="L1202" title="All 4 branches missed.">    if (withScheduling != null &amp;&amp; withScheduling) {</span>
<span class="nc" id="L1203">      json.add(&quot;scheduling&quot;, SchedulingInfo.of(event.getIdentifier(), schedulerService).toJson());</span>
    }

<span class="nc bnc" id="L1206" title="All 4 branches missed.">    if (withPublications != null &amp;&amp; withPublications) {</span>
<span class="nc" id="L1207">      List&lt;JsonObject&gt; publications = getPublications(event, withSignedUrls, includeInternalPublication, requestedVersion);</span>
<span class="nc" id="L1208">      JsonArray pubDetails = new JsonArray();</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">      for (JsonObject pub : publications) {</span>
<span class="nc" id="L1210">        pubDetails.add(pub);</span>
<span class="nc" id="L1211">      }</span>
<span class="nc" id="L1212">      json.add(&quot;publications&quot;, pubDetails);</span>
    }

<span class="nc" id="L1215">    return json;</span>
  }

  private JsonArray splitSubjectIntoArray(final String subject) {
<span class="nc" id="L1219">    JsonArray array = new JsonArray();</span>
<span class="nc bnc" id="L1220" title="All 4 branches missed.">    if (subject != null &amp;&amp; !subject.trim().isEmpty()) {</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">      for (String part : subject.split(&quot;,&quot;)) {</span>
<span class="nc" id="L1222">        array.add(new JsonPrimitive(part.trim()));</span>
      }
    }
<span class="nc" id="L1225">    return array;</span>
  }

  @GET
  @Path(&quot;{eventId}/acl&quot;)
  @RestQuery(name = &quot;geteventacl&quot;, description = &quot;Returns an event's access policy.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
                  @RestResponse(description = &quot;The access control list for the specified event is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventAcl(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
          throws Exception {
<span class="nc" id="L1236">    Optional&lt;Event&gt; eventOpt = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">    if (eventOpt.isPresent()) {</span>
<span class="nc" id="L1238">      AccessControlList acl = getAclFromEvent(eventOpt.get());</span>
<span class="nc" id="L1239">      return ApiResponseBuilder.Json.ok(acceptHeader, AclUtils.serializeAclToJson(acl));</span>
    }
<span class="nc" id="L1241">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @PUT
  @Path(&quot;{eventId}/acl&quot;)
  @RestQuery(name = &quot;updateeventacl&quot;, description = &quot;Update an event's access policy.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;acl&quot;, isRequired = true, description = &quot;Access policy&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The access control list for the specified event is updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventAcl(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @FormParam(&quot;acl&quot;) String acl) throws Exception {
<span class="nc bnc" id="L1253" title="All 2 branches missed.">    if (indexService.getEvent(id, elasticsearchIndex).isPresent()) {</span>
      AccessControlList accessControlList;
      try {
<span class="nc" id="L1256">        accessControlList = AclUtils.deserializeJsonToAcl(acl, false);</span>
<span class="nc" id="L1257">      } catch (ParseException e) {</span>
<span class="nc" id="L1258">        logger.debug(&quot;Unable to update event acl to '{}'&quot;, acl, e);</span>
<span class="nc" id="L1259">        return R.badRequest(String.format(&quot;Unable to parse acl '%s' because '%s'&quot;, acl, e.getMessage()));</span>
<span class="nc" id="L1260">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1261">        logger.debug(&quot;Unable to update event acl to '{}'&quot;, acl, e);</span>
<span class="nc" id="L1262">        return R.badRequest(e.getMessage());</span>
<span class="nc" id="L1263">      }</span>
      try {
<span class="nc" id="L1265">        accessControlList = indexService.updateEventAcl(id, accessControlList, elasticsearchIndex);</span>
<span class="nc" id="L1266">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1267">        logger.error(&quot;Unable to update event '{}' acl with '{}'&quot;, id, acl, e);</span>
<span class="nc" id="L1268">        return Response.status(Status.FORBIDDEN).build();</span>
<span class="nc" id="L1269">      }</span>
<span class="nc" id="L1270">      return Response.noContent().build();</span>
    } else {
<span class="nc" id="L1272">      return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
    }
  }

  @POST
  @Path(&quot;{eventId}/acl/{action}&quot;)
  @RestQuery(name = &quot;addeventace&quot;, description = &quot;Grants permission to execute action on the specified event to any user with role role. Note that this is a convenience method to avoid having to build and post a complete access control list.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;action&quot;, description = &quot;The action that is allowed to be executed&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;role&quot;, isRequired = true, description = &quot;The role that is granted permission&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The permission has been created in the access control list of the specified event.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response addEventAce(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @PathParam(&quot;action&quot;) String action, @FormParam(&quot;role&quot;) String role) throws Exception {
<span class="nc" id="L1286">    List&lt;AccessControlEntry&gt; entries = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1287">    Optional&lt;Event&gt; eventOpt = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">    if (eventOpt.isPresent()) {</span>
<span class="nc" id="L1289">      AccessControlList accessControlList = getAclFromEvent(eventOpt.get());</span>
<span class="nc" id="L1290">      AccessControlEntry newAce = new AccessControlEntry(role, action, true);</span>
<span class="nc" id="L1291">      boolean alreadyInAcl = false;</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">      for (AccessControlEntry ace : accessControlList.getEntries()) {</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">        if (ace.equals(newAce)) {</span>
          // We have found an identical access control entry so just return.
<span class="nc" id="L1295">          entries = accessControlList.getEntries();</span>
<span class="nc" id="L1296">          alreadyInAcl = true;</span>
<span class="nc" id="L1297">          break;</span>
<span class="nc bnc" id="L1298" title="All 4 branches missed.">        } else if (ace.getAction().equals(newAce.getAction()) &amp;&amp; ace.getRole().equals(newAce.getRole())</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">                &amp;&amp; !ace.isAllow()) {</span>
<span class="nc" id="L1300">          entries.add(newAce);</span>
<span class="nc" id="L1301">          alreadyInAcl = true;</span>
        } else {
<span class="nc" id="L1303">          entries.add(ace);</span>
        }
<span class="nc" id="L1305">      }</span>

<span class="nc bnc" id="L1307" title="All 2 branches missed.">      if (!alreadyInAcl) {</span>
<span class="nc" id="L1308">        entries.add(newAce);</span>
      }

<span class="nc" id="L1311">      AccessControlList withNewAce = new AccessControlList(entries);</span>
      try {
<span class="nc" id="L1313">        withNewAce = indexService.updateEventAcl(id, withNewAce, elasticsearchIndex);</span>
<span class="nc" id="L1314">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1315">        logger.error(&quot;Unable to update event '{}' acl entry with action '{}' and role '{}'&quot;, id, action, role, e);</span>
<span class="nc" id="L1316">        return Response.status(Status.FORBIDDEN).build();</span>
<span class="nc" id="L1317">      }</span>
<span class="nc" id="L1318">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1320">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @DELETE
  @Path(&quot;{eventId}/acl/{action}/{role}&quot;)
  @RestQuery(name = &quot;deleteeventace&quot;, description = &quot;Revokes permission to execute action on the specified event from any user with role role.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;action&quot;, description = &quot;The action that is no longer allowed to be executed&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;role&quot;, description = &quot;The role that is no longer granted permission&quot;, isRequired = true, type = STRING) }, responses = {
                  @RestResponse(description = &quot;The permission has been revoked from the access control list of the specified event.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteEventAce(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @PathParam(&quot;action&quot;) String action, @PathParam(&quot;role&quot;) String role) throws Exception {
<span class="nc" id="L1333">    List&lt;AccessControlEntry&gt; entries = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1334">    Optional&lt;Event&gt; eventOpt = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">    if (eventOpt.isPresent()) {</span>
<span class="nc" id="L1336">      AccessControlList accessControlList = getAclFromEvent(eventOpt.get());</span>
<span class="nc" id="L1337">      boolean foundDelete = false;</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">      for (AccessControlEntry ace : accessControlList.getEntries()) {</span>
<span class="nc bnc" id="L1339" title="All 4 branches missed.">        if (ace.getAction().equals(action) &amp;&amp; ace.getRole().equals(role)) {</span>
<span class="nc" id="L1340">          foundDelete = true;</span>
        } else {
<span class="nc" id="L1342">          entries.add(ace);</span>
        }
<span class="nc" id="L1344">      }</span>

<span class="nc bnc" id="L1346" title="All 2 branches missed.">      if (!foundDelete) {</span>
<span class="nc" id="L1347">        return ApiResponseBuilder.notFound(&quot;Unable to find an access control entry with action '%s' and role '%s'&quot;, action,</span>
                role);
      }

<span class="nc" id="L1351">      AccessControlList withoutDeleted = new AccessControlList(entries);</span>
      try {
<span class="nc" id="L1353">        withoutDeleted = indexService.updateEventAcl(id, withoutDeleted, elasticsearchIndex);</span>
<span class="nc" id="L1354">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1355">        logger.error(&quot;Unable to delete event's '{}' acl entry with action '{}' and role '{}'&quot;, id, action, role, e);</span>
<span class="nc" id="L1356">        return Response.status(Status.FORBIDDEN).build();</span>
<span class="nc" id="L1357">      }</span>
<span class="nc" id="L1358">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1360">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @GET
  @Path(&quot;{eventId}/metadata&quot;)
  @RestQuery(name = &quot;geteventmetadata&quot;, description = &quot;Returns the event's metadata of the specified type. For a metadata catalog there is the flavor such as 'dublincore/episode' and this is the unique type.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = false, description = &quot;The type of metadata to get&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The metadata collection is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getAllEventMetadata(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type) throws Exception {
<span class="fc" id="L1372">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">    if (StringUtils.trimToNull(type) == null) {</span>
<span class="fc" id="L1374">      Optional&lt;MetadataList&gt; metadataList = getEventMetadataById(id);</span>
<span class="pc bpc" id="L1375" title="1 of 2 branches missed.">      if (metadataList.isPresent()) {</span>
<span class="fc" id="L1376">        MetadataList actualList = metadataList.get();</span>

        // API v1 should return a two separate fields for start date and start time. Since those fields were merged in index service, we have to split them up.
<span class="fc" id="L1379">        final DublinCoreMetadataCollection collection = actualList.getMetadataByFlavor(&quot;dublincore/episode&quot;);</span>
<span class="pc bpc" id="L1380" title="1 of 2 branches missed.">        final boolean withOrderedText = collection == null;</span>
<span class="pc bpc" id="L1381" title="1 of 2 branches missed.">        if (collection != null) {</span>
<span class="fc" id="L1382">          convertStartDateTimeToApiV1(collection);</span>
        }

<span class="fc" id="L1385">        return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.listToJson(actualList, withOrderedText));</span>
      }
      else
<span class="nc" id="L1388">        return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
    } else {
<span class="nc" id="L1390">      return getEventMetadataByType(id, type, requestedVersion);</span>
    }
  }

  private void convertStartDateTimeToApiV1(DublinCoreMetadataCollection collection) throws java.text.ParseException {

<span class="pc bpc" id="L1396" title="1 of 2 branches missed.">    if (!collection.getOutputFields().containsKey(&quot;startDate&quot;)) return;</span>

<span class="fc" id="L1398">    MetadataField oldStartDateField = collection.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="fc" id="L1399">    SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(oldStartDateField.getPattern());</span>
<span class="fc" id="L1400">    Date startDate = sdf.parse((String) oldStartDateField.getValue());</span>

<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">    if (configuredMetadataFields.containsKey(&quot;startDate&quot;)) {</span>
<span class="fc" id="L1403">      MetadataField startDateField = configuredMetadataFields.get(&quot;startDate&quot;);</span>
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">      final String pattern = startDateField.getPattern() == null ? &quot;yyyy-MM-dd&quot; : startDateField.getPattern();</span>
<span class="fc" id="L1405">      startDateField = new MetadataField(startDateField);</span>
<span class="fc" id="L1406">      startDateField.setPattern(pattern);</span>
<span class="fc" id="L1407">      sdf.applyPattern(startDateField.getPattern());</span>
<span class="fc" id="L1408">      startDateField.setValue(sdf.format(startDate));</span>
<span class="fc" id="L1409">      collection.removeField(oldStartDateField);</span>
<span class="fc" id="L1410">      collection.addField(startDateField);</span>
    }

<span class="pc bpc" id="L1413" title="1 of 2 branches missed.">    if (configuredMetadataFields.containsKey(&quot;startTime&quot;)) {</span>
<span class="fc" id="L1414">      MetadataField startTimeField = configuredMetadataFields.get(&quot;startTime&quot;);</span>
<span class="pc bpc" id="L1415" title="1 of 2 branches missed.">      final String pattern = startTimeField.getPattern() == null ? &quot;HH:mm&quot; : startTimeField.getPattern();</span>
<span class="fc" id="L1416">      startTimeField = new MetadataField(startTimeField);</span>
<span class="fc" id="L1417">      startTimeField.setPattern(pattern);</span>
<span class="fc" id="L1418">      sdf.applyPattern(startTimeField.getPattern());</span>
<span class="fc" id="L1419">      startTimeField.setValue(sdf.format(startDate));</span>
<span class="fc" id="L1420">      collection.addField(startTimeField);</span>
    }
<span class="fc" id="L1422">  }</span>

  protected Optional&lt;MetadataList&gt; getEventMetadataById(String id) throws IndexServiceException, Exception {
<span class="fc" id="L1425">    Optional&lt;Event&gt; eventOpt = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="pc bpc" id="L1426" title="1 of 2 branches missed.">    if (eventOpt.isPresent()) {</span>
<span class="fc" id="L1427">      return getEventMetadata(eventOpt.get());</span>
    }
<span class="nc" id="L1429">    return Optional.&lt;MetadataList&gt; empty();</span>
  }

  protected Optional&lt;MetadataList&gt; getEventMetadata(Event event) throws IndexServiceException, Exception {
<span class="fc" id="L1433">    MetadataList metadataList = new MetadataList();</span>
<span class="fc" id="L1434">    List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = getEventCatalogUIAdapters();</span>
<span class="fc" id="L1435">    EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="fc" id="L1436">    catalogUIAdapters.remove(eventCatalogUIAdapter);</span>
<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">    if (catalogUIAdapters.size() &gt; 0) {</span>
<span class="fc" id="L1438">      MediaPackage mediaPackage = indexService.getEventMediapackage(event);</span>
<span class="fc bfc" id="L1439" title="All 2 branches covered.">      for (EventCatalogUIAdapter catalogUIAdapter : catalogUIAdapters) {</span>
        // TODO: This is very slow:
<span class="fc" id="L1441">        DublinCoreMetadataCollection fields = catalogUIAdapter.getFields(mediaPackage);</span>
<span class="pc bpc" id="L1442" title="1 of 2 branches missed.">        if (fields != null) {</span>
<span class="nc" id="L1443">          ExternalMetadataUtils.removeCollectionList(fields);</span>
<span class="nc" id="L1444">          metadataList.add(catalogUIAdapter, fields);</span>
        }
<span class="fc" id="L1446">      }</span>
    }
<span class="fc" id="L1448">    DublinCoreMetadataCollection collection = EventUtils.getEventMetadata(event, eventCatalogUIAdapter,</span>
        new EmptyResourceListQuery());
<span class="fc" id="L1450">    ExternalMetadataUtils.changeSubjectToSubjects(collection);</span>
<span class="fc" id="L1451">    ExternalMetadataUtils.removeCollectionList(collection);</span>
<span class="fc" id="L1452">    metadataList.add(eventCatalogUIAdapter, collection);</span>
<span class="pc bpc" id="L1453" title="1 of 2 branches missed.">    if (WorkflowInstance.WorkflowState.RUNNING.toString().equals(event.getWorkflowState())) {</span>
<span class="nc" id="L1454">      metadataList.setLocked(Locked.WORKFLOW_RUNNING);</span>
    }
<span class="fc" id="L1456">    return Optional.of(metadataList);</span>
  }

  private Optional&lt;MediaPackageElementFlavor&gt; getFlavor(String flavorString) {
    try {
<span class="fc" id="L1461">      MediaPackageElementFlavor flavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>
<span class="fc" id="L1462">      return Optional.of(flavor);</span>
<span class="nc" id="L1463">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1464">      return Optional.empty();</span>
    }
  }

  private Response getEventMetadataByType(String id, String type, ApiVersion requestedVersion) throws Exception {
<span class="nc" id="L1469">    Optional&lt;Event&gt; eventOpt = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">    if (eventOpt.isPresent()) {</span>
<span class="nc" id="L1471">      Event event = eventOpt.get();</span>
<span class="nc" id="L1472">      Optional&lt;MediaPackageElementFlavor&gt; flavor = getFlavor(type);</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">      if (flavor.isEmpty()) {</span>
<span class="nc" id="L1474">        return R.badRequest(</span>
<span class="nc" id="L1475">                String.format(&quot;Unable to parse type '%s' as a flavor so unable to find the matching catalog.&quot;, type));</span>
      }
      // Try the main catalog first as we load it from the index.
<span class="nc" id="L1478">      EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">      if (flavor.get().equals(eventCatalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1480">        DublinCoreMetadataCollection collection = EventUtils.getEventMetadata(event, eventCatalogUIAdapter,</span>
            new EmptyResourceListQuery());
<span class="nc" id="L1482">        ExternalMetadataUtils.changeSubjectToSubjects(collection);</span>
<span class="nc" id="L1483">        ExternalMetadataUtils.removeCollectionList(collection);</span>
<span class="nc" id="L1484">        convertStartDateTimeToApiV1(collection);</span>
<span class="nc" id="L1485">        return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.collectionToJson(collection, false));</span>
      }
      // Try the other catalogs
<span class="nc" id="L1488">      List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = getEventCatalogUIAdapters();</span>
<span class="nc" id="L1489">      catalogUIAdapters.remove(eventCatalogUIAdapter);</span>
<span class="nc bnc" id="L1490" title="All 2 branches missed.">      if (catalogUIAdapters.size() &gt; 0) {</span>
<span class="nc" id="L1491">        MediaPackage mediaPackage = indexService.getEventMediapackage(event);</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">        for (EventCatalogUIAdapter catalogUIAdapter : catalogUIAdapters) {</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">          if (flavor.get().equals(catalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1494">            DublinCoreMetadataCollection fields = catalogUIAdapter.getFields(mediaPackage);</span>
<span class="nc" id="L1495">            ExternalMetadataUtils.removeCollectionList(fields);</span>
<span class="nc" id="L1496">            convertStartDateTimeToApiV1(fields);</span>
<span class="nc" id="L1497">            return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.collectionToJson(fields, false));</span>
          }
<span class="nc" id="L1499">        }</span>
      }
<span class="nc" id="L1501">      return ApiResponseBuilder.notFound(&quot;Cannot find a catalog with type '%s' for event with id '%s'.&quot;, type, id);</span>
    }
<span class="nc" id="L1503">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @PUT
  @Path(&quot;{eventId}/metadata&quot;)
  @RestQuery(name = &quot;updateeventmetadata&quot;, description = &quot;Update the metadata with the matching type of the specified event. For a metadata catalog there is the flavor such as 'dublincore/episode' and this is the unique type.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = true, description = &quot;The type of metadata to update&quot;, type = STRING),
                  @RestParameter(name = &quot;metadata&quot;, description = &quot;Metadata catalog in JSON format&quot;, isRequired = true, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The metadata of the given namespace has been updated.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The request is invalid or inconsistent.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventMetadataByType(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type, @FormParam(&quot;metadata&quot;) String metadataJSON) throws Exception {
    Map&lt;String, String&gt; updatedFields;
<span class="fc" id="L1518">    JSONParser parser = new JSONParser();</span>
    try {
<span class="fc" id="L1520">      updatedFields = RequestUtils.getKeyValueMap(metadataJSON);</span>
<span class="nc" id="L1521">    } catch (ParseException e) {</span>
<span class="nc" id="L1522">      logger.debug(&quot;Unable to update event '{}' with metadata type '{}' and content '{}'&quot;, id, type, metadataJSON, e);</span>
<span class="nc" id="L1523">      return RestUtil.R.badRequest(String.format(&quot;Unable to parse metadata fields as json from '%s'&quot;, metadataJSON));</span>
<span class="nc" id="L1524">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1525">      logger.debug(&quot;Unable to update event '{}' with metadata type '{}' and content '{}'&quot;, id, type, metadataJSON, e);</span>
<span class="nc" id="L1526">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="fc" id="L1527">    }</span>

<span class="pc bpc" id="L1529" title="2 of 4 branches missed.">    if (updatedFields == null || updatedFields.size() == 0) {</span>
<span class="nc" id="L1530">      return RestUtil.R.badRequest(</span>
<span class="nc" id="L1531">              String.format(&quot;Unable to parse metadata fields as json from '%s' because there were no fields to update.&quot;,</span>
                      metadataJSON));
    }

<span class="fc" id="L1535">    Optional&lt;MediaPackageElementFlavor&gt; flavor = getFlavor(type);</span>
<span class="pc bpc" id="L1536" title="1 of 2 branches missed.">    if (flavor.isEmpty()) {</span>
<span class="nc" id="L1537">      return R.badRequest(</span>
<span class="nc" id="L1538">              String.format(&quot;Unable to parse type '%s' as a flavor so unable to find the matching catalog.&quot;, type));</span>
    }

<span class="fc" id="L1541">    DublinCoreMetadataCollection collection = null;</span>
<span class="fc" id="L1542">    EventCatalogUIAdapter adapter = null;</span>
<span class="fc" id="L1543">    Optional&lt;Event&gt; eventOpt = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">    if (eventOpt.isPresent()) {</span>
<span class="fc" id="L1545">      Event event = eventOpt.get();</span>
<span class="fc" id="L1546">      MetadataList metadataList = new MetadataList();</span>
      // Try the main catalog first as we load it from the index.
<span class="fc" id="L1548">      EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="pc bpc" id="L1549" title="1 of 2 branches missed.">      if (flavor.get().equals(eventCatalogUIAdapter.getFlavor())) {</span>
<span class="fc" id="L1550">        collection = EventUtils.getEventMetadata(event, eventCatalogUIAdapter);</span>
<span class="fc" id="L1551">        adapter = eventCatalogUIAdapter;</span>
      } else {
<span class="nc" id="L1553">        metadataList.add(eventCatalogUIAdapter, EventUtils.getEventMetadata(event, eventCatalogUIAdapter));</span>
      }

      // Try the other catalogs
<span class="fc" id="L1557">      List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = getEventCatalogUIAdapters();</span>
<span class="fc" id="L1558">      catalogUIAdapters.remove(eventCatalogUIAdapter);</span>
<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">      if (catalogUIAdapters.size() &gt; 0) {</span>
<span class="fc" id="L1560">        MediaPackage mediaPackage = indexService.getEventMediapackage(event);</span>
<span class="fc bfc" id="L1561" title="All 2 branches covered.">        for (EventCatalogUIAdapter catalogUIAdapter : catalogUIAdapters) {</span>
<span class="pc bpc" id="L1562" title="1 of 2 branches missed.">          if (flavor.get().equals(catalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1563">            collection = catalogUIAdapter.getFields(mediaPackage);</span>
<span class="nc" id="L1564">            adapter = eventCatalogUIAdapter;</span>
          } else {
<span class="fc" id="L1566">            metadataList.add(catalogUIAdapter, catalogUIAdapter.getFields(mediaPackage));</span>
          }
<span class="fc" id="L1568">        }</span>
      }

<span class="pc bpc" id="L1571" title="1 of 2 branches missed.">      if (collection == null) {</span>
<span class="nc" id="L1572">        return ApiResponseBuilder.notFound(&quot;Cannot find a catalog with type '%s' for event with id '%s'.&quot;, type, id);</span>
      }

<span class="fc bfc" id="L1575" title="All 2 branches covered.">      for (String key : updatedFields.keySet()) {</span>
<span class="pc bpc" id="L1576" title="1 of 2 branches missed.">        if (&quot;subjects&quot;.equals(key)) {</span>
<span class="nc" id="L1577">          MetadataField field = collection.getOutputFields().get(DublinCore.PROPERTY_SUBJECT.getLocalName());</span>
<span class="nc" id="L1578">          Optional&lt;Response&gt; error = validateField(field, key, id, type, updatedFields);</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">          if (error.isPresent()) {</span>
<span class="nc" id="L1580">            return error.get();</span>
          }
<span class="nc" id="L1582">          collection.removeField(field);</span>
<span class="nc" id="L1583">          JSONArray subjectArray = (JSONArray) parser.parse(updatedFields.get(key));</span>
<span class="nc" id="L1584">          collection.addField(</span>
<span class="nc" id="L1585">                  MetadataJson.copyWithDifferentJsonValue(field, StringUtils.join(subjectArray.iterator(), &quot;,&quot;)));</span>
<span class="pc bfc" id="L1586" title="All 2 branches covered.">        } else if (&quot;startDate&quot;.equals(key)) {</span>
          // Special handling for start date since in API v1 we expect start date and start time to be separate fields.
<span class="fc" id="L1588">          MetadataField field = collection.getOutputFields().get(key);</span>
<span class="fc" id="L1589">          Optional&lt;Response&gt; error = validateField(field, key, id, type, updatedFields);</span>
<span class="pc bpc" id="L1590" title="1 of 2 branches missed.">          if (error.isPresent()) {</span>
<span class="nc" id="L1591">            return error.get();</span>
          }
<span class="fc" id="L1593">          String apiPattern = field.getPattern();</span>
<span class="pc bpc" id="L1594" title="1 of 2 branches missed.">          if (configuredMetadataFields.containsKey(&quot;startDate&quot;)) {</span>
<span class="fc" id="L1595">            final String startDate = configuredMetadataFields.get(&quot;startDate&quot;).getPattern();</span>
<span class="pc bpc" id="L1596" title="1 of 2 branches missed.">            apiPattern = startDate == null ? apiPattern : startDate;</span>
          }
<span class="fc" id="L1598">          SimpleDateFormat apiSdf = MetadataField.getSimpleDateFormatter(apiPattern);</span>
<span class="fc" id="L1599">          SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L1600">          DateTime oldStartDate = new DateTime(sdf.parse((String) field.getValue()), DateTimeZone.UTC);</span>
<span class="fc" id="L1601">          DateTime newStartDate = new DateTime(apiSdf.parse(updatedFields.get(key)), DateTimeZone.UTC);</span>
<span class="fc" id="L1602">          DateTime updatedStartDate = oldStartDate.withDate(newStartDate.year().get(), newStartDate.monthOfYear().get(), newStartDate.dayOfMonth().get());</span>
<span class="fc" id="L1603">          collection.removeField(field);</span>
<span class="fc" id="L1604">          collection.addField(</span>
<span class="fc" id="L1605">                  MetadataJson.copyWithDifferentJsonValue(field, sdf.format(updatedStartDate.toDate())));</span>
<span class="fc bfc" id="L1606" title="All 2 branches covered.">        } else if (&quot;startTime&quot;.equals(key)) {</span>
          // Special handling for start time since in API v1 we expect start date and start time to be separate fields.
<span class="fc" id="L1608">          MetadataField field = collection.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="fc" id="L1609">          Optional&lt;Response&gt; error = validateField(field, &quot;startDate&quot;, id, type, updatedFields);</span>
<span class="pc bpc" id="L1610" title="1 of 2 branches missed.">          if (error.isPresent()) {</span>
<span class="nc" id="L1611">            return error.get();</span>
          }
<span class="fc" id="L1613">          String apiPattern = &quot;HH:mm&quot;;</span>
<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">          if (configuredMetadataFields.containsKey(&quot;startTime&quot;)) {</span>
<span class="fc" id="L1615">            final String startTime = configuredMetadataFields.get(&quot;startTime&quot;).getPattern();</span>
<span class="pc bpc" id="L1616" title="1 of 2 branches missed.">            apiPattern = startTime == null ? apiPattern : startTime;</span>
          }
<span class="fc" id="L1618">          SimpleDateFormat apiSdf = MetadataField.getSimpleDateFormatter(apiPattern);</span>
<span class="fc" id="L1619">          SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L1620">          DateTime oldStartDate = new DateTime(sdf.parse((String) field.getValue()), DateTimeZone.UTC);</span>
<span class="fc" id="L1621">          DateTime newStartDate = new DateTime(apiSdf.parse(updatedFields.get(key)), DateTimeZone.UTC);</span>
<span class="fc" id="L1622">          DateTime updatedStartDate = oldStartDate.withTime(</span>
<span class="fc" id="L1623">                  newStartDate.hourOfDay().get(),</span>
<span class="fc" id="L1624">                  newStartDate.minuteOfHour().get(),</span>
<span class="fc" id="L1625">                  newStartDate.secondOfMinute().get(),</span>
<span class="fc" id="L1626">                  newStartDate.millisOfSecond().get());</span>
<span class="fc" id="L1627">          collection.removeField(field);</span>
<span class="fc" id="L1628">          collection.addField(</span>
<span class="fc" id="L1629">                  MetadataJson.copyWithDifferentJsonValue(field, sdf.format(updatedStartDate.toDate())));</span>
<span class="fc" id="L1630">        } else {</span>
<span class="fc" id="L1631">          MetadataField field = collection.getOutputFields().get(key);</span>
<span class="fc" id="L1632">          Optional&lt;Response&gt; error = validateField(field, key, id, type, updatedFields);</span>
<span class="pc bpc" id="L1633" title="1 of 2 branches missed.">          if (error.isPresent()) {</span>
<span class="nc" id="L1634">            return error.get();</span>
          }
<span class="fc" id="L1636">          collection.removeField(field);</span>
<span class="fc" id="L1637">          collection.addField(</span>
<span class="fc" id="L1638">                  MetadataJson.copyWithDifferentJsonValue(field, updatedFields.get(key)));</span>
        }
<span class="fc" id="L1640">      }</span>

<span class="fc" id="L1642">      metadataList.add(adapter, collection);</span>
<span class="fc" id="L1643">      indexService.updateEventMetadata(id, metadataList, elasticsearchIndex);</span>
<span class="fc" id="L1644">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1646">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  private Optional&lt;Response&gt; validateField(MetadataField field, String key, String id, String type, Map&lt;String, String&gt; updatedFields) {
<span class="pc bpc" id="L1650" title="1 of 2 branches missed.">    if (field == null) {</span>
<span class="nc" id="L1651">      return Optional.of(ApiResponseBuilder.notFound(</span>
              &quot;Cannot find a metadata field with id '%s' from event with id '%s' and the metadata type '%s'.&quot;,
              key, id, type));
<span class="pc bpc" id="L1654" title="1 of 4 branches missed.">    } else if (field.isRequired() &amp;&amp; StringUtils.isBlank(updatedFields.get(key))) {</span>
<span class="nc" id="L1655">      return Optional.of(R.badRequest(String.format(</span>
              &quot;The event metadata field with id '%s' and the metadata type '%s' is required and can not be empty!.&quot;,
              key, type)));
    }
<span class="fc" id="L1659">    return Optional.empty();</span>
  }

  @DELETE
  @Path(&quot;{eventId}/metadata&quot;)
  @RestQuery(name = &quot;deleteeventmetadata&quot;, description = &quot;Delete the metadata namespace catalog of the specified event. This will remove all fields and values of the catalog.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = true, description = &quot;The type of metadata to delete&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The metadata of the given namespace has been updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The main metadata catalog dublincore/episode cannot be deleted as it has mandatory fields.&quot;, responseCode = HttpServletResponse.SC_FORBIDDEN),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteEventMetadataByType(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type) throws SearchIndexException {
<span class="nc" id="L1672">    Optional&lt;Event&gt; eventOpt = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">    if (eventOpt.isPresent()) {</span>
<span class="nc" id="L1674">      Optional&lt;MediaPackageElementFlavor&gt; flavor = getFlavor(type);</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">      if (flavor.isEmpty()) {</span>
<span class="nc" id="L1676">        return R.badRequest(</span>
<span class="nc" id="L1677">                String.format(&quot;Unable to parse type '%s' as a flavor so unable to find the matching catalog.&quot;, type));</span>
      }
<span class="nc" id="L1679">      EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">      if (flavor.get().equals(eventCatalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1681">        return Response</span>
<span class="nc" id="L1682">                .status(Status.FORBIDDEN).entity(String</span>
<span class="nc" id="L1683">                        .format(&quot;Unable to delete mandatory metadata catalog with type '%s' for event '%s'&quot;, type, id))</span>
<span class="nc" id="L1684">                .build();</span>
      }
      try {
<span class="nc" id="L1687">        indexService.removeCatalogByFlavor(eventOpt.get(), flavor.get());</span>
<span class="nc" id="L1688">      } catch (NotFoundException e) {</span>
<span class="nc" id="L1689">        return ApiResponseBuilder.notFound(e.getMessage());</span>
<span class="nc" id="L1690">      } catch (IndexServiceException e) {</span>
<span class="nc" id="L1691">        logger.error(&quot;Unable to remove metadata catalog with type '{}' from event '{}'&quot;, type, id, e);</span>
<span class="nc" id="L1692">        throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L1693">      } catch (IllegalStateException e) {</span>
<span class="nc" id="L1694">        logger.debug(&quot;Unable to remove metadata catalog with type '{}' from event '{}'&quot;, type, id, e);</span>
<span class="nc" id="L1695">        throw new WebApplicationException(e, Status.BAD_REQUEST);</span>
<span class="nc" id="L1696">      } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1697">        return Response.status(Status.UNAUTHORIZED).build();</span>
<span class="nc" id="L1698">      }</span>
<span class="nc" id="L1699">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1701">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @GET
  @Path(&quot;{eventId}/publications&quot;)
  @RestQuery(name = &quot;geteventpublications&quot;, description = &quot;Returns an event's list of publications.&quot;,
             returnDescription = &quot;&quot;,
             pathParameters = {
               @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING)
             },
             restParameters = {
               @RestParameter(name = &quot;sign&quot;, description = &quot;Whether public distribution urls should be signed.&quot;,
                              isRequired = false, type = Type.BOOLEAN),
               @RestParameter(name = &quot;includeInternalPublication&quot;, description = &quot;Whether internal publications should be included.&quot;,
                              isRequired = false, type = Type.BOOLEAN)
             },
             responses = {
                  @RestResponse(description = &quot;The list of publications is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })

    public Response getEventPublications(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;sign&quot;) boolean sign, @QueryParam(&quot;includeInternalPublication&quot;) boolean includeInternalPublication) throws Exception {
    try {
<span class="nc" id="L1724">      final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc" id="L1725">      final Optional&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">      if (event.isPresent()) {</span>
<span class="nc" id="L1727">        JsonArray jsonArray = new JsonArray();</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">        for (JsonElement pub : getPublications(event.get(), sign, includeInternalPublication, requestedVersion)) {</span>
<span class="nc" id="L1729">          jsonArray.add(pub);</span>
<span class="nc" id="L1730">        }</span>
<span class="nc" id="L1731">        return ApiResponseBuilder.Json.ok(acceptHeader, jsonArray);</span>
      } else {
<span class="nc" id="L1733">        return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
      }
<span class="nc" id="L1735">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1736">      logger.error(&quot;Unable to get list of publications from event with id '{}'&quot;, id, e);</span>
<span class="nc" id="L1737">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  private List&lt;JsonObject&gt; getPublications(Event event, Boolean withSignedUrls, Boolean includeInternalPublication, ApiVersion requestedVersion) {
<span class="nc" id="L1742">    return event.getPublications().stream()</span>
<span class="nc" id="L1743">        .filter(publication -&gt; {</span>
<span class="nc bnc" id="L1744" title="All 6 branches missed.">          boolean isInternalAllowed = includeInternalPublication != null &amp;&amp; includeInternalPublication &amp;&amp; !requestedVersion.isSmallerThan(VERSION_1_11_0);</span>
<span class="nc bnc" id="L1745" title="All 4 branches missed.">          return isInternalAllowed || EventUtils.internalChannelFilter.test(publication);</span>
        })
<span class="nc" id="L1747">        .map(p -&gt; getPublication(p, withSignedUrls, requestedVersion))</span>
<span class="nc" id="L1748">        .collect(Collectors.toList());</span>
  }

  public JsonObject getPublication(Publication publication, Boolean sign, ApiVersion requestedVersion) {
    // Signing URLs introduced in version 1.7.0
<span class="nc" id="L1753">    URI publicationUrl = publication.getURI();</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">    if (!requestedVersion.isSmallerThan(VERSION_1_7_0)) {</span>
<span class="nc" id="L1755">      publicationUrl = getSignedUrl(publicationUrl, sign);</span>
    }

<span class="nc" id="L1758">    JsonObject json = new JsonObject();</span>
<span class="nc" id="L1759">    json.addProperty(&quot;id&quot;, publication.getIdentifier());</span>
<span class="nc" id="L1760">    json.addProperty(&quot;channel&quot;, publication.getChannel());</span>
<span class="nc" id="L1761">    json.addProperty(&quot;mediatype&quot;, safeString(publication.getMimeType()));</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">    json.addProperty(&quot;url&quot;, publicationUrl != null ? publicationUrl.toString() : &quot;&quot;);</span>
<span class="nc" id="L1763">    JsonArray mediaArray = new JsonArray();</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">    for (JsonObject trackJson : getPublicationTracksJson(publication, sign, requestedVersion)) {</span>
<span class="nc" id="L1765">      mediaArray.add(trackJson);</span>
<span class="nc" id="L1766">    }</span>
<span class="nc" id="L1767">    json.add(&quot;media&quot;, mediaArray);</span>
<span class="nc" id="L1768">    JsonArray attachmentArray = new JsonArray();</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">    for (JsonObject attachmentJson : getPublicationAttachmentsJson(publication, sign)) {</span>
<span class="nc" id="L1770">      attachmentArray.add(attachmentJson);</span>
<span class="nc" id="L1771">    }</span>
<span class="nc" id="L1772">    json.add(&quot;attachments&quot;, attachmentArray);</span>
<span class="nc" id="L1773">    JsonArray metadataArray = new JsonArray();</span>
<span class="nc bnc" id="L1774" title="All 2 branches missed.">    for (JsonObject catalogJson : getPublicationCatalogsJson(publication, sign)) {</span>
<span class="nc" id="L1775">      metadataArray.add(catalogJson);</span>
<span class="nc" id="L1776">    }</span>
<span class="nc" id="L1777">    json.add(&quot;metadata&quot;, metadataArray);</span>

<span class="nc" id="L1779">    return json;</span>
  }

  private URI getSignedUrl(URI url, boolean sign) {
<span class="nc bnc" id="L1783" title="All 4 branches missed.">    if (url == null || !sign) {</span>
<span class="nc" id="L1784">      return url;</span>
    }

<span class="nc bnc" id="L1787" title="All 2 branches missed.">    if (urlSigningService.accepts(url.toString())) {</span>
      try {
<span class="nc" id="L1789">        return URI.create(urlSigningService.sign(url.toString(), expireSeconds, null, null));</span>
<span class="nc" id="L1790">      } catch (UrlSigningException e) {</span>
<span class="nc" id="L1791">        logger.error(&quot;Unable to sign URI {}&quot;, url, e);</span>
      }
    }
<span class="nc" id="L1794">    return url;</span>
  }

  private List&lt;JsonObject&gt; getPublicationTracksJson(Publication publication, Boolean sign, ApiVersion requestedVersion) {
<span class="nc" id="L1798">    List&lt;JsonObject&gt; tracksJson = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1800" title="All 2 branches missed.">    for (Track track : publication.getTracks()) {</span>
<span class="nc" id="L1801">      JsonObject trackJson = new JsonObject();</span>

<span class="nc" id="L1803">      trackJson.addProperty(&quot;id&quot;, safeString(track.getIdentifier()));</span>
<span class="nc" id="L1804">      trackJson.addProperty(&quot;mediatype&quot;, safeString(track.getMimeType()));</span>
<span class="nc" id="L1805">      trackJson.addProperty(&quot;url&quot;, safeString(getSignedUrl(track.getURI(), sign)));</span>
<span class="nc" id="L1806">      trackJson.addProperty(&quot;flavor&quot;, safeString(track.getFlavor()));</span>
<span class="nc" id="L1807">      trackJson.addProperty(&quot;size&quot;, track.getSize());</span>
<span class="nc" id="L1808">      trackJson.addProperty(&quot;checksum&quot;, safeString(track.getChecksum()));</span>
<span class="nc" id="L1809">      trackJson.add(&quot;tags&quot;, arrayToJsonArray(track.getTags()));</span>
<span class="nc" id="L1810">      trackJson.addProperty(&quot;has_audio&quot;, track.hasAudio());</span>
<span class="nc" id="L1811">      trackJson.addProperty(&quot;has_video&quot;, track.hasVideo());</span>
<span class="nc bnc" id="L1812" title="All 2 branches missed.">      trackJson.addProperty(&quot;duration&quot;, track.getDuration() != null ? track.getDuration() : null);</span>
<span class="nc" id="L1813">      trackJson.addProperty(&quot;description&quot;, safeString(track.getDescription()));</span>

<span class="nc" id="L1815">      VideoStream[] videoStreams = TrackSupport.byType(track.getStreams(), VideoStream.class);</span>
<span class="nc bnc" id="L1816" title="All 2 branches missed.">      if (videoStreams.length &gt; 0) {</span>
        // Only supporting one stream, like in many other places...
<span class="nc" id="L1818">        VideoStream videoStream = videoStreams[0];</span>
<span class="nc bnc" id="L1819" title="All 2 branches missed.">        if (videoStream.getBitRate() != null)</span>
<span class="nc" id="L1820">          trackJson.addProperty(&quot;bitrate&quot;, videoStream.getBitRate());</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">        if (videoStream.getFrameRate() != null)</span>
<span class="nc" id="L1822">          trackJson.addProperty(&quot;framerate&quot;, videoStream.getFrameRate());</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">        if (videoStream.getFrameCount() != null)</span>
<span class="nc" id="L1824">          trackJson.addProperty(&quot;framecount&quot;, videoStream.getFrameCount());</span>
<span class="nc bnc" id="L1825" title="All 2 branches missed.">        if (videoStream.getFrameWidth() != null)</span>
<span class="nc" id="L1826">          trackJson.addProperty(&quot;width&quot;, videoStream.getFrameWidth());</span>
<span class="nc bnc" id="L1827" title="All 2 branches missed.">        if (videoStream.getFrameHeight() != null)</span>
<span class="nc" id="L1828">          trackJson.addProperty(&quot;height&quot;, videoStream.getFrameHeight());</span>
      }

<span class="nc bnc" id="L1831" title="All 2 branches missed.">      if (!requestedVersion.isSmallerThan(VERSION_1_7_0)) {</span>
<span class="nc" id="L1832">        trackJson.addProperty(&quot;is_master_playlist&quot;, track.isMaster());</span>
<span class="nc" id="L1833">        trackJson.addProperty(&quot;is_live&quot;, track.isLive());</span>
      }

<span class="nc" id="L1836">      tracksJson.add(trackJson);</span>
    }

<span class="nc" id="L1839">    return tracksJson;</span>
  }

  private List&lt;JsonObject&gt; getPublicationAttachmentsJson(Publication publication, Boolean sign) {
<span class="nc" id="L1843">    List&lt;JsonObject&gt; attachmentsJson = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1845" title="All 2 branches missed.">    for (Attachment attachment : publication.getAttachments()) {</span>
<span class="nc" id="L1846">      JsonObject json = new JsonObject();</span>

<span class="nc" id="L1848">      json.addProperty(&quot;id&quot;, safeString(attachment.getIdentifier()));</span>
<span class="nc" id="L1849">      json.addProperty(&quot;mediatype&quot;, safeString(attachment.getMimeType()));</span>
<span class="nc" id="L1850">      json.addProperty(&quot;url&quot;, safeString(getSignedUrl(attachment.getURI(), sign)));</span>
<span class="nc" id="L1851">      json.addProperty(&quot;flavor&quot;, safeString(attachment.getFlavor()));</span>
<span class="nc" id="L1852">      json.addProperty(&quot;ref&quot;, safeString(attachment.getReference()));</span>
<span class="nc" id="L1853">      json.addProperty(&quot;size&quot;, attachment.getSize());</span>
<span class="nc" id="L1854">      json.addProperty(&quot;checksum&quot;, safeString(attachment.getChecksum()));</span>
<span class="nc" id="L1855">      json.add(&quot;tags&quot;, arrayToJsonArray(attachment.getTags()));</span>

<span class="nc" id="L1857">      attachmentsJson.add(json);</span>
    }

<span class="nc" id="L1860">    return attachmentsJson;</span>
  }

  private List&lt;JsonObject&gt; getPublicationCatalogsJson(Publication publication, Boolean sign) {
<span class="nc" id="L1864">    List&lt;JsonObject&gt; catalogsJson = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1866" title="All 2 branches missed.">    for (Catalog catalog : publication.getCatalogs()) {</span>
<span class="nc" id="L1867">      JsonObject json = new JsonObject();</span>

<span class="nc" id="L1869">      json.addProperty(&quot;id&quot;, safeString(catalog.getIdentifier()));</span>
<span class="nc" id="L1870">      json.addProperty(&quot;mediatype&quot;, safeString(catalog.getMimeType()));</span>
<span class="nc" id="L1871">      json.addProperty(&quot;url&quot;, safeString(getSignedUrl(catalog.getURI(), sign)));</span>
<span class="nc" id="L1872">      json.addProperty(&quot;flavor&quot;, safeString(catalog.getFlavor()));</span>
<span class="nc" id="L1873">      json.addProperty(&quot;size&quot;, catalog.getSize());</span>
<span class="nc" id="L1874">      json.addProperty(&quot;checksum&quot;, safeString(catalog.getChecksum()));</span>
<span class="nc" id="L1875">      json.add(&quot;tags&quot;, arrayToJsonArray(catalog.getTags()));</span>

<span class="nc" id="L1877">      catalogsJson.add(json);</span>
    }

<span class="nc" id="L1880">    return catalogsJson;</span>
  }

  @GET
  @Path(&quot;{eventId}/publications/{publicationId}&quot;)
  @RestQuery(name = &quot;geteventpublication&quot;, description = &quot;Returns a single publication.&quot;, returnDescription = &quot;&quot;,
             pathParameters = {
               @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING),
               @RestParameter(name = &quot;publicationId&quot;, description = &quot;The publication id&quot;, isRequired = true, type = STRING)
             },
             restParameters = {
               @RestParameter(name = &quot;sign&quot;, description = &quot;Whether public distribution urls should be signed.&quot;,
                              isRequired = false, type = Type.BOOLEAN)
             },
             responses = {
                  @RestResponse(description = &quot;The track details are returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified event or publication does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })

  public Response getEventPublication(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String eventId,
          @PathParam(&quot;publicationId&quot;) String publicationId, @QueryParam(&quot;sign&quot;) boolean sign) throws Exception {
    try {
<span class="nc" id="L1901">      final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc" id="L1902">      return ApiResponseBuilder.Json.ok(acceptHeader, getPublication(eventId, publicationId, sign, requestedVersion));</span>
<span class="nc" id="L1903">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1904">      return ApiResponseBuilder.notFound(e.getMessage());</span>
<span class="nc" id="L1905">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1906">      logger.error(&quot;Unable to get list of publications from event with id '{}'&quot;, eventId, e);</span>
<span class="nc" id="L1907">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }


  private JsonObject getPublication(String eventId, String publicationId, Boolean withSignedUrls, ApiVersion requestedVersion)
          throws SearchIndexException, NotFoundException {
<span class="nc" id="L1914">    Optional&lt;Event&gt; eventOpt = indexService.getEvent(eventId, elasticsearchIndex);</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">    if (eventOpt.isPresent()) {</span>
      List&lt;Publication&gt; publications;
<span class="nc bnc" id="L1917" title="All 4 branches missed.">      publications = eventOpt.get().getPublications().stream().filter(publication -&gt; (!requestedVersion.isSmallerThan(VERSION_1_11_0) || EventUtils.internalChannelFilter.test(publication))).collect(Collectors.toList());</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">      for (Publication publication : publications) {</span>
<span class="nc bnc" id="L1919" title="All 2 branches missed.">        if (publicationId.equals(publication.getIdentifier())) {</span>
<span class="nc" id="L1920">          return getPublication(publication, withSignedUrls, requestedVersion);</span>
        }
<span class="nc" id="L1922">      }</span>
<span class="nc" id="L1923">      throw new NotFoundException(</span>
<span class="nc" id="L1924">              String.format(&quot;Unable to find publication with id '%s' in event with id '%s'&quot;, publicationId, eventId));</span>
    }
<span class="nc" id="L1926">    throw new NotFoundException(String.format(&quot;Unable to find event with id '%s'&quot;, eventId));</span>
  }

  /**
   * Get an {@link AccessControlList} from an {@link Event}.
   *
   * @param event
   *          The {@link Event} to get the ACL from.
   * @return The {@link AccessControlList} stored in the {@link Event}
   */
  protected static AccessControlList getAclFromEvent(Event event) {
<span class="nc" id="L1937">    AccessControlList activeAcl = new AccessControlList();</span>
    try {
<span class="nc bnc" id="L1939" title="All 2 branches missed.">      if (event.getAccessPolicy() != null)</span>
<span class="nc" id="L1940">        activeAcl = AccessControlParser.parseAcl(event.getAccessPolicy());</span>
<span class="nc" id="L1941">    } catch (Exception e) {</span>
<span class="nc" id="L1942">      logger.error(&quot;Unable to parse access policy&quot;, e);</span>
<span class="nc" id="L1943">    }</span>
<span class="nc" id="L1944">    return activeAcl;</span>
  }

  private JsonObject getJsonStream(Stream stream) {
<span class="nc" id="L1948">    JsonObject json = new JsonObject();</span>

<span class="nc bnc" id="L1950" title="All 2 branches missed.">    if (stream instanceof AudioStream) {</span>
<span class="nc" id="L1951">      AudioStream audio = (AudioStream) stream;</span>

<span class="nc bnc" id="L1953" title="All 2 branches missed.">      if (audio.getBitDepth() != null) json.addProperty(&quot;bitdepth&quot;, audio.getBitDepth());</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">      if (audio.getBitRate() != null) json.addProperty(&quot;bitrate&quot;, audio.getBitRate());</span>
<span class="nc bnc" id="L1955" title="All 2 branches missed.">      if (audio.getCaptureDevice() != null) json.addProperty(&quot;capturedevice&quot;, audio.getCaptureDevice());</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">      if (audio.getCaptureDeviceVendor() != null) json.addProperty(&quot;capturedevicevendor&quot;, audio.getCaptureDeviceVendor());</span>
<span class="nc bnc" id="L1957" title="All 2 branches missed.">      if (audio.getCaptureDeviceVersion() != null) json.addProperty(&quot;capturedeviceversion&quot;, audio.getCaptureDeviceVersion());</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">      if (audio.getChannels() != null) json.addProperty(&quot;channels&quot;, audio.getChannels());</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">      if (audio.getEncoderLibraryVendor() != null) json.addProperty(&quot;encoderlibraryvendor&quot;, audio.getEncoderLibraryVendor());</span>
<span class="nc bnc" id="L1960" title="All 2 branches missed.">      if (audio.getFormat() != null) json.addProperty(&quot;format&quot;, audio.getFormat());</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">      if (audio.getFormatVersion() != null) json.addProperty(&quot;formatversion&quot;, audio.getFormatVersion());</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">      if (audio.getFrameCount() != null) json.addProperty(&quot;framecount&quot;, audio.getFrameCount());</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">      if (audio.getIdentifier() != null) json.addProperty(&quot;identifier&quot;, audio.getIdentifier());</span>
<span class="nc bnc" id="L1964" title="All 2 branches missed.">      if (audio.getPkLevDb() != null) json.addProperty(&quot;pklevdb&quot;, audio.getPkLevDb());</span>
<span class="nc bnc" id="L1965" title="All 2 branches missed.">      if (audio.getRmsLevDb() != null) json.addProperty(&quot;rmslevdb&quot;, audio.getRmsLevDb());</span>
<span class="nc bnc" id="L1966" title="All 2 branches missed.">      if (audio.getRmsPkDb() != null) json.addProperty(&quot;rmspkdb&quot;, audio.getRmsPkDb());</span>
<span class="nc bnc" id="L1967" title="All 2 branches missed.">      if (audio.getSamplingRate() != null) json.addProperty(&quot;samplingrate&quot;, audio.getSamplingRate());</span>

<span class="nc bnc" id="L1969" title="All 2 branches missed.">    } else if (stream instanceof VideoStream) {</span>
<span class="nc" id="L1970">      VideoStream video = (VideoStream) stream;</span>

<span class="nc bnc" id="L1972" title="All 2 branches missed.">      if (video.getBitRate() != null) json.addProperty(&quot;bitrate&quot;, video.getBitRate());</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">      if (video.getCaptureDevice() != null) json.addProperty(&quot;capturedevice&quot;, video.getCaptureDevice());</span>
<span class="nc bnc" id="L1974" title="All 2 branches missed.">      if (video.getCaptureDeviceVendor() != null) json.addProperty(&quot;capturedevicevendor&quot;, video.getCaptureDeviceVendor());</span>
<span class="nc bnc" id="L1975" title="All 2 branches missed.">      if (video.getCaptureDeviceVersion() != null) json.addProperty(&quot;capturedeviceversion&quot;, video.getCaptureDeviceVersion());</span>
<span class="nc bnc" id="L1976" title="All 2 branches missed.">      if (video.getEncoderLibraryVendor() != null) json.addProperty(&quot;encoderlibraryvendor&quot;, video.getEncoderLibraryVendor());</span>
<span class="nc bnc" id="L1977" title="All 2 branches missed.">      if (video.getFormat() != null) json.addProperty(&quot;format&quot;, video.getFormat());</span>
<span class="nc bnc" id="L1978" title="All 2 branches missed.">      if (video.getFormatVersion() != null) json.addProperty(&quot;formatversion&quot;, video.getFormatVersion());</span>
<span class="nc bnc" id="L1979" title="All 2 branches missed.">      if (video.getFrameCount() != null) json.addProperty(&quot;framecount&quot;, video.getFrameCount());</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">      if (video.getFrameHeight() != null) json.addProperty(&quot;frameheight&quot;, video.getFrameHeight());</span>
<span class="nc bnc" id="L1981" title="All 2 branches missed.">      if (video.getFrameRate() != null) json.addProperty(&quot;framerate&quot;, video.getFrameRate());</span>
<span class="nc bnc" id="L1982" title="All 2 branches missed.">      if (video.getFrameWidth() != null) json.addProperty(&quot;framewidth&quot;, video.getFrameWidth());</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">      if (video.getIdentifier() != null) json.addProperty(&quot;identifier&quot;, video.getIdentifier());</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">      if (video.getScanOrder() != null) json.addProperty(&quot;scanorder&quot;, video.getScanOrder().toString());</span>
<span class="nc bnc" id="L1985" title="All 2 branches missed.">      if (video.getScanType() != null) json.addProperty(&quot;scantype&quot;, video.getScanType().toString());</span>
    }

<span class="nc" id="L1988">    return json;</span>
  }

  private String getEventUrl(String eventId) {
<span class="nc" id="L1992">    return UrlSupport.concat(endpointBaseUrl, eventId);</span>
  }

  @GET
  @Path(&quot;{eventId}/scheduling&quot;)
  @Produces({ ApiMediaType.JSON, ApiMediaType.VERSION_1_1_0, ApiMediaType.VERSION_1_2_0, ApiMediaType.VERSION_1_3_0,
              ApiMediaType.VERSION_1_4_0, ApiMediaType.VERSION_1_5_0, ApiMediaType.VERSION_1_6_0,
              ApiMediaType.VERSION_1_7_0, ApiMediaType.VERSION_1_8_0, ApiMediaType.VERSION_1_9_0,
              ApiMediaType.VERSION_1_10_0, ApiMediaType.VERSION_1_11_0 })
  @RestQuery(name = &quot;geteventscheduling&quot;, description = &quot;Returns an event's scheduling information.&quot;, returnDescription = &quot;&quot;, pathParameters = {
      @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
      @RestResponse(description = &quot;The scheduling information for the specified event is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;The specified event has no scheduling information.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
      @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventScheduling(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
      throws Exception {
    try {
<span class="fc" id="L2009">      final Optional&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>

<span class="pc bpc" id="L2011" title="1 of 2 branches missed.">      if (event.isEmpty()) {</span>
<span class="nc" id="L2012">        return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
      }

<span class="fc" id="L2015">      final JsonObject scheduling = SchedulingInfo.of(event.get().getIdentifier(), schedulerService).toJson();</span>
<span class="pc bpc" id="L2016" title="1 of 2 branches missed.">      if (!scheduling.isEmpty()) {</span>
<span class="fc" id="L2017">        return ApiResponseBuilder.Json.ok(acceptHeader, scheduling);</span>
      }
<span class="nc" id="L2019">      return Response.noContent().build();</span>
<span class="nc" id="L2020">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L2021">      logger.error(&quot;Unable to get list of publications from event with id '{}'&quot;, id, e);</span>
<span class="nc" id="L2022">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @PUT
  @Path(&quot;{eventId}/scheduling&quot;)
  @Produces({ ApiMediaType.JSON, ApiMediaType.VERSION_1_1_0, ApiMediaType.VERSION_1_2_0, ApiMediaType.VERSION_1_3_0,
              ApiMediaType.VERSION_1_4_0, ApiMediaType.VERSION_1_5_0, ApiMediaType.VERSION_1_6_0,
              ApiMediaType.VERSION_1_7_0, ApiMediaType.VERSION_1_8_0, ApiMediaType.VERSION_1_9_0,
              ApiMediaType.VERSION_1_10_0, ApiMediaType.VERSION_1_11_0 })
  @RestQuery(name = &quot;updateeventscheduling&quot;, description = &quot;Update an event's scheduling information.&quot;, returnDescription = &quot;&quot;, pathParameters = {
      @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = Type.STRING) }, restParameters = {
      @RestParameter(name = &quot;scheduling&quot;, isRequired = true, description = &quot;Scheduling Information&quot;, type = Type.STRING),
      @RestParameter(name = &quot;allowConflict&quot;, description = &quot;Allow conflicts when updating scheduling&quot;, isRequired = false, type = Type.BOOLEAN) }, responses = {
      @RestResponse(description = &quot;The  scheduling information for the specified event is updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
      @RestResponse(description = &quot;The specified event has no scheduling information to update.&quot;, responseCode = HttpServletResponse.SC_NOT_ACCEPTABLE),
      @RestResponse(description = &quot;The scheduling information could not be updated due to a conflict.&quot;, responseCode = HttpServletResponse.SC_CONFLICT),
      @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventScheduling(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
                                 @FormParam(&quot;scheduling&quot;) String scheduling,
                                 @FormParam(&quot;allowConflict&quot;) @DefaultValue(&quot;false&quot;) boolean allowConflict) throws Exception {
<span class="fc" id="L2043">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="fc" id="L2044">    final Optional&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>

<span class="pc bpc" id="L2046" title="1 of 2 branches missed.">    if (requestedVersion.isSmallerThan(ApiVersion.VERSION_1_2_0)) {</span>
<span class="nc" id="L2047">        allowConflict = false;</span>
    }
<span class="pc bpc" id="L2049" title="1 of 2 branches missed.">    if (event.isEmpty()) {</span>
<span class="nc" id="L2050">      return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
    }
<span class="fc" id="L2052">    final JSONParser parser = new JSONParser();</span>
    JSONObject parsedJson;
    try {
<span class="fc" id="L2055">       parsedJson = (JSONObject) parser.parse(scheduling);</span>
<span class="nc" id="L2056">    } catch (ParseException e) {</span>
<span class="nc" id="L2057">      logger.debug(&quot;Client sent unparsable scheduling information for event {}: {}&quot;, id, scheduling);</span>
<span class="nc" id="L2058">      return RestUtil.R.badRequest(&quot;Unparsable scheduling information&quot;);</span>
<span class="fc" id="L2059">    }</span>
<span class="fc" id="L2060">    Optional&lt;Response&gt; clientError = updateSchedulingInformation(parsedJson, id, requestedVersion, allowConflict);</span>
<span class="fc" id="L2061">    return clientError.orElse(Response.noContent().build());</span>
  }

  private Optional&lt;Response&gt; updateSchedulingInformation(
      JSONObject parsedScheduling,
      String id,
      ApiVersion requestedVersion,
      boolean allowConflict) throws Exception {

    SchedulingInfo schedulingInfo;
    try {
<span class="fc" id="L2072">      schedulingInfo = SchedulingInfo.of(parsedScheduling);</span>
<span class="nc" id="L2073">    } catch (DateTimeParseException e) {</span>
<span class="nc" id="L2074">      logger.debug(&quot;Client sent unparsable start or end date for event {}&quot;, id);</span>
<span class="nc" id="L2075">      return Optional.of(RestUtil.R.badRequest(&quot;Unparsable date in scheduling information&quot;));</span>
<span class="fc" id="L2076">    }</span>
<span class="fc" id="L2077">    final TechnicalMetadata technicalMetadata = schedulerService.getTechnicalMetadata(id);</span>

    // When &quot;inputs&quot; is updated, capture agent configuration needs to be merged
<span class="fc" id="L2080">    Optional&lt;Map&lt;String, String&gt;&gt; caConfig = Optional.empty();</span>
<span class="pc bpc" id="L2081" title="1 of 2 branches missed.">    if (schedulingInfo.getInputs().isPresent()) {</span>
<span class="fc" id="L2082">      final Map&lt;String, String&gt; configMap = new HashMap&lt;&gt;(technicalMetadata.getCaptureAgentConfiguration());</span>
<span class="fc" id="L2083">      configMap.put(CaptureParameters.CAPTURE_DEVICE_NAMES, schedulingInfo.getInputs().get());</span>
<span class="fc" id="L2084">      caConfig = Optional.of(configMap);</span>
    }

    try {
<span class="fc" id="L2088">      schedulerService.updateEvent(</span>
          id,
<span class="fc" id="L2090">          schedulingInfo.getStartDate(),</span>
<span class="fc" id="L2091">          schedulingInfo.getEndDate(),</span>
<span class="fc" id="L2092">          schedulingInfo.getAgentId(),</span>
<span class="fc" id="L2093">          Optional.empty(),</span>
<span class="fc" id="L2094">          Optional.empty(),</span>
<span class="fc" id="L2095">          Optional.empty(),</span>
          caConfig,
          allowConflict);
<span class="nc" id="L2098">    } catch (SchedulerConflictException e) {</span>
<span class="nc" id="L2099">      final List&lt;MediaPackage&gt; conflictingEvents = getConflictingEvents(</span>
<span class="nc" id="L2100">          schedulingInfo.merge(technicalMetadata), agentStateService, schedulerService);</span>
<span class="nc" id="L2101">      logger.debug(&quot;Client tried to change scheduling information causing a conflict for event {}.&quot;, id);</span>
<span class="nc" id="L2102">      List&lt;JsonObject&gt; conflicts = convertConflictingEvents(</span>
<span class="nc" id="L2103">          Optional.of(id), conflictingEvents, indexService, elasticsearchIndex</span>
      );

<span class="nc" id="L2106">      JsonArray conflictArray = new JsonArray();</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">      for (JsonObject conflict : conflicts) {</span>
<span class="nc" id="L2108">        conflictArray.add(conflict);</span>
<span class="nc" id="L2109">      }</span>

<span class="nc" id="L2111">      return Optional.of(ApiResponseBuilder.Json.conflict(requestedVersion, conflictArray));</span>
<span class="fc" id="L2112">    }</span>
<span class="fc" id="L2113">    return Optional.empty();</span>
  }

  @POST
  @Path(&quot;{eventId}/track&quot;)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @RestQuery(name = &quot;updateFlavorWithTrack&quot;, description = &quot;Update an events track for a given flavor&quot;, returnDescription = &quot;&quot;,
          pathParameters = {
                  @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) },
          restParameters = {
                  @RestParameter(description = &quot;Flavor to add track to, e.g. captions/source&quot;,
                      isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
                  @RestParameter(description = &quot;Comma separated list of tags for the given track, e.g. archive,publish. &quot;
                      + &quot;If a 'lang:LANG-CODE' tag exists and overwriteExisting=true &quot;
                      + &quot;only tracks with same lang tag and flavor will be replaced. This behavior is used for captions.&quot;,
                      isRequired = false, name = &quot;tags&quot;, type = RestParameter.Type.STRING),
                  @RestParameter(description = &quot;If true, all other tracks in the specified flavor are REMOVED. &quot;
                      + &quot;If tags argument contains a lang:LANG-CODE tag, only elements with same tag would be removed.&quot;,
                      isRequired = true, name = &quot;overwriteExisting&quot;, type = RestParameter.Type.BOOLEAN),
                  @RestParameter(description = &quot;The track file&quot;, isRequired = true, name = &quot;track&quot;, type = RestParameter.Type.FILE),
          },
          responses = {
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND),
                  @RestResponse(description = &quot;The track has been added to the event.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The request is invalid or inconsistent.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          })
  public Response updateFlavorWithTrack(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @Context HttpServletRequest request) {
<span class="fc" id="L2141">    logger.debug(&quot;updateFlavorWithTrack called&quot;);</span>
    try {
<span class="fc" id="L2143">      boolean overwriteExisting = false;</span>
<span class="fc" id="L2144">      MediaPackageElementFlavor tmpFlavor = MediaPackageElementFlavor.parseFlavor(&quot;addTrack/temporary&quot;);</span>
<span class="fc" id="L2145">      MediaPackageElementFlavor newFlavor = null;</span>
      Optional&lt;Event&gt; event;
<span class="fc" id="L2147">      List&lt;String&gt; tags = null;</span>
<span class="fc" id="L2148">      String langTag = null;</span>

      try {
<span class="fc" id="L2151">        event = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc" id="L2152">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L2153">        return RestUtil.R.badRequest(String.format(&quot;Error while searching for event with id %s; %s&quot;, id, e.getMessage()));</span>
<span class="fc" id="L2154">      }</span>

<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">      if (event.isEmpty()) {</span>
<span class="nc" id="L2157">        return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
      }
<span class="fc" id="L2159">      MediaPackage mp = indexService.getEventMediapackage(event.get());</span>

      try {
<span class="pc bpc" id="L2162" title="1 of 2 branches missed.">        if (workflowService.mediaPackageHasActiveWorkflows(mp.getIdentifier().toString())) {</span>
<span class="nc" id="L2163">          return RestUtil.R.conflict(String.format(&quot;Cannot update while a workflow is running on event '%s'&quot;, id));</span>
        }
<span class="nc" id="L2165">      } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L2166">        return RestUtil.R.serverError();</span>
<span class="fc" id="L2167">      }</span>

<span class="pc bpc" id="L2169" title="1 of 2 branches missed.">      if (!ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L2170">        throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
      }
<span class="fc bfc" id="L2172" title="All 2 branches covered.">      for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="fc" id="L2173">        FileItemStream item = iter.next();</span>
<span class="fc" id="L2174">        String fieldName = item.getFieldName();</span>
<span class="fc bfc" id="L2175" title="All 2 branches covered.">        if (item.isFormField()) {</span>
<span class="fc bfc" id="L2176" title="All 2 branches covered.">          if (&quot;flavor&quot;.equals(fieldName)) {</span>
<span class="fc" id="L2177">            String flavorString = Streams.asString(item.openStream());</span>
            try {
<span class="fc" id="L2179">              newFlavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>
<span class="nc" id="L2180">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L2181">              return RestUtil.R.badRequest(String.format(&quot;Could not parse flavor %s; %s&quot;, flavorString, e.getMessage()));</span>
<span class="fc" id="L2182">            }</span>
<span class="pc bpc" id="L2183" title="1 of 2 branches missed.">          } else if (&quot;tags&quot;.equals(fieldName)) {</span>
<span class="nc" id="L2184">            String tagsString = Streams.asString(item.openStream());</span>
<span class="nc bnc" id="L2185" title="All 2 branches missed.">            if (StringUtils.isNotBlank(tagsString)) {</span>
<span class="nc" id="L2186">              tags = List.of(StringUtils.split(tagsString, ','));</span>
              // find lang tag if exists
<span class="nc bnc" id="L2188" title="All 2 branches missed.">              for (String tag : tags) {</span>
<span class="nc bnc" id="L2189" title="All 2 branches missed.">                if (StringUtils.startsWith(StringUtils.trimToEmpty(tag), &quot;lang:&quot;)) {</span>
                  // lang tag is set
<span class="nc" id="L2191">                  langTag = StringUtils.trimToEmpty(tag);</span>
<span class="nc" id="L2192">                  break;</span>
                }
<span class="nc" id="L2194">              }</span>
            }
<span class="pc bpc" id="L2196" title="1 of 2 branches missed.">          } else if (&quot;overwriteExisting&quot;.equals(fieldName)) {</span>
<span class="fc" id="L2197">            overwriteExisting = Boolean.parseBoolean(Streams.asString(item.openStream()));</span>
          }
        } else {
          // Add track with temporary flavor
<span class="pc bpc" id="L2201" title="1 of 2 branches missed.">          if (&quot;track&quot;.equals(item.getFieldName())) {</span>
<span class="fc" id="L2202">            mp = ingestService.addTrack(item.openStream(), item.getName(), tmpFlavor, mp);</span>
          }
        }
<span class="fc" id="L2205">      }</span>

<span class="pc bpc" id="L2207" title="1 of 2 branches missed.">      if (overwriteExisting) {</span>
        // remove existing attachments of the new flavor
<span class="fc" id="L2209">        Track[] existing = mp.getTracks(newFlavor);</span>
<span class="pc bpc" id="L2210" title="1 of 2 branches missed.">        for (int i = 0; i &lt; existing.length; i++) {</span>
          // if lang tag is set, remove only matching elements
<span class="nc bnc" id="L2212" title="All 4 branches missed.">          if (null == langTag || existing[i].containsTag(langTag)) {</span>
<span class="nc" id="L2213">            mp.remove(existing[i]);</span>
<span class="nc" id="L2214">            logger.debug(&quot;Overwriting existing asset {} {}&quot;, tmpFlavor, newFlavor);</span>
          }
        }
      }
      // correct the flavor of the new attachment
<span class="fc bfc" id="L2219" title="All 2 branches covered.">      for (Track track : mp.getTracks(tmpFlavor)) {</span>
<span class="fc" id="L2220">        track.setFlavor(newFlavor);</span>
<span class="pc bpc" id="L2221" title="1 of 2 branches missed.">        if (null != tags) {</span>
<span class="nc bnc" id="L2222" title="All 2 branches missed.">          for (String tag : tags) {</span>
<span class="nc" id="L2223">            track.addTag(tag);</span>
<span class="nc" id="L2224">          }</span>
        }
      }
<span class="fc" id="L2227">      logger.debug(&quot;Updated asset {} {}&quot;, tmpFlavor, newFlavor);</span>

      try {
<span class="fc" id="L2230">        assetManager.takeSnapshot(mp);</span>
<span class="nc" id="L2231">      } catch (AssetManagerException e) {</span>
<span class="nc" id="L2232">        logger.error(&quot;Error while adding the updated media package ({}) to the archive&quot;, mp.getIdentifier(), e);</span>
<span class="nc" id="L2233">        return RestUtil.R.badRequest(e.getMessage());</span>
<span class="fc" id="L2234">      }</span>

<span class="fc" id="L2236">      return Response.status(Status.OK).build();</span>
<span class="nc" id="L2237">    } catch (IllegalArgumentException | IOException | FileUploadException | IndexServiceException | IngestException</span>
            | MediaPackageException e) {
<span class="nc" id="L2239">      return RestUtil.R.badRequest(String.format(&quot;Could not add track: %s&quot;, e.getMessage()));</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>