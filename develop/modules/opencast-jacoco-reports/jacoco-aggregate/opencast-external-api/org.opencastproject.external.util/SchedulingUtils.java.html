<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SchedulingUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-external-api</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.external.util</a> &gt; <span class="el_source">SchedulingUtils.java</span></div><h1>SchedulingUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.external.util;

import static java.time.ZoneOffset.UTC;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.isNotBlank;

import org.opencastproject.capture.CaptureParameters;
import org.opencastproject.capture.admin.api.Agent;
import org.opencastproject.capture.admin.api.CaptureAgentStateService;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.index.service.api.IndexService;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.scheduler.api.SchedulerException;
import org.opencastproject.scheduler.api.SchedulerService;
import org.opencastproject.scheduler.api.TechnicalMetadata;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.util.NotFoundException;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;

import net.fortuna.ical4j.model.property.RRule;

import org.apache.commons.lang3.StringUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.TimeZone;

public final class SchedulingUtils {

  /** The logging facility */
<span class="nc" id="L66">  private static final Logger logger = LoggerFactory.getLogger(SchedulingUtils.class);</span>

  private static final String JSON_KEY_AGENT_ID = &quot;agent_id&quot;;
  private static final String JSON_KEY_START_DATE = &quot;start&quot;;
  private static final String JSON_KEY_END_DATE = &quot;end&quot;;
  private static final String JSON_KEY_DURATION = &quot;duration&quot;;
  private static final String JSON_KEY_INPUTS = &quot;inputs&quot;;
  private static final String JSON_KEY_RRULE = &quot;rrule&quot;;


  private SchedulingUtils() {
  }

  public static class SchedulingInfo {
<span class="pc" id="L80">    private Optional&lt;Date&gt; startDate = Optional.empty();</span>
<span class="pc" id="L81">    private Optional&lt;Date&gt; endDate = Optional.empty();</span>
<span class="pc" id="L82">    private Optional&lt;Long&gt; duration = Optional.empty();</span>
<span class="pc" id="L83">    private Optional&lt;String&gt; agentId = Optional.empty();</span>
<span class="pc" id="L84">    private Optional&lt;String&gt; inputs = Optional.empty();</span>
<span class="pc" id="L85">    private Optional&lt;RRule&gt; rrule = Optional.empty();</span>

<span class="fc" id="L87">    public SchedulingInfo() {</span>
<span class="fc" id="L88">    }</span>

    /**
     * Copy the given SchedulingInfo object.
     *
     * @param other
     *          The SchedulingInfo object to copy.
     */
<span class="nc" id="L96">    public SchedulingInfo(SchedulingInfo other) {</span>
<span class="nc" id="L97">      this.startDate = other.startDate;</span>
<span class="nc" id="L98">      this.endDate = other.endDate;</span>
<span class="nc" id="L99">      this.duration = other.duration;</span>
<span class="nc" id="L100">      this.agentId = other.agentId;</span>
<span class="nc" id="L101">      this.inputs = other.inputs;</span>
<span class="nc" id="L102">      this.rrule = other.rrule;</span>
<span class="nc" id="L103">    }</span>

    public Optional&lt;Date&gt; getStartDate() {
<span class="fc" id="L106">      return startDate;</span>
    }

    public void setStartDate(Optional&lt;Date&gt; startDate) {
<span class="fc" id="L110">      this.startDate = startDate;</span>
<span class="fc" id="L111">    }</span>

    public Optional&lt;Date&gt; getEndDate() {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">      if (endDate.isPresent()) {</span>
<span class="fc" id="L115">        return endDate;</span>
<span class="nc bnc" id="L116" title="All 4 branches missed.">      } else if (startDate.isPresent() &amp;&amp; duration.isPresent()) {</span>
<span class="nc" id="L117">        return Optional.of(Date.from(startDate.get().toInstant().plusMillis(duration.get())));</span>
      } else {
<span class="nc" id="L119">        return Optional.empty();</span>
      }
    }

    public void setEndDate(Optional&lt;Date&gt; endDate) {
<span class="fc" id="L124">      this.endDate = endDate;</span>
<span class="fc" id="L125">    }</span>

    public Optional&lt;Long&gt; getDuration() {
<span class="nc bnc" id="L128" title="All 2 branches missed.">      if (duration.isPresent()) {</span>
<span class="nc" id="L129">        return duration;</span>
<span class="nc bnc" id="L130" title="All 4 branches missed.">      } else if (startDate.isPresent() &amp;&amp; endDate.isPresent()) {</span>
<span class="nc" id="L131">        return Optional.of(endDate.get().getTime() - startDate.get().getTime());</span>
      } else {
<span class="nc" id="L133">        return Optional.empty();</span>
      }
    }

    public void setDuration(Optional&lt;Long&gt; duration) {
<span class="nc" id="L138">      this.duration = duration;</span>
<span class="nc" id="L139">    }</span>

    public Optional&lt;String&gt; getAgentId() {
<span class="fc" id="L142">      return agentId;</span>
    }

    public void setAgentId(Optional&lt;String&gt; agentId) {
<span class="fc" id="L146">      this.agentId = agentId;</span>
<span class="fc" id="L147">    }</span>

    public Optional&lt;String&gt; getInputs() {
<span class="fc" id="L150">      return inputs;</span>
    }

    public void setInputs(Optional&lt;String&gt; inputs) {
<span class="fc" id="L154">      this.inputs = inputs;</span>
<span class="fc" id="L155">    }</span>

    public Optional&lt;RRule&gt; getRrule() {
<span class="nc" id="L158">      return rrule;</span>
    }

    public void setRrule(Optional&lt;RRule&gt; rrule) {
<span class="nc" id="L162">      this.rrule = rrule;</span>
<span class="nc" id="L163">    }</span>

    /**
     * @return A JSON representation of this SchedulingInfo object.
     */
    public JsonObject toJson() {
<span class="fc" id="L169">      JsonObject json = new JsonObject();</span>
<span class="fc" id="L170">      DateTimeFormatter dateFormatter = DateTimeFormatter.ISO_DATE_TIME;</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">      if (startDate.isPresent()) {</span>
<span class="fc" id="L172">        json.addProperty(JSON_KEY_START_DATE, dateFormatter.format(startDate.get().toInstant().atZone(ZoneOffset.UTC)));</span>
      }
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">      if (endDate.isPresent()) {</span>
<span class="fc" id="L175">        json.addProperty(JSON_KEY_END_DATE, dateFormatter.format(endDate.get().toInstant().atZone(ZoneOffset.UTC)));</span>
      }
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">      if (agentId.isPresent()) {</span>
<span class="fc" id="L178">        json.addProperty(JSON_KEY_AGENT_ID, agentId.get());</span>
      }
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">      if (inputs.isPresent()) {</span>
<span class="fc" id="L181">        JsonArray inputsArray = new JsonArray();</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (String input : inputs.get().split(&quot;,&quot;)) {</span>
<span class="fc" id="L183">          inputsArray.add(new JsonPrimitive(input.trim()));</span>
        }
<span class="fc" id="L185">        json.add(JSON_KEY_INPUTS, inputsArray);</span>
      }
<span class="fc" id="L187">      return json;</span>
    }

    /**
     * @return A JSON source representation of this SchedulingInfo as needed by the IndexService to create an event.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public JSONObject toSource() {
<span class="nc" id="L195">      final JSONObject source = new JSONObject();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">      if (rrule.isPresent()) {</span>
<span class="nc" id="L197">        source.put(&quot;type&quot;, &quot;SCHEDULE_MULTIPLE&quot;);</span>
      } else {
<span class="nc" id="L199">        source.put(&quot;type&quot;, &quot;SCHEDULE_SINGLE&quot;);</span>
      }
<span class="nc" id="L201">      final JSONObject sourceMetadata = new JSONObject();</span>
<span class="nc" id="L202">      final DateTimeFormatter dateFormatter = DateTimeFormatter.ISO_DATE_TIME;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">      if (startDate.isPresent()) {</span>
<span class="nc" id="L204">        sourceMetadata.put(&quot;start&quot;, dateFormatter.format(startDate.get().toInstant().atZone(UTC)));</span>
      }
<span class="nc bnc" id="L206" title="All 2 branches missed.">      if (endDate.isPresent()) {</span>
<span class="nc" id="L207">        sourceMetadata.put(&quot;end&quot;, dateFormatter.format(endDate.get().toInstant().atZone(UTC)));</span>
      }
<span class="nc bnc" id="L209" title="All 2 branches missed.">      if (agentId.isPresent()) {</span>
<span class="nc" id="L210">        sourceMetadata.put(&quot;device&quot;, agentId.get());</span>
      }
<span class="nc bnc" id="L212" title="All 2 branches missed.">      if (getDuration().isPresent()) {</span>
<span class="nc" id="L213">        sourceMetadata.put(&quot;duration&quot;, String.valueOf(getDuration().get()));</span>
      }
<span class="nc bnc" id="L215" title="All 2 branches missed.">      if (rrule.isPresent()) {</span>
<span class="nc" id="L216">        sourceMetadata.put(&quot;rrule&quot;, rrule.get().getValue());</span>
      }
<span class="nc" id="L218">      sourceMetadata.put(&quot;inputs&quot;, inputs.orElse(&quot;&quot;));</span>

<span class="nc" id="L220">      source.put(&quot;metadata&quot;, sourceMetadata);</span>
<span class="nc" id="L221">      return source;</span>
    }

    /**
     * Creates a new SchedulingInfo of this instance which uses start date, end date, and agent id form the given
     * {@link TechnicalMetadata} if they are not present in this instance.
     *
     * @param metadata
     *          The {@link TechnicalMetadata} of which to use start date, end date, and agent id in case they are missing.
     *
     * @return The new SchedulingInfo with start date, end date, and agent id set.
     */
    public SchedulingInfo merge(TechnicalMetadata metadata) {
<span class="nc" id="L234">      SchedulingInfo result = new SchedulingInfo(this);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">      if (result.startDate.isEmpty()) {</span>
<span class="nc" id="L236">        result.startDate = Optional.of(metadata.getStartDate());</span>
      }
<span class="nc bnc" id="L238" title="All 2 branches missed.">      if (result.endDate.isEmpty()) {</span>
<span class="nc" id="L239">        result.endDate = Optional.of(metadata.getEndDate());</span>
      }
<span class="nc bnc" id="L241" title="All 2 branches missed.">      if (result.agentId.isEmpty()) {</span>
<span class="nc" id="L242">        result.agentId = Optional.of(metadata.getAgentId());</span>
      }
<span class="nc" id="L244">      return result;</span>
    }

    /**
     * Parse the given json and create a new SchedulingInfo.
     *
     * @param json
     *          The JSONObject to parse.
     *
     * @return The SchedulingInfo instance represented by the given JSON.
     */
    public static SchedulingInfo of(JSONObject json) {
<span class="fc" id="L256">      final DateTimeFormatter dateFormatter = DateTimeFormatter.ISO_DATE_TIME;</span>
<span class="fc" id="L257">      final SchedulingInfo schedulingInfo = new SchedulingInfo();</span>
<span class="fc" id="L258">      final String startDate = (String) json.get(JSON_KEY_START_DATE);</span>
<span class="fc" id="L259">      final String endDate = (String) json.get(JSON_KEY_END_DATE);</span>
<span class="fc" id="L260">      final String agentId = (String) json.get(JSON_KEY_AGENT_ID);</span>
<span class="fc" id="L261">      final JSONArray inputs = (JSONArray) json.get(JSON_KEY_INPUTS);</span>
<span class="fc" id="L262">      final String rrule = (String) json.get(JSON_KEY_RRULE);</span>

      // Special handling because the original implementation required String but now we require long
<span class="fc" id="L265">      final String durationString = Objects.toString(json.get(JSON_KEY_DURATION), null);</span>

<span class="pc bpc" id="L267" title="1 of 2 branches missed.">      if (isNotBlank(startDate)) {</span>
<span class="fc" id="L268">        schedulingInfo.startDate = Optional.of(Date.from(Instant.from(dateFormatter.parse(startDate))));</span>
      }
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">      if (isNotBlank(endDate)) {</span>
<span class="fc" id="L271">        schedulingInfo.endDate = Optional.of(Date.from(Instant.from(dateFormatter.parse(endDate))));</span>
      }
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">      if (isNotBlank(agentId)) {</span>
<span class="fc" id="L274">        schedulingInfo.agentId = Optional.of(agentId);</span>
      }
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">      if (isNotBlank(durationString)) {</span>
        try {
<span class="nc" id="L278">          schedulingInfo.duration = Optional.of(Long.parseLong(durationString));</span>
<span class="nc" id="L279">        } catch (Exception e) {</span>
<span class="nc" id="L280">          throw new IllegalArgumentException(&quot;Invalid format of field 'duration'&quot;);</span>
<span class="nc" id="L281">        }</span>
      }

<span class="pc bpc" id="L284" title="3 of 4 branches missed.">      if (isBlank(endDate) &amp;&amp; isBlank(durationString)) {</span>
<span class="nc" id="L285">        throw new IllegalArgumentException(&quot;Either 'end' or 'duration' must be specified&quot;);</span>
      }

<span class="pc bpc" id="L288" title="1 of 2 branches missed.">      if (inputs != null) {</span>
<span class="fc" id="L289">        schedulingInfo.inputs = Optional.of(String.join(&quot;,&quot;, inputs));</span>
      }
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">      if (isNotBlank(rrule)) {</span>
        try {
<span class="nc" id="L293">          RRule parsedRrule = new RRule(rrule);</span>
<span class="nc" id="L294">          parsedRrule.validate();</span>
<span class="nc" id="L295">          schedulingInfo.rrule = Optional.of(parsedRrule);</span>
<span class="nc" id="L296">        } catch (Exception e) {</span>
<span class="nc" id="L297">          throw new IllegalArgumentException(&quot;Invalid RRule: &quot; + rrule);</span>
<span class="nc" id="L298">        }</span>
<span class="nc bnc" id="L299" title="All 6 branches missed.">        if (isBlank(durationString) || isBlank(startDate) || isBlank(endDate)) {</span>
<span class="nc" id="L300">          throw new IllegalArgumentException(&quot;'start', 'end' and 'duration' must be specified when 'rrule' is specified&quot;);</span>
        }
      }
<span class="fc" id="L303">      return schedulingInfo;</span>
    }

    /**
     * Get the SchedulingInfo for the given event id.
     *
     * @param eventId
     *          The id of the event to get the SchedulingInfo for.
     * @param schedulerService
     *          The {@link SchedulerService} to query for the event id.
     *
     * @return The SchedulingInfo for the given event id.
     *
     * @throws UnauthorizedException
     *          If the {@link SchedulerService} cannot be queried due to missing authorization.
     * @throws SchedulerException
     *          In case internal errors occur within the {@link SchedulerService}.
     */
    public static SchedulingInfo of(String eventId, SchedulerService schedulerService)
        throws UnauthorizedException, SchedulerException {
<span class="fc" id="L323">      final SchedulingInfo result = new SchedulingInfo();</span>
      try {
<span class="fc" id="L325">        final TechnicalMetadata technicalMetadata = schedulerService.getTechnicalMetadata(eventId);</span>
<span class="fc" id="L326">        result.startDate = Optional.of(technicalMetadata.getStartDate());</span>
<span class="fc" id="L327">        result.endDate = Optional.of(technicalMetadata.getEndDate());</span>
<span class="fc" id="L328">        result.agentId = Optional.of(technicalMetadata.getAgentId());</span>
<span class="fc" id="L329">        String inputs = technicalMetadata.getCaptureAgentConfiguration().get(CaptureParameters.CAPTURE_DEVICE_NAMES);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (isNotBlank(inputs)) {</span>
<span class="fc" id="L331">          result.inputs = Optional.of(inputs);</span>
        }
<span class="fc" id="L333">        return result;</span>
<span class="nc" id="L334">      } catch (NotFoundException e) {</span>
<span class="nc" id="L335">        return result;</span>
      }
    }
  }

  /**
   * Convert the given list of {@link MediaPackage} elements to a JSON used to tell which events are causing conflicts.
   *
   * @param checkedEventId
   *          The id of the event which was checked for conflicts. May be empty if an rrule was checked.
   * @param mediaPackages
   *          The conflicting {@link MediaPackage}s.
   * @param indexService
   *          The {@link IndexService} for getting the corresponding events for the conflicting {@link MediaPackage}s.
   * @param elasticsearchIndex
   *          The index to use for getting the corresponding events for the conflicting MediaPackages.
   *
   * @return A List of conflicting events, represented as JSON objects.
   *
   * @throws SearchIndexException
   *          If an event cannot be found.
   */
  public static List&lt;JsonObject&gt; convertConflictingEvents(
      Optional&lt;String&gt; checkedEventId,
      List&lt;MediaPackage&gt; mediaPackages,
      IndexService indexService,
      ElasticsearchIndex elasticsearchIndex
  ) throws SearchIndexException {
<span class="nc" id="L363">    List&lt;JsonObject&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">    for (MediaPackage mediaPackage : mediaPackages) {</span>
<span class="nc" id="L365">      Optional&lt;Event&gt; eventOpt = indexService.getEvent(mediaPackage.getIdentifier().toString(), elasticsearchIndex);</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">      if (eventOpt.isPresent()) {</span>
<span class="nc" id="L367">        final Event event = eventOpt.get();</span>
<span class="nc bnc" id="L368" title="All 4 branches missed.">        if (checkedEventId.isPresent() &amp;&amp; checkedEventId.get().equals(event.getIdentifier())) {</span>
<span class="nc" id="L369">          continue;</span>
        }

<span class="nc" id="L372">        JsonObject eventJson = new JsonObject();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (event.getTechnicalStartTime() != null)</span>
<span class="nc" id="L374">          eventJson.addProperty(&quot;start&quot;, event.getTechnicalStartTime().toString());</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (event.getTechnicalEndTime() != null)</span>
<span class="nc" id="L376">          eventJson.addProperty(&quot;end&quot;, event.getTechnicalEndTime().toString());</span>
<span class="nc" id="L377">        eventJson.addProperty(&quot;title&quot;, event.getTitle());</span>

<span class="nc" id="L379">        result.add(eventJson);</span>
<span class="nc" id="L380">      } else {</span>
<span class="nc" id="L381">        logger.warn(&quot;Index out of sync! Conflicting event catalog {} not found on event index!&quot;,</span>
<span class="nc" id="L382">            mediaPackage.getIdentifier().toString());</span>
      }
<span class="nc" id="L384">    }</span>
<span class="nc" id="L385">    return result;</span>
  }

  /**
   * Get the conflicting events for the given SchedulingInfo.
   *
   * @param schedulingInfo
   *          The SchedulingInfo to check for conflicts.
   * @param agentStateService
   *          The {@link CaptureAgentStateService} to use for retrieving capture agents.
   * @param schedulerService
   *          The {@link SchedulerService} to use for conflict checking.
   * @return
   *          A list of {@link MediaPackage} elements which cause conflicts with the given SchedulingInfo.
   *
   * @throws NotFoundException
   *          If the capture agent cannot be found.
   * @throws UnauthorizedException
   *          If the {@link SchedulerService} cannot be queried due to missing authorization.
   * @throws SchedulerException
   *          In case internal errors occur within the {@link SchedulerService}.
   */
  public static List&lt;MediaPackage&gt; getConflictingEvents(
      SchedulingInfo schedulingInfo,
      CaptureAgentStateService agentStateService,
      SchedulerService schedulerService
  ) throws NotFoundException, UnauthorizedException, SchedulerException {

<span class="nc bnc" id="L413" title="All 2 branches missed.">    if (schedulingInfo.getRrule().isPresent()) {</span>
<span class="nc" id="L414">      final Agent agent = agentStateService.getAgent(schedulingInfo.getAgentId().get());</span>
<span class="nc" id="L415">      String timezone = agent.getConfiguration().getProperty(&quot;capture.device.timezone&quot;);</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">      if (StringUtils.isBlank(timezone)) {</span>
<span class="nc" id="L417">        timezone = TimeZone.getDefault().getID();</span>
<span class="nc" id="L418">        logger.warn(&quot;No 'capture.device.timezone' set on agent {}. The default server timezone {} will be used.&quot;,</span>
<span class="nc" id="L419">            schedulingInfo.getAgentId().get(), timezone);</span>
      }
<span class="nc" id="L421">      return schedulerService.findConflictingEvents(</span>
<span class="nc" id="L422">          schedulingInfo.getAgentId().get(),</span>
<span class="nc" id="L423">          schedulingInfo.getRrule().get(),</span>
<span class="nc" id="L424">          schedulingInfo.getStartDate().get(),</span>
<span class="nc" id="L425">          schedulingInfo.getEndDate().get(),</span>
<span class="nc" id="L426">          schedulingInfo.getDuration().get(),</span>
<span class="nc" id="L427">          TimeZone.getTimeZone(timezone)</span>
      );
    }

<span class="nc" id="L431">    return schedulerService.findConflictingEvents(</span>
<span class="nc" id="L432">        schedulingInfo.getAgentId().get(),</span>
<span class="nc" id="L433">        schedulingInfo.getStartDate().get(),</span>
<span class="nc" id="L434">        schedulingInfo.getEndDate().get()</span>
    );
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>