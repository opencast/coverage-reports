<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SeriesWorkflowOperationHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-workflow-workflowoperation</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.workflow.handler.workflow</a> &gt; <span class="el_source">SeriesWorkflowOperationHandler.java</span></div><h1>SeriesWorkflowOperationHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.workflow.handler.workflow;

import org.opencastproject.job.api.JobContext;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.EName;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.selector.AbstractMediaPackageElementSelector;
import org.opencastproject.mediapackage.selector.CatalogSelector;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreUtil;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.metadata.dublincore.SeriesCatalogUIAdapter;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AclScope;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.series.api.SeriesException;
import org.opencastproject.series.api.SeriesService;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.util.Checksum;
import org.opencastproject.util.ChecksumType;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.XmlNamespaceBinding;
import org.opencastproject.util.XmlNamespaceContext;
import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowOperationException;
import org.opencastproject.workflow.api.WorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowOperationResult;
import org.opencastproject.workflow.api.WorkflowOperationResult.Action;
import org.opencastproject.workspace.api.Workspace;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * The workflow definition for handling &quot;series&quot; operations
 */
@Component(
    immediate = true,
    service = WorkflowOperationHandler.class,
    property = {
        &quot;service.description=Apply Series to Recording Workflow Operation Handler&quot;,
        &quot;workflow.operation=series&quot;
    }
)
<span class="fc" id="L90">public class SeriesWorkflowOperationHandler extends AbstractWorkflowOperationHandler {</span>

  /** The logging facility */
<span class="fc" id="L93">  private static final Logger logger = LoggerFactory.getLogger(SeriesWorkflowOperationHandler.class);</span>

  /** Name of the configuration option that provides the optional series identifier */
  public static final String SERIES_PROPERTY = &quot;series&quot;;

  /** Name of the configuration option that provides the flavors of the series catalogs to attach */
  public static final String ATTACH_PROPERTY = &quot;attach&quot;;

  /** Name of the configuration option that provides whether the ACL should be applied or not */
  public static final String APPLY_ACL_PROPERTY = &quot;apply-acl&quot;;

  /** Name of the configuration key that specifies the list of series metadata to be copied to the episode */
  public static final String COPY_METADATA_PROPERTY = &quot;copy-metadata&quot;;

  /** Name of the configuration key that specifies the default namespace for the metadata to be copied to the episode */
  public static final String DEFAULT_NS_PROPERTY = &quot;default-namespace&quot;;

  /** The authorization service */
  private AuthorizationService authorizationService;

  /** The series service */
  private SeriesService seriesService;

  /** The workspace */
  private Workspace workspace;

  /** The security service */
  private SecurityService securityService;

  /** The list series catalog UI adapters */
<span class="fc" id="L123">  private final List&lt;SeriesCatalogUIAdapter&gt; seriesCatalogUIAdapters = new ArrayList&lt;&gt;();</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param authorizationService
   *          the authorization service
   */
  @Reference
  protected void setAuthorizationService(AuthorizationService authorizationService) {
<span class="fc" id="L133">    this.authorizationService = authorizationService;</span>
<span class="fc" id="L134">  }</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param seriesService
   *          the series service
   */
  @Reference
  public void setSeriesService(SeriesService seriesService) {
<span class="fc" id="L144">    this.seriesService = seriesService;</span>
<span class="fc" id="L145">  }</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param workspace
   *          the workspace
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="fc" id="L155">    this.workspace = workspace;</span>
<span class="fc" id="L156">  }</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param securityService
   *          the securityService
   */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L166">    this.securityService = securityService;</span>
<span class="fc" id="L167">  }</span>

  /** OSGi callback to add {@link SeriesCatalogUIAdapter} instance. */
  @Reference(
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeCatalogUIAdapter&quot;
  )
  public void addCatalogUIAdapter(SeriesCatalogUIAdapter catalogUIAdapter) {
<span class="fc" id="L176">    seriesCatalogUIAdapters.add(catalogUIAdapter);</span>
<span class="fc" id="L177">  }</span>

  /** OSGi callback to remove {@link SeriesCatalogUIAdapter} instance. */
  public void removeCatalogUIAdapter(SeriesCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L181">    seriesCatalogUIAdapters.remove(catalogUIAdapter);</span>
<span class="nc" id="L182">  }</span>

  @Reference
  @Override
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="nc" id="L187">    super.setServiceRegistry(serviceRegistry);</span>
<span class="nc" id="L188">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,
   *      JobContext)
   */
  @Override
  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)
          throws WorkflowOperationException {
<span class="fc" id="L199">    logger.debug(&quot;Running series workflow operation&quot;);</span>

<span class="fc" id="L201">    MediaPackage mediaPackage = workflowInstance.getMediaPackage();</span>

<span class="fc" id="L203">    Optional&lt;String&gt; optSeries = getOptConfig(workflowInstance.getCurrentOperation(), SERIES_PROPERTY);</span>
<span class="fc" id="L204">    Optional&lt;String&gt; optAttachFlavors = getOptConfig(workflowInstance.getCurrentOperation(), ATTACH_PROPERTY);</span>
<span class="fc" id="L205">    Boolean applyAcl = getOptConfig(workflowInstance.getCurrentOperation(), APPLY_ACL_PROPERTY)</span>
<span class="fc" id="L206">        .map(value -&gt; BooleanUtils.toBoolean(value))</span>
<span class="fc" id="L207">        .orElse(false);</span>
<span class="fc" id="L208">    Optional&lt;String&gt; optCopyMetadata = getOptConfig(workflowInstance.getCurrentOperation(), COPY_METADATA_PROPERTY);</span>
<span class="fc" id="L209">    String defaultNamespace = getOptConfig(workflowInstance.getCurrentOperation(), DEFAULT_NS_PROPERTY)</span>
<span class="fc" id="L210">        .orElse(DublinCore.TERMS_NS_URI);</span>
<span class="fc" id="L211">    logger.debug(&quot;Using default namespace: '{}'&quot;, defaultNamespace);</span>

<span class="pc bpc" id="L213" title="1 of 4 branches missed.">    if (optSeries.isPresent() &amp;&amp; !optSeries.get().equals(mediaPackage.getSeries())) {</span>
<span class="fc" id="L214">      logger.info(&quot;Changing series id from '{}' to '{}'&quot;, StringUtils.trimToEmpty(mediaPackage.getSeries()),</span>
<span class="fc" id="L215">              optSeries.get());</span>
<span class="fc" id="L216">      mediaPackage.setSeries(optSeries.get());</span>
    }

<span class="fc" id="L219">    String seriesId = mediaPackage.getSeries();</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">    if (seriesId == null) {</span>
<span class="fc" id="L221">      logger.info(&quot;No series set, skip operation&quot;);</span>
<span class="fc" id="L222">      return createResult(mediaPackage, Action.SKIP);</span>
    }

    DublinCoreCatalog series;
    try {
<span class="fc" id="L227">      series = seriesService.getSeries(seriesId);</span>
<span class="nc" id="L228">    } catch (NotFoundException e) {</span>
<span class="nc" id="L229">      logger.info(&quot;No series with the identifier '{}' found, skip operation&quot;, seriesId);</span>
<span class="nc" id="L230">      return createResult(mediaPackage, Action.SKIP);</span>
<span class="nc" id="L231">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L232">      logger.warn(&quot;Not authorized to get series with identifier '{}' found, skip operation&quot;, seriesId);</span>
<span class="nc" id="L233">      return createResult(mediaPackage, Action.SKIP);</span>
<span class="nc" id="L234">    } catch (SeriesException e) {</span>
<span class="nc" id="L235">      logger.error(&quot;Unable to get series with identifier '{}', skip operation:&quot;, seriesId, e);</span>
<span class="nc" id="L236">      throw new WorkflowOperationException(e);</span>
<span class="fc" id="L237">    }</span>

<span class="fc" id="L239">    mediaPackage.setSeriesTitle(series.getFirst(DublinCore.PROPERTY_TITLE));</span>

    // Process extra metadata
<span class="fc" id="L242">    HashSet&lt;EName&gt; extraMetadata = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">    if (optCopyMetadata.isPresent()) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">      for (String strEName : optCopyMetadata.get().split(&quot;,+\\s*&quot;))</span>
        try {
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">          if (!strEName.isEmpty()) {</span>
<span class="fc" id="L247">            extraMetadata.add(EName.fromString(strEName, defaultNamespace));</span>
          }
<span class="nc" id="L249">        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L250">          logger.warn(&quot;Ignoring incorrect dublincore metadata property: '{}'&quot;, strEName);</span>
<span class="fc" id="L251">        }</span>
    }

    // Update the episode catalog
<span class="fc bfc" id="L255" title="All 2 branches covered.">    for (Catalog episodeCatalog : mediaPackage.getCatalogs(MediaPackageElements.EPISODE)) {</span>
<span class="fc" id="L256">      DublinCoreCatalog episodeDublinCore = DublinCoreUtil.loadDublinCore(workspace, episodeCatalog);</span>
      // Make sure the MP catalog has bindings defined
<span class="fc" id="L258">      episodeDublinCore.addBindings(</span>
<span class="fc" id="L259">              XmlNamespaceContext.mk(XmlNamespaceBinding.mk(DublinCore.TERMS_NS_PREFIX, DublinCore.TERMS_NS_URI)));</span>
<span class="fc" id="L260">      episodeDublinCore.addBindings(XmlNamespaceContext</span>
<span class="fc" id="L261">              .mk(XmlNamespaceBinding.mk(DublinCore.ELEMENTS_1_1_NS_PREFIX, DublinCore.ELEMENTS_1_1_NS_URI)));</span>
<span class="fc" id="L262">      episodeDublinCore.addBindings(XmlNamespaceContext</span>
<span class="fc" id="L263">              .mk(XmlNamespaceBinding.mk(DublinCores.OC_PROPERTY_NS_PREFIX, DublinCores.OC_PROPERTY_NS_URI)));</span>
<span class="fc" id="L264">      episodeDublinCore.set(DublinCore.PROPERTY_IS_PART_OF, seriesId);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">      for (EName property : extraMetadata) {</span>
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">        if (!episodeDublinCore.hasValue(property) &amp;&amp; series.hasValue(property)) {</span>
<span class="fc" id="L267">          episodeDublinCore.set(property, series.get(property));</span>
        }
<span class="fc" id="L269">      }</span>
<span class="fc" id="L270">      try (InputStream in = IOUtils.toInputStream(episodeDublinCore.toXmlString(), &quot;UTF-8&quot;)) {</span>
<span class="fc" id="L271">        String filename = FilenameUtils.getName(episodeCatalog.getURI().toString());</span>
<span class="fc" id="L272">        URI uri = workspace.put(mediaPackage.getIdentifier().toString(), episodeCatalog.getIdentifier(), filename, in);</span>
<span class="fc" id="L273">        episodeCatalog.setURI(uri);</span>
        // setting the URI to a new source so the checksum will most like be invalid
<span class="fc" id="L275">        episodeCatalog.setChecksum(null);</span>
<span class="nc" id="L276">      } catch (Exception e) {</span>
<span class="nc" id="L277">        logger.error(&quot;Unable to update episode catalog isPartOf field&quot;, e);</span>
<span class="nc" id="L278">        throw new WorkflowOperationException(e);</span>
<span class="fc" id="L279">      }</span>
    }

    // Attach series catalogs
<span class="fc bfc" id="L283" title="All 2 branches covered.">    if (optAttachFlavors.isPresent()) {</span>
      // Remove existing series catalogs
<span class="fc" id="L285">      AbstractMediaPackageElementSelector&lt;Catalog&gt; catalogSelector = new CatalogSelector();</span>
<span class="fc" id="L286">      String[] seriesFlavors = StringUtils.split(optAttachFlavors.get(), &quot;,&quot;);</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">      for (String flavor : seriesFlavors) {</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (&quot;*&quot;.equals(flavor)) {</span>
<span class="fc" id="L289">          catalogSelector.addFlavor(&quot;*/*&quot;);</span>
        } else {
<span class="fc" id="L291">          catalogSelector.addFlavor(flavor);</span>
        }
      }
<span class="fc bfc" id="L294" title="All 2 branches covered.">      for (Catalog c : catalogSelector.select(mediaPackage, false)) {</span>
<span class="pc bpc" id="L295" title="1 of 4 branches missed.">        if (MediaPackageElements.SERIES.equals(c.getFlavor()) || &quot;series&quot;.equals(c.getFlavor().getSubtype())) {</span>
<span class="fc" id="L296">          mediaPackage.remove(c);</span>
        }
<span class="fc" id="L298">      }</span>

<span class="fc" id="L300">      List&lt;SeriesCatalogUIAdapter&gt; adapters = getSeriesCatalogUIAdapters();</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">      for (String flavorString : seriesFlavors) {</span>
        MediaPackageElementFlavor flavor;
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (&quot;*&quot;.equals(flavorString)) {</span>
<span class="fc" id="L304">          flavor = MediaPackageElementFlavor.parseFlavor(&quot;*/*&quot;);</span>
        } else {
<span class="fc" id="L306">          flavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>
        }
<span class="fc bfc" id="L308" title="All 2 branches covered.">        for (SeriesCatalogUIAdapter a : adapters) {</span>
<span class="fc" id="L309">          MediaPackageElementFlavor adapterFlavor = MediaPackageElementFlavor.parseFlavor(a.getFlavor().toString());</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">          if (flavor.matches(adapterFlavor)) {</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (MediaPackageElements.SERIES.eq(a.getFlavor().toString())) {</span>
<span class="fc" id="L312">              addDublinCoreCatalog(series, MediaPackageElements.SERIES, mediaPackage);</span>
            } else {
              try {
<span class="fc" id="L315">                Optional&lt;byte[]&gt; seriesElementData = seriesService.getSeriesElementData(seriesId, adapterFlavor.getType());</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">                if (seriesElementData.isPresent()) {</span>
<span class="fc" id="L317">                  DublinCoreCatalog catalog = DublinCores.read(new ByteArrayInputStream(seriesElementData.get()));</span>
<span class="fc" id="L318">                  addDublinCoreCatalog(catalog, adapterFlavor, mediaPackage);</span>
<span class="fc" id="L319">                } else {</span>
<span class="nc" id="L320">                  logger.warn(&quot;No extended series catalog found for flavor '{}' and series '{}', skip adding catalog&quot;,</span>
<span class="nc" id="L321">                          adapterFlavor.getType(), seriesId);</span>
                }
<span class="nc" id="L323">              } catch (SeriesException e) {</span>
<span class="nc" id="L324">                logger.error(&quot;Unable to load extended series metadata for flavor {}&quot;, adapterFlavor.getType());</span>
<span class="nc" id="L325">                throw new WorkflowOperationException(e);</span>
<span class="fc" id="L326">              }</span>
            }
          }
<span class="fc" id="L329">        }</span>
      }
    }

<span class="fc bfc" id="L333" title="All 2 branches covered.">    if (applyAcl) {</span>
      try {
<span class="fc" id="L335">        AccessControlList acl = seriesService.getSeriesAccessControl(seriesId);</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        if (acl != null)</span>
<span class="fc" id="L337">          authorizationService.setAcl(mediaPackage, AclScope.Series, acl);</span>
<span class="nc" id="L338">      } catch (Exception e) {</span>
<span class="nc" id="L339">        logger.error(&quot;Unable to update series ACL&quot;, e);</span>
<span class="nc" id="L340">        throw new WorkflowOperationException(e);</span>
<span class="fc" id="L341">      }</span>
    }
<span class="fc" id="L343">    return createResult(mediaPackage, Action.CONTINUE);</span>
  }

  /**
   * @param organization
   *          The organization to filter the results with.
   * @return A {@link List} of {@link SeriesCatalogUIAdapter} that provide the metadata to the front end.
   */
  private List&lt;SeriesCatalogUIAdapter&gt; getSeriesCatalogUIAdapters() {
<span class="fc" id="L352">    String organization = securityService.getOrganization().getId();</span>

<span class="fc" id="L354">    List&lt;SeriesCatalogUIAdapter&gt; filteredAdapters = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L356" title="All 2 branches covered.">    for (SeriesCatalogUIAdapter adapter : seriesCatalogUIAdapters) {</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">      if (adapter.handlesOrganization(organization)) {</span>
<span class="fc" id="L358">        filteredAdapters.add(adapter);</span>
      }
<span class="fc" id="L360">    }</span>

<span class="fc" id="L362">    return filteredAdapters;</span>
  }

  private MediaPackage addDublinCoreCatalog(DublinCoreCatalog catalog, MediaPackageElementFlavor flavor,
          MediaPackage mediaPackage) throws WorkflowOperationException {
<span class="fc" id="L367">    try (InputStream in = IOUtils.toInputStream(catalog.toXmlString(), &quot;UTF-8&quot;)) {</span>
<span class="fc" id="L368">      String elementId = UUID.randomUUID().toString();</span>
<span class="fc" id="L369">      URI catalogUrl = workspace.put(mediaPackage.getIdentifier().toString(), elementId, &quot;dublincore.xml&quot;, in);</span>
<span class="fc" id="L370">      logger.info(&quot;Adding catalog with flavor {} to mediapackage {}&quot;, flavor, mediaPackage);</span>
<span class="fc" id="L371">      MediaPackageElement mpe = mediaPackage.add(catalogUrl, MediaPackageElement.Type.Catalog, flavor);</span>
<span class="fc" id="L372">      mpe.setIdentifier(elementId);</span>
<span class="fc" id="L373">      mpe.setChecksum(Checksum.create(ChecksumType.DEFAULT_TYPE, workspace.get(catalogUrl)));</span>
<span class="fc" id="L374">      return mediaPackage;</span>
<span class="nc" id="L375">    } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L376">      throw new WorkflowOperationException(e);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>