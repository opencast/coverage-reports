<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DynamicLoginHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-security-jwt</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.security.jwt</a> &gt; <span class="el_source">DynamicLoginHandler.java</span></div><h1>DynamicLoginHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.security.jwt;

import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.security.impl.jpa.JpaOrganization;
import org.opencastproject.security.impl.jpa.JpaRole;
import org.opencastproject.security.impl.jpa.JpaUserReference;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.userdirectory.api.UserReferenceProvider;

import com.auth0.jwk.JwkException;
import com.auth0.jwt.exceptions.JWTDecodeException;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

import org.apache.commons.lang3.StringUtils;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.util.Assert;


import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

/**
 * Dynamic login handler for JWTs.
 */
<span class="fc" id="L64">public class DynamicLoginHandler implements InitializingBean, JWTLoginHandler {</span>

  /** Logging facility. */
<span class="fc" id="L67">  private static final Logger logger = LoggerFactory.getLogger(DynamicLoginHandler.class);</span>

  /** Spring security's user details manager. */
<span class="fc" id="L70">  private UserDetailsService userDetailsService = null;</span>

  /** User directory service. */
<span class="fc" id="L73">  private UserDirectoryService userDirectoryService = null;</span>

  /** User reference provider. */
<span class="fc" id="L76">  private UserReferenceProvider userReferenceProvider = null;</span>

  /** Security service. */
<span class="fc" id="L79">  private SecurityService securityService = null;</span>

  /** JWKS URL to use for JWT validation (asymmetric algorithms). */
<span class="fc" id="L82">  private String jwksUrl = null;</span>

  /** Number of minutes fetched JWKs will be cached. */
<span class="fc" id="L85">  private int jwksCacheExpiresIn = 60 * 24;</span>

  /** Secret to use for JWT validation (symmetric algorithms). */
<span class="fc" id="L88">  private String secret = null;</span>

  /** Allowed algorithms with which a valid JWT may be signed ('alg' claim). */
<span class="fc" id="L91">  private List&lt;String&gt; expectedAlgorithms = null;</span>

  /** Constraints that the claims of a valid JWT must fulfill. */
<span class="fc" id="L94">  private List&lt;String&gt; claimConstraints = null;</span>

  /** Mapping used to extract the username from the JWT. */
<span class="fc" id="L97">  private String usernameMapping = null;</span>

  /** Mapping used to extract the name from the JWT. */
<span class="fc" id="L100">  private String nameMapping = null;</span>

  /** Mapping used to extract the email from the JWT. */
<span class="fc" id="L103">  private String emailMapping = null;</span>

  /** Whether the built-in schema role mapping should be used. */
<span class="fc" id="L106">  private boolean ocStandardRoleMappings = true;</span>

  /** Mapping used to extract roles from the JWT. */
<span class="fc" id="L109">  private List&lt;String&gt; roleMappings = null;</span>

  /** Mapping used to extract roles from the JWT. */
  private GuavaCachedUrlJwkProvider jwkProvider;

  /** Size of the JWT cache. */
<span class="fc" id="L115">  private int jwtCacheSize = 500;</span>

  /** Number of minutes validated JWTs will be cached before re-validating them. */
<span class="fc" id="L118">  private int jwtCacheExpiresIn = 60;</span>

  /** Cache for validated JWTs. */
  private Cache&lt;String, CachedJWT&gt; cache;

  @Override
  public void afterPropertiesSet() {
<span class="fc" id="L125">    Assert.notNull(userDetailsService, &quot;A UserDetailsService must be set&quot;);</span>
<span class="fc" id="L126">    Assert.notNull(userDirectoryService, &quot;A UserDirectoryService must be set&quot;);</span>
<span class="fc" id="L127">    Assert.notNull(userReferenceProvider, &quot;A UserReferenceProvider must be set&quot;);</span>
<span class="fc" id="L128">    Assert.notNull(securityService, &quot;A SecurityService must be set&quot;);</span>
<span class="fc" id="L129">    Assert.isTrue(StringUtils.isNotBlank(jwksUrl) ^ StringUtils.isNotBlank(secret),</span>
        &quot;Either a JWKS URL or a secret must be set&quot;);
<span class="fc" id="L131">    Assert.notEmpty(expectedAlgorithms, &quot;Expected algorithms must be set&quot;);</span>
<span class="fc" id="L132">    Assert.notEmpty(claimConstraints, &quot;Claim constraints must be set&quot;);</span>
<span class="fc" id="L133">    Assert.notNull(usernameMapping, &quot;User name mapping must be set&quot;);</span>
<span class="fc" id="L134">    Assert.notNull(nameMapping, &quot;Name mapping must be set&quot;);</span>
<span class="fc" id="L135">    Assert.notNull(emailMapping, &quot;Email mapping must be set&quot;);</span>
<span class="pc bpc" id="L136" title="3 of 4 branches missed.">    Assert.isTrue(roleMappings != null || ocStandardRoleMappings,</span>
            &quot;Role mappings must be set if ocStandardRoleMappings is false&quot;);

<span class="pc bpc" id="L139" title="1 of 2 branches missed.">    if (jwksUrl != null) {</span>
<span class="nc" id="L140">      jwkProvider = new GuavaCachedUrlJwkProvider(jwksUrl, jwksCacheExpiresIn, TimeUnit.MINUTES);</span>
    }
<span class="fc" id="L142">    userReferenceProvider.setRoleProvider(new JWTRoleProvider(securityService, userReferenceProvider));</span>
<span class="fc" id="L143">    cache = CacheBuilder.newBuilder()</span>
<span class="fc" id="L144">        .maximumSize(jwtCacheSize)</span>
<span class="fc" id="L145">        .expireAfterWrite(jwtCacheExpiresIn, TimeUnit.MINUTES)</span>
<span class="fc" id="L146">        .build();</span>
<span class="fc" id="L147">  }</span>

  @Override
  public String handleToken(String token) {
    try {
<span class="fc" id="L152">      String signature = extractSignature(token);</span>
<span class="fc" id="L153">      CachedJWT cachedJwt = cache.getIfPresent(signature);</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">      if (cachedJwt == null) {</span>
        // JWT hasn't been cached before, so validate all claims
<span class="fc" id="L157">        DecodedJWT jwt = decodeAndValidate(token);</span>
<span class="fc" id="L158">        String username = extractUsername(jwt);</span>

        try {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">          if (userDetailsService.loadUserByUsername(username) != null) {</span>
<span class="fc" id="L162">            existingUserLogin(username, jwt);</span>
          }
<span class="fc" id="L164">        } catch (UsernameNotFoundException e) {</span>
<span class="fc" id="L165">          newUserLogin(username, jwt);</span>
<span class="fc" id="L166">        }</span>

<span class="fc" id="L168">        userDirectoryService.invalidate(username);</span>
<span class="fc" id="L169">        cache.put(jwt.getSignature(), new CachedJWT(jwt, username));</span>
<span class="fc" id="L170">        return username;</span>
      } else {
        // JWT has been cached before, so only check if it has expired
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (cachedJwt.hasExpired()) {</span>
<span class="fc" id="L174">          cache.invalidate(signature);</span>
<span class="fc" id="L175">          throw new JWTVerificationException(&quot;JWT token is not valid anymore&quot;);</span>
        }
<span class="fc" id="L177">        logger.debug(&quot;Using decoded and validated JWT from cache&quot;);</span>
<span class="fc" id="L178">        return cachedJwt.getUsername();</span>
      }
<span class="fc" id="L180">    } catch (JWTVerificationException | JwkException exception) {</span>
<span class="fc" id="L181">      logger.debug(exception.getMessage());</span>
    }

<span class="fc" id="L184">    return null;</span>
  }

  /**
   * Decodes and validates a JWT.
   *
   * @param token The JWT string.
   * @return The decoded JWT.
   * @throws JwkException If the JWT fails to be validated.
   */
  private DecodedJWT decodeAndValidate(String token) throws JwkException {
    DecodedJWT jwt;

<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (jwksUrl != null) {</span>
<span class="fc" id="L198">      jwt = JWTVerifier.verify(token, jwkProvider, claimConstraints);</span>
    } else {
<span class="fc" id="L200">      jwt = JWTVerifier.verify(token, secret, claimConstraints);</span>
    }

<span class="fc bfc" id="L203" title="All 2 branches covered.">    if (!expectedAlgorithms.contains(jwt.getAlgorithm())) {</span>
<span class="fc" id="L204">      throw new JWTVerificationException(</span>
<span class="fc" id="L205">          &quot;JWT token was signed with an unexpected algorithm '&quot; + jwt.getAlgorithm() + &quot;'&quot;</span>
      );
    }

<span class="fc" id="L209">    return jwt;</span>
  }

  /**
   * Extracts the signature from a JWT.
   *
   * @param token The JWT string.
   * @return The JWT's signature.
   */
  private String extractSignature(String token) {
<span class="fc" id="L219">    String[] parts = token.split(&quot;\\.&quot;);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">    if (parts.length != 3) {</span>
<span class="fc" id="L221">      throw new JWTDecodeException(&quot;Given token is not in a valid JWT format&quot;);</span>
    }
<span class="fc" id="L223">    return parts[2];</span>
  }

  /**
   * Extracts the username from a decoded and validated JWT.
   *
   * @param jwt The decoded JWT.
   * @return The username.
   */
  private String extractUsername(DecodedJWT jwt) {
<span class="fc" id="L233">    String username = evaluateMapping(jwt, usernameMapping);</span>
<span class="fc" id="L234">    Assert.isTrue(StringUtils.isNotBlank(username), &quot;Extracted username is blank&quot;);</span>
<span class="fc" id="L235">    return username;</span>
  }

  /**
   * Extracts the name from a decoded and validated JWT.
   *
   * @param jwt The decoded JWT.
   * @return The name.
   */
  private String extractName(DecodedJWT jwt) {
<span class="fc" id="L245">    String name = evaluateMapping(jwt, nameMapping);</span>
<span class="fc" id="L246">    Assert.isTrue(StringUtils.isNotBlank(name), &quot;Extracted name is blank&quot;);</span>
<span class="fc" id="L247">    return name;</span>
  }

  /**
   * Extracts the email from a decoded and validated JWT.
   *
   * @param jwt The decoded JWT.
   * @return The email.
   */
  private String extractEmail(DecodedJWT jwt) {
<span class="fc" id="L257">    String email = evaluateMapping(jwt, emailMapping);</span>
<span class="fc" id="L258">    Assert.isTrue(StringUtils.isNotBlank(email), &quot;Extracted email is blank&quot;);</span>
<span class="fc" id="L259">    return email;</span>
  }

  /**
   * Extracts the roles from a decoded and validated JWT.
   *
   * @param jwt The decoded JWT.
   * @return The roles.
   */
  private Set&lt;JpaRole&gt; extractRoles(DecodedJWT jwt) {
<span class="fc" id="L269">    JpaOrganization organization = fromOrganization(securityService.getOrganization());</span>
<span class="fc" id="L270">    Set&lt;JpaRole&gt; roles = new HashSet&lt;&gt;();</span>
<span class="fc" id="L271">    Consumer&lt;String&gt; addRole = (String role) -&gt; {</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(role)) {</span>
<span class="fc" id="L273">        roles.add(new JpaRole(role, organization));</span>
      }
<span class="fc" id="L275">    };</span>

    // Evaluate the standard role mapping if specified
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">    if (ocStandardRoleMappings) {</span>
      // Read `role` claim
      try {
<span class="fc" id="L281">        var rolesClaim = jwt.getClaim(&quot;roles&quot;);</span>
<span class="pc bpc" id="L282" title="2 of 4 branches missed.">        if (rolesClaim != null &amp;&amp; !rolesClaim.isNull()) {</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">          for (String r : rolesClaim.asArray(String.class)) {</span>
<span class="fc" id="L284">            addRole.accept(r);</span>
          }
        }
<span class="nc" id="L287">      } catch (JWTDecodeException e) {</span>
<span class="nc" id="L288">        logger.debug(&quot;claim 'roles' is not an array of strings, ignoring&quot;);</span>
<span class="fc" id="L289">      }</span>

      // Read `oc` claim
      try {
<span class="fc" id="L293">        var ocClaim = jwt.getClaim(&quot;oc&quot;);</span>
<span class="pc bpc" id="L294" title="2 of 4 branches missed.">        if (ocClaim != null &amp;&amp; !ocClaim.isNull()) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">          for (var entry : ocClaim.asMap().entrySet()) {</span>
<span class="nc" id="L296">            var key = entry.getKey();</span>
<span class="nc" id="L297">            var parts = key.split(&quot;:&quot;, 2);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (parts.length != 2) {</span>
<span class="nc" id="L299">              logger.debug(&quot;key in 'oc' claim does not start with 'x:' -&gt; ignoring&quot;);</span>
<span class="nc" id="L300">              continue;</span>
            }
<span class="nc" id="L302">            var type = parts[0];</span>
<span class="nc" id="L303">            var id = parts[1];</span>

            try {
<span class="nc bnc" id="L306" title="All 2 branches missed.">              for (var actionObj : (List&lt;?&gt;) entry.getValue()) {</span>
<span class="nc" id="L307">                var action = (String) actionObj;</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">                if (action.isBlank()) {</span>
<span class="nc" id="L309">                  continue;</span>
                }

<span class="nc bnc" id="L312" title="All 2 branches missed.">                if (type.equals(&quot;e&quot;)) {</span>
<span class="nc" id="L313">                  addRole.accept(SecurityUtil.getEpisodeRoleId(id, action));</span>
                } else {
<span class="nc" id="L315">                  logger.debug(&quot;in 'oc' claim: granting access to item type '{}' is not yet supported&quot;, type);</span>
                }
<span class="nc" id="L317">              }</span>
<span class="nc" id="L318">            } catch (ClassCastException e) {</span>
<span class="nc" id="L319">              logger.debug(&quot;value in 'oc' claim is not a string array -&gt; ignoring&quot;);</span>
<span class="nc" id="L320">              continue;</span>
<span class="nc" id="L321">            }</span>
<span class="nc" id="L322">          }</span>
        }
<span class="nc" id="L324">      } catch (JWTDecodeException e) {</span>
<span class="nc" id="L325">        logger.debug(&quot;claim 'oc' is not an array of strings, ignoring&quot;);</span>
<span class="fc" id="L326">      }</span>
    }

<span class="pc bpc" id="L329" title="1 of 4 branches missed.">    for (String mapping : (roleMappings == null ? new ArrayList&lt;String&gt;() : roleMappings)) {</span>
<span class="fc" id="L330">      ExpressionParser parser = new SpelExpressionParser();</span>
<span class="fc" id="L331">      Expression exp = parser.parseExpression(mapping);</span>
<span class="fc" id="L332">      Object value = exp.getValue(jwt.getClaims());</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">      if (value != null) {</span>
        // We allow the expression to either return a string directly, or a list/array of strings.
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if (value instanceof String) {</span>
<span class="fc" id="L336">          addRole.accept((String) value);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        } else if (value.getClass().isArray()) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">          for (var role : (Object[]) value) {</span>
<span class="nc" id="L339">            addRole.accept((String) role);</span>
          }
        } else {
<span class="nc bnc" id="L342" title="All 2 branches missed.">          for (var role : (List&lt;?&gt;) value) {</span>
<span class="nc" id="L343">            addRole.accept((String) role);</span>
<span class="nc" id="L344">          }</span>
        }
      }
<span class="fc" id="L347">    }</span>
<span class="fc" id="L348">    Assert.notEmpty(roles, &quot;No roles could be extracted&quot;);</span>
<span class="fc" id="L349">    return roles;</span>
  }

  /**
   * Evaluates a mapping given in SpEL on a decoded JWT.
   *
   * @param jwt The decoded JWT.
   * @param mapping The mapping.
   *
   * @return The string evaluated from the mapping.
   */
  private String evaluateMapping(DecodedJWT jwt, String mapping) {
<span class="fc" id="L361">    ExpressionParser parser = new SpelExpressionParser();</span>
<span class="fc" id="L362">    Expression exp = parser.parseExpression(mapping);</span>
<span class="fc" id="L363">    return exp.getValue(jwt.getClaims(), String.class);</span>
  }

  /**
   * Handles a new user login.
   *
   * @param username The username.
   * @param jwt The decoded JWT.
   */
  public void newUserLogin(String username, DecodedJWT jwt) {
    // Create a new user reference
<span class="fc" id="L374">    JpaUserReference userReference = new JpaUserReference(username, extractName(jwt), extractEmail(jwt), MECH_JWT,</span>
<span class="fc" id="L375">        new Date(), fromOrganization(securityService.getOrganization()), extractRoles(jwt));</span>

<span class="fc" id="L377">    logger.debug(&quot;JWT user '{}' logged in for the first time&quot;, username);</span>
<span class="fc" id="L378">    userReferenceProvider.addUserReference(userReference, MECH_JWT);</span>
<span class="fc" id="L379">  }</span>

  /**
   * Handles an existing user login.
   *
   * @param username The username.
   * @param jwt The decoded JWT.
   */
  public void existingUserLogin(String username, DecodedJWT jwt) {
<span class="fc" id="L388">    Organization organization = securityService.getOrganization();</span>

    // Load the user reference
<span class="fc" id="L391">    JpaUserReference userReference = userReferenceProvider.findUserReference(username, organization.getId());</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">    if (userReference == null) {</span>
<span class="nc" id="L393">      throw new UsernameNotFoundException(&quot;User reference '&quot; + username + &quot;' was not found&quot;);</span>
    }

    // Update the reference
<span class="fc" id="L397">    userReference.setName(extractName(jwt));</span>
<span class="fc" id="L398">    userReference.setEmail(extractEmail(jwt));</span>
<span class="fc" id="L399">    userReference.setLastLogin(new Date());</span>
<span class="fc" id="L400">    userReference.setRoles(extractRoles(jwt));</span>

<span class="fc" id="L402">    logger.debug(&quot;JWT user '{}' logged in&quot;, username);</span>
<span class="fc" id="L403">    userReferenceProvider.updateUserReference(userReference);</span>
<span class="fc" id="L404">  }</span>

  /**
   * Converts a {@link Organization} object into a {@link JpaOrganization} object.
   *
   * @param org The {@link Organization} object.
   * @return The corresponding {@link JpaOrganization} object.
   */
  private JpaOrganization fromOrganization(Organization org) {
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">    if (org instanceof JpaOrganization) {</span>
<span class="nc" id="L414">      return (JpaOrganization) org;</span>
    }

<span class="fc" id="L417">    return new JpaOrganization(org.getId(), org.getName(), org.getServers(), org.getAdminRole(), org.getAnonymousRole(),</span>
<span class="fc" id="L418">        org.getProperties());</span>
  }

  /**
   * Setter for the user details service.
   *
   * @param userDetailsService The user details service.
   */
  @Reference
  public void setUserDetailsService(UserDetailsService userDetailsService) {
<span class="fc" id="L428">    this.userDetailsService = userDetailsService;</span>
<span class="fc" id="L429">  }</span>

  /**
   * Setter for the user directory service.
   *
   * @param userDirectoryService The user directory service.
   */
  @Reference
  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {
<span class="fc" id="L438">    this.userDirectoryService = userDirectoryService;</span>
<span class="fc" id="L439">  }</span>

  /**
   * Setter for the security service.
   *
   * @param securityService The security service.
   */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L448">    this.securityService = securityService;</span>
<span class="fc" id="L449">  }</span>

  /**
   * Setter for the user reference provider.
   *
   * @param userReferenceProvider The user reference provider.
   */
  @Reference
  public void setUserReferenceProvider(UserReferenceProvider userReferenceProvider) {
<span class="fc" id="L458">    this.userReferenceProvider = userReferenceProvider;</span>
<span class="fc" id="L459">  }</span>

  /**
   * Setter for the JWKS URL.
   *
   * @param jwksUrl The JWKS URL.
   */
  public void setJwksUrl(String jwksUrl) {
<span class="fc" id="L467">    this.jwksUrl = jwksUrl;</span>
<span class="fc" id="L468">  }</span>

  /**
   * Setter for the JWKS cache expiration.
   *
   * @param jwksCacheExpiresIn The number of minutes after which a cached JWKS expires.
   */
  public void setJwksCacheExpiresIn(int jwksCacheExpiresIn) {
<span class="nc" id="L476">    this.jwksCacheExpiresIn = jwksCacheExpiresIn;</span>
<span class="nc" id="L477">  }</span>

  /**
   * Setter for the secret used for JWT validation.
   *
   * @param secret The secret.
   */
  public void setSecret(String secret) {
<span class="fc" id="L485">    this.secret = secret;</span>
<span class="fc" id="L486">  }</span>

  /**
   * Setter for the expected algorithms.
   *
   * @param expectedAlgorithms The expected algorithms.
   */
  public void setExpectedAlgorithms(List&lt;String&gt; expectedAlgorithms) {
<span class="fc" id="L494">    this.expectedAlgorithms = expectedAlgorithms;</span>
<span class="fc" id="L495">  }</span>

  /**
   * Setter for the claim constraints.
   *
   * @param claimConstraints The claim constraints.
   */
  public void setClaimConstraints(List&lt;String&gt; claimConstraints) {
<span class="fc" id="L503">    this.claimConstraints = claimConstraints;</span>
<span class="fc" id="L504">  }</span>

  /**
   * Setter for the username mapping.
   * @param usernameMapping The username mapping.
   */
  public void setUsernameMapping(String usernameMapping) {
<span class="fc" id="L511">    this.usernameMapping = usernameMapping;</span>
<span class="fc" id="L512">  }</span>

  /**
   * Setter for the name mapping.
   *
   * @param nameMapping The name mapping.
   */
  public void setNameMapping(String nameMapping) {
<span class="fc" id="L520">    this.nameMapping = nameMapping;</span>
<span class="fc" id="L521">  }</span>

  /**
   * Setter for the email mapping.
   * @param emailMapping The email mapping.
   */
  public void setEmailMapping(String emailMapping) {
<span class="fc" id="L528">    this.emailMapping = emailMapping;</span>
<span class="fc" id="L529">  }</span>

  public void setOcStandardRoleMappings(boolean ocStandardRoleMappings) {
<span class="nc" id="L532">    this.ocStandardRoleMappings = ocStandardRoleMappings;</span>
<span class="nc" id="L533">  }</span>

  /**
   * Setter for the role mappings.
   *
   * @param roleMappings The role mappings.
   */
  public void setRoleMappings(List&lt;String&gt; roleMappings) {
<span class="fc" id="L541">    this.roleMappings = roleMappings;</span>
<span class="fc" id="L542">  }</span>

  /**
   * Setter for the JWT cache size.
   *
   * @param jwtCacheSize The JWT cache size.
   */
  public void setJwtCacheSize(int jwtCacheSize) {
<span class="nc" id="L550">    this.jwtCacheSize = jwtCacheSize;</span>
<span class="nc" id="L551">  }</span>

  /**
   * Setter for the JWT cache expiration.
   *
   * @param jwtCacheExpiresIn The number of minutes after which a cached JWT expires.
   */
  public void setJwtCacheExpiresIn(int jwtCacheExpiresIn) {
<span class="nc" id="L559">    this.jwtCacheExpiresIn = jwtCacheExpiresIn;</span>
<span class="nc" id="L560">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>