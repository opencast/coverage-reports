<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WowzaUrlSigningProvider.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-urlsigning-service-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.security.urlsigning.provider.impl</a> &gt; <span class="el_source">WowzaUrlSigningProvider.java</span></div><h1>WowzaUrlSigningProvider.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.security.urlsigning.provider.impl;

import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.urlsigning.WowzaResourceStrategyImpl;
import org.opencastproject.security.urlsigning.exception.UrlSigningException;
import org.opencastproject.security.urlsigning.provider.UrlSigningProvider;
import org.opencastproject.urlsigning.common.Policy;
import org.opencastproject.urlsigning.common.ResourceStrategy;

import org.apache.commons.lang3.exception.ExceptionUtils;
import org.osgi.service.cm.ManagedService;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.security.MessageDigest;
import java.util.Base64;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

@Component(
    immediate = true,
    service = { ManagedService.class, UrlSigningProvider.class },
    property = {
        &quot;service.description=Wowza Url Signing Provider&quot;,
        &quot;service.pid=org.opencastproject.security.urlsigning.provider.impl.WowzaUrlSigningProvider&quot;
    }
)
<span class="fc" id="L52">public class WowzaUrlSigningProvider extends AbstractUrlSigningProvider {</span>

<span class="fc" id="L54">  private static final Logger logger = LoggerFactory.getLogger(WowzaUrlSigningProvider.class);</span>

  /** The Wowza resource strategy to use to convert from the base url to a resource url. */
<span class="fc" id="L57">  private ResourceStrategy resourceStrategy = new WowzaResourceStrategyImpl();</span>

  @Override
  public Logger getLogger() {
<span class="fc" id="L61">    return logger;</span>
  }

  @Override
  public ResourceStrategy getResourceStrategy() {
<span class="fc" id="L66">    return resourceStrategy;</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L71">    return &quot;Wowza URL Signing Provider&quot;;</span>
  }

  /**
   * @param policy
   *             the policy
   * @return the signed url
   */
  @Override
  public String sign(Policy policy) throws UrlSigningException {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">    if (!accepts(policy.getBaseUrl())) {</span>
<span class="nc" id="L82">      throw UrlSigningException.urlNotSupported();</span>
    }

    try {
<span class="fc" id="L86">      URI uri = new URI(policy.getBaseUrl());</span>

      /*
        For backward compatibility, but i can not see how this could work.
        According to the documentation 
        &quot;https://www.wowza.com/docs/how-to-protect-streaming-using-securetoken-in-wowza-streaming-engine&quot; 
        if you using token v1 we need a TEA implimentation.
      */
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">      if (&quot;rtmp&quot;.equals((uri.getScheme()))) {</span>
<span class="nc" id="L95">        return super.sign(policy);</span>
      }

        // Get the key that matches this URI since there must be one that matches as the base url has been accepted.
<span class="fc" id="L99">      Key key = getKey(policy.getBaseUrl());</span>

<span class="fc" id="L101">      policy.setResourceStrategy(getResourceStrategy());</span>

<span class="pc bpc" id="L103" title="1 of 2 branches missed.">      if (!key.getSecret().contains(&quot;@&quot;)) {</span>
<span class="nc" id="L104">        getLogger().error(&quot;Given key not valid. (prefix@secret)&quot;);</span>

<span class="nc" id="L106">        throw new Exception(&quot;Given key not valid. (prefix@secret)&quot;);</span>
      }
<span class="fc" id="L108">      String[] wowzaKeyPair = key.getSecret().split(&quot;@&quot;);</span>
<span class="fc" id="L109">      String wowzaPrefix = wowzaKeyPair[0];</span>
<span class="fc" id="L110">      String wowzaSecret = wowzaKeyPair[1];</span>

<span class="fc" id="L112">      String newUri = new URI(uri.getScheme(), null, uri.getHost(), uri.getPort(), uri.getPath(),</span>
<span class="fc" id="L113">          addSignutureToRequest(policy, wowzaPrefix, wowzaSecret), null).toString();</span>
<span class="fc" id="L114">      return newUri;</span>
<span class="nc" id="L115">    } catch (Exception e) {</span>
<span class="nc" id="L116">      getLogger().error(&quot;Unable to create signed URL because {}&quot;, ExceptionUtils.getStackTrace(e));</span>
<span class="nc" id="L117">      throw new UrlSigningException(e);</span>
    }
  }

  /**
   * @param policy
   *             the policy
   * @param encryptionKeyId
   *             the encription key id
   * @param encryptionKey
   *             the encription key
   * @return true
   *             if the url is excluded, false otherwise
   * @exception Exception
   *             if something goes bad
   */
  private String addSignutureToRequest(Policy policy, String encryptionKeyId, String encryptionKey) throws Exception  {
    final String startTime;
<span class="fc" id="L135">    final String endTime = Long.toString(policy.getValidUntil().getMillis() / 1000);</span>
    final String ip;

<span class="fc" id="L138">    String baseUrl = policy.getBaseUrl();</span>
<span class="fc" id="L139">    URI url = new URI(policy.getBaseUrl());</span>
<span class="fc" id="L140">    String resource = policy.getResource();</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">    if (policy.getClientIpAddress().isPresent()) {</span>
      // The ip comes with a slash: /192.168.1.2
<span class="fc" id="L143">      String ipAux = policy.getClientIpAddress().get().toString();</span>
<span class="fc" id="L144">      ipAux = ipAux.substring(1, ipAux.length());</span>
<span class="fc" id="L145">      ip = ipAux;</span>
<span class="fc" id="L146">    } else {</span>
<span class="nc" id="L147">      ip = &quot;&quot;;</span>
    }

<span class="pc bpc" id="L150" title="1 of 2 branches missed.">    if (policy.getValidFrom().isPresent()) {</span>
<span class="fc" id="L151">      startTime = Long.toString(policy.getValidFrom().get().getMillis() / 1000);</span>
    } else {
<span class="nc" id="L153">      startTime = &quot;&quot;;</span>
    }

<span class="fc" id="L156">    String queryStringParameters = new String();</span>

<span class="fc" id="L158">    queryStringParameters += encryptionKeyId + &quot;endtime=&quot; + endTime;</span>

<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (!&quot;&quot;.equals(startTime)) {</span>
<span class="fc" id="L161">      queryStringParameters += &quot;&amp;&quot; + encryptionKeyId + &quot;starttime=&quot; + startTime;</span>
    }

<span class="pc bpc" id="L164" title="1 of 2 branches missed.">    if (url.getQuery() != null) {</span>
<span class="fc" id="L165">      String query = url.getQuery();</span>
<span class="fc" id="L166">      String[] params = query.split(&quot;&amp;&quot;);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">      for (String param : params) {</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (param.contains(&quot;=&quot;)) {</span>
<span class="fc" id="L169">          String[] keyValue = param.split(&quot;=&quot;);</span>
<span class="fc" id="L170">          queryStringParameters += &quot;&amp;&quot; + encryptionKeyId + keyValue[0] + &quot;=&quot; + keyValue[1];</span>
        }
      }
    }

<span class="fc" id="L175">    queryStringParameters += &quot;&amp;&quot; + encryptionKeyId + &quot;hash=&quot; + generateHash(baseUrl,</span>
        resource, ip, encryptionKeyId, encryptionKey, startTime, endTime);

<span class="fc" id="L178">    return queryStringParameters;</span>
  }

  /**
   * @param baseUrl
   *             the base url
   * @param resource
   *             the resource
   * @param ip
   *             the ip
   * @param encryptionKeyId
   *             the encription key id
   * @param encryptionKey
   *             the encription key
   * @param startTime
   *             start time
   * @param endTime
   *             end time
   * @return the generated hashed
   * @exception Exception
   *             if something goes bad
   */
  private String generateHash(String baseUrl, String resource, String ip,
      String encryptionKeyId, String encryptionKey, String startTime, String endTime) throws Exception {
<span class="fc" id="L202">    String urlToHash = resource + &quot;?&quot;;</span>

<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if (!&quot;&quot;.equals(ip)) {</span>
<span class="fc" id="L205">      urlToHash += ip + &quot;&amp;&quot; + encryptionKey;</span>
    } else {
<span class="nc" id="L207">      urlToHash += encryptionKey;</span>
    }

<span class="fc" id="L210">    SortedMap&lt;String, String&gt; arguments = new TreeMap&lt;&gt;();</span>

<span class="fc" id="L212">    arguments.put(encryptionKeyId + &quot;endtime&quot;, endTime);</span>

<span class="pc bpc" id="L214" title="1 of 2 branches missed.">    if (!&quot;&quot;.equals(startTime)) {</span>
<span class="fc" id="L215">      arguments.put(encryptionKeyId + &quot;starttime&quot;, startTime);</span>
    }

<span class="fc" id="L218">    String query = new URI(baseUrl).getQuery();</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">    if (null == query) {</span>
<span class="nc" id="L220">      query = &quot;&quot;;</span>
    }

<span class="fc" id="L223">    String[] params = query.split(&quot;&amp;&quot;);</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">    for (String param : params) {</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">      if (param.contains(&quot;=&quot;)) {</span>
<span class="fc" id="L226">        String[] keyValue = param.split(&quot;=&quot;);</span>
<span class="fc" id="L227">        arguments.put(encryptionKeyId + keyValue[0], keyValue[1]);</span>
      }
    }

<span class="fc bfc" id="L231" title="All 2 branches covered.">    for (Map.Entry&lt;String,String&gt; entry : arguments.entrySet()) {</span>
<span class="fc" id="L232">      String value = entry.getValue();</span>
<span class="fc" id="L233">      String key = entry.getKey();</span>
<span class="fc" id="L234">      urlToHash += &quot;&amp;&quot; + key + &quot;=&quot; + value;</span>
<span class="fc" id="L235">    }</span>

<span class="fc" id="L237">    MessageDigest md = MessageDigest.getInstance(&quot;SHA-256&quot;);</span>
<span class="fc" id="L238">    byte[] messageDigest = md.digest(urlToHash.getBytes());</span>
<span class="fc" id="L239">    String base64Hash = Base64.getEncoder().encodeToString(messageDigest);</span>

<span class="fc" id="L241">    base64Hash = base64Hash.replaceAll(&quot;\\+&quot;, &quot;-&quot;);</span>
<span class="fc" id="L242">    base64Hash = base64Hash.replaceAll(&quot;/&quot;, &quot;_&quot;);</span>

<span class="fc" id="L244">    return base64Hash;</span>
  }

  @Reference
  @Override
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L250">    super.setSecurityService(securityService);</span>
<span class="fc" id="L251">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>