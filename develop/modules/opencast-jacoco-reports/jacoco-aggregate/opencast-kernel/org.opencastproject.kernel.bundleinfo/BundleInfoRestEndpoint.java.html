<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BundleInfoRestEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-kernel</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.kernel.bundleinfo</a> &gt; <span class="el_source">BundleInfoRestEndpoint.java</span></div><h1>BundleInfoRestEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.kernel.bundleinfo;

import static javax.ws.rs.core.MediaType.APPLICATION_JSON;
import static javax.ws.rs.core.MediaType.TEXT_PLAIN_TYPE;
import static org.opencastproject.util.EqualsUtil.ne;
import static org.opencastproject.util.Jsons.arr;
import static org.opencastproject.util.Jsons.obj;
import static org.opencastproject.util.Jsons.p;
import static org.opencastproject.util.Jsons.stringVal;
import static org.opencastproject.util.RestUtil.R.notFound;
import static org.opencastproject.util.RestUtil.R.ok;
import static org.opencastproject.util.data.Collections.set;
import static org.opencastproject.util.data.Collections.toArray;
import static org.opencastproject.util.data.Monadics.mlist;

import org.opencastproject.util.Jsons;
import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Monadics;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.functions.Functions;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;

import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Set;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.DELETE;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Response;

/** Bundle information via REST. */
@RestService(
  name = &quot;systemInfo&quot;,
  title = &quot;System Bundle Info&quot;,
  notes = { &quot;This is used to display the version information on the login page.&quot; },
  abstractText = &quot;The system bundle info endpoint yields information about the running OSGi bundles of Opencast.&quot;)
<span class="fc" id="L70">public abstract class BundleInfoRestEndpoint {</span>

<span class="fc" id="L72">  private static final Logger logger = LoggerFactory.getLogger(BundleInfoRestEndpoint.class);</span>

  private static final String DEFAULT_BUNDLE_PREFIX = &quot;opencast&quot;;

  protected abstract BundleInfoDb getDb();

<span class="fc" id="L78">  private long lastModified = 0;</span>

  @Activate
  public void activate(ComponentContext cc) {
<span class="nc" id="L82">    lastModified = cc.getBundleContext().getBundle().getLastModified();</span>
<span class="nc" id="L83">  }</span>

  @GET
  // path prefix &quot;bundles&quot; is contained here and not in the path annotation of the class
  // See https://opencast.jira.com/browse/MH-9768
  @Path(&quot;bundles/list&quot;)
  @Produces(APPLICATION_JSON)
  @RestQuery(
    name = &quot;list&quot;,
    description = &quot;Return a list of all running bundles on the whole cluster.&quot;,
    responses = {
      @RestResponse(description = &quot;A list of bundles.&quot;, responseCode = HttpServletResponse.SC_OK) },
    returnDescription = &quot;The search results, expressed as xml or json.&quot;)
  public Response getVersions() {
<span class="fc" id="L97">    final Monadics.ListMonadic&lt;Jsons.Val&gt; bundleInfos = mlist(getDb().getBundles()).map(</span>
<span class="fc" id="L98">            Functions.&lt;BundleInfo, Jsons.Val&gt; co(bundleInfo));</span>
<span class="fc" id="L99">    return ok(obj(p(&quot;bundleInfos&quot;, arr(bundleInfos)), p(&quot;count&quot;, bundleInfos.value().size())));</span>
  }

  /** Return true if all bundles have the same bundle version and build number. */
  @GET
  @Path(&quot;bundles/check&quot;)
  @RestQuery(
    name = &quot;check&quot;,
    description = &quot;Check if all bundles throughout the cluster have the same OSGi bundle version and build number.&quot;,
    restParameters = {
      @RestParameter(
        name = &quot;prefix&quot;,
        description = &quot;The bundle name prefixes to check. Defaults to '&quot; + DEFAULT_BUNDLE_PREFIX + &quot;'.&quot;,
        isRequired = false,
        defaultValue = DEFAULT_BUNDLE_PREFIX,
        type = RestParameter.Type.STRING) },
    responses = {
      @RestResponse(description = &quot;true/false&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;cannot find any bundles with the given prefix&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) },
    returnDescription = &quot;The search results, expressed as xml or json.&quot;)
  public Response checkBundles(@DefaultValue(DEFAULT_BUNDLE_PREFIX) @QueryParam(&quot;prefix&quot;) List&lt;String&gt; prefixes) {
<span class="fc" id="L120">    return withBundles(prefixes, new Function&lt;List&lt;BundleInfo&gt;, Response&gt;() {</span>
      @Override
      public Response apply(List&lt;BundleInfo&gt; infos) {
<span class="fc" id="L123">        final String bundleVersion = infos.get(0).getBundleVersion();</span>
<span class="fc" id="L124">        final Option&lt;String&gt; buildNumber = infos.get(0).getBuildNumber();</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        for (BundleInfo a : infos) {</span>
<span class="fc bfc" id="L126" title="All 4 branches covered.">          if (ne(a.getBundleVersion(), bundleVersion) || ne(a.getBuildNumber(), buildNumber))</span>
<span class="fc" id="L127">            return ok(TEXT_PLAIN_TYPE, &quot;false&quot;);</span>
<span class="fc" id="L128">        }</span>
<span class="fc" id="L129">        return ok(TEXT_PLAIN_TYPE, &quot;true&quot;);</span>
      }
    });
  }

  /** Return the common version of all bundles matching the given prefix. */
  @GET
  @Path(&quot;bundles/version&quot;)
  @Produces(APPLICATION_JSON)
  @RestQuery(
    name = &quot;bundleVersion&quot;,
    description = &quot;Return the common OSGi build version and build number of all bundles matching the given prefix.&quot;,
    restParameters = {
      @RestParameter(
        name = &quot;prefix&quot;,
        description = &quot;The bundle name prefixes to check. Defaults to '&quot; + DEFAULT_BUNDLE_PREFIX + &quot;'.&quot;,
        isRequired = false,
        defaultValue = DEFAULT_BUNDLE_PREFIX,
        type = RestParameter.Type.STRING) },
    responses = {
      @RestResponse(description = &quot;Version structure&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;No bundles with the given prefix&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) },
    returnDescription = &quot;The search results as json.&quot;)
  public Response getBundleVersion(@DefaultValue(DEFAULT_BUNDLE_PREFIX) @QueryParam(&quot;prefix&quot;) List&lt;String&gt; prefixes) {
<span class="fc" id="L153">    return withBundles(prefixes, new Function&lt;List&lt;BundleInfo&gt;, Response&gt;() {</span>
      @Override
      public Response apply(List&lt;BundleInfo&gt; infos) {
<span class="fc" id="L156">        final Set&lt;BundleVersion&gt; versions = set();</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        for (BundleInfo bundle : infos) {</span>
<span class="fc" id="L158">          versions.add(bundle.getVersion());</span>
<span class="fc" id="L159">        }</span>
<span class="fc" id="L160">        final BundleInfo example = infos.get(0);</span>
<span class="pc bpc" id="L161" title="1 of 3 branches missed.">        switch (versions.size()) {</span>
          case 0:
            // no versions...
<span class="nc" id="L164">            throw new Error(&quot;bug&quot;);</span>
          case 1:
            // all versions align
<span class="fc" id="L167">            return ok(obj(p(&quot;consistent&quot;, true))</span>
<span class="fc" id="L168">                .append(fullVersionJson.apply(example.getVersion()))</span>
<span class="fc" id="L169">                .append(obj(p(&quot;last-modified&quot;, lastModified))));</span>
          default:
            // multiple versions found
<span class="fc" id="L172">            return ok(obj(p(&quot;consistent&quot;, false),</span>
<span class="fc" id="L173">                          p(&quot;versions&quot;,</span>
<span class="fc" id="L174">                            arr(mlist(versions.iterator())</span>
<span class="fc" id="L175">                                    .map(Functions.&lt;BundleVersion, Jsons.Val&gt; co(fullVersionJson))))));</span>
        }
      }
    });
  }

  @DELETE
  @Path(&quot;bundles/host&quot;)
  @RestQuery(
          name = &quot;clearHost&quot;,
          description = &quot;Removes the tracked bundles for a host. This is done automatically when you shut down &quot;
          + &quot;Opencast. But this endpoint can be used to force this in case e.g. a machine got dropped. Make sure the &quot;
          + &quot;host is actually gone! The database will be automatically rebuilt when Opencast on that host is &quot;
          + &quot;(re)started.&quot;,
          restParameters = {
                  @RestParameter(
                          name = &quot;host&quot;,
                          description = &quot;The name of the host to clear&quot;,
                          isRequired = true,
                          type = RestParameter.Type.STRING,
                          defaultValue = &quot;&quot;) },
          responses = {
                  @RestResponse(description = &quot;Version structure&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT) },
          returnDescription = &quot;No data is returned.&quot;)
  public Response clearHost(@QueryParam(&quot;host&quot;) String host) {
<span class="nc" id="L200">    logger.debug(&quot;Removing tracked bundles of host: {}&quot;, host);</span>
<span class="nc" id="L201">    getDb().clear(host);</span>
<span class="nc" id="L202">    return Response.noContent().build();</span>
  }

<span class="fc" id="L205">  public static final Function&lt;BundleVersion, Jsons.Obj&gt; fullVersionJson = new Function&lt;BundleVersion, Jsons.Obj&gt;() {</span>
    @Override
    public Jsons.Obj apply(BundleVersion version) {
<span class="fc" id="L208">      return obj(p(&quot;version&quot;, version.getBundleVersion()), p(&quot;buildNumber&quot;, version.getBuildNumber().map(stringVal)));</span>
    }
  };

  public static Jsons.Obj bundleInfoJson(BundleInfo bundle) {
<span class="fc" id="L213">    return obj(p(&quot;host&quot;, bundle.getHost()), p(&quot;bundleSymbolicName&quot;, bundle.getBundleSymbolicName()),</span>
<span class="fc" id="L214">            p(&quot;bundleId&quot;, bundle.getBundleId())).append(fullVersionJson.apply(bundle.getVersion()));</span>
  }

<span class="fc" id="L217">  public static final Function&lt;BundleInfo, Jsons.Obj&gt; bundleInfo = new Function&lt;BundleInfo, Jsons.Obj&gt;() {</span>
    @Override
    public Jsons.Obj apply(BundleInfo bundle) {
<span class="fc" id="L220">      return bundleInfoJson(bundle);</span>
    }
  };

  /** Run &lt;code&gt;f&lt;/code&gt; if there is at least one bundle matching the given prefixes. */
  private Response withBundles(List&lt;String&gt; prefixes, Function&lt;List&lt;BundleInfo&gt;, Response&gt; f) {
<span class="fc" id="L226">    final List&lt;BundleInfo&gt; info = getDb().getBundles(toArray(String.class, prefixes));</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">    if (info.size() &gt; 0) {</span>
<span class="fc" id="L228">      return f.apply(info);</span>
    } else {
<span class="fc" id="L230">      return notFound(&quot;No bundles match one of the given prefixes&quot;);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>