<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StaticResourceServlet.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-static</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.fsresources</a> &gt; <span class="el_source">StaticResourceServlet.java</span></div><h1>StaticResourceServlet.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.fsresources;

import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.StaticFileAuthorization;
import org.opencastproject.util.ConfigurationException;
import org.opencastproject.util.MimeTypes;

import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.osgi.service.http.whiteboard.propertytypes.HttpWhiteboardContextSelect;
import org.osgi.service.http.whiteboard.propertytypes.HttpWhiteboardServletName;
import org.osgi.service.http.whiteboard.propertytypes.HttpWhiteboardServletPattern;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.StringTokenizer;
import java.util.regex.Pattern;
import java.util.zip.CRC32;

import javax.servlet.Servlet;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Serves static content from a configured path on the filesystem. In production systems, this should be replaced with
 * apache httpd or another web server optimized for serving static content.
 */
@Component(
    property = {
        &quot;service.description=Opencast Download Resources&quot;,
    },
    service = Servlet.class
)
@HttpWhiteboardServletName(StaticResourceServlet.SERVLET_PATH)
@HttpWhiteboardServletPattern(StaticResourceServlet.SERVLET_PATH + &quot;/*&quot;)
@HttpWhiteboardContextSelect(&quot;(osgi.http.whiteboard.context.name=opencast)&quot;)
public class StaticResourceServlet extends HttpServlet {

  /** The serialization UID */
  private static final long serialVersionUID = 1L;
  /** Full range marker. */
  private static final ArrayList&lt;Range&gt; FULL_RANGE;
  /** The logger */
<span class="fc" id="L82">  private static final Logger logger = LoggerFactory.getLogger(StaticResourceServlet.class);</span>

  private static final String PROP_AUTH_REQUIRED = &quot;authentication.required&quot;;
  private static final String PROP_X_ACCEL_REDIRECT = &quot;x.accel.redirect&quot;;

  /** static initializer */
  static {
<span class="fc" id="L89">    FULL_RANGE = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L90">  }</span>

  public static final String SERVLET_PATH = &quot;/static&quot;;

  /** The filesystem directory to serve files fro */
  private String distributionDirectory;

<span class="fc" id="L97">  private boolean authRequired = true;</span>
<span class="fc" id="L98">  private String xAccelRedirect = null;</span>

<span class="fc" id="L100">  private SecurityService securityService = null;</span>

<span class="fc" id="L102">  private List&lt;StaticFileAuthorization&gt; authorizations = new ArrayList&lt;&gt;();</span>

  /**
   * No-arg constructor
   */
<span class="fc" id="L107">  public StaticResourceServlet() {</span>
<span class="fc" id="L108">  }</span>

  @Reference(
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC
  )
  public void addStaticFileAuthorization(final StaticFileAuthorization authorization) {
<span class="nc" id="L115">    authorizations.add(authorization);</span>
<span class="nc" id="L116">    logger.info(&quot;Added static file authorization for {}&quot;, authorization.getProtectedUrlPattern());</span>
<span class="nc" id="L117">  }</span>

  public void removeStaticFileAuthorization(final StaticFileAuthorization authorization) {
<span class="nc" id="L120">    authorizations.remove(authorization);</span>
<span class="nc" id="L121">    logger.info(&quot;Removed static file authorization for {}&quot;, authorization.getProtectedUrlPattern());</span>
<span class="nc" id="L122">  }</span>

  private boolean isAuthorized(final String path) {
    // Check with authorization plug-ins
<span class="nc bnc" id="L126" title="All 2 branches missed.">    for (StaticFileAuthorization auth: authorizations) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">      for (Pattern pattern: auth.getProtectedUrlPattern()) {</span>
<span class="nc" id="L128">        logger.debug(&quot;Testing pattern `{}`&quot;, pattern);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (pattern.matcher(path).matches()) {</span>
<span class="nc" id="L130">          logger.debug(&quot;Using regexp `{}` for authorization check&quot;, pattern);</span>
<span class="nc" id="L131">          return auth.verifyUrlAccess(path);</span>
        }
<span class="nc" id="L133">      }</span>
<span class="nc" id="L134">    }</span>
<span class="nc" id="L135">    logger.debug(&quot;No authorization plug-in matches&quot;);</span>
<span class="nc" id="L136">    return false;</span>
  }

  /**
   * OSGI Activation callback
   *
   * @param cc
   *          the component context
   */
  @Activate
  public void activate(ComponentContext cc) {
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if (cc == null) {</span>
      // set defaults
<span class="nc" id="L149">      authRequired = true;</span>
<span class="nc" id="L150">      xAccelRedirect = null;</span>
    } else {
<span class="nc" id="L152">      authRequired = BooleanUtils.toBoolean(Objects.toString(cc.getProperties().get(PROP_AUTH_REQUIRED), &quot;true&quot;));</span>

<span class="nc" id="L154">      xAccelRedirect = Objects.toString(cc.getProperties().get(PROP_X_ACCEL_REDIRECT), null);</span>

<span class="nc" id="L156">      distributionDirectory = cc.getBundleContext().getProperty(&quot;org.opencastproject.download.directory&quot;);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">      if (StringUtils.isEmpty(distributionDirectory)) {</span>
<span class="nc" id="L158">        final String storageDir = cc.getBundleContext().getProperty(&quot;org.opencastproject.storage.dir&quot;);</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (StringUtils.isNotEmpty(storageDir)) {</span>
<span class="nc" id="L160">          distributionDirectory = new File(storageDir, &quot;downloads&quot;).getPath();</span>
        }
      }
    }
<span class="nc" id="L164">    logger.debug(&quot;Authentication check enabled: {}&quot;, authRequired);</span>

<span class="nc bnc" id="L166" title="All 2 branches missed.">    if (StringUtils.isEmpty(distributionDirectory)) {</span>
<span class="nc" id="L167">      throw new ConfigurationException(&quot;Distribution directory not set&quot;);</span>
    }
<span class="nc" id="L169">    logger.info(&quot;Serving static files from '{}'&quot;, distributionDirectory);</span>
<span class="nc" id="L170">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see javax.servlet.http.HttpServlet#doGet(javax.servlet.http.HttpServletRequest,
   *      javax.servlet.http.HttpServletResponse)
   */
  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
<span class="nc" id="L180">    logger.debug(&quot;Looking for static resource '{}'&quot;, req.getRequestURI());</span>
<span class="nc" id="L181">    String path = req.getPathInfo();</span>
<span class="nc bnc" id="L182" title="All 4 branches missed.">    if (path == null || path.contains(&quot;..&quot;)) {</span>
<span class="nc" id="L183">      resp.sendError(HttpServletResponse.SC_FORBIDDEN);</span>
<span class="nc" id="L184">      return;</span>
    }

<span class="nc bnc" id="L187" title="All 4 branches missed.">    if (authRequired &amp;&amp; !isAuthorized(path)) {</span>
<span class="nc" id="L188">      resp.sendError(HttpServletResponse.SC_FORBIDDEN);</span>
<span class="nc" id="L189">      logger.debug(&quot;Not authorized&quot;);</span>
<span class="nc" id="L190">      return;</span>
    }

<span class="nc" id="L193">    File file = new File(distributionDirectory, path);</span>
<span class="nc bnc" id="L194" title="All 4 branches missed.">    if (!file.isFile() || !file.canRead()) {</span>
<span class="nc" id="L195">      logger.debug(&quot;Unable to find file '{}', returning HTTP 404&quot;, file);</span>
<span class="nc" id="L196">      resp.sendError(HttpServletResponse.SC_NOT_FOUND);</span>
<span class="nc" id="L197">      return;</span>
    }

<span class="nc" id="L200">    logger.debug(&quot;Serving static resource '{}'&quot;, file.getAbsolutePath());</span>
<span class="nc" id="L201">    String eTag = computeEtag(file);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">    if (eTag.equals(req.getHeader(&quot;If-None-Match&quot;))) {</span>
<span class="nc" id="L203">      resp.setStatus(304);</span>
<span class="nc" id="L204">      return;</span>
    }
<span class="nc" id="L206">    resp.setHeader(&quot;ETag&quot;, eTag);</span>

<span class="nc bnc" id="L208" title="All 2 branches missed.">    if (xAccelRedirect != null) {</span>
<span class="nc" id="L209">      resp.setHeader(&quot;X-Accel-Redirect&quot;, Paths.get(xAccelRedirect, path).toString());</span>
<span class="nc" id="L210">      return;</span>
    }

<span class="nc" id="L213">    String contentType = MimeTypes.getMimeType(path);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">    if (!MimeTypes.DEFAULT_TYPE.equals(contentType)) {</span>
<span class="nc" id="L215">      resp.setContentType(contentType);</span>
    }
<span class="nc" id="L217">    resp.setHeader(&quot;Content-Length&quot;, Long.toString(file.length()));</span>
<span class="nc" id="L218">    resp.setDateHeader(&quot;Last-Modified&quot;, file.lastModified());</span>

<span class="nc" id="L220">    resp.setHeader(&quot;Accept-Ranges&quot;, &quot;bytes&quot;);</span>
<span class="nc" id="L221">    ArrayList&lt;Range&gt; ranges = parseRange(req, resp, eTag, file.lastModified(), file.length());</span>

<span class="nc bnc" id="L223" title="All 8 branches missed.">    if ((((ranges == null) || (ranges.isEmpty())) &amp;&amp; (req.getHeader(&quot;Range&quot;) == null)) || (ranges == FULL_RANGE)) {</span>
<span class="nc" id="L224">      IOException e = copyRange(new FileInputStream(file), resp.getOutputStream(), 0, file.length());</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">      if (e != null) {</span>
        try {
<span class="nc" id="L227">          resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L228">        } catch (IOException e1) {</span>
<span class="nc" id="L229">          logger.warn(&quot;unable to send http 500 error&quot;, e1);</span>
<span class="nc" id="L230">        } catch (IllegalStateException e2) {</span>
<span class="nc" id="L231">          logger.trace(&quot;unable to send http 500 error. Client side was probably closed during file copy.&quot;, e2);</span>
<span class="nc" id="L232">        }</span>
      }
<span class="nc" id="L234">      return;</span>
    }
<span class="nc bnc" id="L236" title="All 4 branches missed.">    if ((ranges == null) || (ranges.isEmpty())) {</span>
<span class="nc" id="L237">      return;</span>
    }
<span class="nc bnc" id="L239" title="All 2 branches missed.">    if (ranges.size() == 1) {</span>
<span class="nc" id="L240">      Range range = ranges.get(0);</span>
<span class="nc" id="L241">      resp.addHeader(&quot;Content-Range&quot;, &quot;bytes &quot; + range.start + &quot;-&quot; + range.end + &quot;/&quot; + range.length);</span>
<span class="nc" id="L242">      long length = range.end - range.start + 1;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">      if (length &lt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L244">        resp.setContentLength((int) length);</span>
      } else {
        // Set the content-length as String to be able to use a long
<span class="nc" id="L247">        resp.setHeader(&quot;content-length&quot;, &quot;&quot; + length);</span>
      }
      try {
<span class="nc" id="L250">        resp.setBufferSize(2048);</span>
<span class="nc" id="L251">      } catch (IllegalStateException e) {</span>
<span class="nc" id="L252">        logger.debug(e.getMessage(), e);</span>
<span class="nc" id="L253">      }</span>
<span class="nc" id="L254">      resp.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);</span>
<span class="nc" id="L255">      IOException e = copyRange(new FileInputStream(file), resp.getOutputStream(), range.start, range.end);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (e != null) {</span>
        try {
<span class="nc" id="L258">          resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L259">        } catch (IOException e1) {</span>
<span class="nc" id="L260">          logger.warn(&quot;unable to send http 500 error&quot;, e1);</span>
<span class="nc" id="L261">        } catch (IllegalStateException e2) {</span>
<span class="nc" id="L262">          logger.trace(&quot;unable to send http 500 error. Client side was probably closed during file copy.&quot;, e2);</span>
<span class="nc" id="L263">        }</span>
      }
<span class="nc" id="L265">      return;</span>
    }

<span class="nc" id="L268">    resp.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);</span>
<span class="nc" id="L269">    resp.setContentType(&quot;multipart/byteranges; boundary=&quot; + mimeSeparation);</span>
    try {
<span class="nc" id="L271">      resp.setBufferSize(2048);</span>
<span class="nc" id="L272">    } catch (IllegalStateException e) {</span>
<span class="nc" id="L273">      logger.debug(e.getMessage(), e);</span>
<span class="nc" id="L274">    }</span>
<span class="nc" id="L275">    copy(file, resp.getOutputStream(), ranges.iterator(), contentType);</span>
<span class="nc" id="L276">  }</span>

  /**
   * Computes an etag for a file using the filename, last modified, and length of the file.
   *
   * @param file
   *          the file
   * @return the etag
   */
  private String computeEtag(File file) {
<span class="nc" id="L286">    CRC32 crc = new CRC32();</span>
<span class="nc" id="L287">    crc.update(file.getName().getBytes());</span>
<span class="nc" id="L288">    checksum(file.lastModified(), crc);</span>
<span class="nc" id="L289">    checksum(file.length(), crc);</span>
<span class="nc" id="L290">    return Long.toString(crc.getValue());</span>
  }

  private static void checksum(long l, CRC32 crc) {
<span class="nc bnc" id="L294" title="All 2 branches missed.">    for (int i = 0; i &lt; 8; i++) {</span>
<span class="nc" id="L295">      crc.update((int) (l &amp; 0x000000ff));</span>
<span class="nc" id="L296">      l &gt;&gt;= 8;</span>
    }
<span class="nc" id="L298">  }</span>

  protected void copy(File f, ServletOutputStream out, Iterator&lt;Range&gt; ranges, String contentType) throws IOException {
<span class="nc" id="L301">    IOException exception = null;</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">    while ((exception == null) &amp;&amp; (ranges.hasNext())) {</span>
<span class="nc" id="L303">      Range currentRange = ranges.next();</span>
      // Writing MIME header.
<span class="nc" id="L305">      out.println();</span>
<span class="nc" id="L306">      out.println(&quot;--&quot; + mimeSeparation);</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">      if (contentType != null) {</span>
<span class="nc" id="L308">        out.println(&quot;Content-Type: &quot; + contentType);</span>
      }
<span class="nc" id="L310">      out.println(&quot;Content-Range: bytes &quot; + currentRange.start + &quot;-&quot; + currentRange.end + &quot;/&quot; + currentRange.length);</span>
<span class="nc" id="L311">      out.println();</span>

      // Printing content
<span class="nc" id="L314">      InputStream in = new FileInputStream(f);</span>
<span class="nc" id="L315">      exception = copyRange(in, out, currentRange.start, currentRange.end);</span>
<span class="nc" id="L316">      in.close();</span>
<span class="nc" id="L317">    }</span>
<span class="nc" id="L318">    out.println();</span>
<span class="nc" id="L319">    out.print(&quot;--&quot; + mimeSeparation + &quot;--&quot;);</span>
    // Rethrow any exception that has occurred
<span class="nc bnc" id="L321" title="All 2 branches missed.">    if (exception != null) {</span>
<span class="nc" id="L322">      throw exception;</span>
    }
<span class="nc" id="L324">  }</span>

  /**
   * MIME multipart separation string
   */
  private static final String mimeSeparation = &quot;MATTERHORN_MIME_BOUNDARY&quot;;

  /**
   * Parse the range header.
   *
   * @param req
   *          The servlet request we are processing
   * @param response
   *          The servlet response we are creating
   * @return Vector of ranges
   */
  protected ArrayList&lt;Range&gt; parseRange(HttpServletRequest req, HttpServletResponse response, String eTag,
          long lastModified, long fileLength) throws IOException {

    // Checking If-Range
<span class="nc" id="L344">    String headerValue = req.getHeader(&quot;If-Range&quot;);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">    if (headerValue != null) {</span>
<span class="nc" id="L346">      long headerValueTime = (-1L);</span>
      try {
<span class="nc" id="L348">        headerValueTime = req.getDateHeader(&quot;If-Range&quot;);</span>
<span class="nc" id="L349">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L350">        logger.debug(e.getMessage(), e);</span>
<span class="nc" id="L351">      }</span>

<span class="nc bnc" id="L353" title="All 2 branches missed.">      if (headerValueTime == (-1L)) {</span>
        // If the ETag the client gave does not match the entity
        // etag, then the entire entity is returned.
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (!eTag.equals(headerValue.trim())) {</span>
<span class="nc" id="L357">          return FULL_RANGE;</span>
        }
      } else {
        // If the timestamp of the entity the client got is older than
        // the last modification date of the entity, the entire entity
        // is returned.
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (lastModified &gt; (headerValueTime + 1000)) {</span>
<span class="nc" id="L364">          return FULL_RANGE;</span>
        }
      }
    }

<span class="nc bnc" id="L369" title="All 2 branches missed.">    if (fileLength == 0) {</span>
<span class="nc" id="L370">      return null;</span>
    }

    // Retrieving the range header (if any is specified
<span class="nc" id="L374">    String rangeHeader = req.getHeader(&quot;Range&quot;);</span>

<span class="nc bnc" id="L376" title="All 2 branches missed.">    if (rangeHeader == null) {</span>
<span class="nc" id="L377">      return null;</span>
    }
    // bytes is the only range unit supported (and I don't see the point
    // of adding new ones).
<span class="nc bnc" id="L381" title="All 2 branches missed.">    if (!rangeHeader.startsWith(&quot;bytes&quot;)) {</span>
<span class="nc" id="L382">      response.addHeader(&quot;Content-Range&quot;, &quot;bytes */&quot; + fileLength);</span>
<span class="nc" id="L383">      response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);</span>
<span class="nc" id="L384">      return null;</span>
    }

<span class="nc" id="L387">    rangeHeader = rangeHeader.substring(6);</span>

    // Vector which will contain all the ranges which are successfully
    // parsed.
<span class="nc" id="L391">    ArrayList&lt;Range&gt; result = new ArrayList&lt;Range&gt;();</span>
<span class="nc" id="L392">    StringTokenizer commaTokenizer = new StringTokenizer(rangeHeader, &quot;,&quot;);</span>

    // Parsing the range list
<span class="nc bnc" id="L395" title="All 2 branches missed.">    while (commaTokenizer.hasMoreTokens()) {</span>
<span class="nc" id="L396">      String rangeDefinition = commaTokenizer.nextToken().trim();</span>
<span class="nc" id="L397">      Range currentRange = new Range();</span>
<span class="nc" id="L398">      currentRange.length = fileLength;</span>
<span class="nc" id="L399">      int dashPos = rangeDefinition.indexOf('-');</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">      if (dashPos == -1) {</span>
<span class="nc" id="L401">        response.addHeader(&quot;Content-Range&quot;, &quot;bytes */&quot; + fileLength);</span>
<span class="nc" id="L402">        response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);</span>
<span class="nc" id="L403">        return null;</span>
      }
<span class="nc bnc" id="L405" title="All 2 branches missed.">      if (dashPos == 0) {</span>
        try {
<span class="nc" id="L407">          long offset = Long.parseLong(rangeDefinition);</span>
<span class="nc" id="L408">          currentRange.start = fileLength + offset;</span>
<span class="nc" id="L409">          currentRange.end = fileLength - 1;</span>
<span class="nc" id="L410">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L411">          response.addHeader(&quot;Content-Range&quot;, &quot;bytes */&quot; + fileLength);</span>
<span class="nc" id="L412">          response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);</span>
<span class="nc" id="L413">          return null;</span>
<span class="nc" id="L414">        }</span>
      } else {
        try {
<span class="nc" id="L417">          currentRange.start = Long.parseLong(rangeDefinition.substring(0, dashPos));</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">          if (dashPos &lt; rangeDefinition.length() - 1) {</span>
<span class="nc" id="L419">            currentRange.end = Long.parseLong(rangeDefinition.substring(dashPos + 1, rangeDefinition.length()));</span>
          } else {
<span class="nc" id="L421">            currentRange.end = fileLength - 1;</span>
          }
<span class="nc" id="L423">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L424">          response.addHeader(&quot;Content-Range&quot;, &quot;bytes */&quot; + fileLength);</span>
<span class="nc" id="L425">          response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);</span>
<span class="nc" id="L426">          return null;</span>
<span class="nc" id="L427">        }</span>
      }
<span class="nc bnc" id="L429" title="All 2 branches missed.">      if (!currentRange.validate()) {</span>
<span class="nc" id="L430">        response.addHeader(&quot;Content-Range&quot;, &quot;bytes */&quot; + fileLength);</span>
<span class="nc" id="L431">        response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);</span>
<span class="nc" id="L432">        return null;</span>
      }
<span class="nc" id="L434">      result.add(currentRange);</span>
<span class="nc" id="L435">    }</span>
<span class="nc" id="L436">    return result;</span>
  }

  /**
   * Copy the contents of the specified input stream to the specified output stream, and ensure that both streams are
   * closed before returning (even in the face of an exception).
   *
   * @param istream
   *          The input stream to read from
   * @param ostream
   *          The output stream to write to
   * @param start
   *          Start of the range which will be copied
   * @param end
   *          End of the range which will be copied
   * @return Exception which occurred during processing
   */
  protected IOException copyRange(InputStream istream, ServletOutputStream ostream, long start, long end) {
<span class="fc" id="L454">    logger.debug(&quot;Serving bytes:{}-{}&quot;, start, end);</span>
    try {
<span class="fc" id="L456">      istream.skip(start);</span>
<span class="nc" id="L457">    } catch (IOException e) {</span>
<span class="nc" id="L458">      logger.trace(&quot;Cannot skip to input stream position {}. The user probably closed the client side.&quot;, start, e);</span>
<span class="nc" id="L459">      return e;</span>
<span class="fc" id="L460">    }</span>
    // MH-10447, fix for files of size 2048*C bytes
<span class="fc" id="L462">    long bytesToRead = end - start + 1;</span>
<span class="fc" id="L463">    byte[] buffer = new byte[2048];</span>
<span class="fc" id="L464">    int len = buffer.length;</span>
    try {
<span class="fc" id="L466">      len = (int) bytesToRead % buffer.length;</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">      if (len &gt; 0) {</span>
<span class="fc" id="L468">        len = istream.read(buffer, 0, len);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">        if (len &gt; 0) {</span>
          // This test could actually be &quot;if (len != -1)&quot;
<span class="fc" id="L471">          ostream.write(buffer, 0, len);</span>
<span class="fc" id="L472">          bytesToRead -= len;</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">          if (bytesToRead == 0) {</span>
<span class="nc" id="L474">            return null;</span>
          }
        } else {
<span class="fc" id="L477">          return null;</span>
        }
      }

<span class="fc bfc" id="L481" title="All 2 branches covered.">      for (len = istream.read(buffer); len &gt; 0; len = istream.read(buffer)) {</span>
<span class="fc" id="L482">        ostream.write(buffer, 0, len);</span>
<span class="fc" id="L483">        bytesToRead -= len;</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        if (bytesToRead &lt; 1) {</span>
<span class="nc" id="L485">          break;</span>
        }
      }
<span class="nc" id="L488">    } catch (IOException e) {</span>
<span class="nc" id="L489">      logger.trace(&quot;IOException after starting the byte copy, current length {}, buffer {}.&quot;</span>
              + &quot; The user probably closed the client side after the file started copying.&quot;,
<span class="nc" id="L491">              len, buffer, e);</span>
<span class="nc" id="L492">      return e;</span>
<span class="fc" id="L493">    }</span>
<span class="fc" id="L494">    return null;</span>
  }

<span class="nc" id="L497">  protected class Range {</span>

    protected long start;
    protected long end;
    protected long length;

    /**
     * Validate range.
     */
    public boolean validate() {
<span class="nc bnc" id="L507" title="All 2 branches missed.">      if (end &gt;= length) {</span>
<span class="nc" id="L508">        end = length - 1;</span>
      }
<span class="nc bnc" id="L510" title="All 8 branches missed.">      return ((start &gt;= 0) &amp;&amp; (end &gt;= 0) &amp;&amp; (start &lt;= end) &amp;&amp; (length &gt; 0));</span>
    }

    public void recycle() {
<span class="nc" id="L514">      start = 0;</span>
<span class="nc" id="L515">      end = 0;</span>
<span class="nc" id="L516">      length = 0;</span>
<span class="nc" id="L517">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>