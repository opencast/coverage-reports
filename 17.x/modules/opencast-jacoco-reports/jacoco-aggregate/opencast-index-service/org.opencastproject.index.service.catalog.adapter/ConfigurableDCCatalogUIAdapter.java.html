<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ConfigurableDCCatalogUIAdapter.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-index-service</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.index.service.catalog.adapter</a> &gt; <span class="el_source">ConfigurableDCCatalogUIAdapter.java</span></div><h1>ConfigurableDCCatalogUIAdapter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.index.service.catalog.adapter;

import static org.opencastproject.index.service.catalog.adapter.CatalogUIAdapterFactory.CONF_FLAVOR_KEY;
import static org.opencastproject.index.service.catalog.adapter.CatalogUIAdapterFactory.CONF_ORGANIZATION_KEY;
import static org.opencastproject.index.service.catalog.adapter.CatalogUIAdapterFactory.CONF_TITLE_KEY;
import static org.opencastproject.util.OsgiUtil.getCfg;

import org.opencastproject.list.api.ListProviderException;
import org.opencastproject.list.api.ListProvidersService;
import org.opencastproject.list.api.ResourceListQuery;
import org.opencastproject.mediapackage.EName;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.metadata.dublincore.CatalogUIAdapter;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.DublinCoreValue;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.SeriesCatalogUIAdapter;

import org.osgi.service.cm.ConfigurationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

<span class="fc" id="L54">public abstract class ConfigurableDCCatalogUIAdapter implements CatalogUIAdapter {</span>

<span class="fc" id="L56">  private static final Logger logger = LoggerFactory.getLogger(ConfigurableDCCatalogUIAdapter.class);</span>

  /** The catalog UI adapter configuration */
  protected CatalogUIAdapterConfiguration config;

  /** The organization name */
  protected String organization;

  /** The flavor of this catalog */
  protected MediaPackageElementFlavor flavor;

  /** The title of this catalog */
  protected String title;

  /** The metadata fields for all properties of the underlying DublinCore */
  protected Map&lt;String, MetadataField&gt; dublinCoreProperties;

  /** Reference to the list providers service */
  protected ListProvidersService listProvidersService;

  /**
   * Reconfigures the {@link SeriesCatalogUIAdapter} instance with an updated set of configuration properties;
   *
   * @param properties
   *          the configuration properties
   * @throws ConfigurationException
   *           if there is a configuration error
   */
  public void updated(Dictionary&lt;String, ?&gt; properties) throws ConfigurationException {
<span class="fc" id="L85">    config = CatalogUIAdapterConfiguration.loadFromDictionary(properties);</span>
<span class="fc" id="L86">    organization = getCfg(properties, CONF_ORGANIZATION_KEY);</span>
<span class="fc" id="L87">    flavor = MediaPackageElementFlavor.parseFlavor(getCfg(properties, CONF_FLAVOR_KEY));</span>
<span class="fc" id="L88">    title = getCfg(properties, CONF_TITLE_KEY);</span>
<span class="fc" id="L89">    dublinCoreProperties = DublinCoreMetadataUtil.getDublinCoreProperties(properties);</span>
<span class="fc" id="L90">  }</span>

  /**
   * Get default value for collection from list providers service
   * @param metadataField
   * @param listProvidersService
   * @return default value
   */
  private String getCollectionDefault(MetadataField metadataField,
          ListProvidersService listProvidersService) {
<span class="pc bpc" id="L100" title="3 of 4 branches missed.">    if (listProvidersService != null &amp;&amp; metadataField.getListprovider() != null) {</span>
      try {
<span class="nc" id="L102">        return listProvidersService.getDefault(metadataField.getListprovider());</span>

<span class="nc" id="L104">      } catch (ListProviderException ex) {</span>
        // failed to get default property on list-provider-service
        // as this field is optional, it is fine to pass here
      }
    }
<span class="fc" id="L109">    return null;</span>
  }

  @Override
  public DublinCoreMetadataCollection getRawFields() {
<span class="fc" id="L114">    return getRawFields(Collections.emptyMap());</span>
  }

  @Override
  public DublinCoreMetadataCollection getRawFields(Map&lt;String, ResourceListQuery&gt; collectionQueryOverrides) {
<span class="fc" id="L119">    DublinCoreMetadataCollection rawFields = new DublinCoreMetadataCollection();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">    for (MetadataField metadataField : dublinCoreProperties.values()) {</span>
      try {
<span class="fc" id="L122">        String defaultKey = getCollectionDefault(metadataField, listProvidersService);</span>
<span class="fc" id="L123">        ResourceListQuery collectionQueryOverride = collectionQueryOverrides.get(metadataField.getOutputID());</span>

<span class="fc" id="L125">        rawFields.addField(new MetadataField(metadataField), Optional.ofNullable(defaultKey),</span>
<span class="fc" id="L126">                Optional.ofNullable(collectionQueryOverride), listProvidersService);</span>
<span class="nc" id="L127">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L128">        logger.error(&quot;Skipping metadata field '{}' because of error&quot;, metadataField, e);</span>
<span class="fc" id="L129">      }</span>
<span class="fc" id="L130">    }</span>
<span class="fc" id="L131">    return rawFields;</span>
  }

  @Override
  public DublinCoreMetadataCollection getRawFields(ResourceListQuery collectionQueryOverride) {
<span class="fc" id="L136">    DublinCoreMetadataCollection rawFields = new DublinCoreMetadataCollection();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">    for (MetadataField metadataField : dublinCoreProperties.values()) {</span>
      try {
<span class="fc" id="L139">        String defaultKey = getCollectionDefault(metadataField, listProvidersService);</span>

<span class="fc" id="L141">        rawFields.addField(new MetadataField(metadataField), Optional.ofNullable(defaultKey),</span>
<span class="fc" id="L142">            Optional.ofNullable(collectionQueryOverride), listProvidersService);</span>
<span class="nc" id="L143">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L144">        logger.error(&quot;Skipping metadata field '{}' because of error&quot;, metadataField, e);</span>
<span class="fc" id="L145">      }</span>
<span class="fc" id="L146">    }</span>
<span class="fc" id="L147">    return rawFields;</span>
  }

  protected DublinCoreMetadataCollection getFieldsFromCatalogs(List&lt;DublinCoreCatalog&gt; dcCatalogs) {
<span class="fc" id="L151">    Map&lt;String,List&lt;MetadataField&gt;&gt; metadataFields = new HashMap&lt;&gt;();</span>
<span class="fc" id="L152">    List&lt;MetadataField&gt; emptyFields = new ArrayList&lt;&gt;(dublinCoreProperties.values());</span>

<span class="fc bfc" id="L154" title="All 2 branches covered.">    for (MetadataField metadataField: dublinCoreProperties.values()) {</span>

<span class="fc" id="L156">      String namespace = DublinCore.TERMS_NS_URI;</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">      if (metadataField.getNamespace() != null) {</span>
<span class="nc" id="L158">        namespace = metadataField.getNamespace();</span>
      }

<span class="fc" id="L161">      String metadataFieldKey = namespace.toLowerCase() + &quot;:&quot; + metadataField.getInputID().toLowerCase();</span>

<span class="fc" id="L163">      List&lt;MetadataField&gt; metadataFieldList = metadataFields.computeIfAbsent(metadataFieldKey,</span>
<span class="fc" id="L164">              key -&gt; new ArrayList&lt;&gt;());</span>
<span class="fc" id="L165">      metadataFieldList.add(metadataField);</span>
<span class="fc" id="L166">    }</span>

<span class="fc" id="L168">    DublinCoreMetadataCollection dublinCoreMetadata = new DublinCoreMetadataCollection();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">    for (DublinCoreCatalog dc : dcCatalogs) {</span>
<span class="fc" id="L170">      getFieldsFromCatalog(metadataFields, emptyFields, dublinCoreMetadata, dc);</span>
<span class="fc" id="L171">    }</span>

    // Add all of the rest of the fields that didn't have values as empty.
<span class="fc bfc" id="L174" title="All 2 branches covered.">    for (MetadataField metadataField: emptyFields) {</span>
      try {
<span class="fc" id="L176">        dublinCoreMetadata.addEmptyField(new MetadataField(metadataField), getListProvidersService());</span>
<span class="nc" id="L177">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L178">        logger.error(&quot;Skipping metadata field '{}' because of error&quot;, metadataField, e);</span>
<span class="fc" id="L179">      }</span>
<span class="fc" id="L180">    }</span>
<span class="fc" id="L181">    return dublinCoreMetadata;</span>
  }

  private void getFieldsFromCatalog(
          Map&lt;String, List&lt;MetadataField&gt;&gt; metadataFields,
          List&lt;MetadataField&gt; emptyFields,
          DublinCoreMetadataCollection dublinCoreMetadata,
          DublinCoreCatalog dc) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">    for (EName propertyKey : dc.getValues().keySet()) {</span>
      // namespace and input id need to match
<span class="fc" id="L191">      final String metadataFieldKey = propertyKey.getNamespaceURI().toLowerCase() + &quot;:&quot;</span>
<span class="fc" id="L192">              + propertyKey.getLocalName().toLowerCase();</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">      if (metadataFields.containsKey(metadataFieldKey)) {</span>

        // multiple metadata fields can match
<span class="fc bfc" id="L196" title="All 2 branches covered.">        for (MetadataField metadataField : metadataFields.get(metadataFieldKey)) {</span>
<span class="fc" id="L197">          List&lt;DublinCoreValue&gt; values = dc.get(propertyKey);</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">          if (!values.isEmpty()) {</span>
            try {
<span class="fc" id="L200">              dublinCoreMetadata.addField(</span>
                      new MetadataField(metadataField),
<span class="fc" id="L202">                      values.stream().map(DublinCoreValue::getValue).collect(Collectors.toList()),</span>
<span class="fc" id="L203">                      getListProvidersService());</span>
<span class="fc" id="L204">              emptyFields.remove(metadataField);</span>
<span class="nc" id="L205">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L206">              logger.error(&quot;Skipping metadata field '{}' because of error:&quot;, metadataField.getInputID(), e);</span>
<span class="fc" id="L207">            }</span>
          }
<span class="fc" id="L209">        }</span>
      }
<span class="fc" id="L211">    }</span>
<span class="fc" id="L212">  }</span>

  @Override
  public String getOrganization() {
<span class="nc" id="L216">    return organization;</span>
  }

  @Override
  public boolean handlesOrganization(String organization) {
<span class="pc bpc" id="L221" title="2 of 4 branches missed.">    return ORGANIZATION_WILDCARD.equals(this.organization) || organization.equals(this.organization);</span>
  }

  @Override
  public MediaPackageElementFlavor getFlavor() {
<span class="nc" id="L226">    return flavor;</span>
  }

  @Override
  public String getUITitle() {
<span class="nc" id="L231">    return title;</span>
  }

  public void setListProvidersService(ListProvidersService listProvidersService) {
<span class="fc" id="L235">    this.listProvidersService = listProvidersService;</span>
<span class="fc" id="L236">  }</span>

  protected ListProvidersService getListProvidersService() {
<span class="fc" id="L239">    return listProvidersService;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>