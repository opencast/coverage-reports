<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IndexServiceImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-index-service</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.index.service.impl</a> &gt; <span class="el_source">IndexServiceImpl.java</span></div><h1>IndexServiceImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.index.service.impl;

import static org.opencastproject.assetmanager.api.AssetManager.DEFAULT_OWNER;
import static org.opencastproject.assetmanager.api.fn.Enrichments.enrich;
import static org.opencastproject.metadata.dublincore.DublinCore.PROPERTY_IDENTIFIER;
import static org.opencastproject.security.api.DefaultOrganization.DEFAULT_ORGANIZATION_ID;
import static org.opencastproject.workflow.api.ConfiguredWorkflow.workflow;

import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.AssetManagerException;
import org.opencastproject.assetmanager.api.query.AQueryBuilder;
import org.opencastproject.assetmanager.api.query.AResult;
import org.opencastproject.assetmanager.api.query.Predicate;
import org.opencastproject.assetmanager.util.WorkflowPropertiesUtil;
import org.opencastproject.assetmanager.util.Workflows;
import org.opencastproject.authorization.xacml.manager.api.AclService;
import org.opencastproject.authorization.xacml.manager.api.AclServiceFactory;
import org.opencastproject.capture.CaptureParameters;
import org.opencastproject.capture.admin.api.CaptureAgentStateService;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.objects.event.EventSearchQuery;
import org.opencastproject.elasticsearch.index.objects.series.Series;
import org.opencastproject.event.comment.EventComment;
import org.opencastproject.event.comment.EventCommentException;
import org.opencastproject.event.comment.EventCommentParser;
import org.opencastproject.event.comment.EventCommentService;
import org.opencastproject.index.service.api.IndexService;
import org.opencastproject.index.service.catalog.adapter.DublinCoreMetadataUtil;
import org.opencastproject.index.service.catalog.adapter.MetadataUtils;
import org.opencastproject.index.service.catalog.adapter.events.CommonEventCatalogUIAdapter;
import org.opencastproject.index.service.catalog.adapter.series.CommonSeriesCatalogUIAdapter;
import org.opencastproject.index.service.exception.IndexServiceException;
import org.opencastproject.index.service.exception.UnsupportedAssetException;
import org.opencastproject.index.service.impl.util.EventHttpServletRequest;
import org.opencastproject.index.service.impl.util.EventUtils;
import org.opencastproject.index.service.impl.util.Retraction;
import org.opencastproject.index.service.impl.util.RetractionListener;
import org.opencastproject.index.service.util.JSONUtils;
import org.opencastproject.index.service.util.RequestUtils;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.ingest.api.IngestException;
import org.opencastproject.ingest.api.IngestService;
import org.opencastproject.list.api.ListProvidersService;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.EName;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElement.Type;
import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.metadata.dublincore.DCMIPeriod;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.DublinCoreUtil;
import org.opencastproject.metadata.dublincore.DublinCoreValue;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.metadata.dublincore.EncodingSchemeUtils;
import org.opencastproject.metadata.dublincore.EventCatalogUIAdapter;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.MetadataJson;
import org.opencastproject.metadata.dublincore.MetadataList;
import org.opencastproject.metadata.dublincore.Precision;
import org.opencastproject.metadata.dublincore.SeriesCatalogUIAdapter;
import org.opencastproject.scheduler.api.SchedulerException;
import org.opencastproject.scheduler.api.SchedulerService;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.AclScope;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.api.User;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.security.util.SecurityContext;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.series.api.SeriesException;
import org.opencastproject.series.api.SeriesService;
import org.opencastproject.util.Checksum;
import org.opencastproject.util.ChecksumType;
import org.opencastproject.util.DateTimeSupport;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.XmlNamespaceBinding;
import org.opencastproject.util.XmlNamespaceContext;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.workflow.api.ConfiguredWorkflow;
import org.opencastproject.workflow.api.WorkflowDatabaseException;
import org.opencastproject.workflow.api.WorkflowDefinition;
import org.opencastproject.workflow.api.WorkflowException;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowInstance.WorkflowState;
import org.opencastproject.workflow.api.WorkflowParsingException;
import org.opencastproject.workflow.api.WorkflowService;
import org.opencastproject.workspace.api.Workspace;

import com.entwinemedia.fn.data.Opt;
import com.google.common.net.MediaType;

import net.fortuna.ical4j.model.Period;
import net.fortuna.ical4j.model.property.RRule;

import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.jettison.json.JSONException;
import org.joda.time.DateTimeZone;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.TimeZone;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;

@Component(
    immediate = true,
    service = IndexService.class,
    property = {
        &quot;service.description=Index Services Implementation&quot;
    }
)
<span class="fc" id="L189">public class IndexServiceImpl implements IndexService {</span>

  private static final String WORKFLOW_CONFIG_PREFIX = &quot;org.opencastproject.workflow.config.&quot;;

  public static final String THEME_PROPERTY_NAME = &quot;theme&quot;;

  /** The logging facility */
<span class="fc" id="L196">  private static final Logger logger = LoggerFactory.getLogger(IndexServiceImpl.class);</span>

<span class="fc" id="L198">  private final List&lt;EventCatalogUIAdapter&gt; eventCatalogUIAdapters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L199">  private final List&lt;SeriesCatalogUIAdapter&gt; seriesCatalogUIAdapters = new ArrayList&lt;&gt;();</span>

  /** A parser for handling JSON documents inside the body of a request. **/
<span class="fc" id="L202">  private static final JSONParser parser = new JSONParser();</span>

<span class="fc" id="L204">  private String attachmentRegex = &quot;^attachment.*&quot;;</span>
<span class="fc" id="L205">  private String catalogRegex = &quot;^catalog.*&quot;;</span>
<span class="fc" id="L206">  private String trackRegex = &quot;^track.*&quot;;</span>
<span class="fc" id="L207">  private String numberedAssetRegex = &quot;^\\*$&quot;;</span>

<span class="fc" id="L209">  private Pattern patternAttachment = Pattern.compile(attachmentRegex);</span>
<span class="fc" id="L210">  private Pattern patternCatalog = Pattern.compile(catalogRegex);</span>
<span class="fc" id="L211">  private Pattern patternTrack = Pattern.compile(trackRegex);</span>
<span class="fc" id="L212">  private Pattern patternNumberedAsset = Pattern.compile(numberedAssetRegex);</span>

  private AclServiceFactory aclServiceFactory;
  private AuthorizationService authorizationService;
  private CaptureAgentStateService captureAgentStateService;
  private EventCommentService eventCommentService;
  private IngestService ingestService;
  private ListProvidersService listProvidersService;
  private AssetManager assetManager;
  private SchedulerService schedulerService;
  private SecurityService securityService;
  private SeriesService seriesService;
  private UserDirectoryService userDirectoryService;
  private WorkflowService workflowService;
  private Workspace workspace;
  private ElasticsearchIndex elasticsearchIndex;

  /** The single thread executor service */
<span class="fc" id="L230">  private ExecutorService executorService = Executors.newSingleThreadExecutor();</span>

<span class="fc" id="L232">  private Map&lt;Long, Retraction&gt; retractions = new ConcurrentHashMap&lt;&gt;();</span>

  /**
   * OSGi DI.
   *
   * @param aclServiceFactory
   *          the factory to set
   */
  @Reference
  public void setAclServiceFactory(AclServiceFactory aclServiceFactory) {
<span class="nc" id="L242">    this.aclServiceFactory = aclServiceFactory;</span>
<span class="nc" id="L243">  }</span>

  @Reference
  public void setElasticsearchIndex(ElasticsearchIndex elasticsearchIndex) {
<span class="nc" id="L247">    this.elasticsearchIndex = elasticsearchIndex;</span>
<span class="nc" id="L248">  }</span>

  /**
   * OSGi DI.
   *
   * @param authorizationService
   *          the service to set
   */
  @Reference
  public void setAuthorizationService(AuthorizationService authorizationService) {
<span class="fc" id="L258">    this.authorizationService = authorizationService;</span>
<span class="fc" id="L259">  }</span>

  /**
   * OSGi DI.
   *
   * @param captureAgentStateService
   *          the service to set
   */
  @Reference
  public void setCaptureAgentStateService(CaptureAgentStateService captureAgentStateService) {
<span class="fc" id="L269">    this.captureAgentStateService = captureAgentStateService;</span>
<span class="fc" id="L270">  }</span>

  /**
   * OSGi callback for the event comment service.
   *
   * @param eventCommentService
   *          the service to set
   */
  @Reference
  public void setEventCommentService(EventCommentService eventCommentService) {
<span class="nc" id="L280">    this.eventCommentService = eventCommentService;</span>
<span class="nc" id="L281">  }</span>

  /**
   * OSGi callback to add {@link EventCatalogUIAdapter} instance.
   *
   * @param catalogUIAdapter
   *          the adapter to add
   */
  @Reference(
      name = &quot;EventCatalogUIAdapter&quot;,
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeCatalogUIAdapter&quot;
  )
  public void addCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="fc" id="L296">    eventCatalogUIAdapters.add(catalogUIAdapter);</span>
<span class="fc" id="L297">  }</span>

  /**
   * OSGi callback to remove {@link EventCatalogUIAdapter} instance.
   *
   * @param catalogUIAdapter
   *          the adapter to remove
   */
  public void removeCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L306">    eventCatalogUIAdapters.remove(catalogUIAdapter);</span>
<span class="nc" id="L307">  }</span>

  /**
   * OSGi callback to add {@link SeriesCatalogUIAdapter} instance.
   *
   * @param catalogUIAdapter
   *          the adapter to add
   */
  @Reference(
      name = &quot;SeriesCatalogUIAdapter&quot;,
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeCatalogUIAdapter&quot;
  )
  public void addCatalogUIAdapter(SeriesCatalogUIAdapter catalogUIAdapter) {
<span class="fc" id="L322">    seriesCatalogUIAdapters.add(catalogUIAdapter);</span>
<span class="fc" id="L323">  }</span>

  /**
   * OSGi callback to remove {@link SeriesCatalogUIAdapter} instance.
   *
   * @param catalogUIAdapter
   *          the adapter to remove
   */
  public void removeCatalogUIAdapter(SeriesCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L332">    seriesCatalogUIAdapters.remove(catalogUIAdapter);</span>
<span class="nc" id="L333">  }</span>

  /**
   * OSGi DI.
   *
   * @param ingestService
   *          the service to set
   */
  @Reference
  public void setIngestService(IngestService ingestService) {
<span class="fc" id="L343">    this.ingestService = ingestService;</span>
<span class="fc" id="L344">  }</span>

  /**
   * OSGi DI.
   *
   * @param listProvidersService
   *          the service to set
   */
  @Reference
  public void setListProvidersService(ListProvidersService listProvidersService) {
<span class="nc" id="L354">    this.listProvidersService = listProvidersService;</span>
<span class="nc" id="L355">  }</span>

  /**
   * OSGi DI.
   *
   * @param assetManager
   *          the manager to set
   */
  @Reference
  public void setAssetManager(AssetManager assetManager) {
<span class="fc" id="L365">    this.assetManager = assetManager;</span>
<span class="fc" id="L366">  }</span>

  /**
   * OSGi DI.
   *
   * @param schedulerService
   *          the service to set
   */
  @Reference
  public void setSchedulerService(SchedulerService schedulerService) {
<span class="fc" id="L376">    this.schedulerService = schedulerService;</span>
<span class="fc" id="L377">  }</span>

  /**
   * OSGi DI.
   *
   * @param securityService
   *          the service to set
   */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L387">    this.securityService = securityService;</span>
<span class="fc" id="L388">  }</span>

  /**
   * OSGi DI.
   *
   * @param seriesService
   *          the service to set
   */
  @Reference
  public void setSeriesService(SeriesService seriesService) {
<span class="fc" id="L398">    this.seriesService = seriesService;</span>
<span class="fc" id="L399">  }</span>

  /**
   * OSGi DI.
   *
   * @param workflowService
   *          the service to set
   */
  @Reference
  public void setWorkflowService(WorkflowService workflowService) {
<span class="nc" id="L409">    this.workflowService = workflowService;</span>
<span class="nc" id="L410">  }</span>

  /**
   * OSGi DI.
   *
   * @param workspace
   *          the workspace to set
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="fc" id="L420">    this.workspace = workspace;</span>
<span class="fc" id="L421">  }</span>

  /**
   * OSGi DI.
   *
   * @param userDirectoryService
   *          the service to set
   */
  @Reference
  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {
<span class="fc" id="L431">    this.userDirectoryService = userDirectoryService;</span>
<span class="fc" id="L432">  }</span>

  /**
   *
   * @return the acl service
   */
  public AclService getAclService() {
<span class="nc" id="L439">    return aclServiceFactory.serviceFor(securityService.getOrganization());</span>
  }

  public List&lt;EventCatalogUIAdapter&gt; getEventCatalogUIAdapters(String organization) {
<span class="fc" id="L443">    return eventCatalogUIAdapters.stream().filter(a -&gt; a.handlesOrganization(organization))</span>
<span class="fc" id="L444">            .collect(Collectors.toList());</span>
  }

  /**
   * @param organization
   *          The organization to filter the results with.
   * @return A {@link List} of {@link SeriesCatalogUIAdapter} that provide the metadata to the front end.
   */
  public List&lt;SeriesCatalogUIAdapter&gt; getSeriesCatalogUIAdapters(String organization) {
<span class="nc" id="L453">    return seriesCatalogUIAdapters.stream().filter(a -&gt; a.handlesOrganization(organization))</span>
<span class="nc" id="L454">            .collect(Collectors.toList());</span>
  }

  public EventCatalogUIAdapter getCommonEventCatalogUIAdapter(String organization) {
<span class="fc" id="L458">    Optional&lt;EventCatalogUIAdapter&gt; orgEventCatalogUIAdapter = eventCatalogUIAdapters.stream()</span>
<span class="fc" id="L459">            .filter(a -&gt; a instanceof CommonEventCatalogUIAdapter)</span>
<span class="fc" id="L460">            .filter(a -&gt; a.handlesOrganization(organization))</span>
<span class="fc" id="L461">            .findFirst();</span>

<span class="pc bpc" id="L463" title="1 of 2 branches missed.">    if (orgEventCatalogUIAdapter.isPresent()) {</span>
<span class="fc" id="L464">      return orgEventCatalogUIAdapter.get();</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">    } else if (!organization.equals(DEFAULT_ORGANIZATION_ID)) {</span>
<span class="nc" id="L466">      return getCommonEventCatalogUIAdapter(DEFAULT_ORGANIZATION_ID);</span>
    } else {
<span class="nc" id="L468">       throw new IllegalStateException(&quot;Common event metadata for &quot; + DEFAULT_ORGANIZATION_ID + &quot; needs to be &quot;</span>
               + &quot;configured!&quot;);
    }
  }

  public SeriesCatalogUIAdapter getCommonSeriesCatalogUIAdapter(String organization) {
<span class="nc" id="L474">    Optional&lt;SeriesCatalogUIAdapter&gt; orgSeriesCatalogUIAdapter = seriesCatalogUIAdapters.stream()</span>
<span class="nc" id="L475">            .filter(a -&gt; a instanceof CommonSeriesCatalogUIAdapter)</span>
<span class="nc" id="L476">            .filter(a -&gt; a.handlesOrganization(organization))</span>
<span class="nc" id="L477">            .findFirst();</span>

<span class="nc bnc" id="L479" title="All 2 branches missed.">    if (orgSeriesCatalogUIAdapter.isPresent()) {</span>
<span class="nc" id="L480">      return orgSeriesCatalogUIAdapter.get();</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">    } else if (!organization.equals(DEFAULT_ORGANIZATION_ID)) {</span>
<span class="nc" id="L482">      return getCommonSeriesCatalogUIAdapter(DEFAULT_ORGANIZATION_ID);</span>
    } else {
<span class="nc" id="L484">      throw new IllegalStateException(&quot;Common series metadata for &quot; + DEFAULT_ORGANIZATION_ID + &quot; needs to be &quot;</span>
              + &quot;configured!&quot;);
    }
  }

  @Override
  public List&lt;EventCatalogUIAdapter&gt; getEventCatalogUIAdapters() {
<span class="fc" id="L491">    return new ArrayList&lt;&gt;(getEventCatalogUIAdapters(securityService.getOrganization().getId()));</span>
  }

  @Override
  public List&lt;EventCatalogUIAdapter&gt; getExtendedEventCatalogUIAdapters() {
<span class="nc" id="L496">    String organization = securityService.getOrganization().getId();</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">    return eventCatalogUIAdapters.stream().filter(a -&gt; !(a instanceof CommonEventCatalogUIAdapter))</span>
<span class="nc" id="L498">            .filter(a -&gt; a.handlesOrganization(organization)).collect(Collectors.toList());</span>
  }

  @Override
  public List&lt;SeriesCatalogUIAdapter&gt; getSeriesCatalogUIAdapters() {
<span class="nc" id="L503">    return new LinkedList&lt;&gt;(getSeriesCatalogUIAdapters(securityService.getOrganization().getId()));</span>
  }

  @Override
  public EventCatalogUIAdapter getCommonEventCatalogUIAdapter() {
<span class="fc" id="L508">    return getCommonEventCatalogUIAdapter(securityService.getOrganization().getId());</span>
  }

  @Override
  public SeriesCatalogUIAdapter getCommonSeriesCatalogUIAdapter() {
<span class="nc" id="L513">    return getCommonSeriesCatalogUIAdapter(securityService.getOrganization().getId());</span>
  }

  @Activate
  public void activate(ComponentContext cc) {
<span class="nc" id="L518">    workflowService.addWorkflowListener(new RetractionListener(this, securityService, retractions));</span>
<span class="nc" id="L519">  }</span>

  @Deactivate
  public void deactivate(ComponentContext cc) {
<span class="nc" id="L523">    executorService.shutdown();</span>
<span class="nc" id="L524">  }</span>

  @Override
  public String createEvent(HttpServletRequest request) throws IndexServiceException, UnsupportedAssetException {
<span class="nc" id="L528">    JSONObject metadataJson = null;</span>
<span class="nc" id="L529">    MediaPackage mp = null;</span>
    // regex for form field name matching an attachment or a catalog
    // The first sub items identifies if the file is an attachment or catalog
    // The second is the item flavor
    // Example form field names:  &quot;catalog/captions/timedtext&quot; and &quot;attachment/captions/vtt&quot;
    // The prefix of field name for attachment and catalog
<span class="nc" id="L535">    List&lt;String&gt; assetList = new LinkedList&lt;String&gt;();</span>
    try {
<span class="nc bnc" id="L537" title="All 2 branches missed.">      if (ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L538">        mp = ingestService.createMediaPackage();</span>

<span class="nc bnc" id="L540" title="All 2 branches missed.">        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L541">          FileItemStream item = iter.next();</span>

<span class="nc" id="L543">          String fieldName = item.getFieldName();</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">          if (item.isFormField()) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">            if (&quot;metadata&quot;.equals(fieldName)) {</span>
<span class="nc" id="L546">              String metadata = Streams.asString(item.openStream());</span>
              try {
<span class="nc" id="L548">                metadataJson = (JSONObject) new JSONParser().parse(metadata);</span>
                // in case of scheduling: Check if user has access to the CA
<span class="nc bnc" id="L550" title="All 2 branches missed.">                if (metadataJson.containsKey(&quot;source&quot;)) {</span>
<span class="nc" id="L551">                  final JSONObject sourceJson = (JSONObject) metadataJson.get(&quot;source&quot;);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                  if (sourceJson.containsKey(&quot;metadata&quot;)) {</span>
<span class="nc" id="L553">                    final JSONObject sourceMetadataJson = (JSONObject) sourceJson.get(&quot;metadata&quot;);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                    if (sourceMetadataJson.containsKey(&quot;device&quot;)) {</span>
<span class="nc" id="L555">                      SecurityUtil.checkAgentAccess(securityService, (String) sourceMetadataJson.get(&quot;device&quot;));</span>
                    }
                  }
                }
<span class="nc" id="L559">              } catch (Exception e) {</span>
<span class="nc" id="L560">                logger.warn(&quot;Unable to parse metadata {}&quot;, metadata);</span>
<span class="nc" id="L561">                throw new IllegalArgumentException(&quot;Unable to parse metadata&quot;);</span>
<span class="nc" id="L562">              }</span>
<span class="nc" id="L563">            }</span>
          } else {
            // AngularJS file upload lib appends &quot;.0&quot; to field name, so we cut that off
<span class="nc" id="L566">            fieldName = fieldName.substring(0, fieldName.lastIndexOf(&quot;.&quot;));</span>
<span class="nc" id="L567">            final MediaType mediaType = MediaType.parse(item.getContentType());</span>
<span class="nc" id="L568">            final boolean accepted = RequestUtils.typeIsAccepted(item.getName(), fieldName, mediaType,</span>
                    listProvidersService);
<span class="nc bnc" id="L570" title="All 2 branches missed.">            if (!accepted) {</span>
<span class="nc" id="L571">              throw new UnsupportedAssetException(&quot;Provided file format &quot; + mediaType.toString() + &quot; not allowed.&quot;);</span>
            }
<span class="nc bnc" id="L573" title="All 2 branches missed.">            if (&quot;presenter&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L574">              mp = ingestService.addTrack(item.openStream(), item.getName(), MediaPackageElements.PRESENTER_SOURCE, mp);</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">            } else if (&quot;presentation&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L576">              mp = ingestService.addTrack(item.openStream(), item.getName(), MediaPackageElements.PRESENTATION_SOURCE,</span>
                      mp);
<span class="nc bnc" id="L578" title="All 2 branches missed.">            } else if (&quot;audio&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L579">              mp = ingestService.addTrack(item.openStream(), item.getName(),</span>
                      new MediaPackageElementFlavor(&quot;presenter-audio&quot;, &quot;source&quot;), mp);
              // For dynamic uploads, cannot get flavor at this point, so saving with temporary flavor
<span class="nc bnc" id="L582" title="All 2 branches missed.">            } else if (item.getFieldName().toLowerCase().matches(attachmentRegex)) {</span>
<span class="nc" id="L583">              assetList.add(item.getFieldName());</span>
<span class="nc" id="L584">              mp =  ingestService.addAttachment(item.openStream(), item.getName(),</span>
<span class="nc" id="L585">                      new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">            } else if (item.getFieldName().toLowerCase().matches(catalogRegex)) {</span>
              // Cannot get flavor at this point, so saving with temporary flavor
<span class="nc" id="L588">              assetList.add(item.getFieldName());</span>
<span class="nc" id="L589">              mp =  ingestService.addCatalog(item.openStream(), item.getName(),</span>
<span class="nc" id="L590">                      new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">            } else if (item.getFieldName().toLowerCase().matches(trackRegex)) {</span>
              // Cannot get flavor at this point, so saving with temporary flavor
<span class="nc" id="L593">              assetList.add(item.getFieldName());</span>
<span class="nc" id="L594">              mp = ingestService.addTrack(item.openStream(), item.getName(),</span>
<span class="nc" id="L595">                      new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
            } else {
<span class="nc" id="L597">              logger.warn(&quot;Unknown field name found {}&quot;, item.getFieldName());</span>
            }
          }
<span class="nc" id="L600">        }</span>
        // MH-12085 update the flavors of any newly added assets.
        try {
<span class="nc" id="L603">          JSONArray assetMetadata = (JSONArray)((JSONObject) metadataJson.get(&quot;assets&quot;)).get(&quot;options&quot;);</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">          if (assetMetadata != null) {</span>
<span class="nc" id="L605">            mp = updateMpAssetFlavor(assetList, mp, assetMetadata);</span>
           }
<span class="nc" id="L607">          } catch (Exception e) {</span>
            // Assuming a parse error versus a file error and logging the error type
<span class="nc" id="L609">            logger.warn(&quot;Unable to process asset metadata {}&quot;, metadataJson.get(&quot;assets&quot;), e);</span>
<span class="nc" id="L610">            throw new IllegalArgumentException(&quot;Unable to parse metadata&quot;, e);</span>
<span class="nc" id="L611">          }</span>

      } else {
<span class="nc" id="L614">        throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
      }

      // MH-10834 If there is only an audio track, change the flavor from presenter-audio/source to presenter/source.
<span class="nc bnc" id="L618" title="All 2 branches missed.">      if (mp.getTracks().length == 1</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">              &amp;&amp; mp.getTracks()[0].getFlavor().equals(new MediaPackageElementFlavor(&quot;presenter-audio&quot;, &quot;source&quot;))) {</span>
<span class="nc" id="L620">        Track audioTrack = mp.getTracks()[0];</span>
<span class="nc" id="L621">        mp.remove(audioTrack);</span>
<span class="nc" id="L622">        audioTrack.setFlavor(MediaPackageElements.PRESENTER_SOURCE);</span>
<span class="nc" id="L623">        mp.add(audioTrack);</span>
      }

<span class="nc" id="L626">      return createEvent(metadataJson, mp);</span>
<span class="nc" id="L627">    } catch (FileUploadException | UnauthorizedException | ParseException | IngestException | SchedulerException</span>
        | MediaPackageException | IOException | NotFoundException e) {
<span class="nc" id="L629">      logger.error(&quot;Unable to create event:&quot;, e);</span>
<span class="nc" id="L630">      throw new IndexServiceException(&quot;Unable to create event&quot;, e);</span>
    }
  }

  @Override
  public String updateEventAssets(MediaPackage mp, HttpServletRequest request) throws IndexServiceException, UnsupportedAssetException {
<span class="nc" id="L636">    JSONObject metadataJson = null;</span>
    // regex for form field name matching an attachment or a catalog
    // The first sub items identifies if the file is an attachment or catalog
    // The second is the item flavor
    // Example form field names:  &quot;catalog/captions/timedtext&quot; and &quot;attachment/captions/vtt&quot;
    // The prefix of field name for attachment and catalog
    // The metadata is expected to contain a workflow definition id and
    // asset metadata mapped to the asset field id.
<span class="nc" id="L644">    List&lt;String&gt; assetList = new LinkedList&lt;String&gt;();</span>
    // 1. save assets with temporary flavors
    try {
<span class="nc bnc" id="L647" title="All 2 branches missed.">      if (!ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L648">        throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
      }
<span class="nc bnc" id="L650" title="All 2 branches missed.">      for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L651">        FileItemStream item = iter.next();</span>
<span class="nc" id="L652">        String fieldName = item.getFieldName();</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (item.isFormField()) {</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">          if (&quot;metadata&quot;.equals(fieldName)) {</span>
<span class="nc" id="L655">            String metadata = Streams.asString(item.openStream());</span>
            try {
<span class="nc" id="L657">              metadataJson = (JSONObject) parser.parse(metadata);</span>
<span class="nc" id="L658">            } catch (Exception e) {</span>
<span class="nc" id="L659">              logger.warn(&quot;Unable to parse metadata {}&quot;, metadata);</span>
<span class="nc" id="L660">              throw new IllegalArgumentException(&quot;Unable to parse metadata&quot;);</span>
<span class="nc" id="L661">            }</span>
<span class="nc" id="L662">          }</span>
        } else {
          // AngularJS file upload lib appends &quot;.0&quot; to field name, so we cut that off
<span class="nc" id="L665">          fieldName = fieldName.substring(0, fieldName.lastIndexOf(&quot;.&quot;));</span>
<span class="nc" id="L666">          final MediaType mediaType = MediaType.parse(item.getContentType());</span>
<span class="nc" id="L667">          final boolean accepted = RequestUtils.typeIsAccepted(item.getName(), fieldName, mediaType,</span>
                  listProvidersService);
<span class="nc bnc" id="L669" title="All 2 branches missed.">          if (!accepted) {</span>
<span class="nc" id="L670">            throw new UnsupportedAssetException(&quot;Provided file format &quot; + mediaType.toString() + &quot; not allowed.&quot;);</span>
          }
<span class="nc bnc" id="L672" title="All 2 branches missed.">          if (item.getFieldName().toLowerCase().matches(attachmentRegex)) {</span>
<span class="nc" id="L673">            assetList.add(item.getFieldName());</span>
            // Add attachment with field name as temporary flavor
<span class="nc" id="L675">            mp =  ingestService.addAttachment(item.openStream(), item.getName(),</span>
<span class="nc" id="L676">                    new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">          } else if (item.getFieldName().toLowerCase().matches(catalogRegex)) {</span>
<span class="nc" id="L678">            assetList.add(item.getFieldName());</span>
            // Add catalog with field name as temporary flavor
<span class="nc" id="L680">            mp = ingestService.addCatalog(item.openStream(), item.getName(),</span>
<span class="nc" id="L681">                new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">          } else if (item.getFieldName().toLowerCase().matches(trackRegex)) {</span>
            // Cannot get flavor at this point, so saving with temporary flavor
<span class="nc" id="L684">            assetList.add(item.getFieldName());</span>
<span class="nc" id="L685">            mp = ingestService.addTrack(item.openStream(), item.getName(),</span>
<span class="nc" id="L686">                new MediaPackageElementFlavor(item.getFieldName(), &quot;*&quot;), mp);</span>
          } else {
<span class="nc" id="L688">            logger.warn(&quot;Unknown field name found {}&quot;, item.getFieldName());</span>
          }
        }
<span class="nc" id="L691">      }</span>
      // 2. remove existing assets of the new flavor
      // and correct the temporary flavor to the new flavor.
      try {
<span class="nc" id="L695">        JSONArray assetMetadata = (JSONArray)((JSONObject) metadataJson.get(&quot;assets&quot;)).get(&quot;options&quot;);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (assetMetadata != null) {</span>
<span class="nc" id="L697">          mp = updateMpAssetFlavor(assetList, mp, assetMetadata);</span>
        } else {
<span class="nc" id="L699">          logger.warn(&quot;The asset option mapping parameter was not found&quot;);</span>
<span class="nc" id="L700">          throw new IndexServiceException(&quot;The asset option mapping parameter was not found&quot;);</span>
        }
<span class="nc" id="L702">      } catch (Exception e) {</span>
        // Assuming a parse error versus a file error and logging the error type
<span class="nc" id="L704">        logger.warn(&quot;Unable to process asset metadata {}&quot;, metadataJson.get(&quot;assets&quot;), e);</span>
<span class="nc" id="L705">        throw new IllegalArgumentException(&quot;Unable to parse metadata&quot;, e);</span>
<span class="nc" id="L706">      }</span>

<span class="nc" id="L708">      return startAddAssetWorkflow(metadataJson, mp);</span>
<span class="nc" id="L709">    } catch (MediaPackageException | FileUploadException | IOException | IngestException e) {</span>
<span class="nc" id="L710">      logger.error(&quot;Unable to create event:&quot;, e);</span>
<span class="nc" id="L711">      throw new IndexServiceException(&quot;Unable to create event&quot;, e);</span>
    }
  }

  /**
   * Parses the processing information, including the workflowDefinitionId, from the metadataJson and starts the
   * workflow with the passed mediapackage.
   * Example of processing json:
   * ...., &quot;processing&quot;: { &quot;workflow&quot;: &quot;full&quot;, &quot;configuration&quot;: { &quot;videoPreview&quot;: &quot;false&quot;, &quot;trimHold&quot;: &quot;false&quot;,
   * &quot;captionHold&quot;: &quot;false&quot;, &quot;archiveOp&quot;: &quot;true&quot;, &quot;publishEngage&quot;: &quot;true&quot;, &quot;publishHarvesting&quot;: &quot;true&quot; } }, ....
   *
   * @param metadataJson
   * @param mediaPackage
   * @return the created workflow instance id
   * @throws IndexServiceException
   */
  private String startAddAssetWorkflow(JSONObject metadataJson, MediaPackage mediaPackage)
          throws IndexServiceException {
<span class="nc" id="L729">    String wfId = null;</span>
<span class="nc" id="L730">    String mpId = mediaPackage.getIdentifier().toString();</span>

<span class="nc" id="L732">    JSONObject processing = (JSONObject) metadataJson.get(&quot;processing&quot;);</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">    if (processing == null)</span>
<span class="nc" id="L734">      throw new IllegalArgumentException(&quot;No processing field in metadata&quot;);</span>

<span class="nc" id="L736">    String workflowDefId = (String) processing.get(&quot;workflow&quot;);</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">    if (workflowDefId == null)</span>
<span class="nc" id="L738">      throw new IllegalArgumentException(&quot;No workflow definition field in processing metadata&quot;);</span>

<span class="nc" id="L740">    JSONObject configJson = (JSONObject) processing.get(&quot;configuration&quot;);</span>

    try {
      // Start the new workflow on the snapshot
      // Workflow params are assumed to be String (not mixed with Number)
<span class="nc" id="L745">      Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">      if (configJson != null) {</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">        for (Object key: configJson.keySet()) {</span>
<span class="nc" id="L748">          params.put((String)key, (String) configJson.get(key));</span>
<span class="nc" id="L749">        }</span>
      }

<span class="nc" id="L752">      WorkflowInstance workflowInstance = workflowService.start(</span>
<span class="nc" id="L753">              workflowService.getWorkflowDefinitionById(workflowDefId), mediaPackage, params);</span>
<span class="nc" id="L754">      logger.info(&quot;Asset update and publish workflow {} scheduled for mp {}&quot;, workflowInstance.getId(), mpId);</span>
<span class="nc" id="L755">    } catch (AssetManagerException | WorkflowParsingException | UnauthorizedException e) {</span>
<span class="nc" id="L756">      throw new IndexServiceException(&quot;Unable to start workflow &quot; + workflowDefId + &quot; on &quot; + mpId);</span>
<span class="nc" id="L757">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L758">      logger.warn(&quot;Unable to load workflow '{}' from workflow service:&quot;, wfId, e);</span>
<span class="nc" id="L759">    } catch (NotFoundException e) {</span>
<span class="nc" id="L760">      logger.warn(&quot;Workflow '{}' not found&quot;, wfId);</span>
<span class="nc" id="L761">    }</span>
<span class="nc" id="L762">    return wfId;</span>
  }

  /**
   * Get the type of the source that is creating the event.
   *
   * @param source
   *          The source of the event e.g. upload, single scheduled, multi scheduled
   * @return The type of the source
   * @throws IllegalArgumentException
   *           Thrown if unable to get the source from the json object.
   */
  private SourceType getSourceType(JSONObject source) {
    SourceType type;
    try {
<span class="fc" id="L777">      type = SourceType.valueOf((String) source.get(&quot;type&quot;));</span>
<span class="nc" id="L778">    } catch (Exception e) {</span>
<span class="nc" id="L779">      logger.error(&quot;Unknown source type '{}'&quot;, source.get(&quot;type&quot;));</span>
<span class="nc" id="L780">      throw new IllegalArgumentException(&quot;Unknown source type&quot;);</span>
<span class="fc" id="L781">    }</span>
<span class="fc" id="L782">    return type;</span>
  }

  /**
   * Get the access control list from a JSON representation
   *
   * @param metadataJson
   *          The {@link JSONObject} that has the access json
   * @return An {@link AccessControlList}
   * @throws IllegalArgumentException
   *           Thrown if unable to parse the access control list
   */
  private AccessControlList getAccessControlList(JSONObject metadataJson) {
<span class="fc" id="L795">    AccessControlList acl = new AccessControlList();</span>
<span class="fc" id="L796">    JSONObject accessJson = (JSONObject) metadataJson.get(&quot;access&quot;);</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">    if (accessJson != null) {</span>
      try {
<span class="fc" id="L799">        acl = AccessControlParser.parseAcl(accessJson.toJSONString());</span>
<span class="nc" id="L800">      } catch (Exception e) {</span>
<span class="nc" id="L801">        throw new IllegalArgumentException(&quot;Unable to parse access control list: &quot; + accessJson.toJSONString());</span>
<span class="fc" id="L802">      }</span>
    }
<span class="fc" id="L804">    return acl;</span>
  }

  public String createEvent(JSONObject metadataJson, MediaPackage mp) throws ParseException, IOException,
          MediaPackageException, IngestException, NotFoundException, SchedulerException, UnauthorizedException {
<span class="fc bfc" id="L809" title="All 2 branches covered.">    if (metadataJson == null)</span>
<span class="fc" id="L810">      throw new IllegalArgumentException(&quot;No metadata set&quot;);</span>

<span class="fc" id="L812">    JSONObject source = (JSONObject) metadataJson.get(&quot;source&quot;);</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">    if (source == null)</span>
<span class="fc" id="L814">      throw new IllegalArgumentException(&quot;No source field in metadata&quot;);</span>

<span class="fc" id="L816">    JSONObject processing = (JSONObject) metadataJson.get(&quot;processing&quot;);</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">    if (processing == null)</span>
<span class="fc" id="L818">      throw new IllegalArgumentException(&quot;No processing field in metadata&quot;);</span>

<span class="fc" id="L820">    JSONArray allEventMetadataJson = (JSONArray) metadataJson.get(&quot;metadata&quot;);</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">    if (allEventMetadataJson == null)</span>
<span class="fc" id="L822">      throw new IllegalArgumentException(&quot;No metadata field in metadata&quot;);</span>

<span class="fc" id="L824">    AccessControlList acl = getAccessControlList(metadataJson);</span>

<span class="fc" id="L826">    MetadataList metadataList = getMetadataListWithAllEventCatalogUIAdapters();</span>
<span class="fc" id="L827">    MetadataJson.fillListFromJson(metadataList, allEventMetadataJson);</span>

<span class="fc" id="L829">    EventHttpServletRequest eventHttpServletRequest = new EventHttpServletRequest();</span>
<span class="fc" id="L830">    eventHttpServletRequest.setAcl(acl);</span>
<span class="fc" id="L831">    eventHttpServletRequest.setMetadataList(metadataList);</span>
<span class="fc" id="L832">    eventHttpServletRequest.setMediaPackage(mp);</span>
<span class="fc" id="L833">    eventHttpServletRequest.setProcessing(processing);</span>
<span class="fc" id="L834">    eventHttpServletRequest.setSource(source);</span>

<span class="fc" id="L836">    return createEvent(eventHttpServletRequest);</span>
  }

  @Override
  public String createEvent(EventHttpServletRequest eventHttpServletRequest) throws ParseException, IOException,
          MediaPackageException, IngestException, NotFoundException, SchedulerException, UnauthorizedException {
    // Preconditions
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">    if (eventHttpServletRequest.getAcl().isNone()) {</span>
<span class="nc" id="L844">      throw new IllegalArgumentException(&quot;No access control list available to create new event.&quot;);</span>
    }
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">    if (eventHttpServletRequest.getMediaPackage().isNone()) {</span>
<span class="nc" id="L847">      throw new IllegalArgumentException(&quot;No mediapackage available to create new event.&quot;);</span>
    }
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">    if (eventHttpServletRequest.getMetadataList().isNone()) {</span>
<span class="nc" id="L850">      throw new IllegalArgumentException(&quot;No metadata list available to create new event.&quot;);</span>
    }
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">    if (eventHttpServletRequest.getProcessing().isNone()) {</span>
<span class="nc" id="L853">      throw new IllegalArgumentException(&quot;No processing metadata available to create new event.&quot;);</span>
    }
<span class="pc bpc" id="L855" title="1 of 2 branches missed.">    if (eventHttpServletRequest.getSource().isNone()) {</span>
<span class="nc" id="L856">      throw new IllegalArgumentException(&quot;No source field metadata available to create new event.&quot;);</span>
    }

    // Get Workflow
<span class="fc" id="L860">    String workflowTemplate = (String) eventHttpServletRequest.getProcessing().get().get(&quot;workflow&quot;);</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">    if (workflowTemplate == null)</span>
<span class="nc" id="L862">      throw new IllegalArgumentException(&quot;No workflow template in metadata&quot;);</span>

    // Get Type of Source
<span class="fc" id="L865">    SourceType type = getSourceType(eventHttpServletRequest.getSource().get());</span>

<span class="fc" id="L867">    DublinCoreMetadataCollection eventMetadata = eventHttpServletRequest.getMetadataList().get()</span>
<span class="fc" id="L868">            .getMetadataByAdapter(getCommonEventCatalogUIAdapter());</span>

<span class="fc" id="L870">    Date currentStartDate = null;</span>
<span class="fc" id="L871">    JSONObject sourceMetadata = (JSONObject) eventHttpServletRequest.getSource().get().get(&quot;metadata&quot;);</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">    if (sourceMetadata != null</span>
<span class="pc bpc" id="L873" title="1 of 4 branches missed.">            &amp;&amp; (type.equals(SourceType.SCHEDULE_SINGLE) || type.equals(SourceType.SCHEDULE_MULTIPLE))) {</span>
      try {
<span class="fc" id="L875">        MetadataField current = eventMetadata.getOutputFields().get(&quot;location&quot;);</span>
<span class="fc" id="L876">        eventMetadata.updateStringField(current, (String) sourceMetadata.get(&quot;device&quot;));</span>
<span class="nc" id="L877">      } catch (Exception e) {</span>
<span class="nc" id="L878">        logger.warn(&quot;Unable to parse device {}&quot;, sourceMetadata.get(&quot;device&quot;));</span>
<span class="nc" id="L879">        throw new IllegalArgumentException(&quot;Unable to parse device&quot;);</span>
<span class="fc" id="L880">      }</span>
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">      if (StringUtils.isNotEmpty((String) sourceMetadata.get(&quot;start&quot;))) {</span>
<span class="fc" id="L882">        currentStartDate = EncodingSchemeUtils.decodeDate((String) sourceMetadata.get(&quot;start&quot;));</span>
      }
    }

<span class="fc" id="L886">    MetadataField startDate = eventMetadata.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="pc bpc" id="L887" title="4 of 6 branches missed.">    if (startDate != null &amp;&amp; startDate.isUpdated() &amp;&amp; startDate.getValue() != null) {</span>
<span class="nc" id="L888">      SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(startDate.getPattern());</span>
<span class="nc" id="L889">      currentStartDate = sdf.parse((String) startDate.getValue());</span>
<span class="pc bfc" id="L890" title="All 2 branches covered.">    } else if (currentStartDate != null) {</span>
<span class="fc" id="L891">      eventMetadata.removeField(startDate);</span>
<span class="fc" id="L892">      MetadataField newStartDate = new MetadataField(startDate);</span>
<span class="fc" id="L893">      newStartDate.setValue(EncodingSchemeUtils.encodeDate(currentStartDate, Precision.Fraction).getValue());</span>
<span class="fc" id="L894">      eventMetadata.addField(newStartDate);</span>
    }

    // This field is null when it is not used in the Admin UI event details metadata tab.
    // If used, set it to the the start Date or a new date.
    // Note, even though this field borrows the DublinCore.PROPERTY_CREATED key,
    // the startDate is used to update the DublinCore catalog PROPERTY_CREATED field,
    // event, and mediapackage start fields.
<span class="fc" id="L902">    MetadataField created = eventMetadata.getOutputFields().get(DublinCore.PROPERTY_CREATED.getLocalName());</span>
<span class="pc bpc" id="L903" title="4 of 6 branches missed.">    if (created != null &amp;&amp; (!created.isUpdated() || created.getValue() == null)) {</span>
<span class="fc" id="L904">      eventMetadata.removeField(created);</span>
<span class="fc" id="L905">      MetadataField newCreated = new MetadataField(created);</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">      if (currentStartDate != null) {</span>
<span class="fc" id="L907">        newCreated.setValue(EncodingSchemeUtils.encodeDate(currentStartDate, Precision.Second).getValue());</span>
      } else {
<span class="fc" id="L909">        newCreated.setValue(EncodingSchemeUtils.encodeDate(new Date(), Precision.Second).getValue());</span>
      }
<span class="fc" id="L911">      eventMetadata.addField(newCreated);</span>
    }

    // Get presenter usernames for use as technical presenters
<span class="fc" id="L915">    Set&lt;String&gt; presenterUsernames = new HashSet&lt;&gt;();</span>
<span class="fc" id="L916">    Opt&lt;Set&lt;String&gt;&gt; technicalPresenters = updatePresenters(eventMetadata);</span>
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">    if (technicalPresenters.isSome()) {</span>
<span class="fc" id="L918">      presenterUsernames = technicalPresenters.get();</span>
    }

<span class="fc" id="L921">    eventHttpServletRequest.getMetadataList().get().add(getCommonEventCatalogUIAdapter(), eventMetadata);</span>
<span class="fc" id="L922">    updateMediaPackageMetadata(eventHttpServletRequest.getMediaPackage().get(),</span>
<span class="fc" id="L923">            eventHttpServletRequest.getMetadataList().get());</span>

<span class="fc" id="L925">    DublinCoreCatalog dc = getDublinCoreCatalog(eventHttpServletRequest);</span>
<span class="fc" id="L926">    String captureAgentId = null;</span>
<span class="fc" id="L927">    TimeZone tz = null;</span>
<span class="fc" id="L928">    org.joda.time.DateTime start = null;</span>
<span class="fc" id="L929">    org.joda.time.DateTime end = null;</span>
<span class="fc" id="L930">    long duration = 0L;</span>
<span class="fc" id="L931">    Properties caProperties = new Properties();</span>
<span class="fc" id="L932">    RRule rRule = null;</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">    if (sourceMetadata != null</span>
<span class="pc bpc" id="L934" title="1 of 4 branches missed.">            &amp;&amp; (type.equals(SourceType.SCHEDULE_SINGLE) || type.equals(SourceType.SCHEDULE_MULTIPLE))) {</span>
      Properties configuration;
      try {
<span class="fc" id="L937">        captureAgentId = (String) sourceMetadata.get(&quot;device&quot;);</span>
<span class="fc" id="L938">        configuration = captureAgentStateService.getAgentConfiguration((String) sourceMetadata.get(&quot;device&quot;));</span>
<span class="nc" id="L939">      } catch (Exception e) {</span>
<span class="nc" id="L940">        logger.warn(&quot;Unable to parse device {}: because:&quot;, sourceMetadata.get(&quot;device&quot;), e);</span>
<span class="nc" id="L941">        throw new IllegalArgumentException(&quot;Unable to parse device&quot;);</span>
<span class="fc" id="L942">      }</span>

<span class="fc" id="L944">      String durationString = (String) sourceMetadata.get(&quot;duration&quot;);</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">      if (StringUtils.isBlank(durationString))</span>
<span class="nc" id="L946">        throw new IllegalArgumentException(&quot;No duration in source metadata&quot;);</span>

      // Create timezone based on CA's reported TZ.
<span class="fc" id="L949">      String agentTimeZone = configuration.getProperty(&quot;capture.device.timezone&quot;);</span>
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(agentTimeZone)) {</span>
<span class="fc" id="L951">        tz = TimeZone.getTimeZone(agentTimeZone);</span>
<span class="fc" id="L952">        dc.set(DublinCores.OC_PROPERTY_AGENT_TIMEZONE, tz.getID());</span>
      } else { // No timezone was present, assume the serve's local timezone.
<span class="nc" id="L954">        tz = TimeZone.getDefault();</span>
<span class="nc" id="L955">        logger.debug(</span>
                &quot;The field 'capture.device.timezone' has not been set in the agent configuration. The default server timezone will be used.&quot;);
      }

<span class="fc" id="L959">      org.joda.time.DateTime now = new org.joda.time.DateTime(DateTimeZone.UTC);</span>
<span class="fc" id="L960">      start = now.withMillis(DateTimeSupport.fromUTC((String) sourceMetadata.get(&quot;start&quot;)));</span>
<span class="fc" id="L961">      end = now.withMillis(DateTimeSupport.fromUTC((String) sourceMetadata.get(&quot;end&quot;)));</span>
<span class="fc" id="L962">      duration = Long.parseLong(durationString);</span>
<span class="fc" id="L963">      DublinCoreValue period = EncodingSchemeUtils</span>
<span class="fc" id="L964">              .encodePeriod(new DCMIPeriod(start.toDate(), start.plus(duration).toDate()), Precision.Second);</span>
<span class="fc" id="L965">      String inputs = (String) sourceMetadata.get(&quot;inputs&quot;);</span>

<span class="fc" id="L967">      caProperties.putAll(configuration);</span>
<span class="fc" id="L968">      dc.set(DublinCore.PROPERTY_TEMPORAL, period);</span>
<span class="fc" id="L969">      caProperties.put(CaptureParameters.CAPTURE_DEVICE_NAMES, inputs);</span>
    }

<span class="fc bfc" id="L972" title="All 2 branches covered.">    if (type.equals(SourceType.SCHEDULE_MULTIPLE)) {</span>
<span class="fc" id="L973">      rRule = new RRule((String) sourceMetadata.get(&quot;rrule&quot;));</span>
    }

<span class="fc" id="L976">    Map&lt;String, String&gt; configuration = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">    if (eventHttpServletRequest.getProcessing().get().get(&quot;configuration&quot;) != null) {</span>
<span class="fc" id="L978">      configuration = new HashMap&lt;&gt;((JSONObject) eventHttpServletRequest.getProcessing().get().get(&quot;configuration&quot;));</span>

    }
<span class="fc bfc" id="L981" title="All 2 branches covered.">    for (Entry&lt;String, String&gt; entry : configuration.entrySet()) {</span>
<span class="fc" id="L982">      caProperties.put(WORKFLOW_CONFIG_PREFIX.concat(entry.getKey()), entry.getValue());</span>
<span class="fc" id="L983">    }</span>
<span class="fc" id="L984">    caProperties.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, workflowTemplate);</span>

<span class="fc" id="L986">    eventHttpServletRequest.setMediaPackage(authorizationService.setAcl(eventHttpServletRequest.getMediaPackage().get(),</span>
<span class="fc" id="L987">            AclScope.Episode, eventHttpServletRequest.getAcl().get()).getA());</span>

    MediaPackage mediaPackage;
<span class="pc bpc" id="L990" title="1 of 4 branches missed.">    switch (type) {</span>
      case UPLOAD:
      case UPLOAD_LATER:
<span class="fc" id="L993">        eventHttpServletRequest</span>
<span class="fc" id="L994">                .setMediaPackage(updateDublincCoreCatalog(eventHttpServletRequest.getMediaPackage().get(), dc));</span>
<span class="fc" id="L995">        configuration.put(&quot;workflowDefinitionId&quot;, workflowTemplate);</span>
<span class="fc" id="L996">        WorkflowInstance ingest = ingestService.ingest(eventHttpServletRequest.getMediaPackage().get(),</span>
                workflowTemplate, configuration);
<span class="fc" id="L998">        return eventHttpServletRequest.getMediaPackage().get().getIdentifier().toString();</span>
      case SCHEDULE_SINGLE:
<span class="fc" id="L1000">        mediaPackage = updateDublincCoreCatalog(eventHttpServletRequest.getMediaPackage().get(), dc);</span>
<span class="fc" id="L1001">        eventHttpServletRequest.setMediaPackage(mediaPackage);</span>
        try {
<span class="fc" id="L1003">          schedulerService.addEvent(start.toDate(), start.plus(duration).toDate(), captureAgentId, presenterUsernames,</span>
<span class="fc" id="L1004">                  mediaPackage, configuration, (Map) caProperties, Opt.&lt;String&gt; none());</span>
        } finally {
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">          for (MediaPackageElement mediaPackageElement : mediaPackage.getElements()) {</span>
            try {
<span class="nc" id="L1008">              workspace.delete(mediaPackage.getIdentifier().toString(), mediaPackageElement.getIdentifier());</span>
<span class="nc" id="L1009">            } catch (NotFoundException | IOException e) {</span>
<span class="nc" id="L1010">              logger.warn(&quot;Failed to delete media package element&quot;, e);</span>
<span class="nc" id="L1011">            }</span>
          }
        }
<span class="fc" id="L1014">        return mediaPackage.getIdentifier().toString();</span>
      case SCHEDULE_MULTIPLE:
<span class="fc" id="L1016">        final Map&lt;String, Period&gt; scheduled = schedulerService.addMultipleEvents(rRule, start.toDate(), end.toDate(), duration, tz, captureAgentId,</span>
<span class="fc" id="L1017">                presenterUsernames, eventHttpServletRequest.getMediaPackage().get(), configuration, (Map) caProperties, Opt.none());</span>
<span class="fc" id="L1018">        return StringUtils.join(scheduled.keySet(), &quot;,&quot;);</span>
      default:
<span class="nc" id="L1020">        throw new IllegalArgumentException(&quot;Unknown source type: &quot; + type);</span>
    }
  }

  /**
   * Get the {@link DublinCoreCatalog} from an {@link EventHttpServletRequest}.
   *
   * @param eventHttpServletRequest
   *          The request to extract the {@link DublinCoreCatalog} from.
   * @return The {@link DublinCoreCatalog}
   */
  private DublinCoreCatalog getDublinCoreCatalog(EventHttpServletRequest eventHttpServletRequest) {
    DublinCoreCatalog dc;
<span class="fc" id="L1033">    Optional&lt;DublinCoreCatalog&gt; dcOpt = DublinCoreUtil.loadEpisodeDublinCore(workspace,</span>
<span class="fc" id="L1034">            eventHttpServletRequest.getMediaPackage().get());</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">    if (dcOpt.isPresent()) {</span>
<span class="nc" id="L1036">      dc = dcOpt.get();</span>
      // make sure to bind the OC_PROPERTY namespace
<span class="nc" id="L1038">      dc.addBindings(XmlNamespaceContext</span>
<span class="nc" id="L1039">              .mk(XmlNamespaceBinding.mk(DublinCores.OC_PROPERTY_NS_PREFIX, DublinCores.OC_PROPERTY_NS_URI)));</span>
    } else {
<span class="fc" id="L1041">      dc = DublinCores.mkOpencastEpisode().getCatalog();</span>
    }
<span class="fc" id="L1043">    return dc;</span>
  }

  /**
   * Update the presenters field in the event {@link DublinCoreMetadataCollection} to have friendly names loaded by the
   * {@link UserDirectoryService} and return the usernames of the presenters.
   *
   * @param eventMetadata
   *          The {@link DublinCoreMetadataCollection} to update the presenters (creator field) with full names.
   * @return If the presenters (creator) field has been updated, the set of user names, if any, of the presenters. None
   *         if it wasn't updated.
   */
  private Opt&lt;Set&lt;String&gt;&gt; updatePresenters(DublinCoreMetadataCollection eventMetadata) {
<span class="fc" id="L1056">    MetadataField presentersMetadataField = eventMetadata.getOutputFields()</span>
<span class="fc" id="L1057">            .get(DublinCore.PROPERTY_CREATOR.getLocalName());</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">    if (presentersMetadataField.isUpdated()) {</span>
<span class="fc" id="L1059">      Tuple&lt;List&lt;String&gt;, Set&lt;String&gt;&gt; updatedPresenters = getTechnicalPresenters(eventMetadata);</span>
<span class="fc" id="L1060">      Set&lt;String&gt; presenterUsernames = updatedPresenters.getB();</span>
<span class="fc" id="L1061">      eventMetadata.removeField(presentersMetadataField);</span>
<span class="fc" id="L1062">      MetadataField newPresentersMetadataField = new MetadataField(presentersMetadataField);</span>
<span class="fc" id="L1063">      newPresentersMetadataField.setValue(updatedPresenters.getA());</span>
<span class="fc" id="L1064">      eventMetadata.addField(newPresentersMetadataField);</span>
<span class="fc" id="L1065">      return Opt.some(presenterUsernames);</span>
    } else {
<span class="fc" id="L1067">      return Opt.none();</span>
    }
  }

  /**
   *
   * @param mp
   *          the mediapackage to update
   * @param dc
   *          the dublincore metadata to use to update the mediapackage
   * @return the updated mediapackage
   * @throws IOException
   *           Thrown if an IO error occurred adding the dc catalog file
   * @throws MediaPackageException
   *           Thrown if an error occurred updating the mediapackage
   * @throws IngestException
   *           Thrown if an error occurred attaching the catalog to the mediapackage
   */
  private MediaPackage updateDublincCoreCatalog(MediaPackage mp, DublinCoreCatalog dc)
          throws IOException, MediaPackageException, IngestException {
<span class="fc" id="L1087">    try (InputStream inputStream = IOUtils.toInputStream(dc.toXmlString(), &quot;UTF-8&quot;)) {</span>
      // Update dublincore catalog
<span class="fc" id="L1089">      Catalog[] catalogs = mp.getCatalogs(MediaPackageElements.EPISODE);</span>
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">      if (catalogs.length &gt; 0) {</span>
<span class="nc" id="L1091">        Catalog catalog = catalogs[0];</span>
<span class="nc" id="L1092">        URI uri = workspace.put(mp.getIdentifier().toString(), catalog.getIdentifier(), &quot;dublincore.xml&quot;, inputStream);</span>
<span class="nc" id="L1093">        catalog.setURI(uri);</span>
        // setting the URI to a new source so the checksum will most like be invalid
<span class="nc" id="L1095">        catalog.setChecksum(null);</span>
<span class="nc" id="L1096">      } else {</span>
<span class="fc" id="L1097">        mp = ingestService.addCatalog(inputStream, &quot;dublincore.xml&quot;, MediaPackageElements.EPISODE, mp);</span>
      }
    }
<span class="fc" id="L1100">    return mp;</span>
  }

  /**
   * Update the flavor of newly added asset with the passed metadata
   *
   * @param assetList
   *          the list of assets to update
   * @param mp
   *          the mediapackage to update
   * @param assetMetadata
   *          a set of mapping metadata for the asset list
   * @return mediapackage updated with assets
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  protected MediaPackage updateMpAssetFlavor(List&lt;String&gt; assetList, MediaPackage mp, JSONArray assetMetadata) {
    // Create JSONObject data map
<span class="fc" id="L1117">    JSONObject assetDataMap = new JSONObject();</span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">    for (int i = 0; i &lt; assetMetadata.size(); i++) {</span>
      try {
<span class="fc" id="L1120">        assetDataMap.put(((JSONObject) assetMetadata.get(i)).get(&quot;id&quot;), assetMetadata.get(i));</span>
<span class="nc" id="L1121">      } catch (Exception e) {</span>
<span class="nc" id="L1122">        throw new IllegalArgumentException(&quot;Unable to parse metadata&quot;, e);</span>
<span class="fc" id="L1123">      }</span>
    }
    // Find the correct flavor for each asset.
<span class="fc bfc" id="L1126" title="All 2 branches covered.">    for (String assetOrig: assetList) {</span>
      // expecting file assets to contain postfix &quot;track_trackpart.0&quot;
<span class="fc" id="L1128">      String asset = assetOrig;</span>
<span class="fc" id="L1129">      String assetNumber = null;</span>
<span class="fc" id="L1130">      String[] assetNameParts = asset.split(Pattern.quote(&quot;.&quot;));</span>
<span class="pc bpc" id="L1131" title="1 of 2 branches missed.">      if (assetNameParts.length &gt; 1) {</span>
<span class="nc" id="L1132">        asset = assetNameParts[0];</span>
<span class="nc" id="L1133">        assetNumber = assetNameParts[1];</span>
      }
      try {
<span class="pc bpc" id="L1136" title="2 of 4 branches missed.">        if ((assetMetadata != null) &amp;&amp; (assetDataMap.get(asset) != null)) {</span>
<span class="fc" id="L1137">          String type = (String)((JSONObject) assetDataMap.get(asset)).get(&quot;type&quot;);</span>
<span class="fc" id="L1138">          String flavorType = (String)((JSONObject) assetDataMap.get(asset)).get(&quot;flavorType&quot;);</span>
<span class="fc" id="L1139">          String flavorSubType = (String)((JSONObject) assetDataMap.get(asset)).get(&quot;flavorSubType&quot;);</span>
<span class="fc" id="L1140">          String tags = (String)((JSONObject) assetDataMap.get(asset)).get(&quot;tags&quot;);</span>
<span class="fc" id="L1141">          String[] tagsArray = null;</span>
          // Captions may have lang:LANG_CODE tag set.
<span class="fc" id="L1143">          String langTag = null;</span>
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">          if (tags != null) {</span>
<span class="nc" id="L1145">            tagsArray = tags.split(&quot;,&quot;);</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">            for (String tag : tagsArray) {</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">              if (StringUtils.startsWith(StringUtils.trimToEmpty(tag), &quot;lang:&quot;)) {</span>
<span class="nc" id="L1148">                langTag = StringUtils.trimToEmpty(tag);</span>
<span class="nc" id="L1149">                break;</span>
              }
            }
          }
          // Use 'multiple' setting to allow multiple elements with same flavor or not.
<span class="pc bpc" id="L1154" title="1 of 2 branches missed.">          boolean overwriteExisting = !(Boolean) ((JSONObject) assetDataMap.get(asset)).getOrDefault(&quot;multiple&quot;, false);</span>
<span class="pc bpc" id="L1155" title="3 of 4 branches missed.">          if (patternNumberedAsset.matcher(flavorSubType).matches() &amp;&amp; (assetNumber != null)) {</span>
<span class="nc" id="L1156">            flavorSubType = assetNumber;</span>
          }
<span class="fc" id="L1158">          MediaPackageElementFlavor newElemflavor = new MediaPackageElementFlavor(flavorType, flavorSubType);</span>
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">          if (patternAttachment.matcher(type).matches()) {</span>
<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">            if (overwriteExisting) {</span>
              // remove existing attachments of the new flavor
<span class="fc" id="L1162">              Attachment[] existing = mp.getAttachments(newElemflavor);</span>
<span class="pc bpc" id="L1163" title="1 of 2 branches missed.">              for (int i = 0; i &lt; existing.length; i++) {</span>
                // if lang tag is set, we should only remove elements with the same lang tag
<span class="nc bnc" id="L1165" title="All 4 branches missed.">                if (null == langTag || existing[i].containsTag(langTag)) {</span>
<span class="nc" id="L1166">                  mp.remove(existing[i]);</span>
<span class="nc" id="L1167">                  logger.info(&quot;Overwriting existing asset {} {}&quot;, type, newElemflavor);</span>
                }
              }
            }
            // correct the flavor of the new attachment
<span class="fc" id="L1172">            Attachment[] elArray = mp.getAttachments(new MediaPackageElementFlavor(assetOrig, &quot;*&quot;));</span>
<span class="fc" id="L1173">            elArray[0].setFlavor(newElemflavor);</span>
<span class="pc bpc" id="L1174" title="3 of 4 branches missed.">            if (tags != null &amp;&amp; tagsArray.length &gt; 0) {</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">              for (String tag : tagsArray) {</span>
<span class="nc" id="L1176">                elArray[0].addTag(tag);</span>
              }
            }
<span class="fc" id="L1179">            logger.info(&quot;Updated asset {} {}&quot;, type, newElemflavor);</span>
<span class="pc bnc" id="L1180" title="All 2 branches missed.">          } else if (patternCatalog.matcher(type).matches()) {</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">            if (overwriteExisting) {</span>
              // remove existing catalogs of the new flavor
<span class="nc" id="L1183">              Catalog[] existing = mp.getCatalogs(newElemflavor);</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">              for (int i = 0; i &lt; existing.length; i++) {</span>
                // if lang tag is set, we should only remove elements with the same lang tag
<span class="nc bnc" id="L1186" title="All 4 branches missed.">                if (null == langTag || existing[i].containsTag(langTag)) {</span>
<span class="nc" id="L1187">                  mp.remove(existing[i]);</span>
<span class="nc" id="L1188">                  logger.info(&quot;Overwriting existing asset {} {}&quot;, type, newElemflavor);</span>
                }
              }
            }
<span class="nc" id="L1192">            Catalog[] catArray = mp.getCatalogs(new MediaPackageElementFlavor(assetOrig, &quot;*&quot;));</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            if (catArray.length &gt; 1) {</span>
<span class="nc" id="L1194">              throw new IllegalArgumentException(&quot;More than one &quot; + asset + &quot; found, only one expected.&quot;);</span>
            }
<span class="nc" id="L1196">            catArray[0].setFlavor(newElemflavor);</span>
<span class="nc bnc" id="L1197" title="All 4 branches missed.">            if (tags != null &amp;&amp; tagsArray.length &gt; 0) {</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">              for (String tag : tagsArray) {</span>
<span class="nc" id="L1199">                catArray[0].addTag(tag);</span>
              }
            }
<span class="nc" id="L1202">            logger.info(&quot;Update asset {} {}&quot;, type, newElemflavor);</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">          } else if (patternTrack.matcher(type).matches()) {</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">            if (overwriteExisting) {</span>
              // remove existing catalogs of the new flavor
<span class="nc" id="L1206">              Track[] existing = mp.getTracks(newElemflavor);</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">              for (int i = 0; i &lt; existing.length; i++) {</span>
                // if lang tag is set, we should only remove elements with the same lang tag
<span class="nc bnc" id="L1209" title="All 4 branches missed.">                if (null == langTag || existing[i].containsTag(langTag)) {</span>
<span class="nc" id="L1210">                  mp.remove(existing[i]);</span>
<span class="nc" id="L1211">                  logger.info(&quot;Overwriting existing asset {} {}&quot;, type, newElemflavor);</span>
                }
              }
            }
<span class="nc" id="L1215">            Track[]  trackArray = mp.getTracks(new MediaPackageElementFlavor(assetOrig, &quot;*&quot;));</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">            if (trackArray.length &gt; 1) {</span>
<span class="nc" id="L1217">              throw new IllegalArgumentException(&quot;More than one &quot; + asset + &quot; found, only one expected.&quot;);</span>
            }
<span class="nc" id="L1219">            trackArray[0].setFlavor(newElemflavor);</span>
<span class="nc bnc" id="L1220" title="All 4 branches missed.">            if (tags != null &amp;&amp; tagsArray.length &gt; 0) {</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">              for (String tag : tagsArray) {</span>
<span class="nc" id="L1222">                trackArray[0].addTag(tag);</span>
              }
            }
<span class="nc" id="L1225">            logger.info(&quot;Update asset {} {}&quot;, type, newElemflavor);</span>
<span class="nc" id="L1226">          } else {</span>
<span class="nc" id="L1227">            logger.warn(&quot;Unknown asset type {} {} for field {}&quot;, type, newElemflavor, asset);</span>
          }
        }
<span class="nc" id="L1230">      } catch (Exception e) {</span>
        // Assuming a parse error versus a file error and logging the error type
<span class="nc" id="L1232">        throw new IllegalArgumentException(&quot;Unable to parse metadata: &quot; + assetMetadata.toJSONString(), e);</span>
<span class="fc" id="L1233">      }</span>
<span class="fc" id="L1234">    }</span>
<span class="fc" id="L1235">    return mp;</span>
  }

  @Override
  public MetadataList updateAllEventMetadata(
          final String id, final String metadataJSON, final ElasticsearchIndex index)
          throws IllegalArgumentException, IndexServiceException, NotFoundException, SearchIndexException,
          UnauthorizedException {
    final MetadataList metadataList;
    try {
<span class="fc" id="L1245">      metadataList = getMetadataListWithAllEventCatalogUIAdapters();</span>
<span class="nc" id="L1246">      MetadataJson.fillListFromJson(metadataList, (JSONArray) new JSONParser().parse(metadataJSON));</span>
<span class="nc" id="L1247">    } catch (final org.json.simple.parser.ParseException e) {</span>
<span class="nc" id="L1248">      throw new IllegalArgumentException(&quot;Not able to parse the event metadata &quot; + metadataJSON, e);</span>
<span class="nc" id="L1249">    }</span>
<span class="nc" id="L1250">    return updateEventMetadata(id, metadataList, index);</span>
  }

  @Override
  public void removeCatalogByFlavor(Event event, MediaPackageElementFlavor flavor)
          throws IndexServiceException, NotFoundException, UnauthorizedException {
<span class="nc" id="L1256">    MediaPackage mediaPackage = getEventMediapackage(event);</span>
<span class="nc" id="L1257">    Catalog[] catalogs = mediaPackage.getCatalogs(flavor);</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">    if (catalogs.length == 0) {</span>
<span class="nc" id="L1259">      throw new NotFoundException(String.format(&quot;Cannot find a catalog with flavor '%s' for event with id '%s'.&quot;,</span>
<span class="nc" id="L1260">              flavor.toString(), event.getIdentifier()));</span>
    }
<span class="nc bnc" id="L1262" title="All 2 branches missed.">    for (Catalog catalog : catalogs) {</span>
<span class="nc" id="L1263">      mediaPackage.remove(catalog);</span>
    }
<span class="nc bnc" id="L1265" title="All 4 branches missed.">    switch (getEventSource(event)) {</span>
      case WORKFLOW:
        try {
<span class="nc" id="L1268">          Optional&lt;WorkflowInstance&gt; workflowInstance = workflowService.</span>
<span class="nc" id="L1269">                  getRunningWorkflowInstanceByMediaPackage(event.getIdentifier(), Permissions.Action.WRITE.toString());</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">          if (workflowInstance.isEmpty()) {</span>
<span class="nc" id="L1271">            throw new IndexServiceException(&quot;No workflow instance found for event &quot; + event.getIdentifier());</span>
          }
<span class="nc" id="L1273">          WorkflowInstance instance = workflowInstance.get();</span>
<span class="nc" id="L1274">          instance.setMediaPackage(mediaPackage);</span>
<span class="nc" id="L1275">          updateWorkflowInstance(instance);</span>
<span class="nc" id="L1276">        } catch (WorkflowException e) {</span>
<span class="nc" id="L1277">          throw new IndexServiceException(&quot;Unable to remove catalog with flavor '&quot; + flavor</span>
<span class="nc" id="L1278">              + &quot;' by updating workflow event &quot; + event.getIdentifier(), e);</span>
<span class="nc" id="L1279">        }</span>
        break;
      case ARCHIVE:
<span class="nc" id="L1282">        assetManager.takeSnapshot(mediaPackage);</span>
<span class="nc" id="L1283">        break;</span>
      case SCHEDULE:
        try {
<span class="nc" id="L1286">          schedulerService.updateEvent(event.getIdentifier(), Opt.none(), Opt.none(), Opt.none(), Opt.none(),</span>
<span class="nc" id="L1287">              Opt.some(mediaPackage), Opt.none(), Opt.none());</span>
<span class="nc" id="L1288">        } catch (SchedulerException e) {</span>
<span class="nc" id="L1289">          throw new IndexServiceException(&quot;Unable to remove catalog with flavor &quot; + flavor + &quot; by updating scheduled &quot;</span>
<span class="nc" id="L1290">              + &quot;event &quot; + event.getIdentifier(), e);</span>
<span class="nc" id="L1291">        }</span>
        break;
      default:
<span class="nc" id="L1294">        throw new IndexServiceException(</span>
<span class="nc" id="L1295">                String.format(&quot;Unable to handle event source type '%s'&quot;, getEventSource(event)));</span>
    }
<span class="nc" id="L1297">  }</span>

  @Override
  public void removeCatalogByFlavor(Series series, MediaPackageElementFlavor flavor)
          throws NotFoundException, IndexServiceException {
<span class="nc bnc" id="L1302" title="All 2 branches missed.">    if (series == null) {</span>
<span class="nc" id="L1303">      throw new IllegalArgumentException(&quot;The series cannot be null.&quot;);</span>
    }
<span class="nc bnc" id="L1305" title="All 2 branches missed.">    if (flavor == null) {</span>
<span class="nc" id="L1306">      throw new IllegalArgumentException(&quot;The flavor cannot be null.&quot;);</span>
    }
<span class="nc" id="L1308">    boolean found = false;</span>
    try {
<span class="nc" id="L1310">      found = seriesService.deleteSeriesElement(series.getIdentifier(), flavor.getType());</span>
<span class="nc" id="L1311">    } catch (SeriesException e) {</span>
<span class="nc" id="L1312">      throw new IndexServiceException(String.format(&quot;Unable to delete catalog from series '%s' with type '%s'&quot;,</span>
<span class="nc" id="L1313">              series.getIdentifier(), flavor.getType()), e);</span>
<span class="nc" id="L1314">    }</span>

<span class="nc bnc" id="L1316" title="All 2 branches missed.">    if (!found) {</span>
<span class="nc" id="L1317">      throw new NotFoundException(String.format(&quot;Unable to find a catalog for series '%s' with flavor '%s'&quot;,</span>
<span class="nc" id="L1318">              series.getIdentifier(), flavor));</span>
    }
<span class="nc" id="L1320">  }</span>

  @Override
  public MetadataList updateEventMetadata(String id, MetadataList metadataList, ElasticsearchIndex index)
          throws IndexServiceException, SearchIndexException, NotFoundException, UnauthorizedException {
<span class="fc" id="L1325">    Opt&lt;Event&gt; optEvent = getEvent(id, index);</span>
<span class="fc bfc" id="L1326" title="All 2 branches covered.">    if (optEvent.isNone())</span>
<span class="fc" id="L1327">      throw new NotFoundException(&quot;Cannot find an event with id &quot; + id);</span>

<span class="fc" id="L1329">    Event event = optEvent.get();</span>
<span class="fc" id="L1330">    MediaPackage mediaPackage = getEventMediapackage(event);</span>
<span class="fc" id="L1331">    updateMediaPackageMetadata(mediaPackage, metadataList);</span>
<span class="pc bpc" id="L1332" title="3 of 4 branches missed.">    switch (getEventSource(event)) {</span>
      case WORKFLOW:
        try {
<span class="nc" id="L1335">          Optional&lt;WorkflowInstance&gt; workflowInstance = workflowService.</span>
<span class="nc" id="L1336">                  getRunningWorkflowInstanceByMediaPackage(event.getIdentifier(), Permissions.Action.WRITE.toString());</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">          if (workflowInstance.isEmpty()) {</span>
<span class="nc" id="L1338">            throw new IndexServiceException(&quot;No workflow instance found for event &quot; + event.getIdentifier());</span>
          }
<span class="nc" id="L1340">          WorkflowInstance instance = workflowInstance.get();</span>
<span class="nc" id="L1341">          instance.setMediaPackage(mediaPackage);</span>
<span class="nc" id="L1342">          updateWorkflowInstance(instance);</span>
<span class="nc" id="L1343">        } catch (WorkflowException e) {</span>
<span class="nc" id="L1344">          throw new IndexServiceException(&quot;Unable to update workflow event &quot; + id + &quot; with metadata &quot;</span>
<span class="nc" id="L1345">              + RestUtils.getJsonStringSilent(MetadataJson.listToJson(metadataList, true)), e);</span>
<span class="nc" id="L1346">        }</span>
        break;
      case ARCHIVE:
<span class="nc" id="L1349">        assetManager.takeSnapshot(mediaPackage);</span>
<span class="nc" id="L1350">        break;</span>
      case SCHEDULE:
<span class="fc" id="L1352">        DublinCoreMetadataCollection eventCatalog = metadataList.getMetadataByAdapter(getCommonEventCatalogUIAdapter());</span>
<span class="pc bpc" id="L1353" title="1 of 2 branches missed.">        Opt&lt;Set&lt;String&gt;&gt; presenters = eventCatalog == null ? Opt.none() : updatePresenters(eventCatalog);</span>
        try {
<span class="fc" id="L1355">          schedulerService.updateEvent(id, Opt.none(), Opt.none(), Opt.none(), presenters, Opt.some(mediaPackage),</span>
<span class="fc" id="L1356">              Opt.none(), Opt.none());</span>
<span class="nc" id="L1357">        } catch (SchedulerException e) {</span>
<span class="nc" id="L1358">          throw new IndexServiceException(&quot;Unable to update scheduled event &quot; + id + &quot; with metadata &quot;</span>
<span class="nc" id="L1359">              + RestUtils.getJsonStringSilent(MetadataJson.listToJson(metadataList, true)), e);</span>
<span class="fc" id="L1360">        }</span>
        break;
      default:
<span class="nc" id="L1363">        logger.error(&quot;Unknown event source!&quot;);</span>
    }
<span class="fc" id="L1365">    return metadataList;</span>
  }

  /**
   * Processes the combined usernames and free text entries of the presenters (creator) field into a list of presenters
   * using the full names of the users if available and adds the usernames to a set of technical presenters.
   *
   * @param eventMetadata
   *          The metadata list that has the presenter (creator) field to pull the list of presenters from.
   * @return A {@link Tuple} with a list of friendly presenter names and a set of user names if available for the
   *         presenters.
   */
  protected Tuple&lt;List&lt;String&gt;, Set&lt;String&gt;&gt; getTechnicalPresenters(DublinCoreMetadataCollection eventMetadata) {
<span class="fc" id="L1378">    MetadataField presentersMetadataField = eventMetadata.getOutputFields()</span>
<span class="fc" id="L1379">            .get(DublinCore.PROPERTY_CREATOR.getLocalName());</span>
<span class="fc" id="L1380">    List&lt;String&gt; presenters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1381">    Set&lt;String&gt; technicalPresenters = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">    for (String presenter : MetadataUtils.getIterableStringMetadata(presentersMetadataField)) {</span>
<span class="fc" id="L1383">      User user = userDirectoryService.loadUser(presenter);</span>
<span class="fc bfc" id="L1384" title="All 2 branches covered.">      if (user == null) {</span>
<span class="fc" id="L1385">        presenters.add(presenter);</span>
      } else {
<span class="fc bfc" id="L1387" title="All 2 branches covered.">        String fullname = StringUtils.isNotBlank(user.getName()) ? user.getName() : user.getUsername();</span>
<span class="fc" id="L1388">        presenters.add(fullname);</span>
<span class="fc" id="L1389">        technicalPresenters.add(user.getUsername());</span>
      }
<span class="fc" id="L1391">    }</span>
<span class="fc" id="L1392">    return Tuple.tuple(presenters, technicalPresenters);</span>
  }

  @Override
  public AccessControlList updateEventAcl(String id, AccessControlList acl, ElasticsearchIndex index)
          throws IllegalArgumentException, IndexServiceException, SearchIndexException, NotFoundException,
          UnauthorizedException {
<span class="nc" id="L1399">    Opt&lt;Event&gt; optEvent = getEvent(id, index);</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">    if (optEvent.isNone())</span>
<span class="nc" id="L1401">      throw new NotFoundException(&quot;Cannot find an event with id &quot; + id);</span>

<span class="nc" id="L1403">    Event event = optEvent.get();</span>
<span class="nc" id="L1404">    MediaPackage mediaPackage = getEventMediapackage(event);</span>
<span class="nc bnc" id="L1405" title="All 4 branches missed.">    switch (getEventSource(event)) {</span>
      case WORKFLOW:
        // Not updating the acl as the workflow might have already passed the point of distribution.
<span class="nc" id="L1408">        throw new IllegalArgumentException(&quot;Unable to update the ACL of this event as it is currently processing.&quot;);</span>
      case ARCHIVE:
        try {
<span class="nc" id="L1411">          mediaPackage = authorizationService.setAcl(mediaPackage, AclScope.Episode, acl).getA();</span>
<span class="nc" id="L1412">        } catch (MediaPackageException e) {</span>
<span class="nc" id="L1413">          throw new IndexServiceException(&quot;Unable to update  acl&quot;, e);</span>
<span class="nc" id="L1414">        }</span>
<span class="nc" id="L1415">        assetManager.takeSnapshot(mediaPackage);</span>
<span class="nc" id="L1416">        return acl;</span>
      case SCHEDULE:
        try {
<span class="nc" id="L1419">          mediaPackage = authorizationService.setAcl(mediaPackage, AclScope.Episode, acl).getA();</span>
<span class="nc" id="L1420">          schedulerService.updateEvent(id, Opt.none(), Opt.none(), Opt.none(), Opt.none(), Opt.some(mediaPackage),</span>
<span class="nc" id="L1421">                  Opt.none(), Opt.none());</span>
<span class="nc" id="L1422">        } catch (SchedulerException | MediaPackageException e) {</span>
<span class="nc" id="L1423">          throw new IndexServiceException(&quot;Unable to update the acl for the scheduled event&quot;, e);</span>
<span class="nc" id="L1424">        }</span>
<span class="nc" id="L1425">        return acl;</span>
      default:
<span class="nc" id="L1427">        throw new IndexServiceException(</span>
<span class="nc" id="L1428">                String.format(&quot;Unable to update the ACL as '%s' is an unknown event source.&quot;, getEventSource(event)));</span>
    }
  }

  private boolean hasSnapshots(String eventId) {
<span class="nc" id="L1433">    AQueryBuilder q = assetManager.createQuery();</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">    return !enrich(q.select(q.snapshot()).where(q.mediaPackageId(eventId).and(q.version().isLatest())).run()).getSnapshots().isEmpty();</span>
  }

  @Override
  public Map&lt;String, Map&lt;String, String&gt;&gt; getEventWorkflowProperties(final List&lt;String&gt; eventIds) {
<span class="nc" id="L1439">    return WorkflowPropertiesUtil.getLatestWorkflowPropertiesForEvents(assetManager, eventIds);</span>
  }

  @Override
  public Opt&lt;Event&gt; getEvent(String id, ElasticsearchIndex index) throws SearchIndexException {
<span class="fc" id="L1444">    SearchResult&lt;Event&gt; result = index</span>
<span class="fc" id="L1445">            .getByQuery(new EventSearchQuery(securityService.getOrganization().getId(), securityService.getUser())</span>
<span class="fc" id="L1446">                    .withIdentifier(id));</span>
    // If the results list if empty, we return already a response.
<span class="fc bfc" id="L1448" title="All 2 branches covered.">    if (result.getPageSize() == 0) {</span>
<span class="fc" id="L1449">      logger.debug(&quot;Didn't find event with id {}&quot;, id);</span>
<span class="fc" id="L1450">      return Opt.none();</span>
    }
<span class="fc" id="L1452">    return Opt.some(result.getItems()[0].getSource());</span>
  }

  @Override
  public EventRemovalResult removeEvent(Event event, String retractWorkflowId)
      throws UnauthorizedException, WorkflowDatabaseException, NotFoundException {
<span class="nc bnc" id="L1458" title="All 2 branches missed.">    final boolean hasOnlyEngageLive = event.getPublications().size() == 1</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">        &amp;&amp; EventUtils.ENGAGE_LIVE_CHANNEL_ID.equals(event.getPublications().get(0).getChannel());</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">    final boolean retract = event.hasPreview()</span>
<span class="nc bnc" id="L1461" title="All 6 branches missed.">        || (!event.getPublications().isEmpty()  &amp;&amp; !hasOnlyEngageLive &amp;&amp; this.hasSnapshots(event.getIdentifier()));</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">    if (retract) {</span>
<span class="nc" id="L1463">      retractAndRemoveEvent(event.getIdentifier(), retractWorkflowId);</span>
<span class="nc" id="L1464">      return EventRemovalResult.RETRACTING;</span>
    } else {
      try {
<span class="nc" id="L1467">        final boolean success = removeEvent(event.getIdentifier());</span>
<span class="nc bnc" id="L1468" title="All 2 branches missed.">        return success ? EventRemovalResult.SUCCESS : EventRemovalResult.GENERAL_FAILURE;</span>
<span class="nc" id="L1469">      } catch (NotFoundException e) {</span>
<span class="nc" id="L1470">        return EventRemovalResult.NOT_FOUND;</span>
      }
    }
  }

  private void retractAndRemoveEvent(String id, String retractWorkflowId)
      throws WorkflowDatabaseException, NotFoundException {
<span class="nc" id="L1477">    final WorkflowDefinition wfd = workflowService.getWorkflowDefinitionById(retractWorkflowId);</span>
<span class="nc" id="L1478">    final Workflows workflows = new Workflows(assetManager, workflowService);</span>
<span class="nc" id="L1479">    final ConfiguredWorkflow workflow = workflow(wfd);</span>
<span class="nc" id="L1480">    final List&lt;WorkflowInstance&gt; result = workflows.applyWorkflowToLatestVersion(Collections.singleton(id), workflow).toList();</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">    if (result.size() != 1) {</span>
<span class="nc" id="L1482">        throw new IllegalStateException(&quot;Couldn't start workflow to retract media package&quot; + id);</span>
    }
<span class="nc" id="L1484">    this.retractions.put(</span>
<span class="nc" id="L1485">        result.get(0).getId(),</span>
<span class="nc" id="L1486">        new Retraction(securityService.getUser(), securityService.getOrganization())</span>
    );
<span class="nc" id="L1488">  }</span>

  @Override
  public boolean removeEvent(String id) throws NotFoundException, UnauthorizedException {
<span class="nc" id="L1492">    boolean unauthorizedWorkflow = false;</span>
<span class="nc" id="L1493">    boolean notFoundWorkflow = false;</span>
<span class="nc" id="L1494">    boolean removedWorkflow = false;</span>
    try {
<span class="nc" id="L1496">      List&lt;WorkflowInstance&gt; workflowInstances = workflowService.getWorkflowInstancesByMediaPackage(id);</span>
<span class="nc bnc" id="L1497" title="All 2 branches missed.">      if (workflowInstances.isEmpty()) {</span>
<span class="nc" id="L1498">        notFoundWorkflow = true;</span>
      } else {
<span class="nc" id="L1500">        var toRemove = workflowInstances.size();</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">        for (WorkflowInstance instance : workflowInstances) {</span>
          try {
<span class="nc" id="L1503">            workflowService.stop(instance.getId());</span>
<span class="nc" id="L1504">            workflowService.remove(instance.getId());</span>
<span class="nc" id="L1505">            toRemove--;</span>
<span class="nc" id="L1506">          } catch (WorkflowDatabaseException e) {</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">            if (e.getCause() instanceof  NotFoundException) {</span>
              // Someone already removed this. That's fine. Continue with the next workflow
<span class="nc" id="L1509">              logger.warn(&quot;Workflow {} has already been removed&quot;, instance.getId());</span>
            } else {
<span class="nc" id="L1511">              throw e;</span>
            }
<span class="nc" id="L1513">          }</span>
<span class="nc" id="L1514">        }</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">        removedWorkflow = toRemove == 0;</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">        notFoundWorkflow = toRemove &gt;= 1;</span>
      }
<span class="nc" id="L1518">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1519">      unauthorizedWorkflow = true;</span>
<span class="nc" id="L1520">    } catch (WorkflowException e) {</span>
<span class="nc" id="L1521">      logger.error(&quot;Unable to remove the event '{}' because removing workflow failed:&quot;, id, e);</span>
<span class="nc" id="L1522">    }</span>

<span class="nc" id="L1524">    boolean unauthorizedScheduler = false;</span>
<span class="nc" id="L1525">    boolean notFoundScheduler = false;</span>
<span class="nc" id="L1526">    boolean removedScheduler = false;</span>
    try {
<span class="nc" id="L1528">      schedulerService.removeEvent(id);</span>
<span class="nc" id="L1529">      removedScheduler = true;</span>
<span class="nc" id="L1530">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1531">      notFoundScheduler = true;</span>
<span class="nc" id="L1532">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1533">      unauthorizedScheduler = true;</span>
<span class="nc" id="L1534">    } catch (SchedulerException e) {</span>
<span class="nc" id="L1535">      logger.error(&quot;Unable to remove the event '{}' from scheduler service:&quot;, id, e);</span>
<span class="nc" id="L1536">    }</span>

<span class="nc" id="L1538">    boolean unauthorizedArchive = false;</span>
<span class="nc" id="L1539">    boolean notFoundArchive = false;</span>
<span class="nc" id="L1540">    boolean removedArchive = false;</span>
    try {
<span class="nc" id="L1542">      final AQueryBuilder q = assetManager.createQuery();</span>
<span class="nc" id="L1543">      final Predicate p = q.organizationId().eq(securityService.getOrganization().getId()).and(q.mediaPackageId(id));</span>
<span class="nc" id="L1544">      final AResult r = q.select(q.nothing()).where(p).run();</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">      if (r.getSize() &gt; 0) {</span>
<span class="nc" id="L1546">        q.delete(DEFAULT_OWNER, q.snapshot()).where(p).run();</span>
<span class="nc" id="L1547">        removedArchive = true;</span>
      } else {
<span class="nc" id="L1549">        notFoundArchive = true;</span>
      }
<span class="nc" id="L1551">    } catch (AssetManagerException e) {</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">      if (e.getCause() instanceof UnauthorizedException) {</span>
<span class="nc" id="L1553">        unauthorizedArchive = true;</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">      } else if (e.getCause() instanceof NotFoundException) {</span>
<span class="nc" id="L1555">        notFoundArchive = true;</span>
      } else {
<span class="nc" id="L1557">        logger.error(&quot;Unable to remove the event '{}' from the archive:&quot;, id, e);</span>
      }
<span class="nc" id="L1559">    }</span>

<span class="nc bnc" id="L1561" title="All 6 branches missed.">    if (unauthorizedScheduler || unauthorizedWorkflow || unauthorizedArchive)</span>
<span class="nc" id="L1562">      throw new UnauthorizedException(&quot;Not authorized to remove event id &quot; + id);</span>

    // if all three services either removed the event successfully or couldn't find it, make sure it's also removed
    // from the index
<span class="nc bnc" id="L1566" title="All 12 branches missed.">    if ((removedScheduler || notFoundScheduler) &amp;&amp; (removedWorkflow || notFoundWorkflow)</span>
            &amp;&amp; (removedArchive || notFoundArchive)) {
      try {
<span class="nc" id="L1569">        elasticsearchIndex.deleteEvent(id, securityService.getOrganization().getId());</span>
<span class="nc" id="L1570">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L1571">        logger.error(&quot;Removing event {} from the {} index failed&quot;, id, elasticsearchIndex.getIndexName(), e);</span>
<span class="nc" id="L1572">      }</span>
    }

    try {
<span class="nc" id="L1576">      eventCommentService.deleteComments(id);</span>
<span class="nc" id="L1577">    } catch (EventCommentException e) {</span>
<span class="nc" id="L1578">      logger.error(&quot;Unable to remove comments for event '{}':&quot;, id, e);</span>
<span class="nc" id="L1579">    }</span>

<span class="nc bnc" id="L1581" title="All 6 branches missed.">    if (notFoundScheduler &amp;&amp; notFoundWorkflow &amp;&amp; notFoundArchive)</span>
<span class="nc" id="L1582">      throw new NotFoundException(&quot;Event id &quot; + id + &quot; not found.&quot;);</span>

<span class="nc bnc" id="L1584" title="All 12 branches missed.">    return ((removedScheduler || notFoundScheduler) &amp;&amp; (removedWorkflow || notFoundWorkflow)</span>
            &amp;&amp; (removedArchive || notFoundArchive));
  }

  private void updateWorkflowInstance(WorkflowInstance workflowInstance)
          throws WorkflowException, UnauthorizedException {
    // Only update the workflow if the instance is in a working state
<span class="nc bnc" id="L1591" title="All 2 branches missed.">    if (WorkflowInstance.WorkflowState.FAILED.equals(workflowInstance.getState())</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">            || WorkflowInstance.WorkflowState.FAILING.equals(workflowInstance.getState())</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">            || WorkflowInstance.WorkflowState.STOPPED.equals(workflowInstance.getState())</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">            || WorkflowInstance.WorkflowState.SUCCEEDED.equals(workflowInstance.getState())) {</span>
<span class="nc" id="L1595">      logger.info(&quot;Skip updating {} workflow mediapackage {} with updated comments catalog&quot;,</span>
<span class="nc" id="L1596">              workflowInstance.getState(), workflowInstance.getMediaPackage().getIdentifier().toString());</span>
<span class="nc" id="L1597">      return;</span>
    }
<span class="nc" id="L1599">    workflowService.update(workflowInstance);</span>
<span class="nc" id="L1600">  }</span>

  @Override
  public MediaPackage getEventMediapackage(Event event) throws IndexServiceException {
<span class="pc bpc" id="L1604" title="3 of 4 branches missed.">    switch (getEventSource(event)) {</span>
      case WORKFLOW:
        try {
<span class="nc" id="L1607">          Optional&lt;WorkflowInstance&gt; currentWorkflowInstance = workflowService.</span>
<span class="nc" id="L1608">                  getRunningWorkflowInstanceByMediaPackage(event.getIdentifier(), Permissions.Action.READ.toString());</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">          if (currentWorkflowInstance.isEmpty()) {</span>
<span class="nc" id="L1610">            throw new IndexServiceException(&quot;No workflow instance found for event &quot; + event.getIdentifier());</span>
          }
<span class="nc" id="L1612">          return currentWorkflowInstance.get().getMediaPackage();</span>
<span class="nc" id="L1613">        } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L1614">          throw new IndexServiceException(&quot;Unable to get current workflow instance for event with id &quot; + event.getIdentifier() + &quot; from workflow service&quot;, e);</span>
<span class="nc" id="L1615">        } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1616">          throw new IndexServiceException(&quot;Not authorized to read media package &quot; + event.getIdentifier() + &quot; from workflow&quot;, e);</span>
<span class="nc" id="L1617">        } catch (WorkflowException e) {</span>
<span class="nc" id="L1618">          throw new IndexServiceException(&quot;Unable to get event media package &quot; + event.getIdentifier() + &quot; from WorkflowService because&quot;, e);</span>
        }
      case ARCHIVE:
<span class="nc" id="L1621">        Optional&lt;MediaPackage&gt; mpOpt = assetManager.getMediaPackage(event.getIdentifier());</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">        if (mpOpt.isPresent()) {</span>
<span class="nc" id="L1623">          logger.debug(&quot;Found event in archive with id {}&quot;, event.getIdentifier());</span>
<span class="nc" id="L1624">          return mpOpt.get();</span>
        }
<span class="nc" id="L1626">        throw new IndexServiceException(&quot;No archived event found with id &quot; + event.getIdentifier());</span>
      case SCHEDULE:
        try {
<span class="fc" id="L1629">          MediaPackage mediaPackage = schedulerService.getMediaPackage(event.getIdentifier());</span>
<span class="fc" id="L1630">          logger.debug(&quot;Found event in scheduler with id {}&quot;, event.getIdentifier());</span>
<span class="fc" id="L1631">          return mediaPackage;</span>
<span class="nc" id="L1632">        } catch (NotFoundException e) {</span>
<span class="nc" id="L1633">          throw new IndexServiceException(&quot;No scheduled event with id &quot; + event.getIdentifier(), e);</span>
<span class="nc" id="L1634">        } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1635">          throw new IndexServiceException(&quot;Unauthorized to get event &quot; + event.getIdentifier() + &quot; from scheduler&quot;, e);</span>
<span class="nc" id="L1636">        } catch (SchedulerException e) {</span>
<span class="nc" id="L1637">          throw new IndexServiceException(&quot;Unable to get event &quot; + event.getIdentifier() + &quot; from scheduler&quot;, e);</span>
        }
      default:
<span class="nc" id="L1640">        throw new IllegalStateException(&quot;Unknown event type!&quot;);</span>
    }
  }

  /**
   * Determines in a very basic way what kind of source the event is
   *
   * @param event
   *          the event
   * @return the source type
   */
  @Override
  public Source getEventSource(Event event) {
<span class="pc bpc" id="L1653" title="3 of 4 branches missed.">    if (event.getWorkflowId() != null &amp;&amp; isWorkflowActive(event.getWorkflowState())) {</span>
<span class="nc" id="L1654">      return Source.WORKFLOW;</span>
<span class="pc bpc" id="L1655" title="3 of 4 branches missed.">    } else if (event.isScheduledEvent() &amp;&amp; !event.hasRecordingStarted()) {</span>
<span class="nc" id="L1656">      return Source.SCHEDULE;</span>
<span class="pc bpc" id="L1657" title="1 of 2 branches missed.">    } else if (event.getArchiveVersion() != null) {</span>
<span class="nc" id="L1658">      return Source.ARCHIVE;</span>
<span class="pc bpc" id="L1659" title="1 of 2 branches missed.">    } else if (event.getWorkflowId() != null) {</span>
<span class="nc" id="L1660">      return Source.WORKFLOW;</span>
    } else {
<span class="fc" id="L1662">      return Source.SCHEDULE;</span>
    }
  }

  private void updateMediaPackageMetadata(MediaPackage mp, MetadataList metadataList) {
<span class="fc" id="L1667">    String oldSeriesId = mp.getSeries();</span>
<span class="fc bfc" id="L1668" title="All 2 branches covered.">    for (EventCatalogUIAdapter catalogUIAdapter : getEventCatalogUIAdapters()) {</span>
<span class="fc" id="L1669">      final DublinCoreMetadataCollection metadata = metadataList.getMetadataByAdapter(catalogUIAdapter);</span>
<span class="pc bpc" id="L1670" title="2 of 4 branches missed.">      if (metadata != null &amp;&amp; metadata.isUpdated()) {</span>
<span class="fc" id="L1671">        catalogUIAdapter.storeFields(mp, metadata);</span>
      }
<span class="fc" id="L1673">    }</span>

    // update series catalogs
<span class="fc bfc" id="L1676" title="All 2 branches covered.">    if (!StringUtils.equals(oldSeriesId, mp.getSeries())) {</span>
<span class="fc" id="L1677">      List&lt;String&gt; seriesDcTags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1678">      List&lt;String&gt; seriesAclTags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1679">      Map&lt;String, List&lt;String&gt;&gt; seriesExtDcTags = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L1680" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(oldSeriesId)) {</span>
        // remove series dublincore from the media package
<span class="nc bnc" id="L1682" title="All 2 branches missed.">        for (MediaPackageElement mpe : mp.getElementsByFlavor(MediaPackageElements.SERIES)) {</span>
<span class="nc" id="L1683">          mp.remove(mpe);</span>
<span class="nc" id="L1684">          seriesDcTags.addAll(Arrays.asList(mpe.getTags()));</span>
        }
<span class="nc bnc" id="L1686" title="All 4 branches missed.">        if (mp.getSeries() != null || mp.getElementsByFlavor(MediaPackageElements.XACML_POLICY_EPISODE).length &gt; 0) {</span>
          // a new series was set or the series was unset and episode ACL exists
          // remove series ACL from the media package
<span class="nc bnc" id="L1689" title="All 2 branches missed.">          for (MediaPackageElement mpe : mp.getElementsByFlavor(MediaPackageElements.XACML_POLICY_SERIES)) {</span>
<span class="nc" id="L1690">            mp.remove(mpe);</span>
<span class="nc" id="L1691">            seriesAclTags.addAll(Arrays.asList(mpe.getTags()));</span>
          }
        } else {
          // series was unset but episode don't have an episode ACL
          // in this case user may lose access to the episode if we delete the series ACL
          // but, we also shouldn't keep the series ACL because the series was unset
          // let's keep the series ACL as episode ACL and provide same access rights as before
<span class="nc" id="L1698">          Tuple&lt;AccessControlList, AclScope&gt; activeAcl = authorizationService.getActiveAcl(mp);</span>
          try {
<span class="nc" id="L1700">            authorizationService.setAcl(mp, AclScope.Episode, activeAcl.getA());</span>
<span class="nc" id="L1701">            authorizationService.removeAcl(mp, AclScope.Series);</span>
<span class="nc" id="L1702">          } catch (MediaPackageException e) {</span>
<span class="nc" id="L1703">            throw new IllegalStateException(&quot;Unable to set episode ACL on media package&quot;, e);</span>
<span class="nc" id="L1704">          }</span>
        }
        // remove series extended metadata from the media package
        try {
<span class="nc" id="L1708">          Opt&lt;Map&lt;String, byte[]&gt;&gt; oldSeriesElementsOpt = seriesService.getSeriesElements(oldSeriesId);</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">          for (Map&lt;String, byte[]&gt; oldSeriesElements : oldSeriesElementsOpt) {</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">            for (String oldSeriesElementType : oldSeriesElements.keySet()) {</span>
<span class="nc bnc" id="L1711" title="All 2 branches missed.">              for (MediaPackageElement mpe : mp</span>
<span class="nc" id="L1712">                      .getElementsByFlavor(MediaPackageElementFlavor.flavor(oldSeriesElementType, &quot;series&quot;))) {</span>
<span class="nc" id="L1713">                mp.remove(mpe);</span>
<span class="nc" id="L1714">                String elementType = mpe.getFlavor().getType();</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">                if (StringUtils.isNotBlank(elementType)) {</span>
                  // remember the tags for this type of element
<span class="nc bnc" id="L1717" title="All 2 branches missed.">                  if (!seriesExtDcTags.containsKey(elementType)) {</span>
                    // initialize the tags list on the first occurrence of this element type
<span class="nc" id="L1719">                    seriesExtDcTags.put(elementType, new ArrayList&lt;&gt;());</span>
                  }
<span class="nc bnc" id="L1721" title="All 2 branches missed.">                  for (String tag : mpe.getTags()) {</span>
<span class="nc" id="L1722">                    seriesExtDcTags.get(elementType).add(tag);</span>
                  }
                }
              }
<span class="nc" id="L1726">            }</span>
<span class="nc" id="L1727">          }</span>
<span class="nc" id="L1728">        } catch (SeriesException e) {</span>
<span class="nc" id="L1729">          logger.info(&quot;Unable to retrieve series element types from series service for the series {}&quot;, oldSeriesId, e);</span>
<span class="nc" id="L1730">        }</span>
      }

<span class="pc bpc" id="L1733" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(mp.getSeries())) {</span>
        // add updated series dublincore to the media package
        try {
<span class="fc" id="L1736">          DublinCoreCatalog seriesDC = seriesService.getSeries(mp.getSeries());</span>
<span class="pc bpc" id="L1737" title="1 of 2 branches missed.">          if (seriesDC != null) {</span>
<span class="fc" id="L1738">            mp.setSeriesTitle(seriesDC.getFirst(DublinCore.PROPERTY_TITLE));</span>
<span class="fc" id="L1739">            try (InputStream in = IOUtils.toInputStream(seriesDC.toXmlString(), &quot;UTF-8&quot;)) {</span>
<span class="fc" id="L1740">              String elementId = UUID.randomUUID().toString();</span>
<span class="fc" id="L1741">              URI catalogUrl = workspace.put(mp.getIdentifier().toString(), elementId, &quot;dublincore.xml&quot;, in);</span>
<span class="fc" id="L1742">              MediaPackageElement mpe = mp.add(catalogUrl, MediaPackageElement.Type.Catalog, MediaPackageElements.SERIES);</span>
<span class="fc" id="L1743">              mpe.setIdentifier(elementId);</span>
<span class="fc" id="L1744">              mpe.setChecksum(Checksum.create(ChecksumType.DEFAULT_TYPE, workspace.read(catalogUrl)));</span>
<span class="pc bpc" id="L1745" title="1 of 2 branches missed.">              if (StringUtils.isNotBlank(oldSeriesId)) {</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">                for (String tag : seriesDcTags) {</span>
<span class="nc" id="L1747">                  mpe.addTag(tag);</span>
<span class="nc" id="L1748">                }</span>
              } else {
                // add archive tag to the element if the media package had no series set before
<span class="fc" id="L1751">                mpe.addTag(&quot;archive&quot;);</span>
              }
<span class="nc" id="L1753">            } catch (IOException e) {</span>
<span class="nc" id="L1754">              throw new IllegalStateException(&quot;Unable to add the series dublincore to the media package &quot; + mp.getIdentifier(), e);</span>
<span class="fc" id="L1755">            }</span>
          }
<span class="nc" id="L1757">        } catch (SeriesException e) {</span>
<span class="nc" id="L1758">          throw new IllegalStateException(&quot;Unable to retrieve series dublincore catalog for the series &quot; + mp.getSeries(), e);</span>
<span class="nc" id="L1759">        } catch (NotFoundException | UnauthorizedException e) {</span>
<span class="nc" id="L1760">          throw new IllegalArgumentException(&quot;Unable to retrieve series dublincore catalog for the series &quot; + mp.getSeries(), e);</span>
<span class="fc" id="L1761">        }</span>
        // add updated series ACL to the media package
        try {
<span class="fc" id="L1764">          AccessControlList seriesAccessControl = seriesService.getSeriesAccessControl(mp.getSeries());</span>
<span class="pc bpc" id="L1765" title="1 of 2 branches missed.">          if (seriesAccessControl != null) {</span>
<span class="nc" id="L1766">            mp = authorizationService.setAcl(mp, AclScope.Series, seriesAccessControl).getA();</span>
<span class="nc bnc" id="L1767" title="All 2 branches missed.">            for (MediaPackageElement seriesAclMpe : mp.getElementsByFlavor(MediaPackageElements.XACML_POLICY_SERIES)) {</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">              if (StringUtils.isNotBlank(oldSeriesId)) {</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">                for (String tag : seriesAclTags) {</span>
<span class="nc" id="L1770">                  seriesAclMpe.addTag(tag);</span>
<span class="nc" id="L1771">                }</span>
              } else {
                // add archive tag to the element if the media package had no series set before
<span class="nc" id="L1774">                seriesAclMpe.addTag(&quot;archive&quot;);</span>
              }
            }
          }
<span class="nc" id="L1778">        } catch (SeriesException | MediaPackageException e) {</span>
<span class="nc" id="L1779">          throw new IllegalStateException(&quot;Unable to retrieve series ACL for series &quot; + oldSeriesId, e);</span>
<span class="nc" id="L1780">        } catch (NotFoundException e) {</span>
<span class="nc" id="L1781">          logger.debug(&quot;There is no ACL set for the series {}&quot;, mp.getSeries());</span>
<span class="fc" id="L1782">        }</span>
        // add updated series extended metadata to the media package
        try {
<span class="fc" id="L1785">          Opt&lt;Map&lt;String, byte[]&gt;&gt; seriesElementsOpt = seriesService.getSeriesElements(mp.getSeries());</span>
<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">          for (Map&lt;String, byte[]&gt; seriesElements : seriesElementsOpt) {</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">            for (String seriesElementType : seriesElements.keySet()) {</span>
<span class="nc" id="L1788">              try (InputStream in = new ByteArrayInputStream(seriesElements.get(seriesElementType))) {</span>
<span class="nc" id="L1789">                String elementId = UUID.randomUUID().toString();</span>
<span class="nc" id="L1790">                URI catalogUrl = workspace.put(mp.getIdentifier().toString(), elementId, &quot;dublincore.xml&quot;, in);</span>
<span class="nc" id="L1791">                MediaPackageElement mpe = mp.add(catalogUrl, MediaPackageElement.Type.Catalog,</span>
<span class="nc" id="L1792">                        MediaPackageElementFlavor.flavor(seriesElementType, &quot;series&quot;));</span>
<span class="nc" id="L1793">                mpe.setIdentifier(elementId);</span>
<span class="nc" id="L1794">                mpe.setChecksum(Checksum.create(ChecksumType.DEFAULT_TYPE, workspace.read(catalogUrl)));</span>
<span class="nc bnc" id="L1795" title="All 2 branches missed.">                if (StringUtils.isNotBlank(oldSeriesId)) {</span>
<span class="nc bnc" id="L1796" title="All 2 branches missed.">                  if (seriesExtDcTags.containsKey(seriesElementType)) {</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">                    for (String tag : seriesExtDcTags.get(seriesElementType)) {</span>
<span class="nc" id="L1798">                      mpe.addTag(tag);</span>
<span class="nc" id="L1799">                    }</span>
                  }
                } else {
                  // add archive tag to the element if the media package had no series set before
<span class="nc" id="L1803">                  mpe.addTag(&quot;archive&quot;);</span>
                }
<span class="nc" id="L1805">              } catch (IOException e) {</span>
<span class="nc" id="L1806">                throw new IllegalStateException(String.format(&quot;Unable to serialize series element %s for the series %s&quot;,</span>
<span class="nc" id="L1807">                        seriesElementType, mp.getSeries()), e);</span>
<span class="nc" id="L1808">              } catch (NotFoundException e) {</span>
<span class="nc" id="L1809">                throw new IllegalArgumentException(&quot;Unable to retrieve series element dublincore catalog for the series &quot;</span>
<span class="nc" id="L1810">                        + mp.getSeries(), e);</span>
<span class="nc" id="L1811">              }</span>
<span class="nc" id="L1812">            }</span>
<span class="nc" id="L1813">          }</span>
<span class="nc" id="L1814">        } catch (SeriesException e) {</span>
<span class="nc" id="L1815">          throw new IllegalStateException(&quot;Unable to retrieve series elements for the series &quot; + mp.getSeries(), e);</span>
<span class="fc" id="L1816">        }</span>
      }
    }
<span class="fc" id="L1819">  }</span>

  @Override
  public String createSeries(MetadataList metadataList, Map&lt;String, String&gt; options, Opt&lt;AccessControlList&gt; optAcl,
          Opt&lt;Long&gt; optThemeId) throws IndexServiceException {
<span class="nc" id="L1824">    DublinCoreCatalog dc = DublinCores.mkOpencastSeries().getCatalog();</span>
<span class="nc" id="L1825">    dc.set(PROPERTY_IDENTIFIER, UUID.randomUUID().toString());</span>
<span class="nc" id="L1826">    dc.set(DublinCore.PROPERTY_CREATED, EncodingSchemeUtils.encodeDate(new Date(), Precision.Second));</span>
<span class="nc bnc" id="L1827" title="All 2 branches missed.">    for (Entry&lt;String, String&gt; entry : options.entrySet()) {</span>
<span class="nc" id="L1828">      dc.set(new EName(DublinCores.OC_PROPERTY_NS_URI, entry.getKey()), entry.getValue());</span>
<span class="nc" id="L1829">    }</span>

<span class="nc" id="L1831">    DublinCoreMetadataCollection seriesMetadata = metadataList.getMetadataByFlavor(MediaPackageElements.SERIES.toString());</span>
<span class="nc bnc" id="L1832" title="All 2 branches missed.">    if (seriesMetadata != null) {</span>
<span class="nc" id="L1833">      DublinCoreMetadataUtil.updateDublincoreCatalog(dc, seriesMetadata);</span>
    }

    AccessControlList acl;
<span class="nc bnc" id="L1837" title="All 2 branches missed.">    if (optAcl.isSome()) {</span>
<span class="nc" id="L1838">      acl = optAcl.get();</span>
    } else {
<span class="nc" id="L1840">      acl = new AccessControlList();</span>
    }

    String seriesId;
    try {
<span class="nc" id="L1845">      DublinCoreCatalog createdSeries = seriesService.updateSeries(dc);</span>
<span class="nc" id="L1846">      seriesId = createdSeries.getFirst(PROPERTY_IDENTIFIER);</span>
<span class="nc" id="L1847">      seriesService.updateAccessControl(seriesId, acl);</span>
<span class="nc bnc" id="L1848" title="All 2 branches missed.">      for (Long id : optThemeId)</span>
<span class="nc" id="L1849">        seriesService.updateSeriesProperty(seriesId, THEME_PROPERTY_NAME, Long.toString(id));</span>
<span class="nc" id="L1850">    } catch (Exception e) {</span>
<span class="nc" id="L1851">      logger.error(&quot;Unable to create new series:&quot;, e);</span>
<span class="nc" id="L1852">      throw new IndexServiceException(&quot;Unable to create new series&quot;);</span>
<span class="nc" id="L1853">    }</span>

<span class="nc" id="L1855">    updateSeriesMetadata(seriesId, metadataList);</span>

<span class="nc" id="L1857">    return seriesId;</span>
  }

  @Override
  public String createSeries(JSONObject metadata)
          throws IllegalArgumentException, IndexServiceException, UnauthorizedException {

<span class="nc" id="L1864">    JSONArray seriesMetadataJson = (JSONArray) metadata.get(&quot;metadata&quot;);</span>
<span class="nc bnc" id="L1865" title="All 2 branches missed.">    if (seriesMetadataJson == null)</span>
<span class="nc" id="L1866">      throw new IllegalArgumentException(&quot;No metadata field in metadata&quot;);</span>

<span class="nc" id="L1868">    JSONObject options = (JSONObject) metadata.get(&quot;options&quot;);</span>
<span class="nc bnc" id="L1869" title="All 2 branches missed.">    if (options == null)</span>
<span class="nc" id="L1870">      throw new IllegalArgumentException(&quot;No options field in metadata&quot;);</span>

<span class="nc" id="L1872">    Opt&lt;Long&gt; themeId = Opt.none();</span>
<span class="nc" id="L1873">    Long theme = (Long) metadata.get(&quot;theme&quot;);</span>
<span class="nc bnc" id="L1874" title="All 2 branches missed.">    if (theme != null) {</span>
<span class="nc" id="L1875">      themeId = Opt.some(theme);</span>
    }

    Map&lt;String, String&gt; optionsMap;
    try {
<span class="nc" id="L1880">      optionsMap = JSONUtils.toMap(new org.codehaus.jettison.json.JSONObject(options.toJSONString()));</span>
<span class="nc" id="L1881">    } catch (JSONException e) {</span>
<span class="nc" id="L1882">      throw new IllegalArgumentException(&quot;Unable to parse options to map&quot;, e);</span>
<span class="nc" id="L1883">    }</span>

<span class="nc" id="L1885">    DublinCoreCatalog dc = DublinCores.mkOpencastSeries().getCatalog();</span>
<span class="nc" id="L1886">    dc.set(PROPERTY_IDENTIFIER, UUID.randomUUID().toString());</span>
<span class="nc" id="L1887">    dc.set(DublinCore.PROPERTY_CREATED, EncodingSchemeUtils.encodeDate(new Date(), Precision.Second));</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">    for (Entry&lt;String, String&gt; entry : optionsMap.entrySet()) {</span>
<span class="nc" id="L1889">      dc.set(new EName(DublinCores.OC_PROPERTY_NS_URI, entry.getKey()), entry.getValue());</span>
<span class="nc" id="L1890">    }</span>

<span class="nc" id="L1892">    final MetadataList metadataList = getMetadataListWithAllSeriesCatalogUIAdapters();</span>
<span class="nc" id="L1893">    MetadataJson.fillListFromJson(metadataList, seriesMetadataJson);</span>

<span class="nc" id="L1895">    DublinCoreMetadataCollection seriesMetadata = metadataList.getMetadataByFlavor(MediaPackageElements.SERIES.toString());</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">    if (seriesMetadata != null) {</span>
<span class="nc" id="L1897">      DublinCoreMetadataUtil.updateDublincoreCatalog(dc, seriesMetadata);</span>
    }

<span class="nc" id="L1900">    AccessControlList acl = getAccessControlList(metadata);</span>

    String seriesId;
    try {
<span class="nc" id="L1904">      DublinCoreCatalog createdSeries = seriesService.updateSeries(dc);</span>
<span class="nc" id="L1905">      seriesId = createdSeries.getFirst(PROPERTY_IDENTIFIER);</span>
<span class="nc" id="L1906">      seriesService.updateAccessControl(seriesId, acl);</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">      for (Long id : themeId)</span>
<span class="nc" id="L1908">        seriesService.updateSeriesProperty(seriesId, THEME_PROPERTY_NAME, Long.toString(id));</span>
<span class="nc" id="L1909">    } catch (Exception e) {</span>
<span class="nc" id="L1910">      throw new IndexServiceException(&quot;Unable to create new series&quot;, e);</span>
<span class="nc" id="L1911">    }</span>

<span class="nc" id="L1913">    updateSeriesMetadata(seriesId, metadataList);</span>

<span class="nc" id="L1915">    return seriesId;</span>
  }

  @Override
  public void removeSeries(String id) throws NotFoundException, SeriesException, UnauthorizedException {
<span class="nc" id="L1920">    seriesService.deleteSeries(id);</span>
<span class="nc" id="L1921">  }</span>

  @Override
  public MetadataList updateAllSeriesMetadata(String id, String metadataJSON, ElasticsearchIndex index)
          throws IllegalArgumentException, IndexServiceException, NotFoundException {
<span class="nc" id="L1926">    MetadataList metadataList = getMetadataListWithAllSeriesCatalogUIAdapters();</span>
<span class="nc" id="L1927">    return updateSeriesMetadata(id, metadataJSON, index, metadataList);</span>
  }

  @Override
  public MetadataList updateAllSeriesMetadata(String id, MetadataList metadataList, ElasticsearchIndex index)
          throws IndexServiceException, NotFoundException {
<span class="nc" id="L1933">    checkSeriesExists(id, index);</span>
<span class="nc" id="L1934">    updateSeriesMetadata(id, metadataList);</span>
<span class="nc" id="L1935">    return metadataList;</span>
  }

  @Override
  public void updateCommentCatalog(final Event event, final List&lt;EventComment&gt; comments) throws Exception {
<span class="nc" id="L1940">    final SecurityContext securityContext = new SecurityContext(securityService, securityService.getOrganization(),</span>
<span class="nc" id="L1941">            securityService.getUser());</span>
<span class="nc" id="L1942">    executorService.execute(() -&gt; securityContext.runInContext(() -&gt; {</span>
      try {
<span class="nc" id="L1944">        MediaPackage mediaPackage = getEventMediapackage(event);</span>
<span class="nc" id="L1945">        updateMediaPackageCommentCatalog(mediaPackage, comments);</span>
<span class="nc bnc" id="L1946" title="All 4 branches missed.">        switch (getEventSource(event)) {</span>
          case WORKFLOW:
<span class="nc" id="L1948">            logger.info(&quot;Update workflow media pacakge {} with updated comments catalog.&quot;, event.getIdentifier());</span>
<span class="nc" id="L1949">            Optional&lt;WorkflowInstance&gt; workflowInstance = workflowService.</span>
<span class="nc" id="L1950">                    getRunningWorkflowInstanceByMediaPackage(event.getIdentifier(), Permissions.Action.WRITE.toString());</span>
<span class="nc bnc" id="L1951" title="All 2 branches missed.">            if (workflowInstance.isEmpty()) {</span>
<span class="nc" id="L1952">              throw new IndexServiceException(&quot;No workflow instance found for event &quot; + event.getIdentifier());</span>
            }
<span class="nc" id="L1954">            WorkflowInstance instance = workflowInstance.get();</span>
<span class="nc" id="L1955">            instance.setMediaPackage(mediaPackage);</span>
<span class="nc" id="L1956">            updateWorkflowInstance(instance);</span>
<span class="nc" id="L1957">            break;</span>
          case ARCHIVE:
<span class="nc" id="L1959">            logger.info(&quot;Update archive mediapacakge {} with updated comments catalog.&quot;, event.getIdentifier());</span>
<span class="nc" id="L1960">            assetManager.takeSnapshot(mediaPackage);</span>
<span class="nc" id="L1961">            break;</span>
          case SCHEDULE:
<span class="nc" id="L1963">            logger.info(&quot;Update scheduled mediapacakge {} with updated comments catalog.&quot;, event.getIdentifier());</span>
<span class="nc" id="L1964">            schedulerService.updateEvent(event.getIdentifier(), Opt.none(), Opt.none(), Opt.none(), Opt.none(),</span>
<span class="nc" id="L1965">                    Opt.some(mediaPackage), Opt.none(), Opt.none());</span>
<span class="nc" id="L1966">            break;</span>
          default:
<span class="nc" id="L1968">            logger.error(&quot;Unknown event source {}!&quot;, event.getSource());</span>
        }
<span class="nc" id="L1970">      } catch (Exception e) {</span>
<span class="nc" id="L1971">        logger.error(&quot;Unable to update event {} comment catalog&quot;, event.getIdentifier(), e);</span>
<span class="nc" id="L1972">      }</span>
<span class="nc" id="L1973">    }));</span>
<span class="nc" id="L1974">  }</span>

  private void updateMediaPackageCommentCatalog(MediaPackage mediaPackage, List&lt;EventComment&gt; comments)
          throws EventCommentException, IOException {
    // Get the comments catalog
<span class="nc" id="L1979">    Catalog[] commentCatalogs = mediaPackage.getCatalogs(MediaPackageElements.COMMENTS);</span>
<span class="nc" id="L1980">    Catalog c = null;</span>
<span class="nc bnc" id="L1981" title="All 2 branches missed.">    if (commentCatalogs.length == 1)</span>
<span class="nc" id="L1982">      c = commentCatalogs[0];</span>

<span class="nc bnc" id="L1984" title="All 2 branches missed.">    if (comments.size() &gt; 0) {</span>
      // If no comments catalog found, create a new one
<span class="nc bnc" id="L1986" title="All 2 branches missed.">      if (c == null) {</span>
<span class="nc" id="L1987">        c = (Catalog) MediaPackageElementBuilderFactory.newInstance().newElementBuilder().newElement(Type.Catalog,</span>
                MediaPackageElements.COMMENTS);
<span class="nc" id="L1989">        c.setIdentifier(UUID.randomUUID().toString());</span>
<span class="nc" id="L1990">        mediaPackage.add(c);</span>
      }

      // Update comments catalog
<span class="nc" id="L1994">      InputStream in = null;</span>
      try {
<span class="nc" id="L1996">        String commentCatalog = EventCommentParser.getAsXml(comments);</span>
<span class="nc" id="L1997">        in = IOUtils.toInputStream(commentCatalog, &quot;UTF-8&quot;);</span>
<span class="nc" id="L1998">        URI uri = workspace.put(mediaPackage.getIdentifier().toString(), c.getIdentifier(), &quot;comments.xml&quot;, in);</span>
<span class="nc" id="L1999">        c.setURI(uri);</span>
        // setting the URI to a new source so the checksum will most like be invalid
<span class="nc" id="L2001">        c.setChecksum(null);</span>
      } finally {
<span class="nc" id="L2003">        IOUtils.closeQuietly(in);</span>
      }
<span class="nc" id="L2005">    } else {</span>
      // Remove comments catalog
<span class="nc bnc" id="L2007" title="All 2 branches missed.">      if (c != null) {</span>
<span class="nc" id="L2008">        mediaPackage.remove(c);</span>
        try {
<span class="nc" id="L2010">          workspace.delete(c.getURI());</span>
<span class="nc" id="L2011">        } catch (NotFoundException e) {</span>
<span class="nc" id="L2012">          logger.warn(&quot;Comments catalog {} not found to delete!&quot;, c.getURI());</span>
<span class="nc" id="L2013">        }</span>
      }
    }
<span class="nc" id="L2016">  }</span>

  /**
   * Checks to see if a given series exists.
   *
   * @param seriesID
   *          The id of the series.
   * @param index
   *          The index to check for the particular series.
   * @throws NotFoundException
   *           Thrown if unable to find the series.
   * @throws IndexServiceException
   *           Thrown if unable to access the index to get the series.
   */
  private void checkSeriesExists(String seriesID, ElasticsearchIndex index)
          throws NotFoundException, IndexServiceException {
    try {
<span class="nc" id="L2033">      Optional&lt;Series&gt; optSeries = index.getSeries(seriesID, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">      if (optSeries.isEmpty())</span>
<span class="nc" id="L2035">        throw new NotFoundException(&quot;Cannot find a series with id &quot; + seriesID);</span>
<span class="nc" id="L2036">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L2037">      throw new IndexServiceException(&quot;Unable to get a series with id: &quot; + seriesID, e);</span>
<span class="nc" id="L2038">    }</span>
<span class="nc" id="L2039">  }</span>

  private MetadataList updateSeriesMetadata(
          final String seriesID,
          final String metadataJSON,
          final ElasticsearchIndex index,
          final MetadataList metadataList)
          throws IllegalArgumentException, IndexServiceException, NotFoundException {
<span class="nc" id="L2047">    checkSeriesExists(seriesID, index);</span>
    try {
<span class="nc" id="L2049">      MetadataJson.fillListFromJson(metadataList, (JSONArray) new JSONParser().parse(metadataJSON));</span>
<span class="nc" id="L2050">    } catch (final org.json.simple.parser.ParseException e) {</span>
<span class="nc" id="L2051">      throw new IllegalArgumentException(&quot;Not able to parse the event metadata: &quot; + metadataJSON, e);</span>
<span class="nc" id="L2052">    }</span>

<span class="nc" id="L2054">    updateSeriesMetadata(seriesID, metadataList);</span>
<span class="nc" id="L2055">    return metadataList;</span>
  }

  /**
   * @return A {@link MetadataList} with all of the available CatalogUIAdapters empty {@link DublinCoreMetadataCollection}
   *         available
   */
  @Override
  public MetadataList getMetadataListWithAllSeriesCatalogUIAdapters() {
<span class="nc" id="L2064">    MetadataList metadataList = new MetadataList();</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">    for (SeriesCatalogUIAdapter adapter : getSeriesCatalogUIAdapters()) {</span>
<span class="nc" id="L2066">      metadataList.add(adapter.getFlavor().toString(), adapter.getUITitle(), adapter.getRawFields());</span>
<span class="nc" id="L2067">    }</span>
<span class="nc" id="L2068">    return metadataList;</span>
  }

  @Override
  public MetadataList getMetadataListWithAllEventCatalogUIAdapters() {
<span class="fc" id="L2073">    MetadataList metadataList = new MetadataList();</span>
<span class="fc bfc" id="L2074" title="All 2 branches covered.">    for (EventCatalogUIAdapter catalogUIAdapter : getEventCatalogUIAdapters()) {</span>
<span class="fc" id="L2075">      metadataList.add(catalogUIAdapter, catalogUIAdapter.getRawFields());</span>
<span class="fc" id="L2076">    }</span>
<span class="fc" id="L2077">    return metadataList;</span>
  }

  /**
   * Checks the list of metadata for updated fields and stores/updates them in the respective metadata catalog.
   *
   * @param seriesId
   *          The series identifier
   * @param metadataList
   *          The metadata list
   */
  private void updateSeriesMetadata(String seriesId, MetadataList metadataList) {
<span class="nc bnc" id="L2089" title="All 2 branches missed.">    for (SeriesCatalogUIAdapter adapter : seriesCatalogUIAdapters) {</span>
<span class="nc" id="L2090">      final DublinCoreMetadataCollection metadata = metadataList.getMetadataByFlavor(adapter.getFlavor().toString());</span>
<span class="nc bnc" id="L2091" title="All 4 branches missed.">      if (metadata != null &amp;&amp; metadata.isUpdated()) {</span>
<span class="nc" id="L2092">        adapter.storeFields(seriesId, metadata);</span>
      }
<span class="nc" id="L2094">    }</span>
<span class="nc" id="L2095">  }</span>

  public boolean isWorkflowActive(String workflowState) {
<span class="nc bnc" id="L2098" title="All 2 branches missed.">    return WorkflowState.INSTANTIATED.toString().equals(workflowState)</span>
<span class="nc bnc" id="L2099" title="All 2 branches missed.">            || WorkflowState.RUNNING.toString().equals(workflowState)</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">            || WorkflowState.PAUSED.toString().equals(workflowState);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>