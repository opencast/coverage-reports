<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EventHttpServletRequest.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-index-service</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.index.service.impl.util</a> &gt; <span class="el_source">EventHttpServletRequest.java</span></div><h1>EventHttpServletRequest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.index.service.impl.util;

import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.index.service.exception.IndexServiceException;
import org.opencastproject.index.service.util.RequestUtils;
import org.opencastproject.ingest.api.IngestException;
import org.opencastproject.ingest.api.IngestService;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.EventCatalogUIAdapter;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.MetadataJson;
import org.opencastproject.metadata.dublincore.MetadataList;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.util.NotFoundException;

import com.entwinemedia.fn.data.Opt;

import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.lang3.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.TimeZone;

import javax.servlet.http.HttpServletRequest;

<span class="fc" id="L69">public class EventHttpServletRequest {</span>
  /** The logging facility */
<span class="fc" id="L71">  private static final Logger logger = LoggerFactory.getLogger(EventHttpServletRequest.class);</span>

  private static final String ACTION_JSON_KEY = &quot;action&quot;;
  private static final String ALLOW_JSON_KEY = &quot;allow&quot;;
  private static final String METADATA_JSON_KEY = &quot;metadata&quot;;
  private static final String ROLE_JSON_KEY = &quot;role&quot;;

<span class="fc" id="L78">  private Opt&lt;AccessControlList&gt; acl = Opt.none();</span>
<span class="fc" id="L79">  private Opt&lt;MediaPackage&gt; mediaPackage = Opt.none();</span>
<span class="fc" id="L80">  private Opt&lt;MetadataList&gt; metadataList = Opt.none();</span>
<span class="fc" id="L81">  private Opt&lt;JSONObject&gt; processing = Opt.none();</span>
<span class="fc" id="L82">  private Opt&lt;JSONObject&gt; source = Opt.none();</span>
<span class="fc" id="L83">  private Opt&lt;JSONObject&gt; scheduling = Opt.none();</span>

  public void setAcl(AccessControlList acl) {
<span class="fc" id="L86">    this.acl = Opt.some(acl);</span>
<span class="fc" id="L87">  }</span>

  public void setMediaPackage(MediaPackage mediaPackage) {
<span class="fc" id="L90">    this.mediaPackage = Opt.some(mediaPackage);</span>
<span class="fc" id="L91">  }</span>

  public void setMetadataList(MetadataList metadataList) {
<span class="fc" id="L94">    this.metadataList = Opt.some(metadataList);</span>
<span class="fc" id="L95">  }</span>

  public void setProcessing(JSONObject processing) {
<span class="fc" id="L98">    this.processing = Opt.some(processing);</span>
<span class="fc" id="L99">  }</span>

  public void setScheduling(JSONObject scheduling) {
<span class="nc" id="L102">    this.scheduling = Opt.some(scheduling);</span>
<span class="nc" id="L103">  }</span>

  public void setSource(JSONObject source) {
<span class="fc" id="L106">    this.source = Opt.some(source);</span>
<span class="fc" id="L107">  }</span>

  public Opt&lt;AccessControlList&gt; getAcl() {
<span class="fc" id="L110">    return acl;</span>
  }

  public Opt&lt;MediaPackage&gt; getMediaPackage() {
<span class="fc" id="L114">    return mediaPackage;</span>
  }

  public Opt&lt;MetadataList&gt; getMetadataList() {
<span class="fc" id="L118">    return metadataList;</span>
  }

  public Opt&lt;JSONObject&gt; getProcessing() {
<span class="fc" id="L122">    return processing;</span>
  }

  public Opt&lt;JSONObject&gt; getScheduling() {
<span class="fc" id="L126">    return scheduling;</span>
  }

  public Opt&lt;JSONObject&gt; getSource() {
<span class="fc" id="L130">    return source;</span>
  }

  /**
   * Create a {@link EventHttpServletRequest} from a {@link HttpServletRequest} to create a new {@link Event}.
   *
   * @param request
   *          The multipart request that should result in a new {@link Event}
   * @param ingestService
   *          The {@link IngestService} to use to ingest {@link Event} media.
   * @param eventCatalogUIAdapters
   *          The catalog ui adapters to use for getting the event metadata.
   * @param startDatePattern
   *          The pattern to use to parse the start date from the request.
   * @param startTimePattern
   *          The pattern to use to parse the start time from the request.
   * @return An {@link EventHttpServletRequest} populated from the request.
   * @throws IndexServiceException
   *           Thrown if unable to create the event for an internal reason.
   * @throws IllegalArgumentException
   *           Thrown if the multi part request doesn't have the necessary data.
   */
  public static EventHttpServletRequest createFromHttpServletRequest(
          HttpServletRequest request,
          IngestService ingestService,
          List&lt;EventCatalogUIAdapter&gt; eventCatalogUIAdapters,
          String startDatePattern,
          String startTimePattern)
                  throws IndexServiceException {
<span class="nc" id="L159">    EventHttpServletRequest eventHttpServletRequest = new EventHttpServletRequest();</span>
    try {
<span class="nc bnc" id="L161" title="All 2 branches missed.">      if (ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L162">        eventHttpServletRequest.setMediaPackage(ingestService.createMediaPackage());</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (eventHttpServletRequest.getMediaPackage().isNone()) {</span>
<span class="nc" id="L164">          throw new IndexServiceException(&quot;Unable to create a new mediapackage to store the new event's media.&quot;);</span>
        }

<span class="nc bnc" id="L167" title="All 2 branches missed.">        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L168">          FileItemStream item = iter.next();</span>
<span class="nc" id="L169">          String fieldName = item.getFieldName();</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">          if (item.isFormField()) {</span>
<span class="nc" id="L171">            setFormField(eventCatalogUIAdapters, eventHttpServletRequest, item, fieldName, startDatePattern, startTimePattern);</span>
          } else {
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (!item.getName().isBlank()) {</span>
<span class="nc" id="L174">              ingestFile(ingestService, eventHttpServletRequest, item);</span>
            } else {
<span class="nc" id="L176">              logger.debug(&quot;Skipping field {} due to missing filename&quot;, item.getFieldName());</span>
            }
          }
<span class="nc" id="L179">        }</span>
      } else {
<span class="nc" id="L181">        throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
      }

<span class="nc" id="L184">      return eventHttpServletRequest;</span>

<span class="nc" id="L186">    } catch (Exception e) {</span>
<span class="nc" id="L187">      throw new IndexServiceException(&quot;Unable to parse new event.&quot;, e);</span>
    }
  }

  /**
   * Ingest a file from a multi part request for a new event.
   *
   * @param ingestService
   *          The {@link IngestService} to use to ingest the file.
   * @param eventHttpServletRequest
   *          The {@link EventHttpServletRequest} that has the ingest mediapackage.
   * @param item
   *          The representation of the file.
   * @throws MediaPackageException
   *           Thrown if unable to add the track to the mediapackage.
   * @throws IOException
   *           Thrown if unable to upload the file into the mediapackage.
   * @throws IngestException
   *           Thrown if unable to ingest the file.
   */
  private static void ingestFile(IngestService ingestService, EventHttpServletRequest eventHttpServletRequest,
          FileItemStream item) throws MediaPackageException, IOException, IngestException {
<span class="nc" id="L209">    MediaPackage mp = eventHttpServletRequest.getMediaPackage().get();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">    if (&quot;presenter&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L211">      eventHttpServletRequest.setMediaPackage(</span>
<span class="nc" id="L212">              ingestService.addTrack(item.openStream(), item.getName(), MediaPackageElements.PRESENTER_SOURCE, mp));</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">    } else if (&quot;presentation&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L214">      eventHttpServletRequest.setMediaPackage(</span>
<span class="nc" id="L215">              ingestService.addTrack(item.openStream(), item.getName(), MediaPackageElements.PRESENTATION_SOURCE, mp));</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    } else if (&quot;audio&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L217">      eventHttpServletRequest.setMediaPackage(ingestService.addTrack(item.openStream(), item.getName(),</span>
              new MediaPackageElementFlavor(&quot;presenter-audio&quot;, &quot;source&quot;), mp));
    } else {
<span class="nc" id="L220">      logger.warn(&quot;Unknown field name found {}&quot;, item.getFieldName());</span>
    }
<span class="nc" id="L222">  }</span>

  /**
   * Set a value for creating a new event from a form field.
   *
   * @param eventCatalogUIAdapters
   *          The list of event catalog ui adapters used for loading the metadata for the new event.
   * @param eventHttpServletRequest
   *          The current details of the request that have been loaded.
   * @param item
   *          The content of the field.
   * @param fieldName
   *          The key of the field.
   * @param startDatePattern
   *          The pattern to use to parse the start date from the request.
   * @param startTimePattern
   *          The pattern to use to parse the start time from the request.
   * @throws IOException
   *           Thrown if unable to laod the content of the field.
   * @throws NotFoundException
   *           Thrown if unable to find a metadata catalog or field that matches an input catalog or field.
   */
  private static void setFormField(List&lt;EventCatalogUIAdapter&gt; eventCatalogUIAdapters,
                                   EventHttpServletRequest eventHttpServletRequest,
                                   FileItemStream item,
                                   String fieldName,
                                   String startDatePattern,
                                   String startTimePattern)
                  throws IOException, NotFoundException {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">    if (METADATA_JSON_KEY.equals(fieldName)) {</span>
<span class="fc" id="L252">      String metadata = Streams.asString(item.openStream());</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">      if (StringUtils.isNotEmpty(metadata)) {</span>
        try {
<span class="fc" id="L255">          MetadataList metadataList = deserializeMetadataList(metadata, eventCatalogUIAdapters, startDatePattern,</span>
                  startTimePattern);
<span class="fc" id="L257">          eventHttpServletRequest.setMetadataList(metadataList);</span>
<span class="nc" id="L258">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L259">          throw e;</span>
<span class="nc" id="L260">        } catch (ParseException e) {</span>
<span class="nc" id="L261">          throw new IllegalArgumentException(String.format(&quot;Unable to parse event metadata because: '%s'&quot;, e.toString()));</span>
<span class="nc" id="L262">        } catch (NotFoundException e) {</span>
<span class="nc" id="L263">          throw e;</span>
<span class="nc" id="L264">        } catch (java.text.ParseException e) {</span>
<span class="nc" id="L265">          throw new IllegalArgumentException(String.format(&quot;Unable to parse event metadata because: '%s'&quot;, e.toString()));</span>
<span class="fc" id="L266">        }</span>
      }
<span class="pc bnc" id="L268" title="All 2 branches missed.">    } else if (&quot;acl&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L269">      String access = Streams.asString(item.openStream());</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">      if (StringUtils.isNotEmpty(access)) {</span>
        try {
<span class="nc" id="L272">          AccessControlList acl = deserializeJsonToAcl(access, true);</span>
<span class="nc" id="L273">          eventHttpServletRequest.setAcl(acl);</span>
<span class="nc" id="L274">        } catch (Exception e) {</span>
<span class="nc" id="L275">          logger.warn(&quot;Unable to parse acl {}&quot;, access);</span>
<span class="nc" id="L276">          throw new IllegalArgumentException(&quot;Unable to parse acl&quot;);</span>
<span class="nc" id="L277">        }</span>
      }
<span class="nc bnc" id="L279" title="All 2 branches missed.">    } else if (&quot;processing&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L280">      String processing = Streams.asString(item.openStream());</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">      if (StringUtils.isNotEmpty(processing)) {</span>
<span class="nc" id="L282">        JSONParser parser = new JSONParser();</span>
        try {
<span class="nc" id="L284">          eventHttpServletRequest.setProcessing((JSONObject) parser.parse(processing));</span>
<span class="nc" id="L285">        } catch (Exception e) {</span>
<span class="nc" id="L286">          logger.warn(&quot;Unable to parse processing configuration {}&quot;, processing);</span>
<span class="nc" id="L287">          throw new IllegalArgumentException(&quot;Unable to parse processing configuration&quot;);</span>
<span class="nc" id="L288">        }</span>
      }
<span class="nc bnc" id="L290" title="All 2 branches missed.">    } else if (&quot;scheduling&quot;.equals(item.getFieldName())) {</span>
<span class="nc" id="L291">      String scheduling = Streams.asString(item.openStream());</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">      if (StringUtils.isNotEmpty(scheduling)) {</span>
<span class="nc" id="L293">        JSONParser parser = new JSONParser();</span>
        try {
<span class="nc" id="L295">          eventHttpServletRequest.setScheduling((JSONObject) parser.parse(scheduling));</span>
<span class="nc" id="L296">        } catch (Exception e) {</span>
<span class="nc" id="L297">          logger.warn(&quot;Unable to parse scheduling information {}&quot;, scheduling);</span>
<span class="nc" id="L298">          throw new IllegalArgumentException(&quot;Unable to parse scheduling information&quot;);</span>
<span class="nc" id="L299">        }</span>
      }
    }
<span class="fc" id="L302">  }</span>

  /**
   * Load the details of updating an event.
   *
   * @param event
   *          The event to update.
   * @param request
   *          The multipart request that has the data to load the updated event.
   * @param eventCatalogUIAdapters
   *          The list of catalog ui adapters to use to load the event metadata.
   * @param startDatePattern
   *          The pattern to use to parse the start date from the request.
   * @param startTimePattern
   *          The pattern to use to parse the start time from the request.
   * @return The data for the event update
   * @throws IllegalArgumentException
   *           Thrown if the request to update the event is malformed.
   * @throws IndexServiceException
   *           Thrown if something is unable to load the event data.
   * @throws NotFoundException
   *           Thrown if unable to find a metadata catalog or field that matches an input catalog or field.
   */
  public static EventHttpServletRequest updateFromHttpServletRequest(
          Event event,
          HttpServletRequest request,
          List&lt;EventCatalogUIAdapter&gt; eventCatalogUIAdapters,
          String startDatePattern,
          String startTimePattern)
                  throws IllegalArgumentException, IndexServiceException, NotFoundException {
<span class="fc" id="L332">    EventHttpServletRequest eventHttpServletRequest = new EventHttpServletRequest();</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">    if (ServletFileUpload.isMultipartContent(request)) {</span>
      try {
<span class="fc bfc" id="L335" title="All 2 branches covered.">        for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="fc" id="L336">          FileItemStream item = iter.next();</span>
<span class="fc" id="L337">          String fieldName = item.getFieldName();</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">          if (item.isFormField()) {</span>
<span class="fc" id="L339">            setFormField(eventCatalogUIAdapters, eventHttpServletRequest, item, fieldName, startDatePattern, startTimePattern);</span>
          }
<span class="fc" id="L341">        }</span>
<span class="nc" id="L342">      } catch (IOException e) {</span>
<span class="nc" id="L343">        throw new IndexServiceException(&quot;Unable to update event&quot;, e);</span>
<span class="nc" id="L344">      } catch (FileUploadException e) {</span>
<span class="nc" id="L345">        throw new IndexServiceException(&quot;Unable to update event&quot;, e);</span>
<span class="fc" id="L346">      }</span>
    } else {
<span class="nc" id="L348">      throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
    }
<span class="fc" id="L350">    return eventHttpServletRequest;</span>
  }

  /**
   * De-serialize an JSON into an {@link AccessControlList}.
   *
   * @param json
   *          The {@link AccessControlList} to serialize.
   * @param assumeAllow
   *          Assume that all entries are allows.
   * @return An {@link AccessControlList} representation of the Json
   * @throws ParseException
   */
  protected static AccessControlList deserializeJsonToAcl(String json, boolean assumeAllow) throws ParseException {
<span class="nc" id="L364">    JSONParser parser = new JSONParser();</span>
<span class="nc" id="L365">    JSONArray aclJson = (JSONArray) parser.parse(json);</span>
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L367">    ListIterator&lt;Object&gt; iterator = aclJson.listIterator();</span>
    JSONObject aceJson;
<span class="nc" id="L369">    List&lt;AccessControlEntry&gt; entries = new ArrayList&lt;AccessControlEntry&gt;();</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">    while (iterator.hasNext()) {</span>
<span class="nc" id="L371">      aceJson = (JSONObject) iterator.next();</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">      String action = aceJson.get(ACTION_JSON_KEY) != null ? aceJson.get(ACTION_JSON_KEY).toString() : &quot;&quot;;</span>
      String allow;
<span class="nc bnc" id="L374" title="All 2 branches missed.">      if (assumeAllow) {</span>
<span class="nc" id="L375">        allow = &quot;true&quot;;</span>
      } else {
<span class="nc bnc" id="L377" title="All 2 branches missed.">        allow = aceJson.get(ALLOW_JSON_KEY) != null ? aceJson.get(ALLOW_JSON_KEY).toString() : &quot;&quot;;</span>
      }
<span class="nc bnc" id="L379" title="All 2 branches missed.">      String role = aceJson.get(ROLE_JSON_KEY) != null ? aceJson.get(ROLE_JSON_KEY).toString() : &quot;&quot;;</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">      if (StringUtils.trimToNull(action) != null &amp;&amp; StringUtils.trimToNull(allow) != null</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">              &amp;&amp; StringUtils.trimToNull(role) != null) {</span>
<span class="nc" id="L382">        AccessControlEntry ace = new AccessControlEntry(role, action, Boolean.parseBoolean(allow));</span>
<span class="nc" id="L383">        entries.add(ace);</span>
<span class="nc" id="L384">      } else {</span>
<span class="nc" id="L385">        throw new IllegalArgumentException(String.format(</span>
                &quot;One of the access control elements is missing a property. The action was '%s', allow was '%s' and the role was '%s'&quot;,
                action, allow, role));
      }
<span class="nc" id="L389">    }</span>
<span class="nc" id="L390">    return new AccessControlList(entries);</span>
  }

  /**
   * Change the simplified fields of key values provided to the external api into a {@link MetadataList}.
   *
   * @param json
   *          The json string that contains an array of metadata field lists for the different catalogs.
   * @param startDatePattern
   *          The pattern to use to parse the start date from the json payload.
   * @param startTimePattern
   *          The pattern to use to parse the start time from the json payload.
   * @return A {@link MetadataList} with the fields populated with the values provided.
   * @throws ParseException
   *           Thrown if unable to parse the json string.
   * @throws NotFoundException
   *           Thrown if unable to find the catalog or field that the json refers to.
   */
  protected static MetadataList deserializeMetadataList(
          String json,
          List&lt;EventCatalogUIAdapter&gt; catalogAdapters,
          String startDatePattern,
          String startTimePattern)
          throws ParseException, NotFoundException, java.text.ParseException {
<span class="fc" id="L414">    MetadataList metadataList = new MetadataList();</span>
<span class="fc" id="L415">    JSONParser parser = new JSONParser();</span>
<span class="fc" id="L416">    JSONArray jsonCatalogs = (JSONArray) parser.parse(json);</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">    for (int i = 0; i &lt; jsonCatalogs.size(); i++) {</span>
<span class="fc" id="L418">      JSONObject catalog = (JSONObject) jsonCatalogs.get(i);</span>
<span class="pc bpc" id="L419" title="2 of 4 branches missed.">      if (catalog.get(&quot;flavor&quot;) == null || StringUtils.isBlank(catalog.get(&quot;flavor&quot;).toString())) {</span>
<span class="nc" id="L420">        throw new IllegalArgumentException(</span>
                &quot;Unable to create new event as no flavor was given for one of the metadata collections&quot;);
      }
<span class="fc" id="L423">      String flavorString = catalog.get(&quot;flavor&quot;).toString();</span>
<span class="fc" id="L424">      MediaPackageElementFlavor flavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>

<span class="fc" id="L426">      DublinCoreMetadataCollection collection = null;</span>
<span class="fc" id="L427">      EventCatalogUIAdapter adapter = null;</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">      for (EventCatalogUIAdapter eventCatalogUIAdapter : catalogAdapters) {</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        if (eventCatalogUIAdapter.getFlavor().equals(flavor)) {</span>
<span class="fc" id="L430">          adapter = eventCatalogUIAdapter;</span>
<span class="fc" id="L431">          collection = eventCatalogUIAdapter.getRawFields();</span>
        }
<span class="fc" id="L433">      }</span>

<span class="pc bpc" id="L435" title="1 of 2 branches missed.">      if (collection == null) {</span>
<span class="nc" id="L436">        throw new IllegalArgumentException(</span>
<span class="nc" id="L437">                String.format(&quot;Unable to find an EventCatalogUIAdapter with Flavor '%s'&quot;, flavorString));</span>
      }

<span class="fc" id="L440">      String fieldsJson = catalog.get(&quot;fields&quot;).toString();</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">      if (StringUtils.trimToNull(fieldsJson) != null) {</span>
<span class="fc" id="L442">        Map&lt;String, String&gt; fields = RequestUtils.getKeyValueMap(fieldsJson);</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">        for (String key : fields.keySet()) {</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">          if (&quot;subjects&quot;.equals(key)) {</span>
            // Handle the special case of allowing subjects to be an array.
<span class="fc" id="L446">            MetadataField field = collection.getOutputFields().get(DublinCore.PROPERTY_SUBJECT.getLocalName());</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L448">              throw new NotFoundException(String.format(</span>
                      &quot;Cannot find a metadata field with id 'subject' from Catalog with Flavor '%s'.&quot;, flavorString));
            }
<span class="fc" id="L451">            collection.removeField(field);</span>
            try {
<span class="fc" id="L453">              JSONArray subjects = (JSONArray) parser.parse(fields.get(key));</span>
<span class="fc" id="L454">              collection.addField(MetadataJson</span>
<span class="fc" id="L455">                      .copyWithDifferentJsonValue(field, StringUtils.join(subjects.iterator(), &quot;,&quot;)));</span>
<span class="nc" id="L456">            } catch (ParseException e) {</span>
<span class="nc" id="L457">              throw new IllegalArgumentException(</span>
<span class="nc" id="L458">                      String.format(&quot;Unable to parse the 'subjects' metadata array field because: %s&quot;, e.toString()));</span>
<span class="fc" id="L459">            }</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">          } else if (&quot;startDate&quot;.equals(key)) {</span>
            // Special handling for start date since in API v1 we expect start date and start time to be separate fields.
<span class="fc" id="L462">            MetadataField field = collection.getOutputFields().get(key);</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L464">              throw new NotFoundException(String.format(</span>
                      &quot;Cannot find a metadata field with id '%s' from Catalog with Flavor '%s'.&quot;, key, flavorString));
            }
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">            SimpleDateFormat apiSdf = MetadataField.getSimpleDateFormatter(startDatePattern == null ? field.getPattern() : startDatePattern);</span>
<span class="fc" id="L468">            SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L469">            DateTime newStartDate = new DateTime(apiSdf.parse(fields.get(key)), DateTimeZone.UTC);</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">            if (field.getValue() != null) {</span>
<span class="nc" id="L471">              DateTime oldStartDate = new DateTime(sdf.parse((String) field.getValue()), DateTimeZone.UTC);</span>
<span class="nc" id="L472">              newStartDate = oldStartDate.withDate(newStartDate.year().get(), newStartDate.monthOfYear().get(), newStartDate.dayOfMonth().get());</span>
            }
<span class="fc" id="L474">            collection.removeField(field);</span>
<span class="fc" id="L475">            collection.addField(MetadataJson.copyWithDifferentJsonValue(field, sdf.format(newStartDate.toDate())));</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">          } else if (&quot;startTime&quot;.equals(key)) {</span>
            // Special handling for start time since in API v1 we expect start date and start time to be separate fields.
<span class="fc" id="L478">            MetadataField field = collection.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L480">              throw new NotFoundException(String.format(</span>
                      &quot;Cannot find a metadata field with id '%s' from Catalog with Flavor '%s'.&quot;, &quot;startDate&quot;, flavorString));
            }
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">            SimpleDateFormat apiSdf = MetadataField.getSimpleDateFormatter(startTimePattern == null ? &quot;HH:mm&quot; : startTimePattern);</span>
<span class="fc" id="L484">            SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L485">            DateTime newStartDate = new DateTime(apiSdf.parse(fields.get(key)), DateTimeZone.UTC);</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">            if (field.getValue() != null) {</span>
<span class="fc" id="L487">              DateTime oldStartDate = new DateTime(sdf.parse((String) field.getValue()), DateTimeZone.UTC);</span>
<span class="fc" id="L488">              newStartDate = oldStartDate.withTime(</span>
<span class="fc" id="L489">                      newStartDate.hourOfDay().get(),</span>
<span class="fc" id="L490">                      newStartDate.minuteOfHour().get(),</span>
<span class="fc" id="L491">                      newStartDate.secondOfMinute().get(),</span>
<span class="fc" id="L492">                      newStartDate.millisOfSecond().get());</span>
            }
<span class="fc" id="L494">            collection.removeField(field);</span>
<span class="fc" id="L495">            collection.addField(MetadataJson.copyWithDifferentJsonValue(field, sdf.format(newStartDate.toDate())));</span>
<span class="fc" id="L496">          } else {</span>
<span class="fc" id="L497">            MetadataField field = collection.getOutputFields().get(key);</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L499">              throw new NotFoundException(String.format(</span>
                      &quot;Cannot find a metadata field with id '%s' from Catalog with Flavor '%s'.&quot;, key, flavorString));
            }
<span class="fc" id="L502">            collection.removeField(field);</span>
<span class="fc" id="L503">            collection.addField(MetadataJson.copyWithDifferentJsonValue(field, fields.get(key)));</span>
          }
<span class="fc" id="L505">        }</span>
      }
<span class="fc" id="L507">      metadataList.add(adapter, collection);</span>
    }
<span class="fc" id="L509">    setStartDateAndTimeIfUnset(metadataList);</span>
<span class="fc" id="L510">    return metadataList;</span>
  }

  /**
   * Set the start date and time to the current date &amp; time if it hasn't been set through the api call.
   *
   * @param metadataList
   *          The metadata list created from the json request to create a new event
   */
  private static void setStartDateAndTimeIfUnset(MetadataList metadataList) {
<span class="fc" id="L520">    final DublinCoreMetadataCollection commonEventCollection = metadataList</span>
<span class="fc" id="L521">            .getMetadataByFlavor(MediaPackageElements.EPISODE.toString());</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">    if (commonEventCollection != null) {</span>
<span class="fc" id="L523">      MetadataField startDate = commonEventCollection.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">      if (!startDate.isUpdated()) {</span>
<span class="nc" id="L525">        SimpleDateFormat utcDateFormat = new SimpleDateFormat(startDate.getPattern());</span>
<span class="nc" id="L526">        utcDateFormat.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
<span class="nc" id="L527">        String currentDate = utcDateFormat.format(new DateTime(DateTimeZone.UTC).toDate());</span>
<span class="nc" id="L528">        commonEventCollection.removeField(startDate);</span>
<span class="nc" id="L529">        commonEventCollection.addField(MetadataJson.copyWithDifferentJsonValue(startDate, currentDate));</span>
      }
    }
<span class="fc" id="L532">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>