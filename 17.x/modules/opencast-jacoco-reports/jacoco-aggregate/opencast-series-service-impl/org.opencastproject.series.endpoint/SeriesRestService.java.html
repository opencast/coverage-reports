<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SeriesRestService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-series-service-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.series.endpoint</a> &gt; <span class="el_source">SeriesRestService.java</span></div><h1>SeriesRestService.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.series.endpoint;

import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
import static javax.servlet.http.HttpServletResponse.SC_CREATED;
import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;
import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
import static javax.servlet.http.HttpServletResponse.SC_NO_CONTENT;
import static javax.servlet.http.HttpServletResponse.SC_OK;
import static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;
import static javax.ws.rs.core.Response.Status.BAD_REQUEST;
import static javax.ws.rs.core.Response.Status.CREATED;
import static javax.ws.rs.core.Response.Status.INTERNAL_SERVER_ERROR;
import static javax.ws.rs.core.Response.Status.NOT_FOUND;
import static javax.ws.rs.core.Response.Status.NO_CONTENT;
import static org.opencastproject.metadata.dublincore.DublinCore.PROPERTY_IDENTIFIER;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;
import static org.opencastproject.util.doc.rest.RestParameter.Type.TEXT;

import org.opencastproject.mediapackage.EName;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreCatalogService;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.rest.RestConstants;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.series.api.Series;
import org.opencastproject.series.api.SeriesException;
import org.opencastproject.series.api.SeriesService;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RestUtil.R;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestParameter.Type;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;

import com.entwinemedia.fn.Stream;
import com.entwinemedia.fn.data.Opt;
import com.entwinemedia.fn.data.json.JValue;
import com.entwinemedia.fn.data.json.Jsons;
import com.entwinemedia.fn.data.json.SimpleSerializer;
import com.google.gson.Gson;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.DELETE;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

/**
 * REST endpoint for Series Service.
 *
 */
@Path(&quot;/series&quot;)
@RestService(
    name = &quot;seriesservice&quot;,
    title = &quot;Series Service&quot;,
    abstractText = &quot;This service creates, edits and retrieves and helps managing series.&quot;,
    notes = {
        &quot;All paths above are relative to the REST endpoint base (something like http://your.server/files)&quot;,
        &quot;If the service is down or not working it will return a status 503, this means the the &quot;
            + &quot;underlying service is not working and is either restarting or has failed&quot;,
        &quot;A status code 500 means a general failure has occurred which is not recoverable and was &quot;
            + &quot;not anticipated. In other words, there is a bug! You should file an error report &quot;
            + &quot;with your server logs from the time when the error occurred: &quot;
            + &quot;&lt;a href=\&quot;https://github.com/opencast/opencast/issues\&quot;&gt;Opencast Issue Tracker&lt;/a&gt;&quot;
    }
)
@Component(
    immediate = true,
    service = SeriesRestService.class,
    property = {
        &quot;service.description=Series REST Endpoint&quot;,
        &quot;opencast.service.type=org.opencastproject.series&quot;,
        &quot;opencast.service.path=/series&quot;
    }
)
@JaxrsResource
<span class="nc" id="L138">public class SeriesRestService {</span>

  private static final String SERIES_ELEMENT_CONTENT_TYPE_PREFIX = &quot;series/&quot;;

<span class="nc" id="L142">  private static final Gson gson = new Gson();</span>

  /** Logging utility */
<span class="nc" id="L145">  private static final Logger logger = LoggerFactory.getLogger(SeriesRestService.class);</span>

  /** Series Service */
  private SeriesService seriesService;

  /** Dublin Core Catalog service */
  private DublinCoreCatalogService dcService;

  /** The security service */
  private SecurityService securityService;

  /** Default server URL */
<span class="nc" id="L157">  protected String serverUrl = &quot;http://localhost:8080&quot;;</span>

  /** Service url */
<span class="nc" id="L160">  protected String serviceUrl = null;</span>

  /** Default number of items on page */
  private static final int DEFAULT_LIMIT = 20;

  /** Suffix to mark descending ordering of results */
  public static final String DESCENDING_SUFFIX = &quot;_DESC&quot;;

  private static final String SAMPLE_DUBLIN_CORE = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot;
      + &quot;&lt;dublincore xmlns=\&quot;http://www.opencastproject.org/xsd/1.0/dublincore/\&quot; &quot;
      + &quot;    xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot;\n&quot;
      + &quot;    xsi:schemaLocation=\&quot;http://www.opencastproject.org http://www.opencastproject.org/schema.xsd\&quot; &quot;
      + &quot;    xmlns:dc=\&quot;http://purl.org/dc/elements/1.1/\&quot;\n&quot;
      + &quot;    xmlns:dcterms=\&quot;http://purl.org/dc/terms/\&quot; &quot;
      + &quot;    xmlns:oc=\&quot;http://www.opencastproject.org/matterhorn/\&quot;&gt;\n\n&quot;
      + &quot;  &lt;dcterms:title xml:lang=\&quot;en\&quot;&gt;\n&quot;
      + &quot;    Land and Vegetation: Key players on the Climate Scene\n&quot;
      + &quot;  &lt;/dcterms:title&gt;\n&quot;
      + &quot;  &lt;dcterms:subject&gt;&quot;
      + &quot;    climate, land, vegetation\n&quot;
      + &quot;  &lt;/dcterms:subject&gt;\n&quot;
      + &quot;  &lt;dcterms:description xml:lang=\&quot;en\&quot;&gt;\n&quot;
      + &quot;    Introduction lecture from the Institute for\n&quot;
      + &quot;    Atmospheric and Climate Science.\n&quot;
      + &quot;  &lt;/dcterms:description&gt;\n&quot;
      + &quot;  &lt;dcterms:publisher&gt;\n&quot;
      + &quot;    ETH Zurich, Switzerland\n&quot;
      + &quot;  &lt;/dcterms:publisher&gt;\n&quot;
      + &quot;  &lt;dcterms:identifier&gt;\n&quot;
      + &quot;    10.0000/5819\n&quot;
      + &quot;  &lt;/dcterms:identifier&gt;\n&quot;
      + &quot;  &lt;dcterms:modified xsi:type=\&quot;dcterms:W3CDTF\&quot;&gt;\n&quot;
      + &quot;    2007-12-05\n&quot;
      + &quot;  &lt;/dcterms:modified&gt;\n&quot;
      + &quot;  &lt;dcterms:format xsi:type=\&quot;dcterms:IMT\&quot;&gt;\n&quot;
      + &quot;    video/x-dv\n&quot;
      + &quot;  &lt;/dcterms:format&gt;\n&quot;
      + &quot;&lt;/dublincore&gt;&quot;;

  private static final String SAMPLE_ACCESS_CONTROL_LIST =
      &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; standalone=\&quot;yes\&quot;?&gt;\n&quot;
          + &quot;&lt;acl xmlns=\&quot;http://org.opencastproject.security\&quot;&gt;\n&quot;
          + &quot;  &lt;ace&gt;\n&quot;
          + &quot;    &lt;role&gt;admin&lt;/role&gt;\n&quot;
          + &quot;    &lt;action&gt;delete&lt;/action&gt;\n&quot;
          + &quot;    &lt;allow&gt;true&lt;/allow&gt;\n&quot;
          + &quot;  &lt;/ace&gt;\n&quot;
          + &quot;&lt;/acl&gt;&quot;;

  /**
   * OSGi callback for setting series service.
   *
   * @param seriesService
   */
  @Reference
  public void setService(SeriesService seriesService) {
<span class="nc" id="L216">    this.seriesService = seriesService;</span>
<span class="nc" id="L217">  }</span>

  /**
   * OSGi callback for setting Dublin Core Catalog service.
   *
   * @param dcService
   */
  @Reference
  public void setDublinCoreService(DublinCoreCatalogService dcService) {
<span class="nc" id="L226">    this.dcService = dcService;</span>
<span class="nc" id="L227">  }</span>

  /** OSGi callback for the security service */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="nc" id="L232">    this.securityService = securityService;</span>
<span class="nc" id="L233">  }</span>


  /**
   * Activates REST service.
   *
   * @param cc
   *          ComponentContext
   */
  @Activate
  public void activate(ComponentContext cc) {
<span class="nc bnc" id="L244" title="All 2 branches missed.">    if (cc == null) {</span>
<span class="nc" id="L245">      this.serverUrl = &quot;http://localhost:8080&quot;;</span>
    } else {
<span class="nc" id="L247">      String ccServerUrl = cc.getBundleContext().getProperty(OpencastConstants.SERVER_URL_PROPERTY);</span>
<span class="nc" id="L248">      logger.debug(&quot;Configured server url is {}&quot;, ccServerUrl);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">      if (ccServerUrl == null) {</span>
<span class="nc" id="L250">        this.serverUrl = &quot;http://localhost:8080&quot;;</span>
      } else {
<span class="nc" id="L252">        this.serverUrl = ccServerUrl;</span>
      }
    }
<span class="nc" id="L255">    serviceUrl = (String) cc.getProperties().get(RestConstants.SERVICE_PATH_PROPERTY);</span>
<span class="nc" id="L256">  }</span>

  public String getSeriesXmlUrl(String seriesId) {
<span class="nc" id="L259">    return UrlSupport.concat(serverUrl, serviceUrl, seriesId + &quot;.xml&quot;);</span>
  }

  public String getSeriesJsonUrl(String seriesId) {
<span class="nc" id="L263">    return UrlSupport.concat(serverUrl, serviceUrl, seriesId + &quot;.json&quot;);</span>
  }

  @GET
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;{seriesID:.+}.xml&quot;)
  @RestQuery(
      name = &quot;getAsXml&quot;,
      description = &quot;Returns the series with the given identifier&quot;,
      returnDescription = &quot;Returns the series dublin core XML document&quot;,
      pathParameters = {
          @RestParameter(name = &quot;seriesID&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING)
      },
      responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The series dublin core.&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;No series with this identifier was found.&quot;),
          @RestResponse(responseCode = SC_FORBIDDEN, description = &quot;You do not have permission to view this series.&quot;),
          @RestResponse(
              responseCode = SC_UNAUTHORIZED,
              description = &quot;You do not have permission to view this series. Maybe you need to authenticate.&quot;
          )
      }
  )
  public Response getSeriesXml(@PathParam(&quot;seriesID&quot;) String seriesID) {
<span class="nc" id="L287">    logger.debug(&quot;Series Lookup: {}&quot;, seriesID);</span>
    try {
<span class="nc" id="L289">      DublinCoreCatalog dc = this.seriesService.getSeries(seriesID);</span>
<span class="nc" id="L290">      return Response.ok(dc.toXmlString()).build();</span>
<span class="nc" id="L291">    } catch (NotFoundException e) {</span>
<span class="nc" id="L292">      return Response.status(Response.Status.NOT_FOUND).build();</span>
<span class="nc" id="L293">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L294">      logger.warn(&quot;permission exception retrieving series&quot;);</span>
      // TODO this should be an 403 (Forbidden) if the user is logged in
<span class="nc" id="L296">      throw new WebApplicationException(Response.Status.UNAUTHORIZED);</span>
<span class="nc" id="L297">    } catch (Exception e) {</span>
<span class="nc" id="L298">      logger.error(&quot;Could not retrieve series: {}&quot;, e.getMessage());</span>
<span class="nc" id="L299">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;{seriesID:.+}.json&quot;)
  @RestQuery(
      name = &quot;getAsJson&quot;,
      description = &quot;Returns the series with the given identifier&quot;,
      returnDescription = &quot;Returns the series dublin core JSON document&quot;,
      pathParameters = {
          @RestParameter(name = &quot;seriesID&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING)
      },
      responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The series dublin core.&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;No series with this identifier was found.&quot;),
          @RestResponse(
              responseCode = SC_UNAUTHORIZED,
              description = &quot;You do not have permission to view this series. Maybe you need to authenticate.&quot;
          )
      }
  )
  public Response getSeriesJSON(@PathParam(&quot;seriesID&quot;) String seriesID) {
<span class="nc" id="L323">    logger.debug(&quot;Series Lookup: {}&quot;, seriesID);</span>
    try {
<span class="nc" id="L325">      DublinCoreCatalog dc = this.seriesService.getSeries(seriesID);</span>
<span class="nc" id="L326">      return Response.ok(dc.toJson()).build();</span>
<span class="nc" id="L327">    } catch (NotFoundException e) {</span>
<span class="nc" id="L328">      return Response.status(Response.Status.NOT_FOUND).build();</span>
<span class="nc" id="L329">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L330">      logger.warn(&quot;permission exception retrieving series&quot;);</span>
      // TODO this should be an 403 (Forbidden) if the user is logged in
<span class="nc" id="L332">      throw new WebApplicationException(Response.Status.UNAUTHORIZED);</span>
<span class="nc" id="L333">    } catch (Exception e) {</span>
<span class="nc" id="L334">      logger.error(&quot;Could not retrieve series: {}&quot;, e.getMessage());</span>
<span class="nc" id="L335">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @GET
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;/{seriesID:.+}/acl.xml&quot;)
  @RestQuery(
      name = &quot;getAclAsXml&quot;,
      description = &quot;Returns the access control list for the series with the given identifier&quot;,
      returnDescription = &quot;Returns the series ACL as XML&quot;,
      pathParameters = {
          @RestParameter(name = &quot;seriesID&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING)
      },
      responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The access control list.&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;No series with this identifier was found.&quot;)
      }
  )
  public Response getSeriesAccessControlListXml(@PathParam(&quot;seriesID&quot;) String seriesID) {
<span class="nc" id="L355">    return getSeriesAccessControlList(seriesID);</span>
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;/{seriesID:.+}/acl.json&quot;)
  @RestQuery(
      name = &quot;getAclAsJson&quot;,
      description = &quot;Returns the access control list for the series with the given identifier&quot;,
      returnDescription = &quot;Returns the series ACL as JSON&quot;,
      pathParameters = {
          @RestParameter(name = &quot;seriesID&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING)
      },
      responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The access control list.&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;No series with this identifier was found.&quot;)
      }
  )
  public Response getSeriesAccessControlListJson(@PathParam(&quot;seriesID&quot;) String seriesID) {
<span class="nc" id="L374">    return getSeriesAccessControlList(seriesID);</span>
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;/allInRangeAdministrative.json&quot;)
  @RestQuery(
      name = &quot;allInRangeAdministrative&quot;,
      description = &quot;Internal API! Returns all series (included deleted ones!) in the given &quot;
          + &quot;range 'from' (inclusive) .. 'to' (exclusive). Returns at most 'limit' many series. &quot;
          + &quot;Can only be used as administrator!&quot;,
      returnDescription = &quot;Series in the range&quot;,
      restParameters = {
          @RestParameter(
              name = &quot;from&quot;,
              isRequired = true,
              description = &quot;Start of date range (inclusive) in milliseconds &quot;
                  + &quot;since 1970-01-01T00:00:00Z. Has to be &gt;=0.&quot;,
              type = Type.INTEGER
          ),
          @RestParameter(
              name = &quot;to&quot;,
              isRequired = false,
              // TODO: this shows the default value as 0 despite us not setting this value!
              description = &quot;End of date range (exclusive) in milliseconds &quot;
                  + &quot;since 1970-01-01T00:00:00Z. Has to be &gt; 'from'.&quot;,
              type = Type.INTEGER
          ),
          @RestParameter(
              name = &quot;limit&quot;,
              isRequired = true,
              description = &quot;Maximum number of series to be returned. Has to be &gt;0.&quot;,
              type = Type.INTEGER
          ),
      },
      responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;All series in the range&quot;),
          @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;if the given parameters are invalid&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;If the user is not an administrator&quot;),
      }
  )
  public Response getAllInRangeAdministrative(
      @FormParam(&quot;from&quot;) Long from,
      @FormParam(&quot;to&quot;) Long to,
      @FormParam(&quot;limit&quot;) Integer limit
  ) throws UnauthorizedException {
    // Parameter error handling
<span class="nc bnc" id="L421" title="All 2 branches missed.">    if (from == null) {</span>
<span class="nc" id="L422">      return badRequestAllInRange(&quot;Required parameter 'from' not specified&quot;);</span>
    }
<span class="nc bnc" id="L424" title="All 2 branches missed.">    if (limit == null) {</span>
<span class="nc" id="L425">      return badRequestAllInRange(&quot;Required parameter 'limit' not specified&quot;);</span>
    }
<span class="nc bnc" id="L427" title="All 2 branches missed.">    if (from &lt; 0) {</span>
<span class="nc" id="L428">      return badRequestAllInRange(&quot;Parameter 'from' &lt; 0, but it has to be &gt;= 0&quot;);</span>
    }
<span class="nc bnc" id="L430" title="All 4 branches missed.">    if (to != null &amp;&amp; to &lt;= from) {</span>
<span class="nc" id="L431">      return badRequestAllInRange(&quot;Parameter 'to' &lt;= 'from', but that is not allowed&quot;);</span>
    }
<span class="nc bnc" id="L433" title="All 2 branches missed.">    if (limit &lt;= 0) {</span>
<span class="nc" id="L434">      return badRequestAllInRange(&quot;Parameter 'limit' &lt;= 0, but it has to be &gt; 0&quot;);</span>
    }

    try {
<span class="nc" id="L438">      final List&lt;Series&gt; series = seriesService.getAllForAdministrativeRead(</span>
<span class="nc" id="L439">          new Date(from),</span>
<span class="nc" id="L440">          Optional.ofNullable(to).map(millis -&gt; new Date(millis)),</span>
<span class="nc" id="L441">          limit);</span>

<span class="nc" id="L443">      return Response.ok(gson.toJson(series)).build();</span>
<span class="nc" id="L444">    } catch (SeriesException e) {</span>
<span class="nc" id="L445">      logger.error(&quot;Unexpected exception in getAllInRangeAdministrative&quot;, e);</span>
<span class="nc" id="L446">      return Response.status(INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L447">          .entity(&quot;internal server error&quot;)</span>
<span class="nc" id="L448">          .build();</span>
    }
  }

  /**
   * Returns a {@code Response} object representing a BAD_REQUEST to `allInRangeAdministrative`
   * with the given message as body. Also logs the message.
   */
  private static Response badRequestAllInRange(String msg) {
<span class="nc" id="L457">    logger.debug(&quot;Bad request to /series/allInRangeAdministrative: {}&quot;, msg);</span>
<span class="nc" id="L458">    return Response.status(BAD_REQUEST).entity(msg).build();</span>
  }

  /**
   * Retrieves ACL associated with series.
   *
   * @param seriesID
   *          series of which ACL should be retrieved
   * @return
   */
  private Response getSeriesAccessControlList(String seriesID) {
<span class="nc" id="L469">    logger.debug(&quot;Series ACL lookup: {}&quot;, seriesID);</span>
    try {
<span class="nc" id="L471">      AccessControlList acl = seriesService.getSeriesAccessControl(seriesID);</span>
<span class="nc" id="L472">      return Response.ok(acl).build();</span>
<span class="nc" id="L473">    } catch (NotFoundException e) {</span>
<span class="nc" id="L474">      return Response.status(NOT_FOUND).build();</span>
<span class="nc" id="L475">    } catch (SeriesException e) {</span>
<span class="nc" id="L476">      logger.error(&quot;Could not retrieve series ACL: {}&quot;, e.getMessage());</span>
    }
<span class="nc" id="L478">    throw new WebApplicationException(INTERNAL_SERVER_ERROR);</span>
  }

  private void addDcData(final DublinCoreCatalog dc, final String field, final String value) {
<span class="nc bnc" id="L482" title="All 2 branches missed.">    if (StringUtils.isNotBlank(value)) {</span>
<span class="nc" id="L483">      EName en = new EName(DublinCore.TERMS_NS_URI, field);</span>
<span class="nc" id="L484">      dc.add(en, value);</span>
    }
<span class="nc" id="L486">  }</span>

  @POST
  @Path(&quot;/&quot;)
  @RestQuery(
      name = &quot;updateSeries&quot;,
      description = &quot;Updates a series&quot;,
      returnDescription = &quot;No content.&quot;,
      restParameters = {
          @RestParameter(
              name = &quot;series&quot;,
              isRequired = false,
              defaultValue = SAMPLE_DUBLIN_CORE,
              description = &quot;The series document. Will take precedence over metadata fields&quot;,
              type = TEXT
          ),
          @RestParameter(
              name = &quot;acl&quot;,
              isRequired = false,
              defaultValue = SAMPLE_ACCESS_CONTROL_LIST,
              description = &quot;The access control list for the series&quot;,
              type = TEXT
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;accessRights&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;available&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;contributor&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;coverage&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;created&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;creator&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;date&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;description&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;extent&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;format&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;identifier&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;isPartOf&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;isReferencedBy&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;isReplacedBy&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;language&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;license&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;publisher&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;relation&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;replaces&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;rights&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;rightsHolder&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;source&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;spatial&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;subject&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;temporal&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;title&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              description = &quot;Series metadata value&quot;,
              isRequired = false,
              name = &quot;type&quot;,
              type = RestParameter.Type.STRING
          ),
          @RestParameter(
              name = &quot;override&quot;,
              isRequired = false,
              defaultValue = &quot;false&quot;,
              description = &quot;If true the series ACL will take precedence over any existing episode ACL&quot;,
              type = STRING
          )
      },
      responses = {
          @RestResponse(
              responseCode = SC_BAD_REQUEST,
              description = &quot;The required form params were missing in the request.&quot;
          ),
          @RestResponse(
              responseCode = SC_NO_CONTENT,
              description = &quot;The access control list has been updated.&quot;
          ),
          @RestResponse(
              responseCode = SC_UNAUTHORIZED,
              description = &quot;If the current user is not authorized to perform this action&quot;
          ),
          @RestResponse(
              responseCode = SC_CREATED,
              description = &quot;The access control list has been created.&quot;
          )
      }
  )
  public Response addOrUpdateSeries(
      @FormParam(&quot;series&quot;) String series,
      @FormParam(&quot;acl&quot;) String accessControl,
      @FormParam(&quot;accessRights&quot;) String dcAccessRights,
      @FormParam(&quot;available&quot;) String dcAvailable,
      @FormParam(&quot;contributor&quot;) String dcContributor,
      @FormParam(&quot;coverage&quot;) String dcCoverage,
      @FormParam(&quot;created&quot;) String dcCreated,
      @FormParam(&quot;creator&quot;) String dcCreator,
      @FormParam(&quot;date&quot;) String dcDate,
      @FormParam(&quot;description&quot;) String dcDescription,
      @FormParam(&quot;extent&quot;) String dcExtent,
      @FormParam(&quot;format&quot;) String dcFormat,
      @FormParam(&quot;identifier&quot;) String dcIdentifier,
      @FormParam(&quot;isPartOf&quot;) String dcIsPartOf,
      @FormParam(&quot;isReferencedBy&quot;) String dcIsReferencedBy,
      @FormParam(&quot;isReplacedBy&quot;) String dcIsReplacedBy,
      @FormParam(&quot;language&quot;) String dcLanguage,
      @FormParam(&quot;license&quot;) String dcLicense,
      @FormParam(&quot;publisher&quot;) String dcPublisher,
      @FormParam(&quot;relation&quot;) String dcRelation,
      @FormParam(&quot;replaces&quot;) String dcReplaces,
      @FormParam(&quot;rights&quot;) String dcRights,
      @FormParam(&quot;rightsHolder&quot;) String dcRightsHolder,
      @FormParam(&quot;source&quot;) String dcSource,
      @FormParam(&quot;spatial&quot;) String dcSpatial,
      @FormParam(&quot;subject&quot;) String dcSubject,
      @FormParam(&quot;temporal&quot;) String dcTemporal,
      @FormParam(&quot;title&quot;) String dcTitle,
      @FormParam(&quot;type&quot;) String dcType,
      @DefaultValue(&quot;false&quot;) @FormParam(&quot;override&quot;) boolean override
  ) throws UnauthorizedException {
    DublinCoreCatalog dc;
<span class="nc bnc" id="L731" title="All 2 branches missed.">    if (StringUtils.isNotBlank(series)) {</span>
      try {
<span class="nc" id="L733">        dc = this.dcService.load(new ByteArrayInputStream(series.getBytes(StandardCharsets.UTF_8)));</span>
<span class="nc" id="L734">      } catch (UnsupportedEncodingException e1) {</span>
<span class="nc" id="L735">        logger.error(&quot;Could not deserialize dublin core catalog&quot;, e1);</span>
<span class="nc" id="L736">        throw new WebApplicationException(INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L737">      } catch (IOException e1) {</span>
<span class="nc" id="L738">        logger.warn(&quot;Could not deserialize dublin core catalog&quot;, e1);</span>
<span class="nc" id="L739">        return Response.status(BAD_REQUEST).build();</span>
<span class="nc" id="L740">      }</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">    } else if (StringUtils.isNotBlank(dcTitle)) {</span>
<span class="nc" id="L742">      dc = DublinCores.mkOpencastSeries().getCatalog();</span>
<span class="nc" id="L743">      addDcData(dc, &quot;accessRights&quot;, dcAccessRights);</span>
<span class="nc" id="L744">      addDcData(dc, &quot;available&quot;, dcAvailable);</span>
<span class="nc" id="L745">      addDcData(dc, &quot;contributor&quot;, dcContributor);</span>
<span class="nc" id="L746">      addDcData(dc, &quot;coverage&quot;, dcCoverage);</span>
<span class="nc" id="L747">      addDcData(dc, &quot;created&quot;, dcCreated);</span>
<span class="nc" id="L748">      addDcData(dc, &quot;creator&quot;, dcCreator);</span>
<span class="nc" id="L749">      addDcData(dc, &quot;date&quot;, dcDate);</span>
<span class="nc" id="L750">      addDcData(dc, &quot;description&quot;, dcDescription);</span>
<span class="nc" id="L751">      addDcData(dc, &quot;extent&quot;, dcExtent);</span>
<span class="nc" id="L752">      addDcData(dc, &quot;format&quot;, dcFormat);</span>
<span class="nc" id="L753">      addDcData(dc, &quot;identifier&quot;, dcIdentifier);</span>
<span class="nc" id="L754">      addDcData(dc, &quot;isPartOf&quot;, dcIsPartOf);</span>
<span class="nc" id="L755">      addDcData(dc, &quot;isReferencedBy&quot;, dcIsReferencedBy);</span>
<span class="nc" id="L756">      addDcData(dc, &quot;isReplacedBy&quot;, dcIsReplacedBy);</span>
<span class="nc" id="L757">      addDcData(dc, &quot;language&quot;, dcLanguage);</span>
<span class="nc" id="L758">      addDcData(dc, &quot;license&quot;, dcLicense);</span>
<span class="nc" id="L759">      addDcData(dc, &quot;publisher&quot;, dcPublisher);</span>
<span class="nc" id="L760">      addDcData(dc, &quot;relation&quot;, dcRelation);</span>
<span class="nc" id="L761">      addDcData(dc, &quot;replaces&quot;, dcReplaces);</span>
<span class="nc" id="L762">      addDcData(dc, &quot;rights&quot;, dcRights);</span>
<span class="nc" id="L763">      addDcData(dc, &quot;rightsHolder&quot;, dcRightsHolder);</span>
<span class="nc" id="L764">      addDcData(dc, &quot;source&quot;, dcSource);</span>
<span class="nc" id="L765">      addDcData(dc, &quot;spatial&quot;, dcSpatial);</span>
<span class="nc" id="L766">      addDcData(dc, &quot;subject&quot;, dcSubject);</span>
<span class="nc" id="L767">      addDcData(dc, &quot;temporal&quot;, dcTemporal);</span>
<span class="nc" id="L768">      addDcData(dc, &quot;title&quot;, dcTitle);</span>
<span class="nc" id="L769">      addDcData(dc, &quot;type&quot;, dcType);</span>
    } else {
<span class="nc" id="L771">      return Response.status(BAD_REQUEST).entity(&quot;Required series metadata not provided&quot;).build();</span>
    }
<span class="nc" id="L773">    AccessControlList acl = null;</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">    if (StringUtils.isNotBlank(accessControl)) {</span>
      try {
<span class="nc" id="L776">        acl = AccessControlParser.parseAcl(accessControl);</span>
<span class="nc" id="L777">      } catch (Exception e) {</span>
<span class="nc" id="L778">        logger.debug(&quot;Could not parse ACL&quot;, e);</span>
<span class="nc" id="L779">        return Response.status(BAD_REQUEST).entity(&quot;Could not parse ACL&quot;).build();</span>
<span class="nc" id="L780">      }</span>
    }

    try {
<span class="nc" id="L784">      DublinCoreCatalog newSeries = seriesService.updateSeries(dc);</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">      if (acl != null) {</span>
<span class="nc" id="L786">        seriesService.updateAccessControl(dc.getFirst(PROPERTY_IDENTIFIER), acl, override);</span>
      }
<span class="nc bnc" id="L788" title="All 2 branches missed.">      if (newSeries == null) {</span>
<span class="nc" id="L789">        logger.debug(&quot;Updated series {} &quot;, dc.getFirst(PROPERTY_IDENTIFIER));</span>
<span class="nc" id="L790">        return Response.status(NO_CONTENT).build();</span>
      }
<span class="nc" id="L792">      String id = newSeries.getFirst(PROPERTY_IDENTIFIER);</span>
<span class="nc" id="L793">      logger.debug(&quot;Created series {} &quot;, id);</span>
<span class="nc" id="L794">      return Response.status(CREATED)</span>
<span class="nc" id="L795">          .header(&quot;Location&quot;, getSeriesXmlUrl(id))</span>
<span class="nc" id="L796">          .header(&quot;Location&quot;, getSeriesJsonUrl(id))</span>
<span class="nc" id="L797">          .entity(newSeries.toXmlString())</span>
<span class="nc" id="L798">          .build();</span>
<span class="nc" id="L799">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L800">      throw e;</span>
<span class="nc" id="L801">    } catch (Exception e) {</span>
<span class="nc" id="L802">      logger.error(&quot;Could not add/update series&quot;, e);</span>
    }
<span class="nc" id="L804">    return Response.serverError().build();</span>
  }

  @POST
  @Path(&quot;/{seriesID:.+}/accesscontrol&quot;)
  @RestQuery(
      name = &quot;updateAcl&quot;,
      description = &quot;Updates the access control list for a series&quot;,
      returnDescription = &quot;No content.&quot;,
      restParameters = {
          @RestParameter(
              name = &quot;acl&quot;,
              isRequired = true,
              defaultValue = SAMPLE_ACCESS_CONTROL_LIST,
              description = &quot;The access control list for the series&quot;,
              type = TEXT
          ),
          @RestParameter(
              name = &quot;override&quot;,
              isRequired = false,
              defaultValue = &quot;false&quot;,
              description = &quot;If true the series ACL will take precedence over any existing episode ACL&quot;,
              type = STRING
          )
      },
      pathParameters = {
          @RestParameter(name = &quot;seriesID&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING)
      },
      responses = {
          @RestResponse(
              responseCode = SC_NOT_FOUND,
              description = &quot;No series with this identifier was found.&quot;
          ),
          @RestResponse(
              responseCode = SC_NO_CONTENT,
              description = &quot;The access control list has been updated.&quot;
          ),
          @RestResponse(
              responseCode = SC_CREATED,
              description = &quot;The access control list has been created.&quot;
          ),
          @RestResponse(
              responseCode = SC_UNAUTHORIZED,
              description = &quot;If the current user is not authorized to perform this action&quot;
          ),
          @RestResponse(
              responseCode = SC_BAD_REQUEST,
              description = &quot;The required path or form params were missing in the request.&quot;
          )
      }
  )
  public Response updateAccessControl(
      @PathParam(&quot;seriesID&quot;) String seriesID,
      @FormParam(&quot;acl&quot;) String accessControl,
      @DefaultValue(&quot;false&quot;) @FormParam(&quot;override&quot;) boolean override
  ) throws UnauthorizedException {
<span class="nc bnc" id="L860" title="All 2 branches missed.">    if (accessControl == null) {</span>
<span class="nc" id="L861">      logger.warn(&quot;Access control parameter is null.&quot;);</span>
<span class="nc" id="L862">      return Response.status(BAD_REQUEST).build();</span>
    }
    AccessControlList acl;
    try {
<span class="nc" id="L866">      acl = AccessControlParser.parseAcl(accessControl);</span>
<span class="nc" id="L867">    } catch (Exception e) {</span>
<span class="nc" id="L868">      logger.warn(&quot;Could not parse ACL: {}&quot;, e.getMessage());</span>
<span class="nc" id="L869">      return Response.status(BAD_REQUEST).build();</span>
<span class="nc" id="L870">    }</span>
    try {
<span class="nc" id="L872">      boolean updated = seriesService.updateAccessControl(seriesID, acl, override);</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">      if (updated) {</span>
<span class="nc" id="L874">        return Response.status(NO_CONTENT).build();</span>
      }
<span class="nc" id="L876">      return Response.status(CREATED).build();</span>
<span class="nc" id="L877">    } catch (NotFoundException e) {</span>
<span class="nc" id="L878">      return Response.status(NOT_FOUND).build();</span>
<span class="nc" id="L879">    } catch (SeriesException e) {</span>
<span class="nc" id="L880">      logger.warn(&quot;Could not update ACL for {}: {}&quot;, seriesID, e.getMessage());</span>
    }
<span class="nc" id="L882">    throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
  }

  @DELETE
  @Path(&quot;/{seriesID:.+}&quot;)
  @RestQuery(
      name = &quot;delete&quot;,
      description = &quot;Delete a series&quot;,
      returnDescription = &quot;No content.&quot;,
      pathParameters = {
          @RestParameter(name = &quot;seriesID&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING)
      },
      responses = {
          @RestResponse(
              responseCode = SC_NOT_FOUND,
              description = &quot;No series with this identifier was found.&quot;
          ),
          @RestResponse(
              responseCode = SC_UNAUTHORIZED,
              description = &quot;If the current user is not authorized to perform this action&quot;
          ),
          @RestResponse(
              responseCode = SC_NO_CONTENT,
              description = &quot;The series was deleted.&quot;
          )
      }
  )
  public Response deleteSeries(@PathParam(&quot;seriesID&quot;) String seriesID) throws UnauthorizedException {
    try {
<span class="nc" id="L911">      this.seriesService.deleteSeries(seriesID);</span>
<span class="nc" id="L912">      return Response.ok().build();</span>
<span class="nc" id="L913">    } catch (NotFoundException e) {</span>
<span class="nc" id="L914">      return Response.status(Response.Status.NOT_FOUND).build();</span>
<span class="nc" id="L915">    } catch (SeriesException se) {</span>
<span class="nc" id="L916">      logger.warn(&quot;Could not delete series {}: {}&quot;, seriesID, se.getMessage());</span>
    }
<span class="nc" id="L918">    throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
  }

  @GET
  @Produces(MediaType.TEXT_PLAIN)
  @Path(&quot;/count&quot;)
  @RestQuery(
      name = &quot;count&quot;,
      description = &quot;Returns the number of series&quot;,
      returnDescription = &quot;Returns the number of series&quot;,
      responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;The number of series&quot;)
      }
  )
  public Response getCount() throws UnauthorizedException {
    try {
<span class="nc" id="L934">      int count = seriesService.getSeriesCount();</span>
<span class="nc" id="L935">      return Response.ok(count).build();</span>
<span class="nc" id="L936">    } catch (SeriesException se) {</span>
<span class="nc" id="L937">      logger.warn(&quot;Could not count series: {}&quot;, se.getMessage());</span>
<span class="nc" id="L938">      throw new WebApplicationException(se);</span>
    }
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;{id}/properties.json&quot;)
  @RestQuery(
      name = &quot;getSeriesProperties&quot;,
      description = &quot;Returns the series properties&quot;,
      returnDescription = &quot;Returns the series properties as JSON&quot;,
      pathParameters = {
          @RestParameter(name = &quot;id&quot;, description = &quot;ID of series&quot;, isRequired = true, type = Type.STRING)
      },
      responses = {
          @RestResponse(
              responseCode = SC_OK,
              description = &quot;The access control list.&quot;
          ),
          @RestResponse(
              responseCode = SC_UNAUTHORIZED,
              description = &quot;If the current user is not authorized to perform this action&quot;
          )
      }
  )
  public Response getSeriesPropertiesAsJson(@PathParam(&quot;id&quot;) String seriesId)
          throws UnauthorizedException, NotFoundException {
<span class="nc bnc" id="L966" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesId)) {</span>
<span class="nc" id="L967">      logger.warn(&quot;Series id parameter is blank '{}'.&quot;, seriesId);</span>
<span class="nc" id="L968">      return Response.status(BAD_REQUEST).build();</span>
    }
    try {
<span class="nc" id="L971">      Map&lt;String, String&gt; properties = seriesService.getSeriesProperties(seriesId);</span>
<span class="nc" id="L972">      JSONArray jsonProperties = new JSONArray();</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">      for (String name : properties.keySet()) {</span>
<span class="nc" id="L974">        JSONObject property = new JSONObject();</span>
<span class="nc" id="L975">        property.put(name, properties.get(name));</span>
<span class="nc" id="L976">        jsonProperties.add(property);</span>
<span class="nc" id="L977">      }</span>
<span class="nc" id="L978">      return Response.ok(jsonProperties.toString()).build();</span>
<span class="nc" id="L979">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L980">      throw e;</span>
<span class="nc" id="L981">    } catch (NotFoundException e) {</span>
<span class="nc" id="L982">      throw e;</span>
<span class="nc" id="L983">    } catch (Exception e) {</span>
<span class="nc" id="L984">      logger.warn(&quot;Could not perform search query: {}&quot;, e.getMessage());</span>
    }
<span class="nc" id="L986">    throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;{seriesId}/property/{propertyName}.json&quot;)
  @RestQuery(
      name = &quot;getSeriesProperty&quot;,
      description = &quot;Returns a series property value&quot;,
      returnDescription = &quot;Returns the series property value&quot;,
      pathParameters = {
          @RestParameter(
              name = &quot;seriesId&quot;,
              description = &quot;ID of series&quot;,
              isRequired = true,
              type = Type.STRING
          ),
          @RestParameter(
              name = &quot;propertyName&quot;,
              description = &quot;Name of series property&quot;,
              isRequired = true,
              type = Type.STRING
          )
      },
      responses = {
          @RestResponse(
              responseCode = SC_OK,
              description = &quot;The access control list.&quot;
          ),
          @RestResponse(
              responseCode = SC_UNAUTHORIZED,
              description = &quot;If the current user is not authorized to perform this action&quot;
          )
      }
  )
  public Response getSeriesProperty(@PathParam(&quot;seriesId&quot;) String seriesId,
          @PathParam(&quot;propertyName&quot;) String propertyName) throws UnauthorizedException, NotFoundException {
<span class="nc bnc" id="L1023" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesId)) {</span>
<span class="nc" id="L1024">      logger.warn(&quot;Series id parameter is blank '{}'.&quot;, seriesId);</span>
<span class="nc" id="L1025">      return Response.status(BAD_REQUEST).build();</span>
    }
<span class="nc bnc" id="L1027" title="All 2 branches missed.">    if (StringUtils.isBlank(propertyName)) {</span>
<span class="nc" id="L1028">      logger.warn(&quot;Series property name parameter is blank '{}'.&quot;, propertyName);</span>
<span class="nc" id="L1029">      return Response.status(BAD_REQUEST).build();</span>
    }
    try {
<span class="nc" id="L1032">      String propertyValue = seriesService.getSeriesProperty(seriesId, propertyName);</span>
<span class="nc" id="L1033">      return Response.ok(propertyValue).build();</span>
<span class="nc" id="L1034">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1035">      throw e;</span>
<span class="nc" id="L1036">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1037">      throw e;</span>
<span class="nc" id="L1038">    } catch (Exception e) {</span>
<span class="nc" id="L1039">      logger.warn(&quot;Could not perform search query&quot;, e);</span>
    }
<span class="nc" id="L1041">    throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
  }

  @POST
  @Path(&quot;/{seriesId}/property&quot;)
  @RestQuery(
      name = &quot;updateSeriesProperty&quot;,
      description = &quot;Updates a series property&quot;,
      returnDescription = &quot;No content.&quot;,
      restParameters = {
          @RestParameter(name = &quot;name&quot;, isRequired = true, description = &quot;The property's name&quot;, type = TEXT),
          @RestParameter(name = &quot;value&quot;, isRequired = true, description = &quot;The property's value&quot;, type = TEXT)
      },
      pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, isRequired = true, description = &quot;The series identifier&quot;, type = STRING)
      },
      responses = {
          @RestResponse(
              responseCode = SC_NOT_FOUND,
              description = &quot;No series with this identifier was found.&quot;
          ),
          @RestResponse(
              responseCode = SC_NO_CONTENT,
              description = &quot;The access control list has been updated.&quot;
          ),
          @RestResponse(
              responseCode = SC_UNAUTHORIZED,
              description = &quot;If the current user is not authorized to perform this action&quot;
          ),
          @RestResponse(
              responseCode = SC_BAD_REQUEST,
              description = &quot;The required path or form params were missing in the request.&quot;
          )
      }
  )
  public Response updateSeriesProperty(
      @PathParam(&quot;seriesId&quot;) String seriesId,
      @FormParam(&quot;name&quot;) String name,
      @FormParam(&quot;value&quot;) String value
  ) throws UnauthorizedException {
<span class="nc bnc" id="L1081" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesId)) {</span>
<span class="nc" id="L1082">      logger.warn(&quot;Series id parameter is blank '{}'.&quot;, seriesId);</span>
<span class="nc" id="L1083">      return Response.status(BAD_REQUEST).build();</span>
    }
<span class="nc bnc" id="L1085" title="All 2 branches missed.">    if (StringUtils.isBlank(name)) {</span>
<span class="nc" id="L1086">      logger.warn(&quot;Name parameter is blank '{}'.&quot;, name);</span>
<span class="nc" id="L1087">      return Response.status(BAD_REQUEST).build();</span>
    }
<span class="nc bnc" id="L1089" title="All 2 branches missed.">    if (StringUtils.isBlank(value)) {</span>
<span class="nc" id="L1090">      logger.warn(&quot;Series id parameter is blank '{}'.&quot;, value);</span>
<span class="nc" id="L1091">      return Response.status(BAD_REQUEST).build();</span>
    }
    try {
<span class="nc" id="L1094">      seriesService.updateSeriesProperty(seriesId, name, value);</span>
<span class="nc" id="L1095">      return Response.status(NO_CONTENT).build();</span>
<span class="nc" id="L1096">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1097">      return Response.status(NOT_FOUND).build();</span>
<span class="nc" id="L1098">    } catch (SeriesException e) {</span>
<span class="nc" id="L1099">      logger.warn(&quot;Could not update series property for series {} property {}:{} :&quot;, seriesId, name, value, e);</span>
    }
<span class="nc" id="L1101">    throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
  }

  @DELETE
  @Path(&quot;{seriesId}/property/{propertyName}&quot;)
  @RestQuery(
      name = &quot;deleteSeriesProperty&quot;,
      description = &quot;Deletes a series property&quot;,
      returnDescription = &quot;No Content&quot;,
      pathParameters = {
          @RestParameter(
              name = &quot;seriesId&quot;,
              description = &quot;ID of series&quot;,
              isRequired = true,
              type = Type.STRING
          ),
          @RestParameter(
              name = &quot;propertyName&quot;,
              description = &quot;Name of series property&quot;,
              isRequired = true,
              type = Type.STRING
          )
      },
      responses = {
          @RestResponse(
              responseCode = SC_NO_CONTENT,
              description = &quot;The series property has been deleted.&quot;
          ),
          @RestResponse(
              responseCode = SC_NOT_FOUND,
              description = &quot;The series or property has not been found.&quot;
          ),
          @RestResponse(
              responseCode = SC_UNAUTHORIZED,
              description = &quot;If the current user is not authorized to perform this action&quot;
          )
      }
  )
  public Response deleteSeriesProperty(
      @PathParam(&quot;seriesId&quot;) String seriesId,
      @PathParam(&quot;propertyName&quot;) String propertyName
  ) throws UnauthorizedException, NotFoundException {
<span class="nc bnc" id="L1143" title="All 2 branches missed.">    if (StringUtils.isBlank(seriesId)) {</span>
<span class="nc" id="L1144">      logger.warn(&quot;Series id parameter is blank '{}'.&quot;, seriesId);</span>
<span class="nc" id="L1145">      return Response.status(BAD_REQUEST).build();</span>
    }
<span class="nc bnc" id="L1147" title="All 2 branches missed.">    if (StringUtils.isBlank(propertyName)) {</span>
<span class="nc" id="L1148">      logger.warn(&quot;Series property name parameter is blank '{}'.&quot;, propertyName);</span>
<span class="nc" id="L1149">      return Response.status(BAD_REQUEST).build();</span>
    }
    try {
<span class="nc" id="L1152">      seriesService.deleteSeriesProperty(seriesId, propertyName);</span>
<span class="nc" id="L1153">      return Response.status(NO_CONTENT).build();</span>
<span class="nc" id="L1154">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1155">      throw e;</span>
<span class="nc" id="L1156">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1157">      throw e;</span>
<span class="nc" id="L1158">    } catch (Exception e) {</span>
<span class="nc" id="L1159">      logger.warn(&quot;Could not delete series '{}' property '{}' query:&quot;, seriesId, propertyName, e);</span>
    }
<span class="nc" id="L1161">    throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
  }

  @GET
  @Path(&quot;{seriesId}/elements.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(
      name = &quot;getSeriesElements&quot;,
      description = &quot;Returns all the element types of a series&quot;,
      returnDescription = &quot;Returns a JSON array with all the types of elements of the given series.&quot;,
      pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series identifier&quot;, type = STRING, isRequired = true)
      },
      responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;Series found&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;Series not found&quot;),
          @RestResponse(responseCode = SC_INTERNAL_SERVER_ERROR, description = &quot;Error while processing the request&quot;)
      }
  )
  public Response getSeriesElements(@PathParam(&quot;seriesId&quot;) String seriesId) {
    try {
<span class="nc" id="L1182">      Opt&lt;Map&lt;String, byte[]&gt;&gt; optSeriesElements = seriesService.getSeriesElements(seriesId);</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">      if (optSeriesElements.isSome()) {</span>
<span class="nc" id="L1184">        Map&lt;String, byte[]&gt; seriesElements = optSeriesElements.get();</span>
<span class="nc" id="L1185">        JValue jsonArray = Jsons.arr(Stream.$(seriesElements.keySet()).map(Jsons.Functions.stringToJValue));</span>
<span class="nc" id="L1186">        return Response.ok(new SimpleSerializer().toJson(jsonArray)).build();</span>
      } else {
<span class="nc" id="L1188">        return R.notFound();</span>
      }
<span class="nc" id="L1190">    } catch (SeriesException e) {</span>
<span class="nc" id="L1191">      logger.warn(&quot;Error while retrieving elements for sieres '{}'&quot;, seriesId, e);</span>
<span class="nc" id="L1192">      return R.serverError();</span>
    }
  }

  @GET
  @Path(&quot;{seriesId}/elements/{elementType}&quot;)
  @RestQuery(
      name = &quot;getSeriesElement&quot;,
      description = &quot;Returns the series element&quot;,
      returnDescription = &quot;The data of the series element&quot;,
      pathParameters = {
          @RestParameter(
              name = &quot;seriesId&quot;,
              description = &quot;The series identifier&quot;,
              type = STRING,
              isRequired = true
          ),
          @RestParameter(
              name = &quot;elementType&quot;,
              description = &quot;The element type. This is equal to the subtype of the media type of &quot;
                  + &quot;this element: series/&lt;elementtype&gt;&quot;,
              type = STRING,
              isRequired = true
          )
      },
      responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;Series element found&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;Series element not found&quot;),
          @RestResponse(responseCode = SC_INTERNAL_SERVER_ERROR, description = &quot;Error while processing the request&quot;)
      }
  )
  public Response getSeriesElement(
      @PathParam(&quot;seriesId&quot;) String seriesId,
      @PathParam(&quot;elementType&quot;) String elementType
  ) {
    try {
<span class="nc" id="L1228">      Opt&lt;byte[]&gt; data = seriesService.getSeriesElementData(seriesId, elementType);</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">      if (data.isSome()) {</span>
<span class="nc" id="L1230">        return Response.ok().entity(new ByteArrayInputStream(data.get()))</span>
<span class="nc" id="L1231">                .type(SERIES_ELEMENT_CONTENT_TYPE_PREFIX + elementType).build();</span>
      } else {
<span class="nc" id="L1233">        return R.notFound();</span>
      }
<span class="nc" id="L1235">    } catch (SeriesException e) {</span>
<span class="nc" id="L1236">      logger.warn(&quot;Error while returning element '{}' of series '{}':&quot;, elementType, seriesId, e);</span>
<span class="nc" id="L1237">      return R.serverError();</span>
    }
  }

  @PUT
  @Path(&quot;{seriesId}/extendedMetadata/{type}&quot;)
  @RestQuery(
          name = &quot;updateExtendedMetadata&quot;,
          description = &quot;Updates extended metadata of a series&quot;,
          returnDescription = &quot;An empty response&quot;,
          pathParameters = {
                  @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series identifier&quot;, type = STRING,
                          isRequired = true),
                  @RestParameter(name = &quot;type&quot;, description = &quot;The type of the catalog flavor&quot;, type = STRING,
                          isRequired = true)
          },
          restParameters = {
                  @RestParameter(name = &quot;dc&quot;, description = &quot;The catalog with extended metadata.&quot;, type = TEXT,
                          isRequired = true, defaultValue = SAMPLE_DUBLIN_CORE
                  )
          },
          responses = {
                  @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;Extended metadata updated&quot;),
                  @RestResponse(responseCode = SC_CREATED, description = &quot;Extended metadata created&quot;),
                  @RestResponse(responseCode = SC_INTERNAL_SERVER_ERROR,
                          description = &quot;Error while processing the request&quot;)
          }
  )
  public Response putSeriesExtendedMetadata(
          @PathParam(&quot;seriesId&quot;) String seriesId,
          @PathParam(&quot;type&quot;) String type,
          @FormParam(&quot;dc&quot;) String dcString
  ) {
    try {
<span class="nc" id="L1271">      DublinCoreCatalog dc = dcService.load(new ByteArrayInputStream(dcString.getBytes(StandardCharsets.UTF_8)));</span>
<span class="nc" id="L1272">      boolean elementExists = seriesService.getSeriesElementData(seriesId, type).isSome();</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">      if (seriesService.updateExtendedMetadata(seriesId, type, dc)) {</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">        if (elementExists) {</span>
<span class="nc" id="L1275">          return R.noContent();</span>
        } else {
<span class="nc" id="L1277">          return R.created(URI.create(UrlSupport.concat(serverUrl, serviceUrl, seriesId, &quot;elements&quot;, type)));</span>
        }
      } else {
<span class="nc" id="L1280">        return R.serverError();</span>
      }
<span class="nc" id="L1282">    } catch (IOException e) {</span>
<span class="nc" id="L1283">      logger.warn(&quot;Could not deserialize dublin core catalog&quot;, e);</span>
<span class="nc" id="L1284">      return Response.status(BAD_REQUEST).build();</span>
<span class="nc" id="L1285">    } catch (SeriesException e) {</span>
<span class="nc" id="L1286">      logger.warn(&quot;Error while updating extended metadata of series '{}'&quot;, seriesId, e);</span>
<span class="nc" id="L1287">      return R.serverError();</span>
    }
  }


  @PUT
  @Path(&quot;{seriesId}/elements/{elementType}&quot;)
  @RestQuery(
      name = &quot;updateSeriesElement&quot;,
      description = &quot;Updates an existing series element&quot;,
      returnDescription = &quot;An empty response&quot;,
      pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series identifier&quot;, type = STRING, isRequired = true),
          @RestParameter(name = &quot;elementType&quot;, description = &quot;The element type&quot;, type = STRING, isRequired = true)
      },
      responses = {
          @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;Series element updated&quot;),
          @RestResponse(responseCode = SC_CREATED, description = &quot;Series element created&quot;),
          @RestResponse(responseCode = SC_INTERNAL_SERVER_ERROR, description = &quot;Error while processing the request&quot;)
      }
  )
  public Response putSeriesElement(
      @Context HttpServletRequest request,
      @PathParam(&quot;seriesId&quot;) String seriesId,
      @PathParam(&quot;elementType&quot;) String elementType
  ) {
<span class="nc" id="L1313">    InputStream is = null;</span>
    try {
<span class="nc" id="L1315">      is = request.getInputStream();</span>
<span class="nc" id="L1316">      final byte[] data = IOUtils.toByteArray(is);</span>
<span class="nc" id="L1317">      boolean elementExists = seriesService.getSeriesElementData(seriesId, elementType).isSome();</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">      if (seriesService.updateSeriesElement(seriesId, elementType, data)) {</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">        if (elementExists) {</span>
<span class="nc" id="L1320">          return R.noContent();</span>
        } else {
<span class="nc" id="L1322">          return R.created(URI.create(UrlSupport.concat(serverUrl, serviceUrl, seriesId, &quot;elements&quot;, elementType)));</span>
        }
      } else {
<span class="nc" id="L1325">        return R.serverError();</span>
      }
<span class="nc" id="L1327">    } catch (IOException e) {</span>
<span class="nc" id="L1328">      logger.error(&quot;Error while trying to read from request&quot;, e);</span>
<span class="nc" id="L1329">      return R.serverError();</span>
<span class="nc" id="L1330">    } catch (SeriesException e) {</span>
<span class="nc" id="L1331">      logger.warn(&quot;Error while adding element to series '{}'&quot;, seriesId, e);</span>
<span class="nc" id="L1332">      return R.serverError();</span>
    } finally {
<span class="nc" id="L1334">      IOUtils.closeQuietly(is);</span>
    }
  }

  @DELETE
  @Path(&quot;{seriesId}/elements/{elementType}&quot;)
  @RestQuery(
      name = &quot;deleteSeriesElement&quot;,
      description = &quot;Deletes a series element&quot;,
      returnDescription = &quot;An empty response&quot;,
      pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series identifier&quot;, type = STRING, isRequired = true),
          @RestParameter(name = &quot;elementType&quot;, description = &quot;The element type&quot;, type = STRING, isRequired = true)
      },
      responses = {
          @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;Series element deleted&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;Series element not found&quot;),
          @RestResponse(responseCode = SC_INTERNAL_SERVER_ERROR, description = &quot;Error while processing the request&quot;)
      }
  )
  public Response deleteSeriesElement(
      @PathParam(&quot;seriesId&quot;) String seriesId,
      @PathParam(&quot;elementType&quot;) String elementType
  ) {
    try {
<span class="nc bnc" id="L1359" title="All 2 branches missed.">      if (seriesService.deleteSeriesElement(seriesId, elementType)) {</span>
<span class="nc" id="L1360">        return R.noContent();</span>
      } else {
<span class="nc" id="L1362">        return R.notFound();</span>
      }
<span class="nc" id="L1364">    } catch (SeriesException e) {</span>
<span class="nc" id="L1365">      return R.serverError();</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>