<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SeriesWorkflowOperationHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-workflow-workflowoperation</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.workflow.handler.workflow</a> &gt; <span class="el_source">SeriesWorkflowOperationHandler.java</span></div><h1>SeriesWorkflowOperationHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.workflow.handler.workflow;

import org.opencastproject.job.api.JobContext;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.EName;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.selector.AbstractMediaPackageElementSelector;
import org.opencastproject.mediapackage.selector.CatalogSelector;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreUtil;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.metadata.dublincore.SeriesCatalogUIAdapter;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AclScope;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.series.api.SeriesException;
import org.opencastproject.series.api.SeriesService;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.util.Checksum;
import org.opencastproject.util.ChecksumType;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.XmlNamespaceBinding;
import org.opencastproject.util.XmlNamespaceContext;
import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowOperationException;
import org.opencastproject.workflow.api.WorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowOperationResult;
import org.opencastproject.workflow.api.WorkflowOperationResult.Action;
import org.opencastproject.workspace.api.Workspace;

import com.entwinemedia.fn.Fn;
import com.entwinemedia.fn.Fn2;
import com.entwinemedia.fn.Stream;
import com.entwinemedia.fn.data.Opt;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.UUID;

/**
 * The workflow definition for handling &quot;series&quot; operations
 */
@Component(
    immediate = true,
    service = WorkflowOperationHandler.class,
    property = {
        &quot;service.description=Apply Series to Recording Workflow Operation Handler&quot;,
        &quot;workflow.operation=series&quot;
    }
)
<span class="fc" id="L94">public class SeriesWorkflowOperationHandler extends AbstractWorkflowOperationHandler {</span>

  /** The logging facility */
<span class="fc" id="L97">  private static final Logger logger = LoggerFactory.getLogger(SeriesWorkflowOperationHandler.class);</span>

  /** Name of the configuration option that provides the optional series identifier */
  public static final String SERIES_PROPERTY = &quot;series&quot;;

  /** Name of the configuration option that provides the flavors of the series catalogs to attach */
  public static final String ATTACH_PROPERTY = &quot;attach&quot;;

  /** Name of the configuration option that provides whether the ACL should be applied or not */
  public static final String APPLY_ACL_PROPERTY = &quot;apply-acl&quot;;

  /** Name of the configuration key that specifies the list of series metadata to be copied to the episode */
  public static final String COPY_METADATA_PROPERTY = &quot;copy-metadata&quot;;

  /** Name of the configuration key that specifies the default namespace for the metadata to be copied to the episode */
  public static final String DEFAULT_NS_PROPERTY = &quot;default-namespace&quot;;

  /** The authorization service */
  private AuthorizationService authorizationService;

  /** The series service */
  private SeriesService seriesService;

  /** The workspace */
  private Workspace workspace;

  /** The security service */
  private SecurityService securityService;

  /** The list series catalog UI adapters */
<span class="fc" id="L127">  private final List&lt;SeriesCatalogUIAdapter&gt; seriesCatalogUIAdapters = new ArrayList&lt;&gt;();</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param authorizationService
   *          the authorization service
   */
  @Reference
  protected void setAuthorizationService(AuthorizationService authorizationService) {
<span class="fc" id="L137">    this.authorizationService = authorizationService;</span>
<span class="fc" id="L138">  }</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param seriesService
   *          the series service
   */
  @Reference
  public void setSeriesService(SeriesService seriesService) {
<span class="fc" id="L148">    this.seriesService = seriesService;</span>
<span class="fc" id="L149">  }</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param workspace
   *          the workspace
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="fc" id="L159">    this.workspace = workspace;</span>
<span class="fc" id="L160">  }</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param securityService
   *          the securityService
   */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L170">    this.securityService = securityService;</span>
<span class="fc" id="L171">  }</span>

  /** OSGi callback to add {@link SeriesCatalogUIAdapter} instance. */
  @Reference(
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeCatalogUIAdapter&quot;
  )
  public void addCatalogUIAdapter(SeriesCatalogUIAdapter catalogUIAdapter) {
<span class="fc" id="L180">    seriesCatalogUIAdapters.add(catalogUIAdapter);</span>
<span class="fc" id="L181">  }</span>

  /** OSGi callback to remove {@link SeriesCatalogUIAdapter} instance. */
  public void removeCatalogUIAdapter(SeriesCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L185">    seriesCatalogUIAdapters.remove(catalogUIAdapter);</span>
<span class="nc" id="L186">  }</span>

  @Reference
  @Override
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="nc" id="L191">    super.setServiceRegistry(serviceRegistry);</span>
<span class="nc" id="L192">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,
   *      JobContext)
   */
  @Override
  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)
          throws WorkflowOperationException {
<span class="fc" id="L203">    logger.debug(&quot;Running series workflow operation&quot;);</span>

<span class="fc" id="L205">    MediaPackage mediaPackage = workflowInstance.getMediaPackage();</span>

<span class="fc" id="L207">    Opt&lt;String&gt; optSeries = getOptConfig(workflowInstance.getCurrentOperation(), SERIES_PROPERTY);</span>
<span class="fc" id="L208">    Opt&lt;String&gt; optAttachFlavors = getOptConfig(workflowInstance.getCurrentOperation(), ATTACH_PROPERTY);</span>
<span class="fc" id="L209">    Boolean applyAcl = getOptConfig(workflowInstance.getCurrentOperation(), APPLY_ACL_PROPERTY).map(toBoolean)</span>
<span class="fc" id="L210">            .getOr(false);</span>
<span class="fc" id="L211">    Opt&lt;String&gt; optCopyMetadata = getOptConfig(workflowInstance.getCurrentOperation(), COPY_METADATA_PROPERTY);</span>
<span class="fc" id="L212">    String defaultNamespace = getOptConfig(workflowInstance.getCurrentOperation(), DEFAULT_NS_PROPERTY)</span>
<span class="fc" id="L213">            .getOr(DublinCore.TERMS_NS_URI);</span>
<span class="fc" id="L214">    logger.debug(&quot;Using default namespace: '{}'&quot;, defaultNamespace);</span>

<span class="pc bpc" id="L216" title="1 of 4 branches missed.">    if (optSeries.isSome() &amp;&amp; !optSeries.get().equals(mediaPackage.getSeries())) {</span>
<span class="fc" id="L217">      logger.info(&quot;Changing series id from '{}' to '{}'&quot;, StringUtils.trimToEmpty(mediaPackage.getSeries()),</span>
<span class="fc" id="L218">              optSeries.get());</span>
<span class="fc" id="L219">      mediaPackage.setSeries(optSeries.get());</span>
    }

<span class="fc" id="L222">    String seriesId = mediaPackage.getSeries();</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">    if (seriesId == null) {</span>
<span class="fc" id="L224">      logger.info(&quot;No series set, skip operation&quot;);</span>
<span class="fc" id="L225">      return createResult(mediaPackage, Action.SKIP);</span>
    }

    DublinCoreCatalog series;
    try {
<span class="fc" id="L230">      series = seriesService.getSeries(seriesId);</span>
<span class="nc" id="L231">    } catch (NotFoundException e) {</span>
<span class="nc" id="L232">      logger.info(&quot;No series with the identifier '{}' found, skip operation&quot;, seriesId);</span>
<span class="nc" id="L233">      return createResult(mediaPackage, Action.SKIP);</span>
<span class="nc" id="L234">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L235">      logger.warn(&quot;Not authorized to get series with identifier '{}' found, skip operation&quot;, seriesId);</span>
<span class="nc" id="L236">      return createResult(mediaPackage, Action.SKIP);</span>
<span class="nc" id="L237">    } catch (SeriesException e) {</span>
<span class="nc" id="L238">      logger.error(&quot;Unable to get series with identifier '{}', skip operation:&quot;, seriesId, e);</span>
<span class="nc" id="L239">      throw new WorkflowOperationException(e);</span>
<span class="fc" id="L240">    }</span>

<span class="fc" id="L242">    mediaPackage.setSeriesTitle(series.getFirst(DublinCore.PROPERTY_TITLE));</span>

    // Process extra metadata
<span class="fc" id="L245">    HashSet&lt;EName&gt; extraMetadata = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">    if (optCopyMetadata.isSome()) {</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">      for (String strEName : optCopyMetadata.get().split(&quot;,+\\s*&quot;))</span>
        try {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">          if (!strEName.isEmpty()) {</span>
<span class="fc" id="L250">            extraMetadata.add(EName.fromString(strEName, defaultNamespace));</span>
          }
<span class="nc" id="L252">        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L253">          logger.warn(&quot;Ignoring incorrect dublincore metadata property: '{}'&quot;, strEName);</span>
<span class="fc" id="L254">        }</span>
    }

    // Update the episode catalog
<span class="fc bfc" id="L258" title="All 2 branches covered.">    for (Catalog episodeCatalog : mediaPackage.getCatalogs(MediaPackageElements.EPISODE)) {</span>
<span class="fc" id="L259">      DublinCoreCatalog episodeDublinCore = DublinCoreUtil.loadDublinCore(workspace, episodeCatalog);</span>
      // Make sure the MP catalog has bindings defined
<span class="fc" id="L261">      episodeDublinCore.addBindings(</span>
<span class="fc" id="L262">              XmlNamespaceContext.mk(XmlNamespaceBinding.mk(DublinCore.TERMS_NS_PREFIX, DublinCore.TERMS_NS_URI)));</span>
<span class="fc" id="L263">      episodeDublinCore.addBindings(XmlNamespaceContext</span>
<span class="fc" id="L264">              .mk(XmlNamespaceBinding.mk(DublinCore.ELEMENTS_1_1_NS_PREFIX, DublinCore.ELEMENTS_1_1_NS_URI)));</span>
<span class="fc" id="L265">      episodeDublinCore.addBindings(XmlNamespaceContext</span>
<span class="fc" id="L266">              .mk(XmlNamespaceBinding.mk(DublinCores.OC_PROPERTY_NS_PREFIX, DublinCores.OC_PROPERTY_NS_URI)));</span>
<span class="fc" id="L267">      episodeDublinCore.set(DublinCore.PROPERTY_IS_PART_OF, seriesId);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">      for (EName property : extraMetadata) {</span>
<span class="pc bpc" id="L269" title="1 of 4 branches missed.">        if (!episodeDublinCore.hasValue(property) &amp;&amp; series.hasValue(property)) {</span>
<span class="fc" id="L270">          episodeDublinCore.set(property, series.get(property));</span>
        }
<span class="fc" id="L272">      }</span>
<span class="fc" id="L273">      try (InputStream in = IOUtils.toInputStream(episodeDublinCore.toXmlString(), &quot;UTF-8&quot;)) {</span>
<span class="fc" id="L274">        String filename = FilenameUtils.getName(episodeCatalog.getURI().toString());</span>
<span class="fc" id="L275">        URI uri = workspace.put(mediaPackage.getIdentifier().toString(), episodeCatalog.getIdentifier(), filename, in);</span>
<span class="fc" id="L276">        episodeCatalog.setURI(uri);</span>
        // setting the URI to a new source so the checksum will most like be invalid
<span class="fc" id="L278">        episodeCatalog.setChecksum(null);</span>
<span class="nc" id="L279">      } catch (Exception e) {</span>
<span class="nc" id="L280">        logger.error(&quot;Unable to update episode catalog isPartOf field&quot;, e);</span>
<span class="nc" id="L281">        throw new WorkflowOperationException(e);</span>
<span class="fc" id="L282">      }</span>
    }

    // Attach series catalogs
<span class="fc bfc" id="L286" title="All 2 branches covered.">    if (optAttachFlavors.isSome()) {</span>
      // Remove existing series catalogs
<span class="fc" id="L288">      AbstractMediaPackageElementSelector&lt;Catalog&gt; catalogSelector = new CatalogSelector();</span>
<span class="fc" id="L289">      String[] seriesFlavors = StringUtils.split(optAttachFlavors.get(), &quot;,&quot;);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">      for (String flavor : seriesFlavors) {</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (&quot;*&quot;.equals(flavor)) {</span>
<span class="fc" id="L292">          catalogSelector.addFlavor(&quot;*/*&quot;);</span>
        } else {
<span class="fc" id="L294">          catalogSelector.addFlavor(flavor);</span>
        }
      }
<span class="fc bfc" id="L297" title="All 2 branches covered.">      for (Catalog c : catalogSelector.select(mediaPackage, false)) {</span>
<span class="pc bpc" id="L298" title="1 of 4 branches missed.">        if (MediaPackageElements.SERIES.equals(c.getFlavor()) || &quot;series&quot;.equals(c.getFlavor().getSubtype())) {</span>
<span class="fc" id="L299">          mediaPackage.remove(c);</span>
        }
<span class="fc" id="L301">      }</span>

<span class="fc" id="L303">      List&lt;SeriesCatalogUIAdapter&gt; adapters = getSeriesCatalogUIAdapters();</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">      for (String flavorString : seriesFlavors) {</span>
        MediaPackageElementFlavor flavor;
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (&quot;*&quot;.equals(flavorString)) {</span>
<span class="fc" id="L307">          flavor = MediaPackageElementFlavor.parseFlavor(&quot;*/*&quot;);</span>
        } else {
<span class="fc" id="L309">          flavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>
        }
<span class="fc bfc" id="L311" title="All 2 branches covered.">        for (SeriesCatalogUIAdapter a : adapters) {</span>
<span class="fc" id="L312">          MediaPackageElementFlavor adapterFlavor = MediaPackageElementFlavor.parseFlavor(a.getFlavor().toString());</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">          if (flavor.matches(adapterFlavor)) {</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">            if (MediaPackageElements.SERIES.eq(a.getFlavor().toString())) {</span>
<span class="fc" id="L315">              addDublinCoreCatalog(series, MediaPackageElements.SERIES, mediaPackage);</span>
            } else {
              try {
<span class="fc" id="L318">                Opt&lt;byte[]&gt; seriesElementData = seriesService.getSeriesElementData(seriesId, adapterFlavor.getType());</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">                if (seriesElementData.isSome()) {</span>
<span class="fc" id="L320">                  DublinCoreCatalog catalog = DublinCores.read(new ByteArrayInputStream(seriesElementData.get()));</span>
<span class="fc" id="L321">                  addDublinCoreCatalog(catalog, adapterFlavor, mediaPackage);</span>
<span class="fc" id="L322">                } else {</span>
<span class="nc" id="L323">                  logger.warn(&quot;No extended series catalog found for flavor '{}' and series '{}', skip adding catalog&quot;,</span>
<span class="nc" id="L324">                          adapterFlavor.getType(), seriesId);</span>
                }
<span class="nc" id="L326">              } catch (SeriesException e) {</span>
<span class="nc" id="L327">                logger.error(&quot;Unable to load extended series metadata for flavor {}&quot;, adapterFlavor.getType());</span>
<span class="nc" id="L328">                throw new WorkflowOperationException(e);</span>
<span class="fc" id="L329">              }</span>
            }
          }
<span class="fc" id="L332">        }</span>
      }
    }

<span class="fc bfc" id="L336" title="All 2 branches covered.">    if (applyAcl) {</span>
      try {
<span class="fc" id="L338">        AccessControlList acl = seriesService.getSeriesAccessControl(seriesId);</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        if (acl != null)</span>
<span class="fc" id="L340">          authorizationService.setAcl(mediaPackage, AclScope.Series, acl);</span>
<span class="nc" id="L341">      } catch (Exception e) {</span>
<span class="nc" id="L342">        logger.error(&quot;Unable to update series ACL&quot;, e);</span>
<span class="nc" id="L343">        throw new WorkflowOperationException(e);</span>
<span class="fc" id="L344">      }</span>
    }
<span class="fc" id="L346">    return createResult(mediaPackage, Action.CONTINUE);</span>
  }

  /**
   * @param organization
   *          The organization to filter the results with.
   * @return A {@link List} of {@link SeriesCatalogUIAdapter} that provide the metadata to the front end.
   */
  private List&lt;SeriesCatalogUIAdapter&gt; getSeriesCatalogUIAdapters() {
<span class="fc" id="L355">    String organization = securityService.getOrganization().getId();</span>
<span class="fc" id="L356">    return Stream.$(seriesCatalogUIAdapters).filter(seriesOrganizationFilter._2(organization)).toList();</span>
  }

  private MediaPackage addDublinCoreCatalog(DublinCoreCatalog catalog, MediaPackageElementFlavor flavor,
          MediaPackage mediaPackage) throws WorkflowOperationException {
<span class="fc" id="L361">    try (InputStream in = IOUtils.toInputStream(catalog.toXmlString(), &quot;UTF-8&quot;)) {</span>
<span class="fc" id="L362">      String elementId = UUID.randomUUID().toString();</span>
<span class="fc" id="L363">      URI catalogUrl = workspace.put(mediaPackage.getIdentifier().toString(), elementId, &quot;dublincore.xml&quot;, in);</span>
<span class="fc" id="L364">      logger.info(&quot;Adding catalog with flavor {} to mediapackage {}&quot;, flavor, mediaPackage);</span>
<span class="fc" id="L365">      MediaPackageElement mpe = mediaPackage.add(catalogUrl, MediaPackageElement.Type.Catalog, flavor);</span>
<span class="fc" id="L366">      mpe.setIdentifier(elementId);</span>
<span class="fc" id="L367">      mpe.setChecksum(Checksum.create(ChecksumType.DEFAULT_TYPE, workspace.get(catalogUrl)));</span>
<span class="fc" id="L368">      return mediaPackage;</span>
<span class="nc" id="L369">    } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L370">      throw new WorkflowOperationException(e);</span>
    }
  }

<span class="fc" id="L374">  private static final Fn2&lt;SeriesCatalogUIAdapter, String, Boolean&gt; seriesOrganizationFilter = new Fn2&lt;SeriesCatalogUIAdapter, String, Boolean&gt;() {</span>
    @Override
    public Boolean apply(SeriesCatalogUIAdapter catalogUIAdapter, String organization) {
<span class="fc" id="L377">      return catalogUIAdapter.handlesOrganization(organization);</span>
    }
  };

  /** Convert a string into a boolean. */
<span class="fc" id="L382">  private static final Fn&lt;String, Boolean&gt; toBoolean = new Fn&lt;String, Boolean&gt;() {</span>
    @Override
    public Boolean apply(String s) {
<span class="fc" id="L385">      return BooleanUtils.toBoolean(s);</span>
    }
  };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>