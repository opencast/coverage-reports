<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WhisperCppEngine.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-speech-to-text-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.speechtotext.impl.engine</a> &gt; <span class="el_source">WhisperCppEngine.java</span></div><h1>WhisperCppEngine.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.speechtotext.impl.engine;

import org.opencastproject.speechtotext.api.SpeechToTextEngine;
import org.opencastproject.speechtotext.api.SpeechToTextEngineException;
import org.opencastproject.speechtotext.util.LangCodeUtil;
import org.opencastproject.util.IoSupport;
import org.opencastproject.util.OsgiUtil;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.functions.Strings;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Modified;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.UUID;

/** WhisperC++ implementation of the Speech-to-text engine interface. */
@Component(
    property = {
        &quot;service.description=WhisperC++ implementation of the SpeechToTextEngine interface&quot;,
        &quot;enginetype=whispercpp&quot;
    }
)

<span class="nc" id="L67">public class WhisperCppEngine implements SpeechToTextEngine {</span>

<span class="nc" id="L69">  private static final Logger logger = LoggerFactory.getLogger(WhisperCppEngine.class);</span>

  /** Name of the engine. */
  private static final String engineName = &quot;WhisperC++&quot;;

  /** Config key for setting the path to WhisperC++. */
  private static final String WHISPERCPP_EXECUTABLE_PATH_CONFIG_KEY = &quot;whispercpp.root.path&quot;;

  /** Default path to WhisperC++. */
  public static final String WHISPERCPP_EXECUTABLE_DEFAULT_PATH = &quot;whisper.cpp&quot;;

  /** Currently used path of the WhisperC++ installation. */
<span class="nc" id="L81">  private String whispercppExecutable = WHISPERCPP_EXECUTABLE_DEFAULT_PATH;</span>

  /** Config key for setting whispercpp model */
  private static final String WHISPERCPP_MODEL_CONFIG_KEY = &quot;whispercpp.model&quot;;

  /** Default whispercpp model */
  public static final String WHISPERCPP_MODEL_DEFAULT = &quot;/usr/share/ggml/ggml-base.bin&quot;;

  /** Currently used whispercpp model */
<span class="nc" id="L90">  private String whispercppModel = WHISPERCPP_MODEL_DEFAULT;</span>

  /** Config key for additional Whisper args */
  private static final String WHISPERCPP_ARGS_CONFIG_KEY = &quot;whispercpp.args&quot;;

  /** Currently used Whisper args */
  private String[] whispercppArgs;

  /** Config key for setting whispercpp beam size */
  private static final String WHISPERCPP_BEAM_SIZE_CONFIG_KEY = &quot;whispercpp.beam-size&quot;;

  /** Currently used whispercpp beam size */
  private Option&lt;Integer&gt; whispercppBeamSize;

  /** Config key for setting whispercpp maximum segment length */
  private static final String WHISPERCPP_MAX_LENGTH_CONFIG_KEY = &quot;whispercpp.max-len&quot;;

  /** Currently used whispercpp maximum segment length */
  private Option&lt;Integer&gt; whispercppMaxLength;

  /** Config key for setting whispercpp number of threads */
  private static final String WHISPERCPP_THREADS_CONFIG_KEY = &quot;whispercpp.threads&quot;;

  /** Currently used whispercpp number of threads */
  private Option&lt;Integer&gt; whispercppThreads;

  /** Config key for setting whispercpp number of processors */
  private static final String WHISPERCPP_PROCESSORS_CONFIG_KEY = &quot;whispercpp.processors&quot;;

  /** Currently used whispercpp number of processors */
  private Option&lt;Integer&gt; whispercppProcessors;

  /** Config key for setting whispercpp maximum context */
  private static final String WHISPERCPP_MAX_CONTEXT_CONFIG_KEY = &quot;whispercpp.max-context&quot;;

  /** Currently used whispercpp maximum context */
  private Option&lt;Integer&gt; whispercppMaxContext;

  /** Config key for setting whispercpp split on word */
  private static final String WHISPERCPP_SPLIT_ON_WORD_CONFIG_KEY = &quot;whispercpp.split-on-word&quot;;

  /** Currently used whispercpp split on word */
  private Option&lt;Boolean&gt; whispercppSplitOnWord;

  /** Config key for setting whispercpp number of best candidates to keep */
  private static final String WHISPERCPP_BEST_OF_CONFIG_KEY = &quot;whispercpp.best-of&quot;;

  /** Currently used whispercpp number of best candidates to keep */
  private Option&lt;Integer&gt; whispercppBestOf;

  /** Config key for setting whispercpp word probability threshold */
  private static final String WHISPERCPP_WORD_THRESHOLD_CONFIG_KEY = &quot;whispercpp.word-thold&quot;;

  /** Currently used whispercpp word probability threshold */
  private Option&lt;Double&gt; whispercppWordThreshold;

  /** Config key for setting whispercpp entropy threshold for decoder fail */
  private static final String WHISPERCPP_ENTROPY_THRESHOLD_CONFIG_KEY = &quot;whispercpp.entropy-thold&quot;;

  /** Currently used whispercpp entropy threshold for decoder fail */
  private Option&lt;Double&gt; whispercppEntropyThreshold;

  /** Config key for setting whispercpp log probability threshold for decoder fail */
  private static final String WHISPERCPP_LOG_PROB_THRESHOLD_CONFIG_KEY = &quot;whispercpp.logprob-thold&quot;;

  /** Currently used whispercpp log probability threshold for decoder fail */
  private Option&lt;Double&gt; whispercppLogProbThreshold;

  /** Config key for setting whispercpp diarization */
  private static final String WHISPERCPP_DIARIZATION_CONFIG_KEY = &quot;whispercpp.diarize&quot;;

  /** Currently used whispercpp diarization */
  private Option&lt;Boolean&gt; whispercppDiarization;

  /** Config key for setting whispercpp tinydiarization */
  private static final String WHISPERCPP_TINY_DIARIZATION_CONFIG_KEY = &quot;whispercpp.tinydiarize&quot;;

  /** Currently used whispercpp tinydiarization */
  private Option&lt;Boolean&gt; whispercppTinyDiarization;

  /** Config key for setting whispercpp no fallback */
  private static final String WHISPERCPP_NO_FALLBACK_CONFIG_KEY = &quot;whispercpp.no-fallback&quot;;

  /** Currently used whispercpp no fallback */
  private Option&lt;Boolean&gt; whispercppNoFallback;

  /** Config key for automatic audio encoding */
  private static final String AUTO_ENCODING_CONFIG_KEY = &quot;whispercpp.auto-encode&quot;;

  /** Default value for automatic audio encoding */
<span class="nc" id="L180">  private static final Boolean AUTO_ENCODING_DEFAULT = true;</span>

  /** If Opencast should automatically re-encode tracks so that they are compatible with Whisper.cpp */
<span class="nc" id="L183">  private boolean autoEncode = AUTO_ENCODING_DEFAULT;</span>

  /** The key to look for in the service configuration file to override the DEFAULT_FFMPEG_BINARY */
  public static final String FFMPEG_BINARY_CONFIG_KEY = &quot;org.opencastproject.composer.ffmpeg.path&quot;;

  /** The default path to the ffmpeg binary */
  public static final String DEFAULT_FFMPEG_BINARY = &quot;ffmpeg&quot;;

  /** Path to the executable */
<span class="nc" id="L192">  protected String ffmpegBinary = DEFAULT_FFMPEG_BINARY;</span>

  @Override
  public String getEngineName() {
<span class="nc" id="L196">    return engineName;</span>
  }

  @Activate
  @Modified
  public void activate(ComponentContext cc) {
<span class="nc" id="L202">    logger.debug(&quot;Activated/Modified WhisperC++ engine service class&quot;);</span>
<span class="nc" id="L203">    whispercppExecutable = StringUtils.defaultIfBlank(</span>
<span class="nc" id="L204">        (String) cc.getProperties().get(WHISPERCPP_EXECUTABLE_PATH_CONFIG_KEY), WHISPERCPP_EXECUTABLE_DEFAULT_PATH);</span>
<span class="nc" id="L205">    logger.debug(&quot;Set WhisperC++ path to {}&quot;, whispercppExecutable);</span>

<span class="nc" id="L207">    whispercppModel = StringUtils.defaultIfBlank(</span>
<span class="nc" id="L208">        (String) cc.getProperties().get(WHISPERCPP_MODEL_CONFIG_KEY), WHISPERCPP_MODEL_DEFAULT);</span>
<span class="nc" id="L209">    logger.debug(&quot;WhisperC++ Language model set to {}&quot;, whispercppModel);</span>

<span class="nc" id="L211">    whispercppBeamSize = OsgiUtil.getOptCfgAsInt(cc.getProperties(), WHISPERCPP_BEAM_SIZE_CONFIG_KEY);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">    if (whispercppBeamSize.isSome()) {</span>
<span class="nc" id="L213">      logger.debug(&quot;WhisperC++ beam size set to {}&quot;, whispercppBeamSize);</span>
    }

<span class="nc" id="L216">    whispercppMaxLength = OsgiUtil.getOptCfgAsInt(cc.getProperties(), WHISPERCPP_MAX_LENGTH_CONFIG_KEY);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">    if (whispercppMaxLength.isSome()) {</span>
<span class="nc" id="L218">      logger.debug(&quot;WhisperC++ maximum segment length set to {}&quot;, whispercppMaxLength);</span>
    }

<span class="nc" id="L221">    whispercppThreads = OsgiUtil.getOptCfgAsInt(cc.getProperties(), WHISPERCPP_THREADS_CONFIG_KEY);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">    if (whispercppThreads.isSome()) {</span>
<span class="nc" id="L223">      logger.debug(&quot;WhisperC++ number of threads set to {}&quot;, whispercppThreads);</span>
    }

<span class="nc" id="L226">    whispercppProcessors = OsgiUtil.getOptCfgAsInt(cc.getProperties(), WHISPERCPP_PROCESSORS_CONFIG_KEY);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">    if (whispercppProcessors.isSome()) {</span>
<span class="nc" id="L228">      logger.debug(&quot;WhisperC++ number of processors set to {}&quot;, whispercppProcessors);</span>
    }

<span class="nc" id="L231">    whispercppMaxContext = OsgiUtil.getOptCfgAsInt(cc.getProperties(), WHISPERCPP_MAX_CONTEXT_CONFIG_KEY);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">    if (whispercppMaxContext.isSome()) {</span>
<span class="nc" id="L233">      logger.debug(&quot;WhisperC++ max context set to {}&quot;, whispercppMaxContext);</span>
    }

<span class="nc" id="L236">    whispercppSplitOnWord = OsgiUtil.getOptCfgAsBoolean(cc.getProperties(), WHISPERCPP_SPLIT_ON_WORD_CONFIG_KEY);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">    if (whispercppSplitOnWord.isSome()) {</span>
<span class="nc" id="L238">      logger.debug(&quot;WhisperC++ split on word set to {}&quot;, whispercppSplitOnWord);</span>
    }

<span class="nc" id="L241">    whispercppBestOf = OsgiUtil.getOptCfgAsInt(cc.getProperties(), WHISPERCPP_BEST_OF_CONFIG_KEY);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">    if (whispercppBestOf.isSome()) {</span>
<span class="nc" id="L243">      logger.debug(&quot;WhisperC++ best of set to {}&quot;, whispercppBestOf);</span>
    }

<span class="nc" id="L246">    whispercppWordThreshold = OsgiUtil.getOptCfg(cc.getProperties(), WHISPERCPP_WORD_THRESHOLD_CONFIG_KEY).bind(</span>
        Strings.toDouble);
<span class="nc bnc" id="L248" title="All 2 branches missed.">    if (whispercppWordThreshold.isSome()) {</span>
<span class="nc" id="L249">      logger.debug(&quot;WhisperC++ word threshold set to {}&quot;, whispercppWordThreshold);</span>
    }

<span class="nc" id="L252">    whispercppEntropyThreshold = OsgiUtil.getOptCfg(cc.getProperties(), WHISPERCPP_ENTROPY_THRESHOLD_CONFIG_KEY).bind(</span>
        Strings.toDouble);
<span class="nc bnc" id="L254" title="All 2 branches missed.">    if (whispercppEntropyThreshold.isSome()) {</span>
<span class="nc" id="L255">      logger.debug(&quot;WhisperC++ entropy threshold set to {}&quot;, whispercppEntropyThreshold);</span>
    }

<span class="nc" id="L258">    whispercppLogProbThreshold = OsgiUtil.getOptCfg(cc.getProperties(), WHISPERCPP_LOG_PROB_THRESHOLD_CONFIG_KEY).bind(</span>
        Strings.toDouble);
<span class="nc bnc" id="L260" title="All 2 branches missed.">    if (whispercppLogProbThreshold.isSome()) {</span>
<span class="nc" id="L261">      logger.debug(&quot;WhisperC++ log prob threshold set to {}&quot;, whispercppLogProbThreshold);</span>
    }

<span class="nc" id="L264">    whispercppDiarization = OsgiUtil.getOptCfgAsBoolean(cc.getProperties(), WHISPERCPP_DIARIZATION_CONFIG_KEY);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">    if (whispercppDiarization.isSome()) {</span>
<span class="nc" id="L266">      logger.debug(&quot;WhisperC++ diarization set to {}&quot;, whispercppDiarization);</span>
    }

<span class="nc" id="L269">    whispercppTinyDiarization = OsgiUtil.getOptCfgAsBoolean(cc.getProperties(), WHISPERCPP_TINY_DIARIZATION_CONFIG_KEY);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">    if (whispercppTinyDiarization.isSome()) {</span>
<span class="nc" id="L271">      logger.debug(&quot;WhisperC++ tiny diarization set to {}&quot;, whispercppTinyDiarization);</span>
    }

<span class="nc" id="L274">    whispercppNoFallback = OsgiUtil.getOptCfgAsBoolean(cc.getProperties(), WHISPERCPP_NO_FALLBACK_CONFIG_KEY);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">    if (whispercppNoFallback.isSome()) {</span>
<span class="nc" id="L276">      logger.debug(&quot;WhisperC++ no fallback set to {}&quot;, whispercppNoFallback);</span>
    }

<span class="nc" id="L279">    whispercppArgs = Objects.toString(cc.getProperties().get(WHISPERCPP_ARGS_CONFIG_KEY), &quot;&quot;).trim().split(&quot;\\s+&quot;);</span>
<span class="nc" id="L280">    logger.debug(&quot;Additional args for WhisperC++: {}&quot;, (Object) whispercppArgs);</span>

<span class="nc" id="L282">    autoEncode = BooleanUtils.toBoolean(Objects.toString(</span>
<span class="nc" id="L283">        cc.getProperties().get(AUTO_ENCODING_CONFIG_KEY),</span>
<span class="nc" id="L284">        AUTO_ENCODING_DEFAULT.toString()));</span>
<span class="nc" id="L285">    logger.debug(&quot;Automatically convert input media: {}&quot;, autoEncode);</span>

<span class="nc" id="L287">    ffmpegBinary = Objects.toString(cc.getBundleContext().getProperty(FFMPEG_BINARY_CONFIG_KEY), DEFAULT_FFMPEG_BINARY);</span>
<span class="nc" id="L288">    logger.debug(&quot;ffmpeg binary set to {}&quot;, ffmpegBinary);</span>

<span class="nc" id="L290">    logger.debug(&quot;Finished activating/updating speech-to-text service&quot;);</span>
<span class="nc" id="L291">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.speechtotext.api.SpeechToTextEngine#generateSubtitlesFile(File, File, String, Boolean)
   */
  @Override
  public Result generateSubtitlesFile(File mediaFile, File workingDirectory, String language, Boolean translate)
          throws SpeechToTextEngineException {

<span class="nc" id="L302">    var whisperInput = mediaFile.getAbsolutePath();</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">    if (autoEncode) {</span>
<span class="nc" id="L304">      whisperInput = FilenameUtils.concat(workingDirectory.getAbsolutePath(), UUID.randomUUID() + &quot;.wav&quot;);</span>
<span class="nc" id="L305">      var ffmpegCommand = List.of(</span>
          ffmpegBinary,
<span class="nc" id="L307">          &quot;-i&quot;, mediaFile.getAbsolutePath(),</span>
          &quot;-ar&quot;, &quot;16000&quot;,
          &quot;-ac&quot;, &quot;1&quot;,
          &quot;-c:a&quot;, &quot;pcm_s16le&quot;,
          whisperInput);
      try {
<span class="nc" id="L313">        execCommand(ffmpegCommand);</span>
<span class="nc" id="L314">      } catch (IOException e) {</span>
<span class="nc" id="L315">        throw new SpeechToTextEngineException(&quot;Failed to convert audio file&quot;, e);</span>
<span class="nc" id="L316">      } catch (InterruptedException e) {</span>
<span class="nc" id="L317">        throw new RuntimeException(e);</span>
<span class="nc" id="L318">      }</span>
    }

<span class="nc bnc" id="L321" title="All 2 branches missed.">    if (!whisperInput.toLowerCase().endsWith(&quot;.wav&quot;)) {</span>
<span class="nc" id="L322">      throw new SpeechToTextEngineException(&quot;WhisperC++ currently doesn't support any media extension other than wav&quot;);</span>
    }

<span class="nc" id="L325">    String outputName = FilenameUtils.getBaseName(mediaFile.getAbsolutePath());</span>

<span class="nc" id="L327">    List&lt;String&gt; command = new ArrayList&lt;&gt;(List.of(</span>
        whispercppExecutable,
        whisperInput,
        &quot;--model&quot;, whispercppModel,
        &quot;-ovtt&quot;,
        &quot;-oj&quot;,
<span class="nc" id="L333">        &quot;--output-file&quot;, FilenameUtils.concat(workingDirectory.getAbsolutePath(), outputName)));</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">    if (whispercppBeamSize.isSome()) {</span>
<span class="nc" id="L335">      command.add(&quot;-bs&quot;);</span>
<span class="nc" id="L336">      command.add(Integer.toString(whispercppBeamSize.get()));</span>
    }
<span class="nc bnc" id="L338" title="All 2 branches missed.">    if (whispercppMaxLength.isSome()) {</span>
<span class="nc" id="L339">      command.add(&quot;-ml&quot;);</span>
<span class="nc" id="L340">      command.add(Integer.toString(whispercppMaxLength.get()));</span>
    }
<span class="nc bnc" id="L342" title="All 2 branches missed.">    if (whispercppThreads.isSome()) {</span>
<span class="nc" id="L343">      command.add(&quot;-t&quot;);</span>
<span class="nc" id="L344">      command.add(Integer.toString(whispercppThreads.get()));</span>
    }
<span class="nc bnc" id="L346" title="All 2 branches missed.">    if (whispercppProcessors.isSome()) {</span>
<span class="nc" id="L347">      command.add(&quot;-p&quot;);</span>
<span class="nc" id="L348">      command.add(Integer.toString(whispercppProcessors.get()));</span>
    }
<span class="nc bnc" id="L350" title="All 2 branches missed.">    if (whispercppMaxContext.isSome()) {</span>
<span class="nc" id="L351">      command.add(&quot;-mc&quot;);</span>
<span class="nc" id="L352">      command.add(Integer.toString(whispercppMaxContext.get()));</span>
    }
<span class="nc bnc" id="L354" title="All 4 branches missed.">    if (whispercppSplitOnWord.isSome() &amp;&amp; whispercppSplitOnWord.get()) {</span>
<span class="nc" id="L355">      command.add(&quot;-sow&quot;);</span>
    }
<span class="nc bnc" id="L357" title="All 2 branches missed.">    if (whispercppBestOf.isSome()) {</span>
<span class="nc" id="L358">      command.add(&quot;-bo&quot;);</span>
<span class="nc" id="L359">      command.add(Integer.toString(whispercppBestOf.get()));</span>
    }
<span class="nc bnc" id="L361" title="All 2 branches missed.">    if (whispercppWordThreshold.isSome()) {</span>
<span class="nc" id="L362">      command.add(&quot;-wt&quot;);</span>
<span class="nc" id="L363">      command.add(String.format(Locale.US, &quot;%f&quot;, whispercppWordThreshold.get()));</span>
    }
<span class="nc bnc" id="L365" title="All 2 branches missed.">    if (whispercppEntropyThreshold.isSome()) {</span>
<span class="nc" id="L366">      command.add(&quot;-et&quot;);</span>
<span class="nc" id="L367">      command.add(String.format(Locale.US, &quot;%f&quot;, whispercppEntropyThreshold.get()));</span>
    }
<span class="nc bnc" id="L369" title="All 2 branches missed.">    if (whispercppLogProbThreshold.isSome()) {</span>
<span class="nc" id="L370">      command.add(&quot;-lpt&quot;);</span>
<span class="nc" id="L371">      command.add(String.format(Locale.US, &quot;%f&quot;, whispercppLogProbThreshold.get()));</span>
    }
<span class="nc bnc" id="L373" title="All 4 branches missed.">    if (whispercppDiarization.isSome() &amp;&amp; whispercppDiarization.get()) {</span>
<span class="nc" id="L374">      command.add(&quot;-di&quot;);</span>
    }
<span class="nc bnc" id="L376" title="All 4 branches missed.">    if (whispercppTinyDiarization.isSome() &amp;&amp; whispercppTinyDiarization.get()) {</span>
<span class="nc" id="L377">      command.add(&quot;-tdrz&quot;);</span>
    }
<span class="nc bnc" id="L379" title="All 4 branches missed.">    if (whispercppNoFallback.isSome() &amp;&amp; whispercppNoFallback.get()) {</span>
<span class="nc" id="L380">      command.add(&quot;-nf&quot;);</span>
    }

    String subtitleLanguage;

    // set language of the source audio if known
<span class="nc bnc" id="L386" title="All 2 branches missed.">    if (!language.isBlank()) {</span>
      // Convert ISO3 language code to ISO2 if possible, as WhisperC++ expects ISO2 codes.
      // If the conversion is not possible, retain the original language code.
<span class="nc" id="L389">      logger.info(&quot;Found language '{}'&quot;, language);</span>
<span class="nc" id="L390">      language = LangCodeUtil.iso3ToIso2(language, language);</span>
<span class="nc" id="L391">      logger.info(&quot;Using language code '{}' for transcription process&quot;, language);</span>
<span class="nc" id="L392">      command.add(&quot;--language&quot;);</span>
<span class="nc" id="L393">      command.add(language);</span>
    } else {
<span class="nc" id="L395">      logger.debug(&quot;Auto-detecting language&quot;);</span>
<span class="nc" id="L396">      command.add(&quot;--language&quot;);</span>
<span class="nc" id="L397">      command.add(&quot;auto&quot;);</span>
    }

<span class="nc bnc" id="L400" title="All 2 branches missed.">    if (translate) {</span>
<span class="nc" id="L401">      command.add(&quot;--translate&quot;);</span>
<span class="nc" id="L402">      logger.info(&quot;Translation enabled&quot;);</span>
<span class="nc" id="L403">      subtitleLanguage = &quot;en&quot;;</span>
    } else {
<span class="nc" id="L405">      subtitleLanguage = language;</span>
    }

<span class="nc" id="L408">    command.addAll(Arrays.asList(whispercppArgs));</span>

<span class="nc" id="L410">    logger.info(&quot;Executing WhisperC++'s transcription command: {}&quot;, command);</span>

    File vtt;

    try {
<span class="nc" id="L415">      execCommand(command);</span>

<span class="nc" id="L417">      vtt = new File(workingDirectory, outputName + &quot;.vtt&quot;);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">      if (!vtt.isFile()) {</span>
<span class="nc" id="L419">        throw new SpeechToTextEngineException(&quot;WhisperC++ produced no output&quot;);</span>
      }
<span class="nc" id="L421">      logger.info(&quot;Subtitles file generated successfully: {}&quot;, vtt);</span>
<span class="nc" id="L422">    } catch (Exception e) {</span>
<span class="nc" id="L423">      logger.info(&quot;Transcription failed closing WhisperC++ transcription process for: {}&quot;, whisperInput);</span>
<span class="nc" id="L424">      throw new SpeechToTextEngineException(e);</span>
<span class="nc" id="L425">    }</span>

    // Detect language if not set
<span class="nc bnc" id="L428" title="All 2 branches missed.">    if (subtitleLanguage.isBlank()) {</span>
<span class="nc" id="L429">      JSONParser jsonParser = new JSONParser();</span>
<span class="nc" id="L430">      File json = new File(workingDirectory, outputName + &quot;.json&quot;);</span>
      try {
<span class="nc" id="L432">        FileReader reader = new FileReader(json);</span>
<span class="nc" id="L433">        Object obj = jsonParser.parse(reader);</span>
<span class="nc" id="L434">        JSONObject jsonObject = (JSONObject) obj;</span>
<span class="nc" id="L435">        JSONObject result = (JSONObject) jsonObject.get(&quot;result&quot;);</span>
<span class="nc" id="L436">        subtitleLanguage = (String) result.get(&quot;language&quot;);</span>
        // convert language name to iso3 if necessary or take default
<span class="nc" id="L438">        subtitleLanguage = LangCodeUtil.getIso2FromLang(subtitleLanguage, subtitleLanguage);</span>
<span class="nc" id="L439">        logger.info(&quot;Language detected by WhisperC++: {}&quot;, subtitleLanguage);</span>
<span class="nc" id="L440">      } catch (Exception e) {</span>
<span class="nc" id="L441">        logger.info(&quot;Error reading WhisperC++ JSON file for: {}&quot;, mediaFile);</span>
<span class="nc" id="L442">        throw new SpeechToTextEngineException(e);</span>
      } finally {
<span class="nc" id="L444">        FileUtils.deleteQuietly(json);</span>
      }
    }

<span class="nc" id="L448">    return new Result(subtitleLanguage, vtt);</span>
  }

  private void execCommand(List&lt;String&gt; command) throws IOException, InterruptedException, SpeechToTextEngineException {
<span class="nc" id="L452">    logger.info(&quot;Executing command: {}&quot;, command);</span>
<span class="nc" id="L453">    Process process = null;</span>

    try {
<span class="nc" id="L456">      ProcessBuilder processBuilder = new ProcessBuilder(command);</span>
<span class="nc" id="L457">      processBuilder.redirectErrorStream(true);</span>
<span class="nc" id="L458">      processBuilder.redirectInput(ProcessBuilder.Redirect.PIPE)</span>
<span class="nc" id="L459">          .redirectError(ProcessBuilder.Redirect.PIPE)</span>
<span class="nc" id="L460">          .redirectOutput(ProcessBuilder.Redirect.PIPE);</span>
<span class="nc" id="L461">      process = processBuilder.start();</span>

<span class="nc" id="L463">      try (BufferedReader in = new BufferedReader(new InputStreamReader(process.getInputStream()))) {</span>
        String line;
<span class="nc bnc" id="L465" title="All 2 branches missed.">        while ((line = in.readLine()) != null) { // consume process output</span>
<span class="nc" id="L466">          logger.debug(line);</span>
        }
      }

      // wait until the task is finished
<span class="nc" id="L471">      int exitCode = process.waitFor();</span>
<span class="nc" id="L472">      logger.info(&quot;Process finished with exit code {}&quot;, exitCode);</span>

<span class="nc bnc" id="L474" title="All 2 branches missed.">      if (exitCode != 0) {</span>
<span class="nc" id="L475">        var error = &quot;&quot;;</span>
<span class="nc" id="L476">        try (var errorStream = process.getInputStream()) {</span>
<span class="nc" id="L477">          error = &quot;\n Output:\n&quot; + IOUtils.toString(errorStream, StandardCharsets.UTF_8);</span>
        }
<span class="nc" id="L479">        throw new SpeechToTextEngineException(</span>
<span class="nc" id="L480">            String.format(&quot;Process exited abnormally with status %d (command: %s) %s&quot;, exitCode, command, error));</span>
      }
    } finally {
<span class="nc" id="L483">      IoSupport.closeQuietly(process);</span>
    }
<span class="nc" id="L485">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>