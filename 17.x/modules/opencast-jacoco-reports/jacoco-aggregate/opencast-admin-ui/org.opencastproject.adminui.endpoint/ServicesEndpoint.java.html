<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ServicesEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-admin-ui</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.adminui.endpoint</a> &gt; <span class="el_source">ServicesEndpoint.java</span></div><h1>ServicesEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.adminui.endpoint;

import static com.entwinemedia.fn.data.json.Jsons.f;
import static com.entwinemedia.fn.data.json.Jsons.obj;
import static com.entwinemedia.fn.data.json.Jsons.v;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;

import org.opencastproject.index.service.resources.list.query.ServicesListQuery;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.serviceregistry.api.HostRegistration;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceState;
import org.opencastproject.serviceregistry.api.ServiceStatistics;
import org.opencastproject.util.SmartIterator;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.util.requests.SortCriterion;
import org.opencastproject.util.requests.SortCriterion.Order;

import com.entwinemedia.fn.data.json.JValue;
import com.entwinemedia.fn.data.json.Jsons;

import org.apache.commons.lang3.StringUtils;
import org.json.simple.JSONAware;
import org.json.simple.JSONObject;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path(&quot;/admin-ng/services&quot;)
@RestService(name = &quot;ServicesProxyService&quot;, title = &quot;UI Services&quot;,
  abstractText = &quot;This service provides the services data for the UI.&quot;,
  notes = { &quot;These Endpoints deliver informations about the services required for the UI.&quot;,
            &quot;&lt;strong&gt;Important:&lt;/strong&gt; &quot;
              + &quot;&lt;em&gt;This service is for exclusive use by the module admin-ui. Its API might change &quot;
              + &quot;anytime without prior notice. Any dependencies other than the admin UI will be strictly ignored. &quot;
              + &quot;DO NOT use this for integration of third-party applications.&lt;em&gt;&quot;})
@Component(
  immediate = true,
  service = ServicesEndpoint.class,
  property = {
    &quot;service.description=Admin UI - Services facade Endpoint&quot;,
    &quot;opencast.service.type=org.opencastproject.adminui.endpoint.ServicesEndpoint&quot;,
    &quot;opencast.service.path=/admin-ng/services&quot;
  }
)
@JaxrsResource
<span class="fc" id="L92">public class ServicesEndpoint {</span>
<span class="fc" id="L93">  private static final Logger logger = LoggerFactory.getLogger(ServicesEndpoint.class);</span>
  private ServiceRegistry serviceRegistry;

  private static final String SERVICE_STATUS_TRANSLATION_PREFIX = &quot;SYSTEMS.SERVICES.STATUS.&quot;;


  @GET
  @Path(&quot;services.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(description = &quot;Returns the list of services&quot;, name = &quot;services&quot;, restParameters = {
          @RestParameter(name = &quot;limit&quot;, description = &quot;The maximum number of items to return per page&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;offset&quot;, description = &quot;The offset&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;filter&quot;, description = &quot;Filter results by name, host, actions, status or free text query&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;sort&quot;, description = &quot;The sort order.  May include any &quot;
                  + &quot;of the following: host, name, running, queued, completed,  meanRunTime, meanQueueTime, &quot;
                  + &quot;status. The sort suffix must be :asc for ascending sort order and :desc for descending.&quot;, isRequired = false, type = STRING)
  }, responses = { @RestResponse(description = &quot;Returns the list of services from Opencast&quot;, responseCode = HttpServletResponse.SC_OK) }, returnDescription = &quot;The list of services&quot;)
  public Response getServices(@QueryParam(&quot;limit&quot;) final int limit, @QueryParam(&quot;offset&quot;) final int offset,
          @QueryParam(&quot;filter&quot;) String filter, @QueryParam(&quot;sort&quot;) String sort) throws Exception {

<span class="fc" id="L113">    Option&lt;String&gt; sortOpt = Option.option(StringUtils.trimToNull(sort));</span>
<span class="fc" id="L114">    ServicesListQuery query = new ServicesListQuery();</span>
<span class="fc" id="L115">    EndpointUtil.addRequestFiltersToQuery(filter, query);</span>

<span class="fc" id="L117">    String fName = null;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">    if (query.getName().isSome())</span>
<span class="fc" id="L119">      fName = StringUtils.trimToNull(query.getName().get());</span>
<span class="fc" id="L120">    String fHostname = null;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">    if (query.getHostname().isSome())</span>
<span class="fc" id="L122">      fHostname = StringUtils.trimToNull(query.getHostname().get());</span>
<span class="fc" id="L123">    String fNodeName = null;</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">    if (query.getNodeName().isSome())</span>
<span class="nc" id="L125">      fNodeName = StringUtils.trimToNull(query.getNodeName().get());</span>
<span class="fc" id="L126">    String fStatus = null;</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">    if (query.getStatus().isSome())</span>
<span class="nc" id="L128">      fStatus = StringUtils.trimToNull(query.getStatus().get());</span>
<span class="fc" id="L129">    String fFreeText = null;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">    if (query.getFreeText().isSome())</span>
<span class="fc" id="L131">      fFreeText = StringUtils.trimToNull(query.getFreeText().get());</span>

<span class="fc" id="L133">    List&lt;HostRegistration&gt; servers = serviceRegistry.getHostRegistrations();</span>
<span class="fc" id="L134">    List&lt;Service&gt; services = new ArrayList&lt;Service&gt;();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">    for (ServiceStatistics stats : serviceRegistry.getServiceStatistics()) {</span>
<span class="fc" id="L136">      Service service = new Service(stats, findServerByHost(stats.getServiceRegistration().getHost(), servers));</span>
<span class="fc bfc" id="L137" title="All 4 branches covered.">      if (fName != null &amp;&amp; !StringUtils.equalsIgnoreCase(service.getName(), fName))</span>
<span class="fc" id="L138">        continue;</span>

<span class="fc bfc" id="L140" title="All 4 branches covered.">      if (fHostname != null &amp;&amp; !StringUtils.equalsIgnoreCase(service.getHost(), fHostname))</span>
<span class="fc" id="L141">        continue;</span>

<span class="pc bpc" id="L143" title="3 of 4 branches missed.">      if (fNodeName != null &amp;&amp; !StringUtils.equalsIgnoreCase(service.getNodeName(), fNodeName))</span>
<span class="nc" id="L144">        continue;</span>

<span class="pc bpc" id="L146" title="3 of 4 branches missed.">      if (fStatus != null &amp;&amp; !StringUtils.equalsIgnoreCase(service.getStatus().toString(), fStatus))</span>
<span class="nc" id="L147">        continue;</span>

<span class="fc bfc" id="L149" title="All 2 branches covered.">      if (query.getActions().isSome()) {</span>
<span class="fc" id="L150">        ServiceState serviceState = service.getStatus();</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (query.getActions().get()) {</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">          if (ServiceState.NORMAL == serviceState)</span>
<span class="fc" id="L154">            continue;</span>
        } else {
<span class="fc bfc" id="L156" title="All 2 branches covered.">          if (ServiceState.NORMAL != serviceState)</span>
<span class="fc" id="L157">            continue;</span>
        }
      }

<span class="fc bfc" id="L161" title="All 4 branches covered.">      if (fFreeText != null &amp;&amp; !StringUtils.containsIgnoreCase(service.getName(), fFreeText)</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">                &amp;&amp; !StringUtils.containsIgnoreCase(service.getHost(), fFreeText)</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">                &amp;&amp; !StringUtils.containsIgnoreCase(service.getNodeName(), fFreeText)</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">                &amp;&amp; !StringUtils.containsIgnoreCase(service.getStatus().toString(), fFreeText))</span>
<span class="fc" id="L165">        continue;</span>

<span class="fc" id="L167">      services.add(service);</span>
<span class="fc" id="L168">    }</span>
<span class="fc" id="L169">    int total = services.size();</span>

<span class="fc bfc" id="L171" title="All 2 branches covered.">    if (sortOpt.isSome()) {</span>
<span class="fc" id="L172">      ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(sortOpt.get());</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">      if (!sortCriteria.isEmpty()) {</span>
        try {
<span class="fc" id="L175">          SortCriterion sortCriterion = sortCriteria.iterator().next();</span>
<span class="fc" id="L176">          Collections.sort(services, new ServiceStatisticsComparator(</span>
<span class="fc" id="L177">                  sortCriterion.getFieldName(),</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                  sortCriterion.getOrder() == Order.Ascending));</span>
<span class="nc" id="L179">        } catch (Exception ex) {</span>
<span class="nc" id="L180">          logger.warn(&quot;Failed to sort services collection.&quot;, ex);</span>
<span class="fc" id="L181">        }</span>
      }
    }

<span class="fc" id="L185">    List&lt;JValue&gt; jsonList = new ArrayList&lt;JValue&gt;();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">    for (Service s : new SmartIterator&lt;Service&gt;(limit, offset).applyLimitAndOffset(services)) {</span>
<span class="fc" id="L187">      jsonList.add(s.toJSON());</span>
<span class="fc" id="L188">    }</span>
<span class="fc" id="L189">    return RestUtils.okJsonList(jsonList, offset, limit, total);</span>
  }

  /**
   * Service UI model. Wrapper class for a {@code ServiceStatistics} class.
   */
  class Service implements JSONAware {
    /** Completed model field name. */
    public static final String COMPLETED_NAME = &quot;completed&quot;;
    /** Host model field name. */
    public static final String HOST_NAME = &quot;hostname&quot;;
    /** Node name model field name. */
    public static final String NODE_NAME = &quot;nodeName&quot;;
    /** MeanQueueTime model field name. */
    public static final String MEAN_QUEUE_TIME_NAME = &quot;meanQueueTime&quot;;
    /** MeanRunTime model field name. */
    public static final String MEAN_RUN_TIME_NAME = &quot;meanRunTime&quot;;
    /** (Service-) Name model field name. */
    public static final String NAME_NAME = &quot;name&quot;;
    /** Queued model field name. */
    public static final String QUEUED_NAME = &quot;queued&quot;;
    /** Running model field name. */
    public static final String RUNNING_NAME = &quot;running&quot;;
    /** Status model field name. */
    public static final String STATUS_NAME = &quot;status&quot;;
    /** Online model field name. */
    public static final String ONLINE_NAME = &quot;online&quot;;
    /** Maintenance model field name. */
    public static final String MAINTENANCE_NAME = &quot;maintenance&quot;;

    /** Wrapped {@code ServiceStatistics} instance. */
    private final ServiceStatistics serviceStatistics;

    private final Optional&lt;HostRegistration&gt; server;

    /** Constructor, set {@code ServiceStatistics} instance to a final private property. */
<span class="fc" id="L225">    Service(ServiceStatistics serviceStatistics, Optional&lt;HostRegistration&gt; server) {</span>
<span class="fc" id="L226">      this.serviceStatistics = serviceStatistics;</span>
<span class="fc" id="L227">      this.server = server;</span>
<span class="fc" id="L228">    }</span>

    /**
     * Returns completed jobs count.
     * @return completed jobs count
     */
    public int getCompletedJobs() {
<span class="fc" id="L235">      return serviceStatistics.getFinishedJobs();</span>
    }

    /**
     * Returns service host name.
     * @return service host name
     */
    public String getHost() {
<span class="fc" id="L243">      return serviceStatistics.getServiceRegistration().getHost();</span>
    }

    /**
     * Returns service host name.
     * @return service host name
     */
    public String getNodeName() {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">      return server.isPresent() ? server.get().getNodeName() : &quot;&quot;;</span>
    }

    /**
     * Returns service mean queue time in seconds.
     * @return service mean queue time in seconds
     */
    public long getMeanQueueTime() {
<span class="fc" id="L259">      return TimeUnit.MILLISECONDS.toSeconds(serviceStatistics.getMeanQueueTime());</span>
    }

    /**
     * Returns service mean run time in seconds.
     * @return service mean run time in seconds
     */
    public long getMeanRunTime() {
<span class="fc" id="L267">      return TimeUnit.MILLISECONDS.toSeconds(serviceStatistics.getMeanRunTime());</span>
    }

    /**
     * Returns service name.
     * @return service name
     */
    public String getName() {
<span class="fc" id="L275">      return serviceStatistics.getServiceRegistration().getServiceType();</span>
    }

    /**
     * Returns queued jobs count.
     * @return queued jobs count
     */
    public int getQueuedJobs() {
<span class="fc" id="L283">      return serviceStatistics.getQueuedJobs();</span>
    }

    /**
     * Returns running jobs count.
     * @return running jobs count
     */
    public int getRunningJobs() {
<span class="fc" id="L291">      return serviceStatistics.getRunningJobs();</span>
    }

    /**
     * Returns service status.
     * @return service status
     */
    public ServiceState getStatus() {
<span class="fc" id="L299">      return serviceStatistics.getServiceRegistration().getServiceState();</span>
    }

    /**
     * Returns whether the service is online.
     * @return online status
     */
    public boolean getIsOnline() {
<span class="fc" id="L307">      return serviceStatistics.getServiceRegistration().isOnline();</span>
    }

    /**
     * Returns whether the service is in maintenance.
     * @return maintenance status
     */
    public boolean getisMaintenance() {
<span class="fc" id="L315">      return serviceStatistics.getServiceRegistration().isInMaintenanceMode();</span>
    }

    /**
     * Returns a map of all service fields.
     * @return a map of all service fields
     */
    public Map&lt;String, String&gt; toMap() {
<span class="nc" id="L323">      Map&lt;String, String&gt; serviceMap = new HashMap&lt;String, String&gt;();</span>
<span class="nc" id="L324">      serviceMap.put(COMPLETED_NAME, Integer.toString(getCompletedJobs()));</span>
<span class="nc" id="L325">      serviceMap.put(HOST_NAME, getHost());</span>
<span class="nc" id="L326">      serviceMap.put(NODE_NAME, getNodeName());</span>
<span class="nc" id="L327">      serviceMap.put(MEAN_QUEUE_TIME_NAME, Long.toString(getMeanQueueTime()));</span>
<span class="nc" id="L328">      serviceMap.put(MEAN_RUN_TIME_NAME, Long.toString(getMeanRunTime()));</span>
<span class="nc" id="L329">      serviceMap.put(NAME_NAME, getName());</span>
<span class="nc" id="L330">      serviceMap.put(QUEUED_NAME, Integer.toString(getQueuedJobs()));</span>
<span class="nc" id="L331">      serviceMap.put(RUNNING_NAME, Integer.toString(getRunningJobs()));</span>
<span class="nc" id="L332">      serviceMap.put(STATUS_NAME, getStatus().name());</span>
<span class="nc" id="L333">      serviceMap.put(ONLINE_NAME, Boolean.toString(getIsOnline()));</span>
<span class="nc" id="L334">      serviceMap.put(MAINTENANCE_NAME, Boolean.toString(getisMaintenance()));</span>
<span class="nc" id="L335">      return serviceMap;</span>
    }

    /**
     * Returns a json representation of a service as {@code String}.
     * @return a json representation of a service as {@code String}
     */
    @Override
    public String toJSONString() {
<span class="nc" id="L344">      return JSONObject.toJSONString(toMap());</span>
    }

    /**
     * Returns a json representation of a service as {@code JValue}.
     * @return a json representation of a service as {@code JValue}
     */
    public JValue toJSON() {
<span class="fc" id="L352">      return obj(f(COMPLETED_NAME, v(getCompletedJobs())), f(HOST_NAME, v(getHost(), Jsons.BLANK)), f(NODE_NAME, v(getNodeName(), Jsons.BLANK)),</span>
<span class="fc" id="L353">              f(MEAN_QUEUE_TIME_NAME, v(getMeanQueueTime())), f(MEAN_RUN_TIME_NAME, v(getMeanRunTime())),</span>
<span class="fc" id="L354">              f(NAME_NAME, v(getName(), Jsons.BLANK)), f(QUEUED_NAME, v(getQueuedJobs())),</span>
<span class="fc" id="L355">              f(RUNNING_NAME, v(getRunningJobs())),</span>
<span class="fc" id="L356">              f(STATUS_NAME, v(SERVICE_STATUS_TRANSLATION_PREFIX + getStatus().name(), Jsons.BLANK)),</span>
<span class="fc" id="L357">              f(ONLINE_NAME, v(getIsOnline())),</span>
<span class="fc" id="L358">              f(MAINTENANCE_NAME, v(getisMaintenance())));</span>
    }
  }

  /**
   * {@code Service} comparator. Can compare service instances based on the given sort criterion and sort order.
   */
  class ServiceStatisticsComparator implements Comparator&lt;Service&gt; {

    /** Sort criterion. */
    private final String sortBy;
    /** Sort order (true if ascending, false otherwise). */
    private final boolean ascending;

    /** Constructor. */
<span class="fc" id="L373">    ServiceStatisticsComparator(String sortBy, boolean ascending) {</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">      if (StringUtils.equalsIgnoreCase(Service.COMPLETED_NAME, sortBy)) {</span>
<span class="fc" id="L375">        this.sortBy = Service.COMPLETED_NAME;</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.HOST_NAME, sortBy)) {</span>
<span class="fc" id="L377">        this.sortBy = Service.HOST_NAME;</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">      } else if (StringUtils.equalsIgnoreCase(Service.NODE_NAME, sortBy)) {</span>
<span class="nc" id="L379">        this.sortBy = Service.NODE_NAME;</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.MEAN_QUEUE_TIME_NAME, sortBy)) {</span>
<span class="fc" id="L381">        this.sortBy = Service.MEAN_QUEUE_TIME_NAME;</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.MEAN_RUN_TIME_NAME, sortBy)) {</span>
<span class="fc" id="L383">        this.sortBy = Service.MEAN_RUN_TIME_NAME;</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.NAME_NAME, sortBy)) {</span>
<span class="fc" id="L385">        this.sortBy = Service.NAME_NAME;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.QUEUED_NAME, sortBy)) {</span>
<span class="fc" id="L387">        this.sortBy = Service.QUEUED_NAME;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">      } else if (StringUtils.equalsIgnoreCase(Service.RUNNING_NAME, sortBy)) {</span>
<span class="fc" id="L389">        this.sortBy = Service.RUNNING_NAME;</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">      } else if (StringUtils.equalsIgnoreCase(Service.STATUS_NAME, sortBy)) {</span>
<span class="fc" id="L391">        this.sortBy = Service.STATUS_NAME;</span>
      } else {
<span class="nc" id="L393">        throw new IllegalArgumentException(String.format(&quot;Can't sort services by %s.&quot;, sortBy));</span>
      }
<span class="fc" id="L395">      this.ascending = ascending;</span>
<span class="fc" id="L396">    }</span>

    /**
     * Compare two service instances.
     * @param s1 first {@code Service} instance to compare
     * @param s2 second {@code Service} instance to compare
     * @return
     */
    @Override
    public int compare(Service s1, Service s2) {
<span class="fc" id="L406">      int result = 0;</span>
<span class="pc bpc" id="L407" title="1 of 9 branches missed.">      switch (sortBy) {</span>
        case Service.COMPLETED_NAME:
<span class="fc" id="L409">          result = s1.getCompletedJobs() - s2.getCompletedJobs();</span>
<span class="fc" id="L410">          break;</span>
        case Service.HOST_NAME:
<span class="fc" id="L412">          result = s1.getHost().compareToIgnoreCase(s2.getHost());</span>
<span class="fc" id="L413">          break;</span>
        case Service.NODE_NAME:
<span class="nc" id="L415">          result = s1.getNodeName().compareToIgnoreCase(s2.getNodeName());</span>
<span class="nc" id="L416">          break;</span>
        case Service.MEAN_QUEUE_TIME_NAME:
<span class="fc" id="L418">          result = (int) (s1.getMeanQueueTime() - s2.getMeanQueueTime());</span>
<span class="fc" id="L419">          break;</span>
        case Service.MEAN_RUN_TIME_NAME:
<span class="fc" id="L421">          result = (int) (s1.getMeanRunTime() - s2.getMeanRunTime());</span>
<span class="fc" id="L422">          break;</span>
        case Service.QUEUED_NAME:
<span class="fc" id="L424">          result = s1.getQueuedJobs() - s2.getQueuedJobs();</span>
<span class="fc" id="L425">          break;</span>
        case Service.RUNNING_NAME:
<span class="fc" id="L427">          result = s1.getRunningJobs() - s2.getRunningJobs();</span>
<span class="fc" id="L428">          break;</span>
        case Service.STATUS_NAME:
<span class="fc" id="L430">          result = s1.getStatus().compareTo(s2.getStatus());</span>
<span class="fc" id="L431">          break;</span>
        case Service.NAME_NAME: // default sorting criterium
        default:
<span class="fc" id="L434">          result = s1.getName().compareToIgnoreCase(s2.getName());</span>
      }
<span class="fc bfc" id="L436" title="All 2 branches covered.">      return ascending ? result : 0 - result;</span>
    }
  }

  /** OSGI activate method. */
  @Activate
  public void activate() {
<span class="fc" id="L443">    logger.info(&quot;ServicesEndpoint is activated!&quot;);</span>
<span class="fc" id="L444">  }</span>

  /**
   * @param serviceRegistry
   *          the serviceRegistry to set
   */
  @Reference
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L452">    this.serviceRegistry = serviceRegistry;</span>
<span class="fc" id="L453">  }</span>

  /**
   * @param hostname of server to find in list
   * @param servers, list of known servers
   */
  private Optional&lt;HostRegistration&gt; findServerByHost(String hostname, List&lt;HostRegistration&gt; servers) {
<span class="fc" id="L460">    return servers.stream().filter(o -&gt; o.getBaseUrl().equals(hostname)).findFirst();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>