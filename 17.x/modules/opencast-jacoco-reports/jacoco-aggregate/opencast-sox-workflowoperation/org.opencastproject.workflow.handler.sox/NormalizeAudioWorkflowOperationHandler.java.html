<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>NormalizeAudioWorkflowOperationHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-sox-workflowoperation</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.workflow.handler.sox</a> &gt; <span class="el_source">NormalizeAudioWorkflowOperationHandler.java</span></div><h1>NormalizeAudioWorkflowOperationHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.workflow.handler.sox;

import org.opencastproject.composer.api.ComposerService;
import org.opencastproject.composer.api.EncoderException;
import org.opencastproject.job.api.Job;
import org.opencastproject.job.api.JobContext;
import org.opencastproject.mediapackage.AudioStream;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.selector.AbstractMediaPackageElementSelector;
import org.opencastproject.mediapackage.selector.TrackSelector;
import org.opencastproject.mediapackage.track.AudioStreamImpl;
import org.opencastproject.mediapackage.track.TrackImpl;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.sox.api.SoxException;
import org.opencastproject.sox.api.SoxService;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;
import org.opencastproject.workflow.api.ConfiguredTagsAndFlavors;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowOperationException;
import org.opencastproject.workflow.api.WorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowOperationInstance;
import org.opencastproject.workflow.api.WorkflowOperationResult;
import org.opencastproject.workflow.api.WorkflowOperationResult.Action;
import org.opencastproject.workspace.api.Workspace;

import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * The workflow definition for handling &quot;sox&quot; operations
 */
@Component(
    immediate = true,
    service = WorkflowOperationHandler.class,
    property = {
        &quot;service.description=Normalize Audio Workflow Operation Handler&quot;,
        &quot;workflow.operation=normalize-audio&quot;
    }
)
<span class="fc" id="L78">public class NormalizeAudioWorkflowOperationHandler extends AbstractWorkflowOperationHandler {</span>

  /** The logging facility */
<span class="fc" id="L81">  private static final Logger logger = LoggerFactory.getLogger(NormalizeAudioWorkflowOperationHandler.class);</span>

  /** Name of the 'encode to SoX audio only work copy' encoding profile */
  public static final String SOX_AONLY_PROFILE = &quot;sox-audio-only.work&quot;;

  /** Name of the muxing encoding profile */
  public static final String SOX_AREPLACE_PROFILE = &quot;sox-audio-replace.work&quot;;

  /** The SoX service */
<span class="fc" id="L90">  private SoxService soxService = null;</span>

  /** The composer service */
<span class="fc" id="L93">  private ComposerService composerService = null;</span>

  /** The local workspace */
<span class="fc" id="L96">  private Workspace workspace = null;</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param soxService
   *          the SoX service
   */
  @Reference
  protected void setSoxService(SoxService soxService) {
<span class="fc" id="L106">    this.soxService = soxService;</span>
<span class="fc" id="L107">  }</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param composerService
   *          the composer service
   */
  @Reference
  protected void setComposerService(ComposerService composerService) {
<span class="fc" id="L117">    this.composerService = composerService;</span>
<span class="fc" id="L118">  }</span>

  /**
   * Callback for declarative services configuration that will introduce us to the local workspace service.
   * Implementation assumes that the reference is configured as being static.
   *
   * @param workspace
   *          an instance of the workspace
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="fc" id="L129">    this.workspace = workspace;</span>
<span class="fc" id="L130">  }</span>

  @Reference
  @Override
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L135">    super.setServiceRegistry(serviceRegistry);</span>
<span class="fc" id="L136">  }</span>

  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)
          throws WorkflowOperationException {
<span class="fc" id="L140">    logger.debug(&quot;Running sox workflow operation on workflow {}&quot;, workflowInstance.getId());</span>

    try {
<span class="fc" id="L143">      return normalize(workflowInstance.getMediaPackage(), workflowInstance);</span>
<span class="nc" id="L144">    } catch (Exception e) {</span>
<span class="nc" id="L145">      throw new WorkflowOperationException(e);</span>
    }
  }

  private WorkflowOperationResult normalize(MediaPackage src, WorkflowInstance workflowInstance) throws SoxException,
          IOException, NotFoundException, MediaPackageException, WorkflowOperationException, EncoderException {
<span class="fc" id="L151">    MediaPackage mediaPackage = (MediaPackage) src.clone();</span>

<span class="fc" id="L153">    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();</span>

    // Check which tags have been configured
<span class="fc" id="L156">    ConfiguredTagsAndFlavors tagsAndFlavors = getTagsAndFlavors(workflowInstance, Configuration.many,</span>
        Configuration.many, Configuration.many, Configuration.many);
<span class="fc" id="L158">    List&lt;String&gt; targetTagsOption = tagsAndFlavors.getTargetTags();</span>
<span class="fc" id="L159">    List&lt;String&gt; sourceTagsOption = tagsAndFlavors.getSrcTags();</span>
<span class="fc" id="L160">    List&lt;MediaPackageElementFlavor&gt; sourceFlavorsOption = tagsAndFlavors.getSrcFlavors();</span>
<span class="fc" id="L161">    List&lt;MediaPackageElementFlavor&gt; targetFlavorOption = tagsAndFlavors.getTargetFlavors();</span>

<span class="fc" id="L163">    String targetDecibelString = StringUtils.trimToNull(operation.getConfiguration(&quot;target-decibel&quot;));</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">    if (targetDecibelString == null) {</span>
<span class="nc" id="L165">      throw new IllegalArgumentException(&quot;target-decibel must be specified&quot;);</span>
    }
<span class="fc" id="L167">    boolean forceTranscode = BooleanUtils.toBoolean(operation.getConfiguration(&quot;force-transcode&quot;));</span>
    Float targetDecibel;
    try {
<span class="fc" id="L170">      targetDecibel = new Float(targetDecibelString);</span>
<span class="nc" id="L171">    } catch (NumberFormatException e1) {</span>
<span class="nc" id="L172">      throw new WorkflowOperationException(&quot;Unable to parse target-decibel &quot; + targetDecibelString);</span>
<span class="fc" id="L173">    }</span>

<span class="fc" id="L175">    AbstractMediaPackageElementSelector&lt;Track&gt; elementSelector = new TrackSelector();</span>

    // Make sure either one of tags or flavors are provided
<span class="pc bpc" id="L178" title="2 of 4 branches missed.">    if (sourceTagsOption.isEmpty() &amp;&amp; sourceFlavorsOption.isEmpty()) {</span>
<span class="nc" id="L179">      logger.info(&quot;No source tags or flavors have been specified, not matching anything&quot;);</span>
<span class="nc" id="L180">      return createResult(mediaPackage, Action.CONTINUE);</span>
    }

    // Select the source flavors
<span class="fc bfc" id="L184" title="All 2 branches covered.">    for (MediaPackageElementFlavor flavor : sourceFlavorsOption) {</span>
<span class="fc" id="L185">      elementSelector.addFlavor(flavor);</span>
<span class="fc" id="L186">    }</span>

    // Select the source tags
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">    for (String tag : sourceTagsOption) {</span>
<span class="nc" id="L190">      elementSelector.addTag(tag);</span>
<span class="nc" id="L191">    }</span>

    //select target flavor
<span class="fc" id="L194">    MediaPackageElementFlavor targetFlavor = null;</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">    if (!targetFlavorOption.isEmpty()) {</span>
<span class="fc" id="L196">      targetFlavor = targetFlavorOption.get(0);</span>
    }

    // Look for elements matching the tag
<span class="fc" id="L200">    Collection&lt;Track&gt; elements = elementSelector.select(mediaPackage, false);</span>

    // Encode all tracks found
<span class="fc" id="L203">    long totalTimeInQueue = 0;</span>
<span class="fc" id="L204">    List&lt;URI&gt; cleanupURIs = new ArrayList&lt;URI&gt;();</span>
<span class="fc" id="L205">    Map&lt;Job, Track&gt; normalizeJobs = new HashMap&lt;Job, Track&gt;();</span>
    try {
<span class="fc bfc" id="L207" title="All 2 branches covered.">      for (Track track : elements) {</span>

<span class="fc" id="L209">        TrackImpl audioTrack = (TrackImpl) track;</span>
        // Skip video only mismatches
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (!track.hasAudio()) {</span>
<span class="nc" id="L212">          logger.info(&quot;Skipping audio normalization of '{}', since it contains no audio stream&quot;, track);</span>
<span class="nc" id="L213">          continue;</span>
<span class="pc bpc" id="L214" title="1 of 4 branches missed.">        } else if (track.hasVideo() || forceTranscode) {</span>
<span class="fc" id="L215">          audioTrack = (TrackImpl) extractAudioTrack(track);</span>
<span class="fc" id="L216">          audioTrack.setAudio(((TrackImpl) track).getAudio());</span>
<span class="fc" id="L217">          cleanupURIs.add(audioTrack.getURI());</span>
        }

        // Analyze audio track
<span class="pc bpc" id="L221" title="2 of 4 branches missed.">        if (audioTrack.getAudio().size() &lt; 1 || audioTrack.getAudio().get(0).getRmsLevDb() == null) {</span>
<span class="fc" id="L222">          logger.info(&quot;Audio track {} has no RMS Lev dB metadata, analyze it first&quot;, audioTrack);</span>
<span class="fc" id="L223">          Job analyzeJob = soxService.analyze(audioTrack);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">          if (!waitForStatus(analyzeJob).isSuccess()) {</span>
<span class="nc" id="L225">            throw new WorkflowOperationException(&quot;Unable to analyze the audio track &quot; + audioTrack);</span>
          }
<span class="fc" id="L227">          audioTrack = (TrackImpl) MediaPackageElementParser.getFromXml(analyzeJob.getPayload());</span>
<span class="fc" id="L228">          cleanupURIs.add(audioTrack.getURI());</span>
        }

<span class="fc" id="L231">        normalizeJobs.put(soxService.normalize(audioTrack, targetDecibel), track);</span>
<span class="fc" id="L232">      }</span>

<span class="pc bpc" id="L234" title="1 of 2 branches missed.">      if (normalizeJobs.isEmpty()) {</span>
<span class="nc" id="L235">        logger.info(&quot;No matching tracks found&quot;);</span>
<span class="nc" id="L236">        return createResult(mediaPackage, Action.CONTINUE);</span>
      }

      // Wait for the jobs to return
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">      if (!waitForStatus(normalizeJobs.keySet().toArray(new Job[normalizeJobs.size()])).isSuccess()) {</span>
<span class="nc" id="L241">        throw new WorkflowOperationException(&quot;One of the normalize jobs did not complete successfully&quot;);</span>
      }

      // Process the result
<span class="fc bfc" id="L245" title="All 2 branches covered.">      for (Map.Entry&lt;Job, Track&gt; entry : normalizeJobs.entrySet()) {</span>
<span class="fc" id="L246">        Job job = entry.getKey();</span>
<span class="fc" id="L247">        TrackImpl origTrack = (TrackImpl) entry.getValue();</span>

        // add this receipt's queue time to the total
<span class="fc" id="L250">        totalTimeInQueue += job.getQueueTime();</span>

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (job.getPayload().length() &gt; 0) {</span>
<span class="fc" id="L253">          TrackImpl normalizedAudioTrack = (TrackImpl) MediaPackageElementParser.getFromXml(job.getPayload());</span>

<span class="fc" id="L255">          TrackImpl resultTrack = normalizedAudioTrack;</span>
<span class="pc bpc" id="L256" title="1 of 4 branches missed.">          if (origTrack.hasVideo() || forceTranscode) {</span>
<span class="fc" id="L257">            cleanupURIs.add(normalizedAudioTrack.getURI());</span>

<span class="fc" id="L259">            logger.info(&quot;Mux normalized audio track {} to video track {}&quot;, normalizedAudioTrack, origTrack);</span>
<span class="fc" id="L260">            Job muxAudioVideo = composerService.mux(origTrack, normalizedAudioTrack, SOX_AREPLACE_PROFILE);</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">            if (!waitForStatus(muxAudioVideo).isSuccess()) {</span>
<span class="nc" id="L262">              throw new WorkflowOperationException(&quot;Muxing normalized audio track &quot; + normalizedAudioTrack</span>
                      + &quot; to video container &quot; + origTrack + &quot; failed&quot;);
            }

<span class="fc" id="L266">            resultTrack = (TrackImpl) MediaPackageElementParser.getFromXml(muxAudioVideo.getPayload());</span>

            // Set metadata on track
<span class="fc" id="L269">            extendAudioStream(resultTrack, normalizedAudioTrack);</span>
          }

<span class="fc" id="L272">          adjustFlavorAndTags(targetTagsOption, targetFlavor, origTrack, resultTrack);</span>

<span class="fc" id="L274">          mediaPackage.addDerived(resultTrack, origTrack);</span>
<span class="fc" id="L275">          String fileName = getFileNameFromElements(origTrack, resultTrack);</span>
<span class="fc" id="L276">          resultTrack.setURI(workspace.moveTo(resultTrack.getURI(), mediaPackage.getIdentifier().toString(),</span>
<span class="fc" id="L277">                  resultTrack.getIdentifier(), fileName));</span>
<span class="fc" id="L278">        } else {</span>
<span class="nc" id="L279">          logger.warn(&quot;Normalize audio job {} for track {} has no result!&quot;, job, origTrack);</span>
        }
<span class="fc" id="L281">      }</span>
    } finally {
      // Clean up temporary audio and video files from workspace
<span class="fc bfc" id="L284" title="All 2 branches covered.">      for (URI uri : cleanupURIs) {</span>
<span class="fc" id="L285">        workspace.delete(uri);</span>
<span class="fc" id="L286">      }</span>
    }

<span class="fc" id="L289">    WorkflowOperationResult result = createResult(mediaPackage, Action.CONTINUE, totalTimeInQueue);</span>
<span class="fc" id="L290">    logger.debug(&quot;Normalize audio operation completed&quot;);</span>
<span class="fc" id="L291">    return result;</span>
  }

  private void extendAudioStream(TrackImpl trackToExtend, TrackImpl audioTrackSource) {
<span class="fc" id="L295">    AudioStreamImpl extendStream = (AudioStreamImpl) trackToExtend.getAudio().get(0);</span>
<span class="fc" id="L296">    AudioStream sourceStream = audioTrackSource.getAudio().get(0);</span>
<span class="fc" id="L297">    extendStream.setPkLevDb(sourceStream.getPkLevDb());</span>
<span class="fc" id="L298">    extendStream.setRmsLevDb(sourceStream.getRmsLevDb());</span>
<span class="fc" id="L299">    extendStream.setRmsPkDb(sourceStream.getRmsPkDb());</span>
<span class="fc" id="L300">  }</span>

  private void adjustFlavorAndTags(List&lt;String&gt; targetTags, MediaPackageElementFlavor targetFlavor, Track origTrack,
          Track normalized) {
    // Adjust the target tags
<span class="fc bfc" id="L305" title="All 2 branches covered.">    for (String tag : targetTags) {</span>
<span class="fc" id="L306">      logger.trace(&quot;Tagging normalized track with '{}'&quot;, tag);</span>
<span class="fc" id="L307">      normalized.addTag(tag);</span>
<span class="fc" id="L308">    }</span>

    // Adjust the target flavor. Make sure to account for partial updates
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">    if (targetFlavor != null) {</span>
<span class="fc" id="L312">      String flavorType = targetFlavor.getType();</span>
<span class="fc" id="L313">      String flavorSubtype = targetFlavor.getSubtype();</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">      if (&quot;*&quot;.equals(flavorType)) {</span>
<span class="fc" id="L315">        flavorType = origTrack.getFlavor().getType();</span>
      }
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">      if (&quot;*&quot;.equals(flavorSubtype)) {</span>
<span class="nc" id="L318">        flavorSubtype = origTrack.getFlavor().getSubtype();</span>
      }
<span class="fc" id="L320">      normalized.setFlavor(new MediaPackageElementFlavor(flavorType, flavorSubtype));</span>
<span class="fc" id="L321">      logger.debug(&quot;Normalized track has flavor '{}'&quot;, normalized.getFlavor());</span>
    }
<span class="fc" id="L323">  }</span>

  /**
   * Extract the audio track from the given video track.
   *
   * @param videoTrack
   *          the track containing the audio
   * @return the extracted audio track
   * @throws WorkflowOperationException
   * @throws NotFoundException
   * @throws EncoderException
   * @throws MediaPackageException
   */
  private Track extractAudioTrack(Track videoTrack) throws WorkflowOperationException, EncoderException,
          MediaPackageException {
<span class="fc" id="L338">    logger.info(&quot;Extract audio stream from track {}&quot;, videoTrack);</span>
<span class="fc" id="L339">    Job job = composerService.encode(videoTrack, SOX_AONLY_PROFILE);</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">    if (!waitForStatus(job).isSuccess()) {</span>
<span class="nc" id="L341">      throw new WorkflowOperationException(&quot;Extracting audio track from video track &quot; + videoTrack + &quot; failed&quot;);</span>
    }

<span class="fc" id="L344">    return (Track) MediaPackageElementParser.getFromXml(job.getPayload());</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>