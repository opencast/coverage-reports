<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SanitizeAdaptiveWorkflowOperationHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-composer-workflowoperation</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.workflow.handler.composer</a> &gt; <span class="el_source">SanitizeAdaptiveWorkflowOperationHandler.java</span></div><h1>SanitizeAdaptiveWorkflowOperationHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.workflow.handler.composer;

import org.opencastproject.composer.api.EncoderException;
import org.opencastproject.job.api.JobContext;
import org.opencastproject.mediapackage.AdaptivePlaylist;
import org.opencastproject.mediapackage.AdaptivePlaylist.HLSMediaPackageCheck;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.selector.TrackSelector;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.data.Function2;
import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;
import org.opencastproject.workflow.api.ConfiguredTagsAndFlavors;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowOperationException;
import org.opencastproject.workflow.api.WorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowOperationInstance;
import org.opencastproject.workflow.api.WorkflowOperationResult;
import org.opencastproject.workflow.api.WorkflowOperationResult.Action;
import org.opencastproject.workspace.api.Workspace;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.function.Function;

/**
 * The &lt;code&gt;&lt;/code&gt; operation will make sure that media where hls playlists and video track come in separate files
 * will have appropriately references prior to further processing such as inspection.
 */
@Component(
    immediate = true,
    service = WorkflowOperationHandler.class,
    property = {
        &quot;service.description=Sanitize Adaptive Workflow Operation Handler&quot;,
        &quot;workflow.operation=sanitize-adaptive&quot;
    }
)
<span class="fc" id="L74">public class SanitizeAdaptiveWorkflowOperationHandler extends AbstractWorkflowOperationHandler {</span>

  /** The logging facility */
<span class="fc" id="L77">  private static final Logger logger = LoggerFactory.getLogger(SanitizeAdaptiveWorkflowOperationHandler.class);</span>
  private static final String PLUS = &quot;+&quot;;
  private static final String MINUS = &quot;-&quot;;

  /** The local workspace */
<span class="fc" id="L82">  private Workspace workspace = null;</span>

  /**
   * Callback for declarative services configuration that will introduce us to the local workspace service.
   * Implementation assumes that the reference is configured as being static.
   *
   * @param workspace
   *          an instance of the workspace
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="fc" id="L93">    this.workspace = workspace;</span>
<span class="fc" id="L94">  }</span>

  @Reference
  @Override
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L99">    super.setServiceRegistry(serviceRegistry);</span>
<span class="fc" id="L100">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,
   *      JobContext)
   */
  @Override
  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)
          throws WorkflowOperationException {
<span class="fc" id="L111">    logger.debug(&quot;Running HLS Check workflow operation on workflow {}&quot;, workflowInstance.getId());</span>
    try {
<span class="fc" id="L113">      return sanitizeHLS(workflowInstance);</span>
<span class="fc" id="L114">    } catch (Exception e) {</span>
<span class="fc" id="L115">      throw new WorkflowOperationException(e);</span>
    }
  }

  /**
   * Checks the references in the playists and make sure that the playlists can pass though an ffmpeg inspection. If the
   * file references are off, they will be rewritten. The problem is mainly the media package elementID.
   *
   * @param wi
   *          the sanitizeHLS workflow instance
   * @return the operation result containing the updated mediapackage
   * @throws EncoderException
   *           if encoding fails
   * @throws IOException
   *           if read/write operations from and to the workspace fail
   * @throws NotFoundException
   *           if the workspace does not contain the requested element
   * @throws URISyntaxException
   */
  private WorkflowOperationResult sanitizeHLS(WorkflowInstance wi)
          throws EncoderException,
          WorkflowOperationException, NotFoundException, MediaPackageException, IOException, URISyntaxException {
<span class="fc" id="L137">    MediaPackage src = wi.getMediaPackage();</span>
<span class="fc" id="L138">    MediaPackage mediaPackage = (MediaPackage) src.clone();</span>

<span class="fc" id="L140">    WorkflowOperationInstance operation = wi.getCurrentOperation();</span>

    // Check which tags have been configured
<span class="fc" id="L143">    ConfiguredTagsAndFlavors tagsAndFlavors = getTagsAndFlavors(wi,</span>
        Configuration.none, Configuration.one, Configuration.many, Configuration.one);

    // Read the configuration properties
<span class="fc" id="L147">    MediaPackageElementFlavor sourceFlavor = tagsAndFlavors.getSingleSrcFlavor();</span>
<span class="fc" id="L148">    List&lt;String&gt; targetTrackTags = tagsAndFlavors.getTargetTags();</span>
<span class="fc" id="L149">    MediaPackageElementFlavor targetFlavor = tagsAndFlavors.getSingleTargetFlavor();</span>

<span class="fc" id="L151">    List&lt;String&gt; removeTags = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L152">    List&lt;String&gt; addTags = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L153">    List&lt;String&gt; overrideTags = new ArrayList&lt;String&gt;();</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">    if (!targetTrackTags.isEmpty()) {</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">      for (String tag : targetTrackTags) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (tag.startsWith(MINUS)) {</span>
<span class="fc" id="L158">          removeTags.add(tag);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        } else if (tag.startsWith(PLUS)) {</span>
<span class="fc" id="L160">          addTags.add(tag);</span>
        } else {
<span class="fc" id="L162">          overrideTags.add(tag);</span>
        }
<span class="fc" id="L164">      }</span>
    }

    // Select those tracks that have matching flavors
<span class="fc" id="L168">    TrackSelector trackSelector = new TrackSelector();</span>
<span class="fc" id="L169">    trackSelector.addFlavor(sourceFlavor);</span>
<span class="fc" id="L170">    Collection&lt;Track&gt; tracks = trackSelector.select(mediaPackage, false);</span>
<span class="fc" id="L171">    List&lt;Track&gt; tracklist = new ArrayList&lt;&gt;(tracks);</span>

    // Nothing to sanitize, do not set target tags or flavor on tracks, just return
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">    if (!tracklist.stream().filter(AdaptivePlaylist.isHLSTrackPred).findAny().isPresent()) {</span>
<span class="nc" id="L175">      return createResult(mediaPackage, Action.CONTINUE, 0);</span>
    }
    HLSMediaPackageCheck hlstree;
    try {
<span class="fc" id="L179">      hlstree = new HLSMediaPackageCheck(tracklist, new Function&lt;URI, File&gt;() {</span>
        @Override
        public File apply(URI uri) {
          try {
<span class="fc" id="L183">            return workspace.get(uri);</span>
<span class="nc" id="L184">          } catch (NotFoundException | IOException e1) { // from workspace.get</span>
<span class="nc" id="L185">            logger.error(&quot;Cannot get {} from workspace&quot;, uri, e1);</span>
          }
<span class="nc" id="L187">          return null;</span>
        }
      });
<span class="nc" id="L190">    } catch (URISyntaxException e1) {</span>
<span class="nc" id="L191">      throw new MediaPackageException(&quot;Cannot process tracks from workspace&quot;);</span>
<span class="fc" id="L192">    }</span>
    /**
     * Adds new file to Mediapackage to replace old Track, while retaining all properties. Also sets the target flavor
     * and target tags
     */
<span class="fc" id="L197">    Function2&lt;File, Track, Track&gt; replaceHLSPlaylistInWS = new Function2&lt;File, Track, Track&gt;() {</span>
      @Override
      public Track apply(File file, Track track) {
        try {
<span class="fc" id="L201">          InputStream inputStream = new FileInputStream(file);</span>
          // put file into workspace for mp
<span class="fc" id="L203">          URI uri = workspace.put(mediaPackage.getIdentifier().toString(), track.getIdentifier(), file.getName(),</span>
                  inputStream);
<span class="fc" id="L205">          track.setURI(uri); // point track to new URI</span>
<span class="fc" id="L206">          handleTags(track, targetFlavor, overrideTags, removeTags, addTags); // add tags and flavor</span>
<span class="fc" id="L207">          return track;</span>
<span class="nc" id="L208">        } catch (Exception e) {</span>
<span class="nc" id="L209">          logger.error(&quot;Cannot add track file to mediapackage in workspace: {} {} &quot;,</span>
<span class="nc" id="L210">                  mediaPackage.getIdentifier().toString(),</span>
                  file);
<span class="nc" id="L212">          return null;</span>
        }
      }
    };
    // remove old tracks if the entire operation succeeds, or remove new tracks if any of them fails
<span class="fc" id="L217">    Function&lt;Track, Void&gt; removeFromWS = new Function&lt;Track, Void&gt;() {</span>
      @Override
      public Void apply(Track track) {
        try {
<span class="fc" id="L221">          workspace.delete(track.getURI());</span>
<span class="nc" id="L222">        } catch (NotFoundException e) {</span>
<span class="nc" id="L223">          logger.error(&quot;Cannot delete from workspace: File not found {} &quot;, track);</span>
<span class="nc" id="L224">        } catch (IOException e) {</span>
<span class="nc" id="L225">          logger.error(&quot;Cannot delete from workspace: IO Error {} &quot;, track);</span>
<span class="pc" id="L226">        }</span>
<span class="fc" id="L227">        return null;</span>
      }
    };
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">    if (hlstree.needsRewriting()) {</span>
      // rewrites the playlists and replaced the old ones in the mp
      try {
<span class="fc" id="L233">        hlstree.rewriteHLS(mediaPackage, replaceHLSPlaylistInWS, removeFromWS);</span>
<span class="nc" id="L234">      } catch (Exception e) {</span>
<span class="nc" id="L235">        logger.error(&quot;Error: cannot rewrite HLS renditions&quot;, e);</span>
<span class="nc" id="L236">        throw new WorkflowOperationException(e);</span>
<span class="fc" id="L237">      }</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">      for (Track track : tracks) { // Update the flavor and tags for all non HLS segments</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (!AdaptivePlaylist.isPlaylist(track.getURI().getPath())) {</span>
<span class="fc" id="L240">          handleTags(track, targetFlavor, overrideTags, removeTags, addTags);</span>
<span class="fc" id="L241">          logger.info(&quot;Set flavor {} and tags to {} &quot;, track, targetFlavor);</span>
        }
<span class="fc" id="L243">      }</span>
    } else { // change flavor to mark as sanitized
<span class="nc bnc" id="L245" title="All 2 branches missed.">      for (Track track : tracks) {</span>
<span class="nc" id="L246">        handleTags(track, targetFlavor, overrideTags, removeTags, addTags);</span>
<span class="nc" id="L247">        logger.info(&quot;Set flavor {} and tags to {} &quot;, track, targetFlavor);</span>
<span class="nc" id="L248">      }</span>
    }
<span class="fc" id="L250">    return createResult(mediaPackage, Action.CONTINUE, 0);</span>
  }

  // Add the target tags and flavor
  private void handleTags(Track track, MediaPackageElementFlavor targetFlavor, List&lt;String&gt; overrideTags,
          List&lt;String&gt; removeTags, List&lt;String&gt; addTags) {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">    if (targetFlavor != null) {</span>
<span class="fc" id="L257">      String flavorType = targetFlavor.getType();</span>
<span class="fc" id="L258">      String flavorSubtype = targetFlavor.getSubtype();</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">      if (&quot;*&quot;.equals(flavorType))</span>
<span class="fc" id="L260">        flavorType = track.getFlavor().getType();</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">      if (&quot;*&quot;.equals(flavorSubtype))</span>
<span class="fc" id="L262">        flavorSubtype = track.getFlavor().getSubtype();</span>
<span class="fc" id="L263">      track.setFlavor(new MediaPackageElementFlavor(flavorType, flavorSubtype));</span>
<span class="fc" id="L264">      logger.debug(&quot;Composed track has flavor '{}'&quot;, track.getFlavor());</span>
    }
<span class="fc bfc" id="L266" title="All 2 branches covered.">    if (overrideTags.size() &gt; 0) {</span>
<span class="fc" id="L267">      track.clearTags();</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">      for (String tag : overrideTags) {</span>
<span class="fc" id="L269">        logger.trace(&quot;Tagging composed track with '{}'&quot;, tag);</span>
<span class="fc" id="L270">        track.addTag(tag);</span>
<span class="fc" id="L271">      }</span>
    } else {
<span class="fc bfc" id="L273" title="All 2 branches covered.">      for (String tag : removeTags) {</span>
<span class="fc" id="L274">        logger.trace(&quot;Remove tagging '{}' from composed track&quot;, tag);</span>
<span class="fc" id="L275">        track.removeTag(tag.substring(MINUS.length()));</span>
<span class="fc" id="L276">      }</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">      for (String tag : addTags) {</span>
<span class="fc" id="L278">        logger.trace(&quot;Add tagging '{}' to composed track&quot;, tag);</span>
<span class="fc" id="L279">        track.addTag(tag.substring(PLUS.length()));</span>
<span class="fc" id="L280">      }</span>
    }
<span class="fc" id="L282">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>