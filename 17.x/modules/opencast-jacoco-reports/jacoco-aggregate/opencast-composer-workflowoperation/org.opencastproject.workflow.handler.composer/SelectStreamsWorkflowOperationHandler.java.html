<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SelectStreamsWorkflowOperationHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-composer-workflowoperation</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.workflow.handler.composer</a> &gt; <span class="el_source">SelectStreamsWorkflowOperationHandler.java</span></div><h1>SelectStreamsWorkflowOperationHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.workflow.handler.composer;

import org.opencastproject.composer.api.ComposerService;
import org.opencastproject.composer.api.EncoderException;
import org.opencastproject.composer.api.EncodingProfile;
import org.opencastproject.job.api.Job;
import org.opencastproject.job.api.JobContext;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.selector.TrackSelector;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;
import org.opencastproject.workflow.api.ConfiguredTagsAndFlavors;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowOperationException;
import org.opencastproject.workflow.api.WorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowOperationResult;
import org.opencastproject.workflow.api.WorkflowOperationTagUtil;
import org.opencastproject.workspace.api.Workspace;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.function.Consumer;
import java.util.stream.Collectors;

@Component(
    immediate = true,
    service = WorkflowOperationHandler.class,
    property = {
        &quot;service.description=Hide/unhide specific tracks in a media package&quot;,
        &quot;workflow.operation=select-tracks&quot;
    }
)
<span class="nc" id="L71">public class SelectStreamsWorkflowOperationHandler extends AbstractWorkflowOperationHandler {</span>
<span class="nc" id="L72">  private static final Logger logger = LoggerFactory.getLogger(SelectStreamsWorkflowOperationHandler.class);</span>

  /** Name of the 'encode to video only work copy' encoding profile */
  private static final String PREPARE_VIDEO_ONLY_PROFILE = &quot;video-only.copy&quot;;

  /** Name of the 'encode to video only work copy' encoding profile */
  private static final String PREPARE_AUDIO_ONLY_PROFILE = &quot;audio-only.copy&quot;;

  /** Name of the muxing encoding profile */
  private static final String MUX_AV_PROFILE = &quot;mux-av.copy&quot;;

  /** The composer service */
<span class="nc" id="L84">  private ComposerService composerService = null;</span>

  /** The local workspace */
<span class="nc" id="L87">  private Workspace workspace = null;</span>

<span class="nc" id="L89">  private enum AudioMuxing {</span>
<span class="nc" id="L90">    NONE, FORCE, DUPLICATE;</span>

    @Override
    public String toString() {
<span class="nc" id="L94">      return super.toString().toLowerCase();</span>
    }

    static AudioMuxing fromConfigurationString(final String s) {
<span class="nc" id="L98">      return AudioMuxing.valueOf(s.toUpperCase());</span>
    }
  }

  private static final String CONFIG_AUDIO_MUXING = &quot;audio-muxing&quot;;

  private static final String CONFIG_FORCE_TARGET = &quot;force-target&quot;;

  private static final String FORCE_TARGET_DEFAULT = &quot;presenter&quot;;

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param composerService
   *          the local composer service
   */
  @Reference
  protected void setComposerService(final ComposerService composerService) {
<span class="nc" id="L116">    this.composerService = composerService;</span>
<span class="nc" id="L117">  }</span>

  @Reference
  @Override
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="nc" id="L122">    super.setServiceRegistry(serviceRegistry);</span>
<span class="nc" id="L123">  }</span>

  /**
   * Callback for declarative services configuration that will introduce us to the local workspace service.
   * Implementation assumes that the reference is configured as being static.
   *
   * @param workspace
   *          an instance of the workspace
   */
  @Reference
  public void setWorkspace(final Workspace workspace) {
<span class="nc" id="L134">    this.workspace = workspace;</span>
<span class="nc" id="L135">  }</span>

  private EncodingProfile getProfile(final String identifier) throws WorkflowOperationException {
<span class="nc" id="L138">    final EncodingProfile profile = this.composerService.getProfile(identifier);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">    if (profile == null) {</span>
<span class="nc" id="L140">      throw new WorkflowOperationException(String.format(&quot;couldn't find encoding profile \&quot;%s\&quot;&quot;, identifier));</span>
    }
<span class="nc" id="L142">    return profile;</span>
  }

  private static Optional&lt;String&gt; getConfiguration(final WorkflowInstance instance, final String key) {
<span class="nc" id="L146">    return Optional.ofNullable(instance.getCurrentOperation().getConfiguration(key)).map(StringUtils::trimToNull);</span>
  }

<span class="nc" id="L149">  private enum SubTrack {</span>
<span class="nc" id="L150">    AUDIO, VIDEO</span>
  }

  /**
   * During our operations, we accumulate new tracks and wait times, for which we have this nice helper class
   */
  private static final class MuxResult {
    private long queueTime;
    private final Collection&lt;Track&gt; tracks;

<span class="nc" id="L160">    private MuxResult(final long queueTime, final Collection&lt;Track&gt; tracks) {</span>
<span class="nc" id="L161">      this.queueTime = queueTime;</span>
<span class="nc" id="L162">      this.tracks = tracks;</span>
<span class="nc" id="L163">    }</span>

    static MuxResult empty() {
<span class="nc" id="L166">      return new MuxResult(0L, new ArrayList&lt;&gt;(0));</span>
    }

    void forEachTrack(final Consumer&lt;Track&gt; trackConsumer) {
<span class="nc" id="L170">      tracks.forEach(trackConsumer);</span>
<span class="nc" id="L171">    }</span>

    public void add(final TrackJobResult jobResult) {
<span class="nc" id="L174">      this.queueTime += jobResult.waitTime;</span>
<span class="nc" id="L175">      this.tracks.add(jobResult.track);</span>
<span class="nc" id="L176">    }</span>

    public void add(final MuxResult muxResult) {
<span class="nc" id="L179">      this.queueTime += muxResult.queueTime;</span>
<span class="nc" id="L180">      this.tracks.addAll(muxResult.tracks);</span>
<span class="nc" id="L181">    }</span>
  }

  private static final class AugmentedTrack {
    private final Track track;
    private final boolean hideAudio;
    private final boolean hideVideo;

<span class="nc" id="L189">    private AugmentedTrack(final Track track, final boolean hideAudio, final boolean hideVideo) {</span>
<span class="nc" id="L190">      this.track = track;</span>
<span class="nc" id="L191">      this.hideAudio = hideAudio;</span>
<span class="nc" id="L192">      this.hideVideo = hideVideo;</span>
<span class="nc" id="L193">    }</span>

    boolean has(final SubTrack t) {
<span class="nc bnc" id="L196" title="All 2 branches missed.">      if (t == SubTrack.AUDIO) {</span>
<span class="nc" id="L197">        return hasAudio();</span>
      } else {
<span class="nc" id="L199">        return hasVideo();</span>
      }
    }

    boolean hide(final SubTrack t) {
<span class="nc bnc" id="L204" title="All 2 branches missed.">      if (t == SubTrack.AUDIO) {</span>
<span class="nc" id="L205">        return hideAudio;</span>
      } else {
<span class="nc" id="L207">        return hideVideo;</span>
      }
    }

    boolean hasAudio() {
<span class="nc" id="L212">      return track.hasAudio();</span>
    }

    boolean hasVideo() {
<span class="nc" id="L216">      return track.hasVideo();</span>
    }

    String getFlavorType() {
<span class="nc" id="L220">      return track.getFlavor().getType();</span>
    }

    public String toString() {
<span class="nc" id="L224">      return String.format(&quot;ID: %s, Flavor: %s [hasAudio %s, hideAudio %s, hasVideo %s, hideVideo: %s]&quot;,</span>
<span class="nc" id="L225">          track.getIdentifier(),track.getFlavor(),</span>
<span class="nc" id="L226">          hasAudio(), hide(SubTrack.AUDIO),</span>
<span class="nc" id="L227">          hasVideo(), hide(SubTrack.VIDEO)</span>
      );
    }
  }

  @Override
  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, final JobContext context)
          throws WorkflowOperationException {
    try {
<span class="nc" id="L236">      return doStart(workflowInstance);</span>
<span class="nc" id="L237">    } catch (final EncoderException | MediaPackageException | IOException | NotFoundException e) {</span>
<span class="nc" id="L238">      throw new WorkflowOperationException(e);</span>
    }
  }

  private WorkflowOperationResult doStart(final WorkflowInstance workflowInstance)
          throws WorkflowOperationException, EncoderException, MediaPackageException, NotFoundException, IOException {
<span class="nc" id="L244">    final MediaPackage mediaPackage = workflowInstance.getMediaPackage();</span>

<span class="nc" id="L246">    ConfiguredTagsAndFlavors tagsAndFlavors = getTagsAndFlavors(workflowInstance,</span>
        Configuration.none, Configuration.one, Configuration.many, Configuration.one);

<span class="nc" id="L249">    final MediaPackageElementFlavor sourceFlavor = tagsAndFlavors.getSingleSrcFlavor();</span>
<span class="nc" id="L250">    final MediaPackageElementFlavor targetTrackFlavor = tagsAndFlavors.getSingleTargetFlavor();</span>
<span class="nc" id="L251">    final List&lt;String&gt; targetTrackTags = tagsAndFlavors.getTargetTags();</span>

<span class="nc" id="L253">    TrackSelector trackSelector = new TrackSelector();</span>
<span class="nc" id="L254">    trackSelector.addFlavor(sourceFlavor);</span>
<span class="nc" id="L255">    final Collection&lt;Track&gt; tracks = trackSelector.select(mediaPackage, false);</span>

<span class="nc bnc" id="L257" title="All 2 branches missed.">    if (tracks.isEmpty()) {</span>
<span class="nc" id="L258">      logger.info(&quot;No audio/video tracks with flavor '{}' found to prepare&quot;, sourceFlavor);</span>
<span class="nc" id="L259">      return createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);</span>
    }

<span class="nc" id="L262">    final List&lt;AugmentedTrack&gt; augmentedTracksAll = createAugmentedTracks(tracks, workflowInstance);</span>
<span class="nc" id="L263">    List&lt;AugmentedTrack&gt; augmentedTracks = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L265">    final MuxResult result = MuxResult.empty();</span>

    // add non video/audio tracks, like captions, directly to result as only video/audio tracks are relevant for selection
<span class="nc bnc" id="L268" title="All 2 branches missed.">    for (final AugmentedTrack t : augmentedTracksAll) {</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">      if (t.hasVideo() || t.hasAudio()) {</span>
<span class="nc" id="L270">        augmentedTracks.add(t);</span>
      } else {
<span class="nc" id="L272">        result.add(copyTrack(t.track));</span>
      }
<span class="nc" id="L274">    }</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">    if (allNonHidden(augmentedTracks, SubTrack.VIDEO)) {</span>
      // Case 1: We have only tracks with non-hidden video streams. So we keep them all and possibly cut away audio.

<span class="nc" id="L279">      final AudioMuxing audioMuxing = getConfiguration(workflowInstance, CONFIG_AUDIO_MUXING)</span>
<span class="nc" id="L280">              .map(AudioMuxing::fromConfigurationString).orElse(AudioMuxing.NONE);</span>
<span class="nc" id="L281">      final Optional&lt;AugmentedTrack&gt; singleAudioTrackOpt = findSingleAudioTrack(augmentedTracks);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">      final boolean multipleVideo = augmentedTracks.size() &gt; 1;</span>

<span class="nc bnc" id="L284" title="All 6 branches missed.">      if (multipleVideo &amp;&amp; audioMuxing == AudioMuxing.DUPLICATE &amp;&amp; singleAudioTrackOpt.isPresent()) {</span>
        /* Case 1.1: We have more than one track, all tracks have non-hidden video streams and exactly one track has
           an audio stream. Audio muxing is set to DUPLICATE, so duplicate the single audio stream into all tracks */
<span class="nc" id="L287">        logger.debug(&quot;Duplicate the audio stream of track {} into all tracks&quot;, singleAudioTrackOpt.get());</span>
<span class="nc" id="L288">        final AugmentedTrack singleAudioTrack = singleAudioTrackOpt.get();</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        for (final AugmentedTrack t : augmentedTracks) {</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">          if (t.track != singleAudioTrack.track) {</span>
<span class="nc" id="L291">            final TrackJobResult jobResult = mux(t.track, singleAudioTrack.track, mediaPackage);</span>
<span class="nc" id="L292">            result.add(jobResult);</span>
<span class="nc" id="L293">          } else {</span>
<span class="nc" id="L294">            result.add(copyTrack(t.track));</span>
          }
<span class="nc" id="L296">        }</span>
<span class="nc bnc" id="L297" title="All 6 branches missed.">      } else if (multipleVideo &amp;&amp; audioMuxing == AudioMuxing.FORCE &amp;&amp; singleAudioTrackOpt.isPresent()) {</span>
        /* Case 1.2: We have more than one track, all tracks have non-hidden video streams and exactly one track has
           an audio stream. Audio muxing is set to FORCE, so we enforce that the audio stream is moved to the track
           specified by CONFIG_FORCE_TARGET if not already there */
<span class="nc" id="L301">        logger.debug(&quot;Enforce audio stream to be present in track {} only&quot;, singleAudioTrackOpt.get());</span>
<span class="nc" id="L302">        final AugmentedTrack singleAudioTrack = singleAudioTrackOpt.get();</span>
<span class="nc" id="L303">        final String forceTargetOpt = getConfiguration(workflowInstance, CONFIG_FORCE_TARGET)</span>
<span class="nc" id="L304">                .orElse(FORCE_TARGET_DEFAULT);</span>

<span class="nc" id="L306">        final Optional&lt;AugmentedTrack&gt; forceTargetTrackOpt = findTrackByFlavorType(augmentedTracks, forceTargetOpt);</span>

<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (!forceTargetTrackOpt.isPresent()) {</span>
<span class="nc" id="L309">          throw new IllegalStateException(</span>
<span class="nc" id="L310">                  String.format(&quot;\&quot;%s\&quot; set to \&quot;%s\&quot;, but target flavor \&quot;%s\&quot; not found!&quot;,</span>
                          CONFIG_AUDIO_MUXING,
                          AudioMuxing.FORCE, forceTargetOpt));
        }

<span class="nc" id="L315">        final AugmentedTrack forceTargetTrack = forceTargetTrackOpt.get();</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (singleAudioTrack.track != forceTargetTrack.track) {</span>
          // Copy it over...
<span class="nc" id="L319">          final TrackJobResult muxResult = mux(forceTargetTrack.track, singleAudioTrack.track, mediaPackage);</span>
<span class="nc" id="L320">          result.add(muxResult);</span>

          // ...and remove the original
<span class="nc" id="L323">          final TrackJobResult hideAudioResult = hideAudio(singleAudioTrack.track, mediaPackage);</span>
<span class="nc" id="L324">          result.add(hideAudioResult);</span>
<span class="nc" id="L325">        } else {</span>
<span class="nc" id="L326">          result.add(copyTrack(singleAudioTrack.track));</span>
        }

        // Just copy the rest of the tracks and remove audio where necessary
<span class="nc bnc" id="L330" title="All 2 branches missed.">        for (final AugmentedTrack augmentedTrack : augmentedTracks) {</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">          if (augmentedTrack.track != singleAudioTrack.track &amp;&amp; augmentedTrack.track != forceTargetTrack.track) {</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">            if (augmentedTrack.hasAudio() &amp;&amp; augmentedTrack.hide(SubTrack.AUDIO)) {</span>
<span class="nc" id="L333">              final TrackJobResult hideAudioResult = hideAudio(augmentedTrack.track, mediaPackage);</span>
<span class="nc" id="L334">              result.add(hideAudioResult);</span>
<span class="nc" id="L335">            } else {</span>
<span class="nc" id="L336">              result.add(copyTrack(augmentedTrack.track));</span>
            }
          }
<span class="nc" id="L339">        }</span>
<span class="nc" id="L340">      } else {</span>
        /* Case 1.3: We have one or more tracks and all tracks have non-hidden video streams. Audio muxing is either
           set to NONE or we don't have a single audio streams as required by DUPLICATE and FORCE.
           In this case, simply remove audio streams where requested or copy the track otherwise */
<span class="nc" id="L344">        final MuxResult muxResult = muxMultipleVideoTracks(mediaPackage, augmentedTracks);</span>
<span class="nc" id="L345">        result.add(muxResult);</span>
      }
<span class="nc bnc" id="L347" title="All 2 branches missed.">    } else if (allHidden(augmentedTracks, SubTrack.VIDEO)) {</span>
       /* Case 2: No tracks have non-hidden video streams. In this case, simply remove video streams where
          requested or copy the track otherwise */
<span class="nc bnc" id="L350" title="All 2 branches missed.">       for (final AugmentedTrack t : augmentedTracks) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">         if (t.hasAudio()) {</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">           if (t.hide(SubTrack.VIDEO)) {</span>
<span class="nc" id="L353">             final TrackJobResult hideVideoResult = hideVideo(t.track, mediaPackage);</span>
<span class="nc" id="L354">             result.add(hideVideoResult);</span>
<span class="nc" id="L355">           } else {</span>
<span class="nc" id="L356">             result.add(copyTrack(t.track));</span>
           }
         }
<span class="nc" id="L359">       }</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">    } else if (augmentedTracks.size() == 2) {</span>
      /* Case 3: We have two tracks where exactly one track has a non-hidden video stream (implied as this
         logic assumes at most two input tracks).
         Considering the audio stream, the track with the non-hidden video stream might also contain an audio stream
         or we have to mux the audio stream from another track into that track */
<span class="nc" id="L365">      final MuxResult muxResult = muxSingleVideoTrack(mediaPackage, augmentedTracks);</span>
<span class="nc" id="L366">      result.add(muxResult);</span>
<span class="nc" id="L367">    } else {</span>
      /* Case 4: We have three or more tracks where at least one track has a hidden video stream.
         Simply remove video or audio streams where requested, or copy the track otherwise*/
<span class="nc" id="L370">      final MuxResult muxResult = muxMultipleVideoTracks(mediaPackage, augmentedTracks);</span>
<span class="nc" id="L371">      result.add(muxResult);</span>
    }

    // Update Flavor and add to media package
<span class="nc" id="L375">    result.forEachTrack(t -&gt; {</span>
<span class="nc" id="L376">      t.setFlavor(new MediaPackageElementFlavor(t.getFlavor().getType(), targetTrackFlavor.getSubtype()));</span>
<span class="nc" id="L377">      mediaPackage.add(t);</span>
<span class="nc" id="L378">    });</span>

    // Update Tags here
<span class="nc" id="L381">    final WorkflowOperationTagUtil.TagDiff tagDiff = WorkflowOperationTagUtil.createTagDiff(targetTrackTags);</span>
<span class="nc" id="L382">    result.forEachTrack(t -&gt; WorkflowOperationTagUtil.applyTagDiff(tagDiff, t));</span>

<span class="nc" id="L384">    return createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE, result.queueTime);</span>
  }

  private Optional&lt;AugmentedTrack&gt; findTrackByFlavorType(final Collection&lt;AugmentedTrack&gt; augmentedTracks,
          final String flavorType) {
<span class="nc" id="L389">    return augmentedTracks.stream().filter(augmentedTrack -&gt; augmentedTrack.getFlavorType().equals(flavorType))</span>
<span class="nc" id="L390">            .findAny();</span>
  }

  private MuxResult muxSingleVideoTrack(final MediaPackage mediaPackage, final Collection&lt;AugmentedTrack&gt; augmentedTracks)
          throws MediaPackageException, EncoderException, WorkflowOperationException, NotFoundException, IOException {
<span class="nc" id="L395">    long queueTime = 0L;</span>

<span class="nc" id="L397">    final Collection&lt;Track&gt; resultingTracks = new ArrayList&lt;&gt;(0);</span>

    // This method expects exactly one track with a non-hidden video stream. Let's find it.
<span class="nc" id="L400">    final AugmentedTrack nonHiddenVideo = findNonHidden(augmentedTracks, SubTrack.VIDEO)</span>
<span class="nc" id="L401">            .orElseThrow(() -&gt; new IllegalStateException(&quot;couldn't find a stream with non-hidden video&quot;));</span>
    // Implicit here is the assumption that there's just _one_ other audio stream. It's written so that
    // we can loosen this assumption later on.
<span class="nc" id="L404">    final Optional&lt;AugmentedTrack&gt; nonHiddenAudio = findNonHidden(augmentedTracks, SubTrack.AUDIO);</span>

    // If there's just one non-hidden video stream, and that one has hidden audio, we have to cut that away, too.
<span class="nc bnc" id="L407" title="All 6 branches missed.">    if (nonHiddenVideo.hasAudio() &amp;&amp; nonHiddenVideo.hideAudio &amp;&amp; (!nonHiddenAudio.isPresent()</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            || nonHiddenAudio.get() == nonHiddenVideo)) {</span>
<span class="nc" id="L409">      final TrackJobResult jobResult = hideAudio(nonHiddenVideo.track, mediaPackage);</span>
<span class="nc" id="L410">      resultingTracks.add(jobResult.track);</span>
<span class="nc" id="L411">      queueTime += jobResult.waitTime;</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">    } else if (!nonHiddenAudio.isPresent() || nonHiddenAudio.get() == nonHiddenVideo) {</span>
      // It could be the case that the non-hidden video stream is also the non-hidden audio stream. In that
      // case, we don't have to mux. But have to clone it.
<span class="nc" id="L415">      final Track clonedTrack = (Track) nonHiddenVideo.track.clone();</span>
<span class="nc" id="L416">      clonedTrack.setIdentifier(null);</span>
<span class="nc" id="L417">      resultingTracks.add(clonedTrack);</span>
<span class="nc" id="L418">    } else {</span>
      // Otherwise, we mux!
<span class="nc" id="L420">      final TrackJobResult jobResult = mux(nonHiddenVideo.track, nonHiddenAudio.get().track, mediaPackage);</span>
<span class="nc" id="L421">      resultingTracks.add(jobResult.track);</span>
<span class="nc" id="L422">      queueTime += jobResult.waitTime;</span>
    }
<span class="nc" id="L424">    return new MuxResult(queueTime, resultingTracks);</span>
  }

  private MuxResult muxMultipleVideoTracks(final MediaPackage mediaPackage, final Iterable&lt;AugmentedTrack&gt; augmentedTracks)
          throws MediaPackageException, EncoderException, WorkflowOperationException, NotFoundException, IOException {
<span class="nc" id="L429">    long queueTime = 0L;</span>
<span class="nc" id="L430">    final List&lt;Track&gt; resultingTracks = new ArrayList&lt;&gt;(0);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">    for (final AugmentedTrack t : augmentedTracks) {</span>
      // If track has non-hidden video and non-hidden audio, or only one non-hidden video/audio,
      // clone this track and re-add it to the MP (since it will
      // be a new track with a different flavor)
<span class="nc" id="L435">      if (</span>
<span class="nc bnc" id="L436" title="All 8 branches missed.">        t.hasVideo() &amp;&amp; !t.hideVideo &amp;&amp; t.hasAudio() &amp;&amp; !t.hideAudio  // non-hidden video and non-hidden audio</span>
<span class="nc bnc" id="L437" title="All 6 branches missed.">        || t.hasVideo() &amp;&amp; !t.hideVideo &amp;&amp; !t.hasAudio()  // non-hidden video without audio</span>
<span class="nc bnc" id="L438" title="All 6 branches missed.">        || !t.hasVideo() &amp;&amp; t.hasAudio() &amp;&amp; !t.hideAudio  // non-hidden audio without video</span>
      ) {
<span class="nc" id="L440">        logger.debug(&quot;Add clone of track {} to mediapackage {}&quot;, t.track.getIdentifier(),</span>
<span class="nc" id="L441">            mediaPackage.getIdentifier());</span>
<span class="nc" id="L442">        final Track clonedTrack = (Track) t.track.clone();</span>
<span class="nc" id="L443">        clonedTrack.setIdentifier(null);</span>
<span class="nc" id="L444">        resultingTracks.add(clonedTrack);</span>
<span class="nc bnc" id="L445" title="All 8 branches missed.">      } else if (t.hasVideo() &amp;&amp; !t.hideVideo &amp;&amp; t.hasAudio() &amp;&amp; t.hideAudio) {</span>
        // If track has non-hidden video and hidden audio, hide audio and add it to the MP
        // The flavor gets &quot;nulled&quot; in the process. Reverse that so we can treat all tracks equally.
<span class="nc" id="L448">        final MediaPackageElementFlavor previousFlavor = t.track.getFlavor();</span>
<span class="nc" id="L449">        final TrackJobResult trackJobResult = hideAudio(t.track, mediaPackage);</span>
<span class="nc" id="L450">        trackJobResult.track.setFlavor(previousFlavor);</span>
<span class="nc" id="L451">        resultingTracks.add(trackJobResult.track);</span>
<span class="nc" id="L452">        queueTime += trackJobResult.waitTime;</span>
<span class="nc bnc" id="L453" title="All 8 branches missed.">      } else if (t.hasVideo() &amp;&amp; t.hideVideo &amp;&amp; t.hasAudio() &amp;&amp; !t.hideAudio) {</span>
        // If track has hidden video and non-hidden audio, hide video and add the audio track to the MP
        // The flavor gets &quot;nulled&quot; in the process. Reverse that so we can treat all tracks equally.
<span class="nc" id="L456">        final MediaPackageElementFlavor previousFlavor = t.track.getFlavor();</span>
<span class="nc" id="L457">        final TrackJobResult trackJobResult = hideVideo(t.track, mediaPackage);</span>
<span class="nc" id="L458">        trackJobResult.track.setFlavor(previousFlavor);</span>
<span class="nc" id="L459">        resultingTracks.add(trackJobResult.track);</span>
<span class="nc" id="L460">        queueTime += trackJobResult.waitTime;</span>
      }
<span class="nc" id="L462">    }</span>
<span class="nc" id="L463">    return new MuxResult(queueTime, resultingTracks);</span>
  }

  /**
   * Returns the single track that has audio, or an empty {@code Optional} if either more than one audio track exists, or none exists.
   * @param augmentedTracks List of tracks
   * @return See above.
   */
  private Optional&lt;AugmentedTrack&gt; findSingleAudioTrack(final Iterable&lt;AugmentedTrack&gt; augmentedTracks) {
<span class="nc" id="L472">    AugmentedTrack result = null;</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">    for (final AugmentedTrack augmentedTrack : augmentedTracks) {</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">      if (augmentedTrack.hasAudio() &amp;&amp; !augmentedTrack.hideAudio) {</span>
        // Already got an audio track? Aw, then there's more than one! :(
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L477">          return Optional.empty();</span>
        }
<span class="nc" id="L479">        result = augmentedTrack;</span>
      }
<span class="nc" id="L481">    }</span>
<span class="nc" id="L482">    return Optional.ofNullable(result);</span>
  }

  private TrackJobResult mux(final Track videoTrack, final Track audioTrack, final MediaPackage mediaPackage)
          throws MediaPackageException, EncoderException, WorkflowOperationException, NotFoundException, IOException {
<span class="nc" id="L487">    logger.info(&quot;Mux video track {} and audio track {}&quot;, videoTrack, audioTrack);</span>
    // Find the encoding profile
<span class="nc" id="L489">    final EncodingProfile profile = getProfile(MUX_AV_PROFILE);</span>

<span class="nc" id="L491">    final Job job = composerService.mux(videoTrack, audioTrack, profile.getIdentifier());</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">    if (!waitForStatus(job).isSuccess()) {</span>
<span class="nc" id="L493">      throw new WorkflowOperationException(</span>
<span class="nc" id="L494">              String.format(&quot;Muxing video track %s and audio track %s failed&quot;, videoTrack, audioTrack));</span>
    }
<span class="nc" id="L496">    final MediaPackageElementFlavor previousFlavor = videoTrack.getFlavor();</span>
<span class="nc" id="L497">    final TrackJobResult trackJobResult = processJob(videoTrack, mediaPackage, job);</span>
<span class="nc" id="L498">    trackJobResult.track.setFlavor(previousFlavor);</span>
<span class="nc" id="L499">    return trackJobResult;</span>
  }

  private static final class TrackJobResult {
    private final Track track;
    private final long waitTime;

<span class="nc" id="L506">    private TrackJobResult(final Track track, final long waitTime) {</span>
<span class="nc" id="L507">      this.track = track;</span>
<span class="nc" id="L508">      this.waitTime = waitTime;</span>
<span class="nc" id="L509">    }</span>
  }

  private TrackJobResult hideVideo(final Track track, final MediaPackage mediaPackage)
          throws MediaPackageException, EncoderException, WorkflowOperationException, NotFoundException, IOException {
<span class="nc" id="L514">    logger.info(&quot;Remove video streams from track {}&quot;, track.getIdentifier());</span>
<span class="nc" id="L515">    return hide(PREPARE_AUDIO_ONLY_PROFILE, track, mediaPackage);</span>
  }

  private TrackJobResult hideAudio(final Track track, final MediaPackage mediaPackage)
          throws MediaPackageException, EncoderException, WorkflowOperationException, NotFoundException, IOException {
<span class="nc" id="L520">    logger.info(&quot;Remove audio streams from track {}&quot;, track.getIdentifier());</span>
<span class="nc" id="L521">    return hide(PREPARE_VIDEO_ONLY_PROFILE, track, mediaPackage);</span>
  }

  private TrackJobResult hide(String encodingProfile, final Track track, final MediaPackage mediaPackage)
          throws MediaPackageException, EncoderException, WorkflowOperationException, NotFoundException, IOException {
    // Find the encoding profile
<span class="nc" id="L527">    final EncodingProfile profile = getProfile(encodingProfile);</span>
<span class="nc" id="L528">    final Job job = composerService.encode(track, profile.getIdentifier());</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">    if (!waitForStatus(job).isSuccess()) {</span>
<span class="nc" id="L530">      throw new WorkflowOperationException(String.format(&quot;Rewriting container for video track %s failed&quot;, track));</span>
    }
<span class="nc" id="L532">    final MediaPackageElementFlavor previousFlavor = track.getFlavor();</span>
<span class="nc" id="L533">    final TrackJobResult trackJobResult = processJob(track, mediaPackage, job);</span>
<span class="nc" id="L534">    trackJobResult.track.setFlavor(previousFlavor);</span>
<span class="nc" id="L535">    return trackJobResult;</span>
  }

  private TrackJobResult processJob(final Track track, final MediaPackage mediaPackage, final Job job)
          throws MediaPackageException, NotFoundException, IOException {
<span class="nc" id="L540">    final Track composedTrack = (Track) MediaPackageElementParser.getFromXml(job.getPayload());</span>
<span class="nc" id="L541">    final String fileName = getFileNameFromElements(track, composedTrack);</span>

    // Note that the composed track must have an ID before being moved to the mediapackage in the working file
    // repository. This ID is generated when the track is added to the mediapackage. So the track must be added
    // to the mediapackage before attempting to move the file.
<span class="nc" id="L546">    composedTrack.setURI(workspace</span>
<span class="nc" id="L547">            .moveTo(composedTrack.getURI(), mediaPackage.getIdentifier().toString(), composedTrack.getIdentifier(),</span>
                    fileName));
<span class="nc" id="L549">    return new TrackJobResult(composedTrack, job.getQueueTime());</span>
  }

  private Optional&lt;AugmentedTrack&gt; findNonHidden(final Collection&lt;AugmentedTrack&gt; augmentedTracks, final SubTrack st) {
<span class="nc bnc" id="L553" title="All 4 branches missed.">    return augmentedTracks.stream().filter(t -&gt; t.has(st) &amp;&amp; !t.hide(st)).findAny();</span>
  }

  private boolean allNonHidden(final Collection&lt;AugmentedTrack&gt; augmentedTracks,
          @SuppressWarnings(&quot;SameParameterValue&quot;) final SubTrack st) {
<span class="nc bnc" id="L558" title="All 4 branches missed.">    return augmentedTracks.stream().noneMatch(t -&gt; !t.has(st) || t.hide(st));</span>
  }

  private boolean allHidden(final Collection&lt;AugmentedTrack&gt; augmentedTracks,
          @SuppressWarnings(&quot;SameParameterValue&quot;) final SubTrack st) {
<span class="nc bnc" id="L563" title="All 4 branches missed.">    return augmentedTracks.stream().noneMatch(t -&gt; t.has(st) &amp;&amp; !t.hide(st));</span>
  }

  private static String constructHideProperty(final String s, final SubTrack st) {
<span class="nc" id="L567">    return &quot;hide_&quot; + s + &quot;_&quot; + st.toString().toLowerCase();</span>
  }

  private boolean trackHidden(final WorkflowInstance instance, final String subtype, final SubTrack st) {
<span class="nc" id="L571">    final String hideProperty = instance.getConfiguration(constructHideProperty(subtype, st));</span>
<span class="nc" id="L572">    return Boolean.parseBoolean(hideProperty);</span>
  }

  private List&lt;AugmentedTrack&gt; createAugmentedTracks(final Collection&lt;Track&gt; tracks, final WorkflowInstance instance) {
<span class="nc" id="L576">    return tracks.stream().map(t -&gt; {</span>
<span class="nc" id="L577">      final boolean hideAudio = trackHidden(instance, t.getFlavor().getType(), SubTrack.AUDIO);</span>
<span class="nc" id="L578">      final boolean hideVideo = trackHidden(instance, t.getFlavor().getType(), SubTrack.VIDEO);</span>
<span class="nc" id="L579">      AugmentedTrack result = new AugmentedTrack(t, hideAudio, hideVideo);</span>
<span class="nc" id="L580">      logger.debug(&quot;AugmentedTrack {}&quot;, result);</span>
<span class="nc" id="L581">      return result;</span>
<span class="nc" id="L582">    }).collect(Collectors.toList());</span>
  }

  private TrackJobResult copyTrack(final Track track) throws WorkflowOperationException {
<span class="nc" id="L586">    logger.debug(&quot;Create copy of track {}&quot;, track);</span>
<span class="nc" id="L587">    final Track copiedTrack = (Track) track.clone();</span>
<span class="nc" id="L588">    copiedTrack.setIdentifier(UUID.randomUUID().toString());</span>
    try {
      // Generate a new filename
<span class="nc" id="L591">      String targetFilename = copiedTrack.getIdentifier();</span>
<span class="nc" id="L592">      final String extension = FilenameUtils.getExtension(track.getURI().getPath());</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">      if (!extension.isEmpty()) {</span>
<span class="nc" id="L594">        targetFilename += &quot;.&quot; + extension;</span>
      }

      // Copy the files on dis and put them into the working file repository
<span class="nc" id="L598">      final URI newUri = workspace.put(track.getMediaPackage().getIdentifier().toString(), copiedTrack.getIdentifier(),</span>
<span class="nc" id="L599">              targetFilename, workspace.read(track.getURI()));</span>
<span class="nc" id="L600">      copiedTrack.setURI(newUri);</span>
<span class="nc" id="L601">    } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L602">      throw new WorkflowOperationException(String.format(&quot;Error while copying track %s&quot;, track.getIdentifier()), e);</span>
<span class="nc" id="L603">    }</span>

<span class="nc" id="L605">    return new TrackJobResult(copiedTrack, 0);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>