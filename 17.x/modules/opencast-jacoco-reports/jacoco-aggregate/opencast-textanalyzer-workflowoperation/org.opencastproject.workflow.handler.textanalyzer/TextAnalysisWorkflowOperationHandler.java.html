<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>TextAnalysisWorkflowOperationHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-textanalyzer-workflowoperation</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.workflow.handler.textanalyzer</a> &gt; <span class="el_source">TextAnalysisWorkflowOperationHandler.java</span></div><h1>TextAnalysisWorkflowOperationHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.workflow.handler.textanalyzer;

import org.opencastproject.composer.api.ComposerService;
import org.opencastproject.composer.api.EncoderException;
import org.opencastproject.job.api.Job;
import org.opencastproject.job.api.JobContext;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementBuilder;
import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.MediaPackageReference;
import org.opencastproject.mediapackage.MediaPackageReferenceImpl;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.metadata.mpeg7.MediaDuration;
import org.opencastproject.metadata.mpeg7.MediaRelTimePointImpl;
import org.opencastproject.metadata.mpeg7.MediaTime;
import org.opencastproject.metadata.mpeg7.MediaTimeImpl;
import org.opencastproject.metadata.mpeg7.MediaTimePoint;
import org.opencastproject.metadata.mpeg7.Mpeg7Catalog;
import org.opencastproject.metadata.mpeg7.Mpeg7CatalogService;
import org.opencastproject.metadata.mpeg7.Segment;
import org.opencastproject.metadata.mpeg7.SpatioTemporalDecomposition;
import org.opencastproject.metadata.mpeg7.SpatioTemporalLocator;
import org.opencastproject.metadata.mpeg7.SpatioTemporalLocatorImpl;
import org.opencastproject.metadata.mpeg7.TemporalDecomposition;
import org.opencastproject.metadata.mpeg7.Video;
import org.opencastproject.metadata.mpeg7.VideoSegment;
import org.opencastproject.metadata.mpeg7.VideoText;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.textanalyzer.api.TextAnalyzerException;
import org.opencastproject.textanalyzer.api.TextAnalyzerService;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;
import org.opencastproject.workflow.api.ConfiguredTagsAndFlavors;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowOperationException;
import org.opencastproject.workflow.api.WorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowOperationInstance;
import org.opencastproject.workflow.api.WorkflowOperationResult;
import org.opencastproject.workflow.api.WorkflowOperationResult.Action;
import org.opencastproject.workspace.api.Workspace;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.osgi.service.cm.ConfigurationException;
import org.osgi.service.cm.ManagedService;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ExecutionException;

/**
 * The &lt;code&gt;TextAnalysisOperationHandler&lt;/code&gt; will take an &lt;code&gt;MPEG-7&lt;/code&gt; catalog, look for video segments and
 * run a text analysis on the associated still images. The resulting &lt;code&gt;VideoText&lt;/code&gt; elements will then be added
 * to the segments.
 */
@Component(
    immediate = true,
    service = { WorkflowOperationHandler.class, ManagedService.class },
    property = {
        &quot;service.description=Text Analysis Workflow Operation Handler&quot;,
        &quot;workflow.operation=extract-text&quot;
    }
)
<span class="nc" id="L107">public class TextAnalysisWorkflowOperationHandler extends AbstractWorkflowOperationHandler implements ManagedService {</span>

  /** The logging facility */
<span class="nc" id="L110">  private static final Logger logger = LoggerFactory.getLogger(TextAnalysisWorkflowOperationHandler.class);</span>

  /** Name of the encoding profile that extracts a still image from a movie */
  public static final String IMAGE_EXTRACTION_PROFILE = &quot;text-analysis.http&quot;;

  /** The threshold for scene stability, in seconds */
  private static final int DEFAULT_STABILITY_THRESHOLD = 5;

  /** Name of the constant used to retreive the stability threshold */
  public static final String OPT_STABILITY_THRESHOLD = &quot;stabilitythreshold&quot;;

  /** The stability threshold */
<span class="nc" id="L122">  private int stabilityThreshold = DEFAULT_STABILITY_THRESHOLD;</span>

  /** The local workspace */
<span class="nc" id="L125">  private Workspace workspace = null;</span>

  /** The mpeg7 catalog service */
<span class="nc" id="L128">  private Mpeg7CatalogService mpeg7CatalogService = null;</span>

  /** The text analysis service */
<span class="nc" id="L131">  private TextAnalyzerService analysisService = null;</span>

  /** The composer service */
<span class="nc" id="L134">  protected ComposerService composer = null;</span>

  /**
   * Callback for the OSGi declarative services configuration that will set the text analysis service.
   *
   * @param analysisService
   *          the text analysis service
   */
  @Reference
  protected void setTextAnalyzer(TextAnalyzerService analysisService) {
<span class="nc" id="L144">    this.analysisService = analysisService;</span>
<span class="nc" id="L145">  }</span>

  /**
   * Callback for declarative services configuration that will introduce us to the local workspace service.
   * Implementation assumes that the reference is configured as being static.
   *
   * @param workspace
   *          an instance of the workspace
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="nc" id="L156">    this.workspace = workspace;</span>
<span class="nc" id="L157">  }</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param catalogService
   *          the catalog service
   */
  @Reference(name = &quot;Mpeg7Service&quot;)
  protected void setMpeg7CatalogService(Mpeg7CatalogService catalogService) {
<span class="nc" id="L167">    this.mpeg7CatalogService = catalogService;</span>
<span class="nc" id="L168">  }</span>

  @Override
  public WorkflowOperationResult start(WorkflowInstance workflowInstance, JobContext context)
          throws WorkflowOperationException {
<span class="nc" id="L173">    logger.debug(&quot;Running segments preview workflow operation on {}&quot;, workflowInstance);</span>

<span class="nc" id="L175">    ConfiguredTagsAndFlavors tagsAndFlavors = getTagsAndFlavors(</span>
        workflowInstance, Configuration.many, Configuration.many, Configuration.many, Configuration.none);

    // Check if there is an mpeg-7 catalog containing video segments
<span class="nc" id="L179">    MediaPackage src = (MediaPackage) workflowInstance.getMediaPackage().clone();</span>
<span class="nc" id="L180">    Catalog[] segmentCatalogs = src.getCatalogs(MediaPackageElements.SEGMENTS);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">    if (segmentCatalogs.length == 0) {</span>
<span class="nc" id="L182">      logger.info(&quot;Media package {} does not contain segment information&quot;, src);</span>
<span class="nc" id="L183">      return createResult(Action.CONTINUE);</span>
    }

    try {
<span class="nc" id="L187">      return extractVideoText(src, workflowInstance.getCurrentOperation(), tagsAndFlavors);</span>
<span class="nc" id="L188">    } catch (Exception e) {</span>
<span class="nc" id="L189">      throw new WorkflowOperationException(e);</span>
    }
  }

  /**
   * Runs the text analysis service on each of the video segments found.
   *
   * @param mediaPackage
   *          the original mediapackage
   * @param operation
   *          the workflow operation
   * @throws ExecutionException
   * @throws InterruptedException
   * @throws NotFoundException
   * @throws WorkflowOperationException
   */
  protected WorkflowOperationResult extractVideoText(final MediaPackage mediaPackage,
          WorkflowOperationInstance operation, ConfiguredTagsAndFlavors tagsAndFlavors) throws EncoderException,
          InterruptedException, ExecutionException, IOException, NotFoundException, MediaPackageException,
          TextAnalyzerException, WorkflowOperationException, ServiceRegistryException {
<span class="nc" id="L209">    long totalTimeInQueue = 0;</span>

<span class="nc" id="L211">    List&lt;String&gt; sourceTagSet = tagsAndFlavors.getSrcTags();</span>
<span class="nc" id="L212">    List&lt;String&gt; targetTagSet = tagsAndFlavors.getTargetTags();</span>

    // Select the catalogs according to the tags
<span class="nc" id="L215">    Map&lt;Catalog, Mpeg7Catalog&gt; catalogs = loadSegmentCatalogs(mediaPackage, operation, tagsAndFlavors);</span>

    // Was there at least one matching catalog
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (catalogs.size() == 0) {</span>
<span class="nc" id="L219">      logger.debug(&quot;Mediapackage {} has no suitable mpeg-7 catalogs based on tags {} to to run text analysis&quot;,</span>
              mediaPackage, sourceTagSet);
<span class="nc" id="L221">      return createResult(mediaPackage, Action.CONTINUE);</span>
    }

    // Loop over all existing segment catalogs
<span class="nc bnc" id="L225" title="All 2 branches missed.">    for (Entry&lt;Catalog, Mpeg7Catalog&gt; mapEntry : catalogs.entrySet()) {</span>
<span class="nc" id="L226">      Map&lt;VideoSegment, Job&gt; jobs = new HashMap&lt;VideoSegment, Job&gt;();</span>
<span class="nc" id="L227">      List&lt;Attachment&gt; images = new LinkedList&lt;Attachment&gt;();</span>
<span class="nc" id="L228">      Catalog segmentCatalog = mapEntry.getKey();</span>
      try {
<span class="nc" id="L230">        MediaPackageReference catalogRef = segmentCatalog.getReference();</span>

        // Make sure we can figure out the source track
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (catalogRef == null) {</span>
<span class="nc" id="L234">          logger.info(&quot;Skipping catalog {} since we can't determine the source track&quot;, segmentCatalog);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">        } else if (mediaPackage.getElementByReference(catalogRef) == null) {</span>
<span class="nc" id="L236">          logger.info(&quot;Skipping catalog {} since we can't determine the source track&quot;, segmentCatalog);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        } else if (!(mediaPackage.getElementByReference(catalogRef) instanceof Track)) {</span>
<span class="nc" id="L238">          logger.info(&quot;Skipping catalog {} since it's source was not a track&quot;, segmentCatalog);</span>
        }

<span class="nc" id="L241">        logger.info(&quot;Analyzing mpeg-7 segments catalog {} for text&quot;, segmentCatalog);</span>

        // Create a copy that will contain the segments enriched with the video text elements
<span class="nc" id="L244">        Mpeg7Catalog textCatalog = mapEntry.getValue().clone();</span>
<span class="nc" id="L245">        Track sourceTrack = mediaPackage.getTrack(catalogRef.getIdentifier());</span>

        // Load the temporal decomposition (segments)
<span class="nc" id="L248">        Video videoContent = textCatalog.videoContent().next();</span>
<span class="nc" id="L249">        TemporalDecomposition&lt;? extends Segment&gt; decomposition = videoContent.getTemporalDecomposition();</span>
<span class="nc" id="L250">        Iterator&lt;? extends Segment&gt; segmentIterator = decomposition.segments();</span>

        // For every segment, try to find the still image and run text analysis on it
<span class="nc" id="L253">        List&lt;VideoSegment&gt; videoSegments = new LinkedList&lt;VideoSegment&gt;();</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        while (segmentIterator.hasNext()) {</span>
<span class="nc" id="L255">          Segment segment = segmentIterator.next();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">          if ((segment instanceof VideoSegment)) {</span>
<span class="nc" id="L257">            videoSegments.add((VideoSegment) segment);</span>
          }
<span class="nc" id="L259">        }</span>

        // argument array for image extraction
<span class="nc" id="L262">        double[] times = new double[videoSegments.size()];</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">        for (int i = 0; i &lt; videoSegments.size(); i++) {</span>
<span class="nc" id="L265">          VideoSegment videoSegment = videoSegments.get(i);</span>
<span class="nc" id="L266">          MediaTimePoint segmentTimePoint = videoSegment.getMediaTime().getMediaTimePoint();</span>
<span class="nc" id="L267">          MediaDuration segmentDuration = videoSegment.getMediaTime().getMediaDuration();</span>

          // Choose a time
<span class="nc" id="L270">          MediaPackageReference reference = null;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">          if (catalogRef == null) {</span>
<span class="nc" id="L272">            reference = new MediaPackageReferenceImpl();</span>
          } else {
<span class="nc" id="L274">            reference = new MediaPackageReferenceImpl(catalogRef.getType(), catalogRef.getIdentifier());</span>
          }
<span class="nc" id="L276">          reference.setProperty(&quot;time&quot;, segmentTimePoint.toString());</span>

          // Have the time for ocr image created. To circumvent problems with slowly building slides, we take the image
          // that is
          // almost at the end of the segment, it should contain the most content and is stable as well.
<span class="nc" id="L281">          long startTimeSeconds = segmentTimePoint.getTimeInMilliseconds() / 1000;</span>
<span class="nc" id="L282">          long durationSeconds = segmentDuration.getDurationInMilliseconds() / 1000;</span>
<span class="nc" id="L283">          times[i] = Math.max(startTimeSeconds + durationSeconds - stabilityThreshold + 1, 0);</span>
        }

        // Have the ocr image(s) created.

<span class="nc" id="L288">        Job imageJob = composer.image(sourceTrack, IMAGE_EXTRACTION_PROFILE, times);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (!waitForStatus(imageJob).isSuccess()) {</span>
<span class="nc" id="L290">          throw new WorkflowOperationException(&quot;Extracting scene images from &quot; + sourceTrack + &quot; failed&quot;);</span>
        }
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (imageJob.getPayload() == null) {</span>
<span class="nc" id="L293">          throw new WorkflowOperationException(</span>
                  &quot;The payload of extracting images job from &quot; + sourceTrack + &quot; was null&quot;);
        }

<span class="nc" id="L297">        totalTimeInQueue += imageJob.getQueueTime();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        for (MediaPackageElement imageMpe : MediaPackageElementParser.getArrayFromXml(imageJob.getPayload())) {</span>
<span class="nc" id="L299">          Attachment image = (Attachment) imageMpe;</span>
<span class="nc" id="L300">          images.add(image);</span>
<span class="nc" id="L301">        }</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">        if (images.isEmpty() || images.size() != times.length) {</span>
<span class="nc" id="L303">          throw new WorkflowOperationException(</span>
                  &quot;There are no images produced for &quot; + sourceTrack
                          + &quot; or the images count isn't equal the count of the video segments.&quot;);
        }

        // Run text extraction on each of the images
<span class="nc" id="L309">        Iterator&lt;VideoSegment&gt; it = videoSegments.iterator();</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        for (MediaPackageElement element : images) {</span>
<span class="nc" id="L311">          Attachment image = (Attachment) element;</span>
<span class="nc" id="L312">          VideoSegment videoSegment = it.next();</span>
<span class="nc" id="L313">          jobs.put(videoSegment, analysisService.extract(image));</span>
<span class="nc" id="L314">        }</span>

        // Wait for all jobs to be finished
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (!waitForStatus(jobs.values().toArray(new Job[jobs.size()])).isSuccess()) {</span>
<span class="nc" id="L318">          throw new WorkflowOperationException(&quot;Text extraction failed on images from &quot; + sourceTrack);</span>
        }

        // Process the text extraction results
<span class="nc bnc" id="L322" title="All 2 branches missed.">        for (Map.Entry&lt;VideoSegment, Job&gt; entry : jobs.entrySet()) {</span>
<span class="nc" id="L323">          Job job = serviceRegistry.getJob(entry.getValue().getId());</span>
<span class="nc" id="L324">          totalTimeInQueue += job.getQueueTime();</span>

<span class="nc" id="L326">          VideoSegment videoSegment = entry.getKey();</span>
<span class="nc" id="L327">          MediaDuration segmentDuration = videoSegment.getMediaTime().getMediaDuration();</span>
<span class="nc" id="L328">          Catalog catalog = (Catalog) MediaPackageElementParser.getFromXml(job.getPayload());</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">          if (catalog == null) {</span>
<span class="nc" id="L330">            logger.warn(&quot;Text analysis did not return a valid mpeg7 for segment {}&quot;, videoSegment);</span>
<span class="nc" id="L331">            continue;</span>
          }
<span class="nc" id="L333">          Mpeg7Catalog videoTextCatalog = loadMpeg7Catalog(catalog);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">          if (videoTextCatalog == null) {</span>
<span class="nc" id="L335">            throw new IllegalStateException(&quot;Text analysis service did not return a valid mpeg7&quot;);</span>
          }

          // Add the spatiotemporal decompositions from the new catalog to the existing video segments
<span class="nc" id="L339">          Iterator&lt;Video&gt; videoTextContents = videoTextCatalog.videoContent();</span>
<span class="nc bnc" id="L340" title="All 4 branches missed.">          if (videoTextContents == null || !videoTextContents.hasNext()) {</span>
<span class="nc" id="L341">            logger.debug(&quot;Text analysis was not able to extract any text from {}&quot;, job.getArguments().get(0));</span>
<span class="nc" id="L342">            break;</span>
          }

          try {
<span class="nc" id="L346">            Video textVideoContent = videoTextContents.next();</span>
<span class="nc" id="L347">            VideoSegment textVideoSegment = (VideoSegment) textVideoContent.getTemporalDecomposition().segments()</span>
<span class="nc" id="L348">                    .next();</span>
<span class="nc" id="L349">            VideoText[] videoTexts = textVideoSegment.getSpatioTemporalDecomposition().getVideoText();</span>
<span class="nc" id="L350">            SpatioTemporalDecomposition std = videoSegment.createSpatioTemporalDecomposition(true, false);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">            for (VideoText videoText : videoTexts) {</span>
<span class="nc" id="L352">              MediaTime mediaTime = new MediaTimeImpl(new MediaRelTimePointImpl(0), segmentDuration);</span>
<span class="nc" id="L353">              SpatioTemporalLocator locator = new SpatioTemporalLocatorImpl(mediaTime);</span>
<span class="nc" id="L354">              videoText.setSpatioTemporalLocator(locator);</span>
<span class="nc" id="L355">              std.addVideoText(videoText);</span>
            }
<span class="nc" id="L357">          } catch (Exception e) {</span>
<span class="nc" id="L358">            logger.warn(&quot;The mpeg-7 structure returned by the text analyzer is not what is expected&quot;, e);</span>
<span class="nc" id="L359">            continue;</span>
<span class="nc" id="L360">          }</span>
<span class="nc" id="L361">        }</span>

        // Put the catalog into the workspace and add it to the media package
<span class="nc" id="L364">        MediaPackageElementBuilder builder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();</span>
<span class="nc" id="L365">        Catalog catalog = (Catalog) builder.newElement(MediaPackageElement.Type.Catalog, MediaPackageElements.TEXTS);</span>
<span class="nc" id="L366">        catalog.setIdentifier(null);</span>
<span class="nc" id="L367">        catalog.setReference(segmentCatalog.getReference());</span>
<span class="nc" id="L368">        mediaPackage.add(catalog); // the catalog now has an ID, so we can store the file properly</span>
<span class="nc" id="L369">        InputStream in = mpeg7CatalogService.serialize(textCatalog);</span>
<span class="nc" id="L370">        String filename = &quot;slidetext.xml&quot;;</span>
<span class="nc" id="L371">        URI workspaceURI = workspace</span>
<span class="nc" id="L372">                .put(mediaPackage.getIdentifier().toString(), catalog.getIdentifier(), filename, in);</span>
<span class="nc" id="L373">        catalog.setURI(workspaceURI);</span>

        // Since we've enriched and stored the mpeg7 catalog, remove the original
        try {
<span class="nc" id="L377">          mediaPackage.remove(segmentCatalog);</span>
<span class="nc" id="L378">          workspace.delete(segmentCatalog.getURI());</span>
<span class="nc" id="L379">        } catch (Exception e) {</span>
<span class="nc" id="L380">          logger.warn(&quot;Unable to delete segment catalog {}&quot;, segmentCatalog.getURI(), e);</span>
<span class="nc" id="L381">        }</span>

        // Add flavor and target tags
<span class="nc" id="L384">        catalog.setFlavor(MediaPackageElements.TEXTS);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        for (String tag : targetTagSet) {</span>
<span class="nc" id="L386">          catalog.addTag(tag);</span>
<span class="nc" id="L387">        }</span>
      } finally {
        // Remove images that were created for text extraction
<span class="nc" id="L390">        logger.debug(&quot;Removing temporary images&quot;);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        for (Attachment image : images) {</span>
          try {
<span class="nc" id="L393">            workspace.delete(image.getURI());</span>
<span class="nc" id="L394">          } catch (Exception e) {</span>
<span class="nc" id="L395">            logger.warn(&quot;Unable to delete temporary image {}&quot;, image.getURI(), e);</span>
<span class="nc" id="L396">          }</span>
<span class="nc" id="L397">        }</span>
        // Remove the temporary text
<span class="nc bnc" id="L399" title="All 2 branches missed.">        for (Job j : jobs.values()) {</span>
<span class="nc" id="L400">          Catalog catalog = null;</span>
          try {
<span class="nc" id="L402">            Job job = serviceRegistry.getJob(j.getId());</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (!Job.Status.FINISHED.equals(job.getStatus())) {</span>
<span class="nc" id="L404">              continue;</span>
            }
<span class="nc" id="L406">            catalog = (Catalog) MediaPackageElementParser.getFromXml(job.getPayload());</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">            if (catalog != null) {</span>
<span class="nc" id="L408">              workspace.delete(catalog.getURI());</span>
            }
<span class="nc" id="L410">          } catch (Exception e) {</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (catalog != null) {</span>
<span class="nc" id="L412">              logger.warn(&quot;Unable to delete temporary text file {}&quot;, catalog.getURI(), e);</span>
            } else {
<span class="nc" id="L414">              logger.warn(&quot;Unable to parse textextraction payload of job {}&quot;, j.getId());</span>
            }
<span class="nc" id="L416">          }</span>
<span class="nc" id="L417">        }</span>
      }
<span class="nc" id="L419">    }</span>

<span class="nc" id="L421">    logger.debug(&quot;Text analysis completed&quot;);</span>
<span class="nc" id="L422">    return createResult(mediaPackage, Action.CONTINUE, totalTimeInQueue);</span>
  }

  /**
   * Loads an mpeg7 catalog from a mediapackage's catalog reference
   *
   * @param catalog
   *          the mediapackage's reference to this catalog
   * @return the mpeg7
   * @throws IOException
   *           if there is a problem loading or parsing the mpeg7 object
   */
  protected Mpeg7Catalog loadMpeg7Catalog(Catalog catalog) throws IOException {
<span class="nc" id="L435">    InputStream in = null;</span>
    try {
<span class="nc" id="L437">      File f = workspace.get(catalog.getURI());</span>
<span class="nc" id="L438">      in = new FileInputStream(f);</span>
<span class="nc" id="L439">      return mpeg7CatalogService.load(in);</span>
<span class="nc" id="L440">    } catch (NotFoundException e) {</span>
<span class="nc" id="L441">      throw new IOException(&quot;Unable to open catalog &quot; + catalog + &quot;: &quot; + e.getMessage());</span>
    } finally {
<span class="nc" id="L443">      IOUtils.closeQuietly(in);</span>
    }
  }

  /**
   * Extracts the catalogs from the media package that match the requirements of flavor and tags specified in the
   * operation handler.
   *
   * @param mediaPackage
   *          the media package
   * @param operation
   *          the workflow operation
   * @return a map of catalog elements and their mpeg-7 representations
   * @throws IOException
   *           if there is a problem reading the mpeg7
   */
  protected Map&lt;Catalog, Mpeg7Catalog&gt; loadSegmentCatalogs(MediaPackage mediaPackage,
          WorkflowOperationInstance operation, ConfiguredTagsAndFlavors tagsAndFlavors) throws IOException {
<span class="nc" id="L461">    HashMap&lt;Catalog, Mpeg7Catalog&gt; catalogs = new HashMap&lt;Catalog, Mpeg7Catalog&gt;();</span>

<span class="nc" id="L463">    List&lt;MediaPackageElementFlavor&gt; sourceFlavors = tagsAndFlavors.getSrcFlavors();</span>
<span class="nc" id="L464">    List&lt;String&gt; sourceTagSet = tagsAndFlavors.getSrcTags();</span>

<span class="nc" id="L466">    Catalog[] catalogsWithTags = mediaPackage.getCatalogsByTags(sourceTagSet);</span>

<span class="nc bnc" id="L468" title="All 2 branches missed.">    for (Catalog mediaPackageCatalog : catalogsWithTags) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">      if (!MediaPackageElements.SEGMENTS.equals(mediaPackageCatalog.getFlavor())) {</span>
<span class="nc" id="L470">        continue;</span>
      }
<span class="nc bnc" id="L472" title="All 2 branches missed.">      if (sourceFlavors != null) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (mediaPackageCatalog.getReference() == null) {</span>
<span class="nc" id="L474">          continue;</span>
        }
<span class="nc" id="L476">        Track t = mediaPackage.getTrack(mediaPackageCatalog.getReference().getIdentifier());</span>
<span class="nc bnc" id="L477" title="All 4 branches missed.">        if (t == null || sourceFlavors.stream().noneMatch(flavor -&gt; t.getFlavor().matches(flavor))) {</span>
<span class="nc" id="L478">          continue;</span>
        }
      }

      // Make sure the catalog features at least one of the required tags
<span class="nc bnc" id="L483" title="All 2 branches missed.">      if (!mediaPackageCatalog.containsTag(sourceTagSet)) {</span>
<span class="nc" id="L484">        continue;</span>
      }

<span class="nc" id="L487">      Mpeg7Catalog mpeg7 = loadMpeg7Catalog(mediaPackageCatalog);</span>

      // Make sure there is video content
<span class="nc bnc" id="L490" title="All 4 branches missed.">      if (mpeg7.videoContent() == null || !mpeg7.videoContent().hasNext()) {</span>
<span class="nc" id="L491">        logger.debug(&quot;Mpeg-7 segments catalog {} does not contain any video content&quot;, mpeg7);</span>
<span class="nc" id="L492">        continue;</span>
      }

      // Make sure there is a temporal decomposition
<span class="nc" id="L496">      Video videoContent = mpeg7.videoContent().next();</span>
<span class="nc" id="L497">      TemporalDecomposition&lt;? extends Segment&gt; decomposition = videoContent.getTemporalDecomposition();</span>
<span class="nc bnc" id="L498" title="All 4 branches missed.">      if (decomposition == null || !decomposition.hasSegments()) {</span>
<span class="nc" id="L499">        logger.debug(&quot;Mpeg-7 catalog {} does not contain a temporal decomposition&quot;, mpeg7);</span>
<span class="nc" id="L500">        continue;</span>
      }
<span class="nc" id="L502">      catalogs.put(mediaPackageCatalog, mpeg7);</span>
    }

<span class="nc" id="L505">    return catalogs;</span>
  }

  /**
   * @see org.osgi.service.cm.ManagedService#updated(java.util.Dictionary)
   */
  @SuppressWarnings(&quot;rawtypes&quot;)
  @Override
  public void updated(Dictionary properties) throws ConfigurationException {
<span class="nc bnc" id="L514" title="All 4 branches missed.">    if (properties != null &amp;&amp; properties.get(OPT_STABILITY_THRESHOLD) != null) {</span>
<span class="nc" id="L515">      String threshold = StringUtils.trimToNull((String)properties.get(OPT_STABILITY_THRESHOLD));</span>
      try {
<span class="nc" id="L517">        stabilityThreshold = Integer.parseInt(threshold);</span>
<span class="nc" id="L518">        logger.info(&quot;The videosegmenter's stability threshold has been set to {} frames&quot;, stabilityThreshold);</span>
<span class="nc" id="L519">      } catch (Exception e) {</span>
<span class="nc" id="L520">        stabilityThreshold = DEFAULT_STABILITY_THRESHOLD;</span>
<span class="nc" id="L521">        logger.warn(&quot;Found illegal value '{}' for the videosegmenter stability threshold. &quot;</span>
<span class="nc" id="L522">            + &quot;Falling back to default value of {} frames&quot;, threshold, DEFAULT_STABILITY_THRESHOLD);</span>
<span class="nc" id="L523">      }</span>
<span class="nc" id="L524">    } else {</span>
<span class="nc" id="L525">      stabilityThreshold = DEFAULT_STABILITY_THRESHOLD;</span>
<span class="nc" id="L526">      logger.info(&quot;Using the default value of {} frames for the videosegmenter stability threshold&quot;,</span>
<span class="nc" id="L527">          DEFAULT_STABILITY_THRESHOLD);</span>
    }
<span class="nc" id="L529">  }</span>

  /**
   * Sets the composer service.
   *
   * @param composerService
   */
  @Reference
  void setComposerService(ComposerService composerService) {
<span class="nc" id="L538">    this.composer = composerService;</span>
<span class="nc" id="L539">  }</span>

  @Reference
  @Override
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="nc" id="L544">    super.setServiceRegistry(serviceRegistry);</span>
<span class="nc" id="L545">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>