<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DublinCoreCatalog.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-dublincore</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.metadata.dublincore</a> &gt; <span class="el_source">DublinCoreCatalog.java</span></div><h1>DublinCoreCatalog.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.metadata.dublincore;

import static com.entwinemedia.fn.Stream.$;
import static org.opencastproject.util.EqualsUtil.eq;
import static org.opencastproject.util.data.Monadics.mlist;

import org.opencastproject.mediapackage.EName;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.XMLCatalogImpl;
import org.opencastproject.metadata.api.MetadataCatalog;
import org.opencastproject.util.RequireUtil;
import org.opencastproject.util.XmlNamespaceContext;
import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Function2;

import com.entwinemedia.fn.Fns;
import com.entwinemedia.fn.data.ImmutableSetWrapper;
import com.google.gson.annotations.JsonAdapter;

import org.apache.commons.collections4.Closure;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.Predicate;
import org.apache.commons.collections4.Transformer;
import org.w3c.dom.Document;
import org.xml.sax.Attributes;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

/**
 * Catalog for DublinCore structured metadata to be serialized as XML.
 * &lt;p&gt;
 * Attention: Encoding schemes are not preserved! See http://opencast.jira.com/browse/MH-8759
 */
@ParametersAreNonnullByDefault
@JsonAdapter(DublinCoreGsonAdapter.class)
public class DublinCoreCatalog extends XMLCatalogImpl implements DublinCore, MetadataCatalog, Cloneable {
  private static final long serialVersionUID = -4568663918115847488L;

  /** A flavor that matches any dublin core element */
<span class="fc" id="L73">  public static final MediaPackageElementFlavor ANY_DUBLINCORE = MediaPackageElementFlavor.parseFlavor(&quot;dublincore/*&quot;);</span>

  private EName rootTag;

  /** Create a new catalog. */
<span class="fc" id="L78">  DublinCoreCatalog() {</span>
<span class="fc" id="L79">  }</span>

  public void setRootTag(EName rootTag) {
<span class="fc" id="L82">    this.rootTag = rootTag;</span>
<span class="fc" id="L83">  }</span>

  @Nullable
  public EName getRootTag() {
<span class="fc" id="L87">    return rootTag;</span>
  }

  public void addBindings(XmlNamespaceContext ctx) {
<span class="fc" id="L91">    bindings = this.bindings.add(ctx);</span>
<span class="fc" id="L92">  }</span>

  @Override
  public String toString() {
<span class="nc bnc" id="L96" title="All 2 branches missed.">    return &quot;DublinCore&quot; + (getIdentifier() != null ? &quot;(&quot; + getIdentifier() + &quot;)&quot; : &quot;&quot;);</span>
  }

  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;String&gt; get(EName property, final String language) {
<span class="fc" id="L102">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L103">    RequireUtil.notNull(language, &quot;language&quot;);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">    if (LANGUAGE_ANY.equals(language)) {</span>
<span class="fc" id="L105">      return (List&lt;String&gt;) CollectionUtils.collect(getValuesAsList(property), new Transformer() {</span>
        @Override
        public Object transform(Object o) {
<span class="fc" id="L108">          return ((CatalogEntry) o).getValue();</span>
        }
      });
    } else {
<span class="fc" id="L112">      final List&lt;String&gt; values = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L113">      final boolean langUndef = LANGUAGE_UNDEFINED.equals(language);</span>
<span class="fc" id="L114">      CollectionUtils.forAllDo(getValuesAsList(property), new Closure() {</span>
        @Override
        public void execute(Object o) {
<span class="fc" id="L117">          CatalogEntry c = (CatalogEntry) o;</span>
<span class="fc" id="L118">          String lang = c.getAttribute(XML_LANG_ATTR);</span>
<span class="fc bfc" id="L119" title="All 6 branches covered.">          if ((langUndef &amp;&amp; lang == null) || (language.equals(lang)))</span>
<span class="fc" id="L120">            values.add(c.getValue());</span>
<span class="fc" id="L121">        }</span>
      });
<span class="fc" id="L123">      return values;</span>
    }
  }

  @Override
  public List&lt;DublinCoreValue&gt; get(EName property) {
<span class="fc" id="L129">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L130">    return getValuesAsList(property).stream()</span>
<span class="fc" id="L131">            .map(this::toDublinCoreValue)</span>
<span class="fc" id="L132">            .collect(Collectors.toList());</span>
  }

  private DublinCoreValue toDublinCoreValue(CatalogEntry e) {
<span class="fc" id="L136">    final String langRaw = e.getAttribute(XML_LANG_ATTR);</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">    final String lang = langRaw != null ? langRaw : LANGUAGE_UNDEFINED;</span>
<span class="fc" id="L138">    final String typeRaw = e.getAttribute(XSI_TYPE_ATTR);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">    if (typeRaw != null) {</span>
<span class="fc" id="L140">      return DublinCoreValue.mk(e.getValue(), lang, toEName(typeRaw));</span>
    } else {
<span class="fc" id="L142">      return DublinCoreValue.mk(e.getValue(), lang);</span>
    }
  }

<span class="fc" id="L146">  private final Function&lt;CatalogEntry, DublinCoreValue&gt; toDublinCoreValue = new Function&lt;CatalogEntry, DublinCoreValue&gt;() {</span>
    @Override
    public DublinCoreValue apply(CatalogEntry e) {
<span class="fc" id="L149">      return toDublinCoreValue(e);</span>
    }
  };

  @Override
  public Map&lt;EName, List&lt;DublinCoreValue&gt;&gt; getValues() {
<span class="fc" id="L155">    return mlist(data.values().iterator())</span>
<span class="fc" id="L156">            .foldl(new HashMap&lt;EName, List&lt;DublinCoreValue&gt;&gt;(),</span>
<span class="fc" id="L157">                    new Function2&lt;HashMap&lt;EName, List&lt;DublinCoreValue&gt;&gt;, List&lt;CatalogEntry&gt;, HashMap&lt;EName, List&lt;DublinCoreValue&gt;&gt;&gt;() {</span>
                      @Override
                      public HashMap&lt;EName, List&lt;DublinCoreValue&gt;&gt; apply(HashMap&lt;EName, List&lt;DublinCoreValue&gt;&gt; map,
                              List&lt;CatalogEntry&gt; entries) {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">                        if (entries.size() &gt; 0) {</span>
<span class="fc" id="L162">                          final EName property = entries.get(0).getEName();</span>
<span class="fc" id="L163">                          map.put(property, mlist(entries).map(toDublinCoreValue).value());</span>
                        }
<span class="fc" id="L165">                        return map;</span>
                      }
                    });
  }

  @Override public List&lt;DublinCoreValue&gt; getValuesFlat() {
<span class="fc" id="L171">    return $(data.values()).bind(Fns.&lt;List&lt;CatalogEntry&gt;&gt;id()).map(toDublinCoreValue.toFn()).toList();</span>
  }

  @Override
  @Nullable
  public String getFirst(EName property, String language) {
<span class="fc" id="L177">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L178">    RequireUtil.notNull(language, &quot;language&quot;);</span>

<span class="fc" id="L180">    final CatalogEntry f = getFirstCatalogEntry(property, language);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">    return f != null ? f.getValue() : null;</span>
  }

  @Override
  public String getFirst(EName property) {
<span class="fc" id="L186">    RequireUtil.notNull(property, &quot;property&quot;);</span>

<span class="fc" id="L188">    final CatalogEntry f = getFirstCatalogEntry(property, LANGUAGE_ANY);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">    return f != null ? f.getValue() : null;</span>
  }

  @Override
  public DublinCoreValue getFirstVal(EName property) {
<span class="fc" id="L194">    final CatalogEntry f = getFirstCatalogEntry(property, LANGUAGE_ANY);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">    return f != null ? toDublinCoreValue(f) : null;</span>
  }

  private CatalogEntry getFirstCatalogEntry(EName property, String language) {
<span class="fc" id="L199">    CatalogEntry entry = null;</span>
<span class="fc bfc" id="L200" title="All 3 branches covered.">    switch (language) {</span>
      case LANGUAGE_UNDEFINED:
<span class="fc" id="L202">        entry = getFirstLocalizedValue(property, null);</span>
<span class="fc" id="L203">        break;</span>
      case LANGUAGE_ANY:
<span class="fc bfc" id="L205" title="All 2 branches covered.">        for (CatalogEntry value : getValuesAsList(property)) {</span>
<span class="fc" id="L206">          entry = value;</span>
          // Prefer values without language information
<span class="fc bfc" id="L208" title="All 2 branches covered.">          if (!value.hasAttribute(XML_LANG_ATTR))</span>
<span class="fc" id="L209">            break;</span>
<span class="fc" id="L210">        }</span>
<span class="fc" id="L211">        break;</span>
      default:
<span class="fc" id="L213">        entry = getFirstLocalizedValue(property, language);</span>
        break;
    }
<span class="fc" id="L216">    return entry;</span>
  }

  @Override
  public String getAsText(EName property, String language, String delimiter) {
<span class="fc" id="L221">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L222">    RequireUtil.notNull(language, &quot;language&quot;);</span>
<span class="fc" id="L223">    RequireUtil.notNull(delimiter, &quot;delimiter&quot;);</span>
    final List&lt;CatalogEntry&gt; values;
<span class="pc bpc" id="L225" title="1 of 3 branches missed.">    switch (language) {</span>
      case LANGUAGE_UNDEFINED:
<span class="nc" id="L227">        values = getLocalizedValuesAsList(property, null);</span>
<span class="nc" id="L228">        break;</span>
      case LANGUAGE_ANY:
<span class="fc" id="L230">        values = getValuesAsList(property);</span>
<span class="fc" id="L231">        break;</span>
      default:
<span class="fc" id="L233">        values = getLocalizedValuesAsList(property, language);</span>
        break;
    }
<span class="fc bfc" id="L236" title="All 2 branches covered.">    return values.size() &gt; 0 ? $(values).mkString(delimiter) : null;</span>
  }

  @Override
  public Set&lt;String&gt; getLanguages(EName property) {
<span class="fc" id="L241">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L242">    Set&lt;String&gt; languages = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">    for (CatalogEntry entry : getValuesAsList(property)) {</span>
<span class="fc" id="L244">      String language = entry.getAttribute(XML_LANG_ATTR);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">      if (language != null)</span>
<span class="fc" id="L246">        languages.add(language);</span>
      else
<span class="fc" id="L248">        languages.add(LANGUAGE_UNDEFINED);</span>
<span class="fc" id="L249">    }</span>
<span class="fc" id="L250">    return languages;</span>
  }

  @Override
  public boolean hasMultipleValues(EName property, String language) {
<span class="fc" id="L255">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L256">    RequireUtil.notNull(language, &quot;language&quot;);</span>
<span class="fc" id="L257">    return hasMultiplePropertyValues(property, language);</span>
  }

  @Override
  public boolean hasMultipleValues(EName property) {
<span class="fc" id="L262">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L263">    return hasMultiplePropertyValues(property, LANGUAGE_ANY);</span>
  }

  private boolean hasMultiplePropertyValues(EName property, String language) {
<span class="fc bfc" id="L267" title="All 2 branches covered.">    if (LANGUAGE_ANY.equals(language)) {</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">      return getValuesAsList(property).size() &gt; 1;</span>
    } else {
<span class="fc" id="L270">      int counter = 0;</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">      for (CatalogEntry entry : getValuesAsList(property)) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (equalLanguage(language, entry.getAttribute(XML_LANG_ATTR)))</span>
<span class="fc" id="L273">          counter++;</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (counter &gt; 1)</span>
<span class="fc" id="L275">          return true;</span>
<span class="fc" id="L276">      }</span>
<span class="nc" id="L277">      return false;</span>
    }
  }

  @Override
  public boolean hasValue(EName property, String language) {
<span class="fc" id="L283">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L284">    RequireUtil.notNull(language, &quot;language&quot;);</span>
<span class="fc" id="L285">    return hasPropertyValue(property, language);</span>
  }

  @Override
  public boolean hasValue(EName property) {
<span class="fc" id="L290">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L291">    return hasPropertyValue(property, LANGUAGE_ANY);</span>
  }

  private boolean hasPropertyValue(EName property, final String language) {
<span class="fc bfc" id="L295" title="All 2 branches covered.">    if (LANGUAGE_ANY.equals(language)) {</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">      return getValuesAsList(property).size() &gt; 0;</span>
    } else {
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">      return CollectionUtils.find(getValuesAsList(property), new Predicate() {</span>
        @Override
        public boolean evaluate(Object o) {
<span class="fc" id="L301">          return equalLanguage(((CatalogEntry) o).getAttribute(XML_LANG_ATTR), language);</span>
        }
      }) != null;
    }
  }

  @Override
  public void set(EName property, @Nullable String value, String language) {
<span class="fc" id="L309">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="pc bpc" id="L310" title="2 of 4 branches missed.">    if (language == null || LANGUAGE_ANY.equals(language))</span>
<span class="nc" id="L311">      throw new IllegalArgumentException(&quot;Language code may not be null or LANGUAGE_ANY&quot;);</span>
<span class="fc" id="L312">    setValue(property, value, language, null);</span>
<span class="fc" id="L313">  }</span>

  @Override
  public void set(EName property, String value) {
<span class="fc" id="L317">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L318">    setValue(property, value, LANGUAGE_UNDEFINED, null);</span>
<span class="fc" id="L319">  }</span>

  @Override
  public void set(EName property, @Nullable DublinCoreValue value) {
<span class="fc" id="L323">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">    if (value != null) {</span>
<span class="fc" id="L325">      setValue(property, value.getValue(), value.getLanguage(), value.getEncodingScheme().orNull());</span>
    } else {
<span class="nc" id="L327">      removeValue(property, LANGUAGE_ANY);</span>
    }
<span class="fc" id="L329">  }</span>

  @Override
  public void set(EName property, List&lt;DublinCoreValue&gt; values) {
<span class="fc" id="L333">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L334">    RequireUtil.notNull(values, &quot;values&quot;);</span>
<span class="fc" id="L335">    removeValue(property, LANGUAGE_ANY);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">    for (DublinCoreValue v : values) {</span>
<span class="fc" id="L337">      add(property, v);</span>
<span class="fc" id="L338">    }</span>
<span class="fc" id="L339">  }</span>

  private void setValue(EName property, @Nullable String value, String language, @Nullable EName encodingScheme) {
<span class="fc bfc" id="L342" title="All 2 branches covered.">    if (value == null) {</span>
      // No value, remove the whole element
<span class="fc" id="L344">      removeValue(property, language);</span>
    } else {
<span class="fc bfc" id="L346" title="All 2 branches covered.">      String lang = !LANGUAGE_UNDEFINED.equals(language) ? language : null;</span>
<span class="fc" id="L347">      removeLocalizedValues(property, lang);</span>
<span class="fc" id="L348">      add(property, value, language, encodingScheme);</span>
    }
<span class="fc" id="L350">  }</span>

  @Override
  public void add(EName property, String value) {
<span class="fc" id="L354">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L355">    RequireUtil.notNull(value, &quot;value&quot;);</span>

<span class="fc" id="L357">    add(property, value, LANGUAGE_UNDEFINED, null);</span>
<span class="fc" id="L358">  }</span>

  @Override
  public void add(EName property, String value, String language) {
<span class="fc" id="L362">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L363">    RequireUtil.notNull(value, &quot;value&quot;);</span>
<span class="pc bpc" id="L364" title="2 of 4 branches missed.">    if (language == null || LANGUAGE_ANY.equals(language))</span>
<span class="nc" id="L365">      throw new IllegalArgumentException(&quot;Language code may not be null or LANGUAGE_ANY&quot;);</span>

<span class="fc" id="L367">    add(property, value, language, null);</span>
<span class="fc" id="L368">  }</span>

  @Override
  public void add(EName property, DublinCoreValue value) {
<span class="fc" id="L372">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L373">    RequireUtil.notNull(value, &quot;value&quot;);</span>

<span class="fc" id="L375">    add(property, value.getValue(), value.getLanguage(), value.getEncodingScheme().orNull());</span>
<span class="fc" id="L376">  }</span>

  void add(EName property, String value, String language, @Nullable EName encodingScheme) {
    // Ignore empty rootTag element
<span class="pc bpc" id="L380" title="1 of 4 branches missed.">    if (LANGUAGE_UNDEFINED.equals(language) &amp;&amp; !property.equals(rootTag)) {</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">      if (encodingScheme == null) {</span>
<span class="fc" id="L382">        addElement(property, value);</span>
      } else {
<span class="fc" id="L384">        addTypedElement(property, value, encodingScheme);</span>
      }
    } else {
      // Language defined
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">      if (encodingScheme == null) {</span>
<span class="fc" id="L389">        addLocalizedElement(property, value, language);</span>
      } else {
<span class="nc" id="L391">        addTypedLocalizedElement(property, value, language, encodingScheme);</span>
      }
    }
<span class="fc" id="L394">  }</span>

  @Override
  public void remove(EName property, String language) {
<span class="fc" id="L398">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L399">    RequireUtil.notNull(language, &quot;language&quot;);</span>
<span class="fc" id="L400">    removeValue(property, language);</span>
<span class="fc" id="L401">  }</span>

  @Override
  public void remove(EName property) {
<span class="fc" id="L405">    RequireUtil.notNull(property, &quot;property&quot;);</span>
<span class="fc" id="L406">    removeValue(property, LANGUAGE_ANY);</span>
<span class="fc" id="L407">  }</span>

  private void removeValue(EName property, String language) {
<span class="fc bfc" id="L410" title="All 3 branches covered.">    switch (language) {</span>
      case LANGUAGE_ANY:
<span class="fc" id="L412">        removeElement(property);</span>
<span class="fc" id="L413">        break;</span>
      case LANGUAGE_UNDEFINED:
<span class="fc" id="L415">        removeLocalizedValues(property, null);</span>
<span class="fc" id="L416">        break;</span>
      default:
<span class="fc" id="L418">        removeLocalizedValues(property, language);</span>
        break;
    }
<span class="fc" id="L421">  }</span>

  @Override
  public void clear() {
<span class="nc" id="L425">    super.clear();</span>
<span class="nc" id="L426">  }</span>

  @Override
  public Object clone() {
<span class="fc" id="L430">    DublinCoreCatalog clone = new DublinCoreCatalog();</span>
<span class="fc" id="L431">    clone.setIdentifier(getIdentifier());</span>
<span class="fc" id="L432">    clone.setFlavor(getFlavor());</span>
<span class="fc" id="L433">    clone.setSize(getSize());</span>
<span class="fc" id="L434">    clone.setChecksum(getChecksum());</span>
<span class="fc" id="L435">    clone.bindings = bindings; // safe, since XmlNamespaceContext is immutable</span>
<span class="fc" id="L436">    clone.rootTag = rootTag;</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">    for (Map.Entry&lt;EName, List&lt;CatalogEntry&gt;&gt; entry : data.entrySet()) {</span>
<span class="fc" id="L438">      EName elmName = entry.getKey();</span>
<span class="fc" id="L439">      EName elmNameCopy = new EName(elmName.getNamespaceURI(), elmName.getLocalName());</span>
<span class="fc" id="L440">      List&lt;CatalogEntry&gt; elmsCopy = new ArrayList&lt;CatalogEntry&gt;();</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">      for (CatalogEntry catalogEntry : entry.getValue()) {</span>
<span class="fc" id="L442">        elmsCopy.add(new CatalogEntry(catalogEntry.getEName(), catalogEntry.getValue(), catalogEntry.getAttributes()));</span>
<span class="fc" id="L443">      }</span>
<span class="fc" id="L444">      clone.data.put(elmNameCopy, elmsCopy);</span>
<span class="fc" id="L445">    }</span>
<span class="fc" id="L446">    return clone;</span>
  }

  @Override
  public Set&lt;EName&gt; getProperties() {
<span class="fc" id="L451">    return new ImmutableSetWrapper&lt;&gt;(data.keySet());</span>
  }

  boolean equalLanguage(String a, String b) {
<span class="pc bpc" id="L455" title="2 of 10 branches missed.">    return (a == null &amp;&amp; eq(b, LANGUAGE_UNDEFINED)) || (b == null &amp;&amp; eq(a, LANGUAGE_UNDEFINED)) || eq(a, LANGUAGE_ANY)</span>
<span class="pc bpc" id="L456" title="1 of 6 branches missed.">            || eq(b, LANGUAGE_ANY) || (a != null &amp;&amp; eq(a, b));</span>
  }

  // make public
  @Override public EName toEName(String qName) {
<span class="fc" id="L461">    return super.toEName(qName);</span>
  }

  // make public
  @Nonnull @Override public String toQName(EName eName) {
<span class="fc" id="L466">    return super.toQName(eName);</span>
  }

  // make public
  @Override public void addElement(EName element, String value, Attributes attributes) {
    // Ignore empty root element
<span class="fc bfc" id="L472" title="All 2 branches covered.">    if (! rootTag.equals(element)) {</span>
<span class="fc" id="L473">      super.addElement(element, value, attributes);</span>
    }
<span class="fc" id="L475">  }</span>

  // make public
  @Override public CatalogEntry[] getValues(EName element) {
<span class="fc" id="L479">    return super.getValues(element);</span>
  }

  // make public
  @Override public List&lt;CatalogEntry&gt; getEntriesSorted() {
<span class="fc" id="L484">    return super.getEntriesSorted();</span>
  }

  /**
   * Saves the dublin core metadata container to a dom.
   *
   * @throws ParserConfigurationException
   *           if the xml parser environment is not correctly configured
   * @throws TransformerException
   *           if serialization of the metadata document fails
   * @throws IOException
   *           if an error with catalog serialization occurs
   */
  @Override
  public Document toXml() throws ParserConfigurationException, TransformerException, IOException {
<span class="fc" id="L499">    return DublinCoreXmlFormat.writeDocument(this);</span>
  }

  @Override
  public String toJson() throws IOException {
<span class="fc" id="L504">    return DublinCoreJsonFormat.writeJsonObject(this).toJSONString();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>