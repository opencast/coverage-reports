<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>XmlGen.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-oaipmh</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.oaipmh.util</a> &gt; <span class="el_source">XmlGen.java</span></div><h1>XmlGen.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.oaipmh.util;

import static com.entwinemedia.fn.Stream.$;
import static org.opencastproject.util.IoSupport.withResource;
import static org.opencastproject.util.data.Option.some;
import static org.opencastproject.util.data.functions.Misc.chuck;

import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.util.XmlSafeParser;
import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Function0;
import org.opencastproject.util.data.Option;

import com.entwinemedia.fn.Fn;

import org.apache.commons.io.output.ByteArrayOutputStream;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

/**
 * DOM based XML generation environment. Implement {@link #create()} to create the XML. Serialize to an output stream
 * with {@link #generate(java.io.OutputStream)}.
 *
 * todo document the node creator functions
 */
public abstract class XmlGen {
  private final Document document;
  private final Option&lt;String&gt; defaultNamespace;

  /**
   * Create a new environment.
   */
<span class="fc" id="L74">  public XmlGen(Option&lt;String&gt; defaultNamespace) {</span>
<span class="fc" id="L75">    document = createDocument();</span>
<span class="fc" id="L76">    this.defaultNamespace = defaultNamespace;</span>
<span class="fc" id="L77">  }</span>

  private Document createDocument() {
    try {
<span class="fc" id="L81">      DocumentBuilderFactory factory = XmlSafeParser.newDocumentBuilderFactory();</span>
<span class="fc" id="L82">      factory.setNamespaceAware(true);</span>
<span class="fc" id="L83">      DocumentBuilder builder = factory.newDocumentBuilder();</span>
<span class="fc" id="L84">      return builder.newDocument();</span>
<span class="nc" id="L85">    } catch (ParserConfigurationException e) {</span>
<span class="nc" id="L86">      return chuck(e);</span>
    }
  }

  private void write(OutputStream out) {
    try {
<span class="nc" id="L92">      Transformer transformer = XmlSafeParser.newTransformerFactory().newTransformer();</span>
<span class="nc" id="L93">      transformer.setOutputProperty(OutputKeys.METHOD, &quot;xml&quot;);</span>
<span class="nc" id="L94">      transformer.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);</span>
<span class="nc" id="L95">      transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
<span class="nc" id="L96">      transformer.setOutputProperty(&quot;{http://xml.apache.org/xslt}indent-amount&quot;, &quot;2&quot;);</span>
<span class="nc" id="L97">      DOMSource source = new DOMSource(document);</span>
<span class="nc" id="L98">      StreamResult result = new StreamResult(out);</span>
<span class="nc" id="L99">      transformer.transform(source, result);</span>
<span class="nc" id="L100">    } catch (TransformerException e) {</span>
<span class="nc" id="L101">      throw new RuntimeException(e);</span>
<span class="nc" id="L102">    }</span>
<span class="nc" id="L103">  }</span>

  /**
   * Generate the XML and write it to &lt;code&gt;out&lt;/code&gt;.
   */
  public void generate(OutputStream out) {
<span class="nc" id="L109">    generate();</span>
<span class="nc" id="L110">    write(out);</span>
<span class="nc" id="L111">  }</span>

  /**
   * Generate the document.
   */
  public Document generate() {
<span class="fc" id="L117">    final Node node = document.importNode(create(), true);</span>
<span class="fc" id="L118">    final Element docElem = document.getDocumentElement();</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">    if (docElem != null) {</span>
<span class="nc" id="L120">      document.removeChild(docElem);</span>
    }
<span class="fc" id="L122">    document.appendChild(node);</span>
<span class="fc" id="L123">    return document;</span>
  }

  /** Generate the document as a string. */
  public String generateAsString() {
<span class="nc" id="L128">    return withResource(new ByteArrayOutputStream(), new Function&lt;ByteArrayOutputStream, String&gt;() {</span>
      @Override public String apply(ByteArrayOutputStream out) {
<span class="nc" id="L130">        generate(out);</span>
<span class="nc" id="L131">        return out.toString();</span>
      }
    });
  }

  /**
   * Implement this method to create the DOM. Use the various node creation functions for this purpose.
   */
  public abstract Element create();

  // --

  protected Namespace ns(String prefix, String namespace) {
<span class="fc" id="L144">    return new Namespace(prefix, namespace);</span>
  }

  protected Node schemaLocation(String location) {
<span class="fc" id="L148">    return $a(&quot;xsi:schemaLocation&quot;, location);</span>
  }

  // CHECKSTYLE:OFF

  protected Node $langNode(String language) {
<span class="pc bpc" id="L154" title="1 of 4 branches missed.">    if (StringUtils.isBlank(language) || DublinCore.LANGUAGE_UNDEFINED.equals(language)</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">            || DublinCore.LANGUAGE_ANY.equals(language))</span>
<span class="fc" id="L156">      return nodeZero();</span>

<span class="fc" id="L158">    Attr a = document.createAttributeNS(XMLConstants.XML_NS_URI, &quot;xml:lang&quot;);</span>
<span class="fc" id="L159">    a.setValue(language);</span>
<span class="fc" id="L160">    return a;</span>
  }

  protected Node $a(String name, String value) {
<span class="fc" id="L164">    Attr a = document.createAttribute(name);</span>
<span class="fc" id="L165">    a.setValue(value);</span>
<span class="fc" id="L166">    return a;</span>
  }

  protected Node $aBlank(String name, String value) {
<span class="nc bnc" id="L170" title="All 2 branches missed.">    if (StringUtils.isNotBlank(value)) {</span>
<span class="nc" id="L171">      Attr a = document.createAttribute(name);</span>
<span class="nc" id="L172">      a.setValue(value);</span>
<span class="nc" id="L173">      return a;</span>
    } else {
<span class="nc" id="L175">      return nodeZero();</span>
    }
  }

  protected Node $aSome(final String name, final Option&lt;String&gt; value) {
<span class="fc" id="L180">    return value.fold(new Option.Match&lt;String, Node&gt;() {</span>
      @Override
      public Node some(String value) {
<span class="fc" id="L183">        Attr a = document.createAttribute(name);</span>
<span class="fc" id="L184">        a.setValue(value);</span>
<span class="fc" id="L185">        return a;</span>
      }

      @Override
      public Node none() {
<span class="fc" id="L190">        return nodeZero();</span>
      }
    });
  }

  protected Element $e(String qname, Option&lt;String&gt; namespace, List&lt;Node&gt; nodes) {
<span class="fc" id="L196">    return appendTo(createElemNs(namespace, qname), nodes);</span>
  }

  /**
   * Create an element with the qualified name &lt;code&gt;qname&lt;/code&gt; -- i.e. &lt;code&gt;prefix:tagname&lt;/code&gt; -- in the
   * namespace &lt;code&gt;namespace&lt;/code&gt; with children &lt;code&gt;nodes&lt;/code&gt;.
   */
  protected Element $e(String qname, Option&lt;String&gt; namespace, NodeList nodes) {
<span class="nc" id="L204">    return appendTo(createElemNs(namespace, qname), nodes);</span>
  }

  protected Element $e(String qname, Option&lt;String&gt; namespace, Node... nodes) {
<span class="fc" id="L208">    return $e(qname, namespace, Arrays.asList(nodes));</span>
  }

  protected Element $e(String name, Node... nodes) {
<span class="fc" id="L212">    return $e(name, defaultNamespace, Arrays.asList(nodes));</span>
  }

  protected Element $e(String name, List&lt;Node&gt; nodes) {
<span class="fc" id="L216">    return $e(name, defaultNamespace, Collections.unmodifiableList(nodes));</span>
  }

  /**
   * Create an element with the qualified name &lt;code&gt;qname&lt;/code&gt; -- i.e. &lt;code&gt;prefix:tagname&lt;/code&gt; -- in the
   * namespace &lt;code&gt;namespace&lt;/code&gt; with children &lt;code&gt;nodes&lt;/code&gt;.
   */
  protected Element $e(String qname, String namespace, Node... nodes) {
<span class="fc" id="L224">    return $e(qname, some(namespace), Arrays.asList(nodes));</span>
  }

  protected Element $e(String qname, String namespace, List&lt;Node&gt; nodes) {
<span class="nc" id="L228">    return $e(qname, some(namespace), nodes);</span>
  }

  protected Node $eTxtBlank(final String name, String text) {
<span class="nc" id="L232">    return $txtBlank(text).map(new Function&lt;Node, Node&gt;() {</span>
      @Override
      public Node apply(Node text) {
<span class="nc" id="L235">        final Element e = createElemDefaultNs(name);</span>
<span class="nc" id="L236">        e.appendChild(text);</span>
<span class="nc" id="L237">        return e;</span>
      }
<span class="nc" id="L239">    }).getOrElse(nodeZero);</span>
  }

  protected Node $eTxt(final String name, String text) {
<span class="fc" id="L243">    final Element e = createElemDefaultNs(name);</span>
<span class="fc" id="L244">    e.appendChild($txt(text));</span>
<span class="fc" id="L245">    return e;</span>
  }

  protected Node $eTxt(final String qname, final String namespace, String text) {
<span class="fc" id="L249">    final Element e = createElemNs(namespace, qname);</span>
<span class="fc" id="L250">    e.appendChild($txt(text));</span>
<span class="fc" id="L251">    return e;</span>
  }

  protected Element $e(String name, List&lt;Namespace&gt; namespaces, Node... nodes) {
<span class="nc" id="L255">    return appendTo(appendNs(createElemDefaultNs(name), namespaces), Arrays.asList(nodes));</span>
  }

  protected Element $e(String name, List&lt;Namespace&gt; namespaces, NodeList nodes) {
<span class="nc" id="L259">    return appendTo(appendNs(createElemDefaultNs(name), namespaces), nodes);</span>
  }

  protected Element $e(String name, List&lt;Namespace&gt; namespaces, List&lt;Node&gt; nodes) {
<span class="fc" id="L263">    return appendTo(appendNs(createElemDefaultNs(name), namespaces), nodes);</span>
  }

  protected Element $e(String qname, String namespace, List&lt;Namespace&gt; namespaces, Node... nodes) {
<span class="nc" id="L267">    return appendTo(appendNs(createElemNs(namespace, qname), namespaces), Arrays.asList(nodes));</span>
  }

  private Element createElemDefaultNs(String name) {
<span class="fc" id="L271">    return createElemNs(defaultNamespace, name);</span>
  }

  private Element createElemNs(Option&lt;String&gt; namespace, String qname) {
<span class="fc" id="L275">    return createElemNs(namespace.getOrElseNull(), qname);</span>
  }

  /**
   * @param namespace
   *         may be null.
   */
  private Element createElemNs(String namespace, String qname) {
<span class="fc" id="L283">    return document.createElementNS(namespace, qname);</span>
  }

  /**
   * Create a new DOM element.
   *
   * @param qname
   *         fully qualified tag name, e.g. &quot;name&quot; or &quot;dc:title&quot;
   * @param namespace
   *         namespace to which this tag belongs to
   * @param namespaces
   *         additional namespace declarations
   * @param nodes
   *         child nodes
   */
  protected Element $e(String qname, String namespace, List&lt;Namespace&gt; namespaces, List&lt;Node&gt; nodes) {
<span class="fc" id="L299">    return appendTo(appendNs(createElemNs(namespace, qname), namespaces), nodes);</span>
  }

  /**
   * Conditional element. Only created if at least one subnode is present. Subnodes may be attributes, elements, text
   * nodes, etc.
   */
  protected Node $e(String name, Option&lt;Node&gt;... nodes) {
<span class="nc" id="L307">    final List&lt;Node&gt; existing = filter(Arrays.asList(nodes));</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">    if (!existing.isEmpty()) {</span>
<span class="nc" id="L309">      return $e(name, existing);</span>
    } else {
<span class="nc" id="L311">      return nodeZero();</span>
    }
  }

  protected Node $txt(String text) {
<span class="fc" id="L316">    return document.createTextNode(text);</span>
  }

  protected Node $cdata(String text) {
<span class="fc" id="L320">    return document.createCDATASection(text);</span>
  }

  /**
   * Text blank.
   */
  protected Option&lt;Node&gt; $txtBlank(String text) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">    return StringUtils.isNotBlank(text) ? some($txt(text)) : Option.&lt;Node&gt;none();</span>
  }

  // --

  // CHECKSTYLE:ON

  private List&lt;Node&gt; filter(List&lt;Option&lt;Node&gt;&gt; nodes) {
<span class="nc" id="L335">    return $(nodes).bind(new Fn&lt;Option&lt;Node&gt;, Collection&lt;Node&gt;&gt;() {</span>
      @Override
      public Collection&lt;Node&gt; apply(Option&lt;Node&gt; nodeOption) {
<span class="nc" id="L338">        return nodeOption.fold(new Option.Match&lt;Node, Collection&lt;Node&gt;&gt;() {</span>
          @Override
          public Collection&lt;Node&gt; some(Node node) {
<span class="nc" id="L341">            return Collections.singletonList(node);</span>
          }

          @Override
          public Collection&lt;Node&gt; none() {
<span class="nc" id="L346">            return Collections.emptyList();</span>
          }
        });
      }
<span class="nc" id="L350">    }).toList();</span>
  }

  private Element appendNs(Element e, List&lt;Namespace&gt; namespaces) {
<span class="fc bfc" id="L354" title="All 2 branches covered.">    for (Namespace n : namespaces) {</span>
<span class="fc" id="L355">      e.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, XMLConstants.XMLNS_ATTRIBUTE + &quot;:&quot; + n.getPrefix(),</span>
<span class="fc" id="L356">                       n.getNamespace());</span>
<span class="fc" id="L357">    }</span>
<span class="fc" id="L358">    return e;</span>
  }

  /**
   * Append &lt;code&gt;nodes&lt;/code&gt; to element &lt;code&gt;e&lt;/code&gt;. Respects different node types like attributes and elements.
   */
  private Element appendTo(Element e, List&lt;Node&gt; nodes) {
<span class="fc bfc" id="L365" title="All 2 branches covered.">    for (Node node : nodes)</span>
<span class="fc" id="L366">      appendTo(e, node);</span>
<span class="fc" id="L367">    return e;</span>
  }

  /**
   * Like {@link #appendTo(org.w3c.dom.Element, java.util.List)} but with a different signature.
   */
  private Element appendTo(Element e, NodeList nodes) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">    for (int i = 0; i &lt; nodes.getLength(); i++)</span>
<span class="nc" id="L375">      appendTo(e, nodes.item(i));</span>
<span class="nc" id="L376">    return e;</span>
  }

  /**
   * Append node &lt;code&gt;n&lt;/code&gt; to element &lt;code&gt;e&lt;/code&gt; respecting different node types like attributes and elements.
   */
  private void appendTo(Element e, Node n) {
<span class="fc bfc" id="L383" title="All 2 branches covered.">    Node toAppend = ObjectUtils.equals(n.getOwnerDocument(), document) ? n : document.importNode(n, true);</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">    if (toAppend instanceof Attr) {</span>
<span class="fc" id="L385">      e.setAttributeNode((Attr) toAppend);</span>
    } else {
<span class="fc" id="L387">      e.appendChild(toAppend);</span>
    }
<span class="fc" id="L389">  }</span>

  /**
   * The neutral element.
   */
  protected Node nodeZero() {
<span class="fc" id="L395">    return document.createTextNode(&quot;&quot;);</span>
  }

  /**
   * Lazy version of {@link #nodeZero()}.
   */
<span class="fc" id="L401">  protected Function0&lt;Node&gt; nodeZero = new Function0&lt;Node&gt;() {</span>
    @Override
    public Node apply() {
<span class="fc" id="L404">      return nodeZero();</span>
    }
  };

  /**
   * Create a text node from a string.
   */
<span class="fc" id="L411">  protected Function&lt;String, Node&gt; mkText = new Function&lt;String, Node&gt;() {</span>
    @Override
    public Node apply(String token) {
<span class="fc" id="L414">      return $txt(token);</span>
    }
  };

  protected class Namespace {
    private final String prefix;
    private final String namespace;

<span class="fc" id="L422">    Namespace(String prefix, String namespace) {</span>
<span class="fc" id="L423">      this.prefix = prefix;</span>
<span class="fc" id="L424">      this.namespace = namespace;</span>
<span class="fc" id="L425">    }</span>

    public String getPrefix() {
<span class="fc" id="L428">      return prefix;</span>
    }

    public String getNamespace() {
<span class="fc" id="L432">      return namespace;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>