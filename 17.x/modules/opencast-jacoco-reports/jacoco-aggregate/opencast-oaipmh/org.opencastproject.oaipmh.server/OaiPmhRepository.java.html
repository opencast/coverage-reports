<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>OaiPmhRepository.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-oaipmh</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.oaipmh.server</a> &gt; <span class="el_source">OaiPmhRepository.java</span></div><h1>OaiPmhRepository.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.oaipmh.server;

import static java.lang.String.format;
import static org.opencastproject.oaipmh.OaiPmhUtil.toOaiRepresentation;
import static org.opencastproject.oaipmh.OaiPmhUtil.toUtc;
import static org.opencastproject.oaipmh.persistence.QueryBuilder.queryRepo;
import static org.opencastproject.oaipmh.server.Functions.addDay;
import static org.opencastproject.oaipmh.server.Functions.asDate;
import static org.opencastproject.util.data.Monadics.mlist;
import static org.opencastproject.util.data.Option.some;
import static org.opencastproject.util.data.Prelude.unexhaustiveMatch;
import static org.opencastproject.util.data.functions.Misc.chuck;

import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.oaipmh.Granularity;
import org.opencastproject.oaipmh.OaiPmhConstants;
import org.opencastproject.oaipmh.OaiPmhUtil;
import org.opencastproject.oaipmh.persistence.OaiPmhDatabase;
import org.opencastproject.oaipmh.persistence.OaiPmhDatabaseException;
import org.opencastproject.oaipmh.persistence.OaiPmhSetDefinition;
import org.opencastproject.oaipmh.persistence.OaiPmhSetDefinitionFilter;
import org.opencastproject.oaipmh.persistence.OaiPmhSetDefinitionImpl;
import org.opencastproject.oaipmh.persistence.SearchResult;
import org.opencastproject.oaipmh.persistence.SearchResultItem;
import org.opencastproject.oaipmh.util.XmlGen;
import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Function0;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.Predicate;
import org.opencastproject.util.data.Tuple;

import org.apache.commons.collections4.EnumerationUtils;
import org.apache.commons.lang3.StringUtils;
import org.osgi.service.cm.ConfigurationException;
import org.osgi.service.cm.ManagedService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Dictionary;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * An OAI-PMH protocol compliant repository.
 * &lt;p&gt;
 * Currently supported:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Currently &lt;em&gt;not&lt;/em&gt; supported:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href=&quot;http://www.openarchives.org/OAI/openarchivesprotocol.html#deletion&quot;&gt;deletions&lt;/a&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;a href=&quot;http://www.openarchives.org/OAI/openarchivesprotocol.html#Set&quot;&gt;sets&lt;/a&gt;&lt;/li&gt;
 * &lt;li&gt;&amp;lt;about&amp;gt; containers in records, see section &lt;a
 * href=&quot;http://www.openarchives.org/OAI/openarchivesprotocol.html#Record&quot;&gt;2.5. Record&lt;/a&gt;&lt;/li&gt;
 * &lt;li&gt;
 * resumption tokens do not report about their expiration date; see section &lt;a
 * href=&quot;http://www.openarchives.org/OAI/openarchivesprotocol.html#FlowControl&quot;&gt;3.5. Flow Control&lt;/a&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 */
// todo - malformed date parameter must produce a BadArgument error - if a date parameter has a finer granularity than
//        supported by the repository this must produce a BadArgument error
<span class="fc" id="L90">public abstract class OaiPmhRepository implements ManagedService {</span>
<span class="fc" id="L91">  private static final Logger logger = LoggerFactory.getLogger(OaiPmhRepository.class);</span>
<span class="fc" id="L92">  private static final OaiDcMetadataProvider OAI_DC_METADATA_PROVIDER = new OaiDcMetadataProvider();</span>
  private static final String OAI_NS = OaiPmhConstants.OAI_2_0_XML_NS;

  private static final String CONF_KEY_SET_PREFIX = &quot;set.&quot;;
  private static final String CONF_KEY_SET_SETSPEC_SUFFIX = &quot;.setSpec&quot;;
  private static final String CONF_KEY_SET_NAME_SUFFIX = &quot;.name&quot;;
  private static final String CONF_KEY_SET_DESCRIPTION_SUFFIX = &quot;.description&quot;;
  private static final String CONF_KEY_SET_FILTER_INFIX = &quot;.filter.&quot;;
  private static final String CONF_KEY_SET_FILTER_FLAVOR_SUFFIX = &quot;.flavor&quot;;
  private static final String CONF_KEY_SET_FILTER_CONTAINS_SUFFIX = &quot;.contains&quot;;
  private static final String CONF_KEY_SET_FILTER_CONTAINSNOT_SUFFIX = &quot;.containsnot&quot;;
  private static final String CONF_KEY_SET_FILTER_MATCH_SUFFIX = &quot;.match&quot;;


  public abstract Granularity getRepositoryTimeGranularity();

  /** Display name of the OAI-PMH repository. */
  public abstract String getRepositoryName();

  /** Repository ID. */
  public abstract String getRepositoryId();

  public abstract OaiPmhDatabase getPersistence();

  public abstract String getAdminEmail();

<span class="fc" id="L118">  private List&lt;OaiPmhSetDefinition&gt; sets = new ArrayList&lt;&gt;();</span>

  /**
   * Parse service configuration file.
   *
   * @param properties
   *        Service configuration as dictionary
   * @throws ConfigurationException
   *        If there is a problem within get configuration
   */
  @Override
  public void updated(Dictionary&lt;String, ?&gt; properties) throws ConfigurationException {
<span class="nc bnc" id="L130" title="All 2 branches missed.">    if (properties == null) {</span>
<span class="nc" id="L131">      return;</span>
    }

    // Wipe set configuration in case some got removed
<span class="nc" id="L135">    sets = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L136">    List&lt;String&gt; confKeys = EnumerationUtils.toList(properties.keys());</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">    for (String confKey : confKeys) {</span>
<span class="nc bnc" id="L138" title="All 4 branches missed.">      if (confKey.startsWith(CONF_KEY_SET_PREFIX) &amp;&amp; confKey.endsWith(CONF_KEY_SET_SETSPEC_SUFFIX)) {</span>
<span class="nc" id="L139">        String confKeyPrefix = confKey.replace(CONF_KEY_SET_SETSPEC_SUFFIX, &quot;&quot;);</span>
<span class="nc" id="L140">        String setSpec = (String) properties.get(confKey);</span>
<span class="nc" id="L141">        String setSpecName = (String) properties.get(confKeyPrefix + CONF_KEY_SET_NAME_SUFFIX);</span>
<span class="nc" id="L142">        String setDescription = null;</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (confKey.contains(confKeyPrefix + CONF_KEY_SET_DESCRIPTION_SUFFIX)) {</span>
<span class="nc" id="L144">          setDescription = (String) properties.get(confKeyPrefix + CONF_KEY_SET_DESCRIPTION_SUFFIX);</span>
        }
        try {
<span class="nc" id="L147">          OaiPmhSetDefinitionImpl setDefinition = OaiPmhSetDefinitionImpl.build(setSpec, setSpecName, setDescription);</span>
<span class="nc" id="L148">          List&lt;String&gt; confKeyFilterNames = confKeys.stream()</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">              .filter(key -&gt; key.startsWith(confKeyPrefix + CONF_KEY_SET_FILTER_INFIX)</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">                  &amp;&amp; key.endsWith(CONF_KEY_SET_FILTER_FLAVOR_SUFFIX))</span>
<span class="nc" id="L151">              .map(key -&gt; key.replace(confKeyPrefix + CONF_KEY_SET_FILTER_INFIX, &quot;&quot;)</span>
<span class="nc" id="L152">                  .replace(CONF_KEY_SET_FILTER_FLAVOR_SUFFIX, &quot;&quot;))</span>
<span class="nc" id="L153">              .distinct().collect(Collectors.toList());</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">          for (String filterName : confKeyFilterNames) {</span>
<span class="nc" id="L155">            String setSpecFilterFlavor = (String) properties</span>
<span class="nc" id="L156">                .get(confKeyPrefix + CONF_KEY_SET_FILTER_INFIX + filterName + CONF_KEY_SET_FILTER_FLAVOR_SUFFIX);</span>
<span class="nc" id="L157">            List&lt;String&gt; confKeyCriteria = confKeys.stream()</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">                .filter(key -&gt; key.startsWith(confKeyPrefix + CONF_KEY_SET_FILTER_INFIX + filterName)</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">                    &amp;&amp; (key.endsWith(CONF_KEY_SET_FILTER_CONTAINS_SUFFIX)</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                    || key.endsWith(CONF_KEY_SET_FILTER_CONTAINSNOT_SUFFIX)</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                    || key.endsWith(CONF_KEY_SET_FILTER_MATCH_SUFFIX)))</span>
<span class="nc" id="L162">                .distinct().collect(Collectors.toList());</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            for (String confKeyCriterion : confKeyCriteria) {</span>
<span class="nc" id="L164">              String criterion = null;</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">              if (confKeyCriterion.endsWith(CONF_KEY_SET_FILTER_CONTAINS_SUFFIX)) {</span>
<span class="nc" id="L166">                criterion = OaiPmhSetDefinitionFilter.CRITERION_CONTAINS;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">              } else if (confKeyCriterion.endsWith(CONF_KEY_SET_FILTER_CONTAINSNOT_SUFFIX)) {</span>
<span class="nc" id="L168">                criterion = OaiPmhSetDefinitionFilter.CRITERION_CONTAINSNOT;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">              } else if (confKeyCriterion.endsWith(CONF_KEY_SET_FILTER_MATCH_SUFFIX)) {</span>
<span class="nc" id="L170">                criterion = OaiPmhSetDefinitionFilter.CRITERION_MATCH;</span>
              } else {
<span class="nc" id="L172">                logger.warn(&quot;Configuration key {} not valid.&quot;, confKeyCriterion);</span>
<span class="nc" id="L173">                continue;</span>
              }
<span class="nc" id="L175">              setDefinition.addFilter(filterName, setSpecFilterFlavor, criterion,</span>
<span class="nc" id="L176">                  (String) properties.get(confKeyCriterion));</span>
<span class="nc" id="L177">            }</span>
<span class="nc" id="L178">          }</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">          if (setDefinition.getFilters().isEmpty()) {</span>
<span class="nc" id="L180">            logger.warn(&quot;No filter criteria defined for OAI-PMH set definition {}.&quot;, setDefinition.getSetSpec());</span>
          } else {
<span class="nc" id="L182">            sets.add(setDefinition);</span>
<span class="nc" id="L183">            logger.debug(&quot;OAI-PMH set difinition {} initialized.&quot;, setDefinition.getSetSpec());</span>
          }
<span class="nc" id="L185">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L186">          logger.warn(&quot;Unable to parse OAI-PMH set definition for setSpec {}.&quot;, setSpec, e);</span>
<span class="nc" id="L187">        }</span>
      }
<span class="nc" id="L189">    }</span>
<span class="nc" id="L190">  }</span>

  /**
   * Save a query.
   *
   * @return a resumption token
   */
  public abstract String saveQuery(ResumableQuery query);

  /** Get a saved query. */
  public abstract Option&lt;ResumableQuery&gt; getSavedQuery(String resumptionToken);

  /** Maximum number of items returned by the list queries ListIdentifiers, ListRecords and ListSets. */
  public abstract int getResultLimit();

  /**
   * Return a list of available metadata providers. Please do not expose the default provider for the
   * mandatory oai_dc format since this is automatically added when calling {@link #getMetadataProviders()}.
   *
   * @see #getMetadataProviders()
   */
  public abstract List&lt;MetadataProvider&gt; getRepositoryMetadataProviders();

  /** Return the current date. Used in implementation instead of new Date(); to facilitate unit testing. */
  public Date currentDate() {
<span class="fc" id="L215">    return new Date();</span>
  }

  /** Return a list of all available metadata providers. The &lt;code&gt;oai_dc&lt;/code&gt; format is always included. */
  public final List&lt;MetadataProvider&gt; getMetadataProviders() {
<span class="fc" id="L220">    return mlist(getRepositoryMetadataProviders()).cons(OAI_DC_METADATA_PROVIDER).value();</span>
  }

  /** Add an item to the repository. */
  public void addItem(MediaPackage mp) {
<span class="nc" id="L225">    getPersistence().search(queryRepo(getRepositoryId()).build());</span>
    try {
<span class="nc" id="L227">      getPersistence().store(mp, getRepositoryId());</span>
<span class="nc" id="L228">    } catch (OaiPmhDatabaseException e) {</span>
<span class="nc" id="L229">      chuck(e);</span>
<span class="nc" id="L230">    }</span>
<span class="nc" id="L231">  }</span>

  /** Create an OAI-PMH response based on the given request params. */
  public XmlGen selectVerb(Params p) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">    if (p.isVerbListIdentifiers()) {</span>
<span class="fc" id="L236">      return handleListIdentifiers(p);</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">    } else if (p.isVerbListRecords()) {</span>
<span class="fc" id="L238">      return handleListRecords(p);</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">    } else if (p.isVerbGetRecord()) {</span>
<span class="fc" id="L240">      return handleGetRecord(p);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">    } else if (p.isVerbIdentify()) {</span>
<span class="fc" id="L242">      return handleIdentify(p);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">    } else if (p.isVerbListMetadataFormats()) {</span>
<span class="fc" id="L244">      return handleListMetadataFormats(p);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">    } else if (p.isVerbListSets()) {</span>
<span class="fc" id="L246">      return handleListSets(p);</span>
    } else {
<span class="fc" id="L248">      return createErrorResponse(</span>
<span class="fc" id="L249">              &quot;badVerb&quot;, Option.&lt;String&gt;none(), p.getRepositoryUrl(), &quot;Illegal OAI verb or verb is missing.&quot;);</span>
    }
  }

  /** Return the metadata provider for a given metadata prefix. */
  public Option&lt;MetadataProvider&gt; getMetadataProvider(final String metadataPrefix) {
<span class="fc" id="L255">    return mlist(getMetadataProviders()).find(new Predicate&lt;MetadataProvider&gt;() {</span>
      @Override
      public Boolean apply(MetadataProvider metadataProvider) {
<span class="fc" id="L258">        return metadataProvider.getMetadataFormat().getPrefix().equals(metadataPrefix);</span>
      }
    });
  }

  /** {@link #getMetadataProvider(String)} as a function. */
<span class="fc" id="L264">  private final Function&lt;String, Option&lt;MetadataProvider&gt;&gt; getMetadataProvider = new Function&lt;String, Option&lt;MetadataProvider&gt;&gt;() {</span>
    @Override public Option&lt;MetadataProvider&gt; apply(String metadataPrefix) {
<span class="fc" id="L266">      return getMetadataProvider(metadataPrefix);</span>
    }
  };

  /** Create the &quot;GetRecord&quot; response. */
  private XmlGen handleGetRecord(final Params p) {
<span class="pc bpc" id="L272" title="2 of 4 branches missed.">    if (p.getIdentifier().isNone() || p.getMetadataPrefix().isNone()) {</span>
<span class="nc" id="L273">      return createBadArgumentResponse(p);</span>
    } else {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">      for (final MetadataProvider metadataProvider : p.getMetadataPrefix().bind(getMetadataProvider)) {</span>
<span class="pc bpc" id="L276" title="3 of 4 branches missed.">        if (p.getSet().isSome() &amp;&amp; !sets.stream().anyMatch(</span>
<span class="nc" id="L277">            setDef -&gt; StringUtils.equals(setDef.getSetSpec(), p.getSet().get()))) {</span>
          // If there is no set specification, immediately return a no result response
<span class="nc" id="L279">          return createNoRecordsMatchResponse(p);</span>
        }
<span class="fc" id="L281">        final SearchResult res = getPersistence()</span>
<span class="fc" id="L282">                .search(queryRepo(getRepositoryId()).mediaPackageId(p.getIdentifier())</span>
<span class="fc" id="L283">                                                    .setDefinitions(sets)</span>
<span class="fc" id="L284">                                                    .setSpec(p.getSet().getOrElseNull()).build());</span>
<span class="fc" id="L285">        final List&lt;SearchResultItem&gt; items = res.getItems();</span>
<span class="pc bpc" id="L286" title="2 of 3 branches missed.">        switch (items.size()) {</span>
          case 0:
<span class="nc" id="L288">            return createIdDoesNotExistResponse(p);</span>
          case 1:
<span class="fc" id="L290">            final SearchResultItem item = items.get(0);</span>
<span class="fc" id="L291">            return new OaiVerbXmlGen(OaiPmhRepository.this, p) {</span>
              @Override
              public Element create() {
                // create the metadata for this item
<span class="fc" id="L295">                Element metadata = metadataProvider.createMetadata(OaiPmhRepository.this, item, p.getSet());</span>
<span class="fc" id="L296">                return oai(request($a(&quot;identifier&quot;, p.getIdentifier().get()), metadataPrefixAttr(p)),</span>
<span class="fc" id="L297">                           verb(record(item, metadata)));</span>
              }
            };
          default:
<span class="nc" id="L301">            throw new RuntimeException(&quot;ERROR: Search index contains more than one item with id &quot;</span>
<span class="nc" id="L302">                                               + p.getIdentifier());</span>
        }
      }
      // no metadata provider found
<span class="nc" id="L306">      return createCannotDisseminateFormatResponse(p);</span>
    }
  }

  /** Handle the &quot;Identify&quot; request. */
  /*&lt;Identify &gt;
    &lt;repositoryName&gt;Test OAI Repository&lt;/repositoryName&gt;
    &lt;baseURL&gt;http://localhost/oaipmh&lt;/baseURL&gt;
    &lt;protocolVersion&gt;2.0&lt;/protocolVersion&gt;
    &lt;adminEmail&gt;admin@localhost.org&lt;/adminEmail&gt;
    &lt;earliestDatestamp&gt;2010-01-01&lt;/earliestDatestamp&gt;
    &lt;deletedRecord&gt;transient&lt;/deletedRecord&gt;
    &lt;granularity&gt;YYYY-MM-DD&lt;/granularity&gt;
  &lt;/Identify&gt;*/
  private XmlGen handleIdentify(final Params p) {
<span class="fc" id="L321">    return new OaiVerbXmlGen(this, p) {</span>
      @Override
      public Element create() {
<span class="fc" id="L324">        return oai(</span>
<span class="fc" id="L325">                request(),</span>
<span class="fc" id="L326">                verb($eTxt(&quot;repositoryName&quot;, OAI_NS, getRepositoryName()),</span>
<span class="fc" id="L327">                     $eTxt(&quot;baseURL&quot;, OAI_NS, p.getRepositoryUrl()),</span>
<span class="fc" id="L328">                     $eTxt(&quot;protocolVersion&quot;, OAI_NS, &quot;2.0&quot;),</span>
<span class="fc" id="L329">                     $eTxt(&quot;adminEmail&quot;, OAI_NS, getAdminEmail()),</span>
<span class="fc" id="L330">                     $eTxt(&quot;earliestDatestamp&quot;, OAI_NS, &quot;2010-01-01&quot;),</span>
<span class="fc" id="L331">                     $eTxt(&quot;deletedRecord&quot;, OAI_NS, &quot;transient&quot;),</span>
<span class="fc" id="L332">                     $eTxt(&quot;granularity&quot;, OAI_NS, toOaiRepresentation(getRepositoryTimeGranularity()))));</span>
      }
    };
  }

  private XmlGen handleListMetadataFormats(final Params p) {
<span class="fc bfc" id="L338" title="All 2 branches covered.">    for (String id : p.getIdentifier()) {</span>
<span class="fc" id="L339">      final SearchResult res = getPersistence().search(queryRepo(getRepositoryId()).mediaPackageId(id).build());</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">      if (res.getItems().size() != 1)</span>
<span class="fc" id="L341">        return createIdDoesNotExistResponse(p);</span>
<span class="fc" id="L342">    }</span>
<span class="fc" id="L343">    return new OaiVerbXmlGen(this, p) {</span>
      @Override
      public Element create() {
<span class="fc" id="L346">        final List&lt;Node&gt; metadataFormats = mlist(getMetadataProviders()).map(new Function&lt;MetadataProvider, Node&gt;() {</span>
          @Override
          public Node apply(MetadataProvider metadataProvider) {
<span class="fc" id="L349">            return metadataFormat(metadataProvider.getMetadataFormat());</span>
          }
<span class="fc" id="L351">        }).value();</span>
<span class="fc" id="L352">        return oai(request($aSome(&quot;identifier&quot;, p.getIdentifier())), verb(metadataFormats));</span>
      }
    };
  }

  private XmlGen handleListRecords(final Params p) {
<span class="fc" id="L358">    final ListItemsEnv env = new ListItemsEnv() {</span>
      @Override
      protected ListXmlGen respond(ListGenParams listParams) {
<span class="fc" id="L361">        return new ListXmlGen(listParams) {</span>
          @Override
          protected List&lt;Node&gt; createContent(final Option&lt;String&gt; set) {
<span class="fc" id="L364">            return mlist(params.getResult().getItems()).map(new Function&lt;SearchResultItem, Node&gt;() {</span>
              @Override
              public Node apply(SearchResultItem item) {
<span class="fc" id="L367">                logger.debug(&quot;Requested set: {}&quot;, set);</span>
<span class="fc" id="L368">                final Element metadata = params.getMetadataProvider().createMetadata(OaiPmhRepository.this, item, set);</span>
<span class="fc" id="L369">                return record(item, metadata);</span>
              }
<span class="fc" id="L371">            }).value();</span>
          }
        };
      }
    };
<span class="fc" id="L376">    return env.apply(p);</span>
  }

  private XmlGen handleListIdentifiers(final Params p) {
<span class="fc" id="L380">    final ListItemsEnv env = new ListItemsEnv() {</span>
      @Override
      protected ListXmlGen respond(ListGenParams listParams) {
        // create XML response
<span class="fc" id="L384">        return new ListXmlGen(listParams) {</span>
          @Override
          protected List&lt;Node&gt; createContent(Option&lt;String&gt; set) {
<span class="fc" id="L387">            return mlist(params.getResult().getItems()).map(new Function&lt;SearchResultItem, Node&gt;() {</span>
              @Override
              public Node apply(SearchResultItem item) {
<span class="fc" id="L390">                return header(item);</span>
              }
<span class="fc" id="L392">            }).value();</span>
          }
        };
      }
    };
<span class="fc" id="L397">    return env.apply(p);</span>
  }

  /** Create the &quot;ListSets&quot; response. Since the list is short the complete list is returned at once. */
  private XmlGen handleListSets(final Params p) {
<span class="fc" id="L402">    return new OaiVerbXmlGen(this, p) {</span>
      @Override
      public Element create() {
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (sets.isEmpty()) {</span>
<span class="fc" id="L406">          return createNoSetHierarchyResponse(p).create();</span>
        }
<span class="nc" id="L408">        List&lt;Node&gt; setNodes = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L409">        sets.forEach(set -&gt; {</span>
<span class="nc" id="L410">          String setSpec = set.getSetSpec();</span>
<span class="nc" id="L411">          String name = set.getName();</span>
<span class="nc" id="L412">          String description = set.getDescription();</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">          if (StringUtils.isNotBlank(description)) {</span>
<span class="nc" id="L414">            setNodes.add($e(&quot;set&quot;, $eTxt(&quot;setSpec&quot;, setSpec), $eTxt(&quot;setName&quot;, name),</span>
<span class="nc" id="L415">                $e(&quot;setDescription&quot;, dc($eTxt(&quot;dc:description&quot;, description)))));</span>
          } else {
<span class="nc" id="L417">            setNodes.add($e(&quot;set&quot;, $eTxt(&quot;setSpec&quot;, setSpec), $eTxt(&quot;setName&quot;, name)));</span>
          }
<span class="nc" id="L419">        });</span>
<span class="nc" id="L420">        return oai(request(), verb(setNodes));</span>
      }
    };
  }

  // --

  private XmlGen createCannotDisseminateFormatResponse(Params p) {
<span class="nc" id="L428">    return createErrorResponse(</span>
<span class="nc" id="L429">            OaiPmhConstants.ERROR_CANNOT_DISSEMINATE_FORMAT, p.getVerb(), p.getRepositoryUrl(),</span>
            &quot;The metadata format identified by the value given for the metadataPrefix argument is not supported by the item or by the repository.&quot;);
  }

  private XmlGen createIdDoesNotExistResponse(Params p) {
<span class="fc" id="L434">    return createErrorResponse(</span>
<span class="fc" id="L435">            OaiPmhConstants.ERROR_ID_DOES_NOT_EXIST, p.getVerb(), p.getRepositoryUrl(),</span>
<span class="fc" id="L436">            format(&quot;The requested id %s does not exist in the repository.&quot;,</span>
<span class="fc" id="L437">                   p.getIdentifier().getOrElse(&quot;?&quot;)));</span>
  }

  private XmlGen createBadArgumentResponse(Params p) {
<span class="fc" id="L441">    return createErrorResponse(OaiPmhConstants.ERROR_BAD_ARGUMENT, p.getVerb(), p.getRepositoryUrl(),</span>
                               &quot;The request includes illegal arguments or is missing required arguments.&quot;);
  }

  private XmlGen createBadResumptionTokenResponse(Params p) {
<span class="nc" id="L446">    return createErrorResponse(</span>
<span class="nc" id="L447">            OaiPmhConstants.ERROR_BAD_RESUMPTION_TOKEN, p.getVerb(), p.getRepositoryUrl(),</span>
            &quot;The value of the resumptionToken argument is either invalid or expired.&quot;);
  }

  private XmlGen createNoRecordsMatchResponse(Params p) {
<span class="fc" id="L452">    return createErrorResponse(</span>
<span class="fc" id="L453">            OaiPmhConstants.ERROR_NO_RECORDS_MATCH, p.getVerb(), p.getRepositoryUrl(),</span>
            &quot;The combination of the values of the from, until, and set arguments results in an empty list.&quot;);
  }

  private XmlGen createNoSetHierarchyResponse(Params p) {
<span class="fc" id="L458">    return createErrorResponse(</span>
<span class="fc" id="L459">            OaiPmhConstants.ERROR_NO_SET_HIERARCHY, p.getVerb(), p.getRepositoryUrl(),</span>
            &quot;This repository does not support sets&quot;);
  }

  private XmlGen createErrorResponse(
          final String code, final Option&lt;String&gt; verb, final String repositoryUrl, final String msg) {
<span class="fc" id="L465">    return new OaiXmlGen(this) {</span>
      @Override
      public Element create() {
<span class="fc" id="L468">        return oai($e(&quot;request&quot;,</span>
                      OaiPmhConstants.OAI_2_0_XML_NS,
<span class="fc" id="L470">                      $aSome(&quot;verb&quot;, verb),</span>
<span class="fc" id="L471">                      $txt(repositoryUrl)),</span>
<span class="fc" id="L472">                   $e(&quot;error&quot;, OaiPmhConstants.OAI_2_0_XML_NS, $a(&quot;code&quot;, code), $cdata(msg)));</span>
      }
    };
  }

  // --

  /**
   * Convert a date to the repository supported time granularity.
   *
   * @return the converted date or null if d is null
   */
  String toSupportedGranularity(Date d) {
<span class="fc" id="L485">    return toUtc(d, getRepositoryTimeGranularity());</span>
  }

  // CHECKSTYLE:OFF
<span class="fc" id="L489">  final Function&lt;Date, String&gt; toSupportedGranularity = new Function&lt;Date, String&gt;() {</span>
    @Override
    public String apply(Date date) {
<span class="fc" id="L492">      return toSupportedGranularity(date);</span>
    }
  };
  // CHECKSTYLE:ON

<span class="fc" id="L497">  private final Function&lt;Date, Date&gt; granulate = new Function&lt;Date, Date&gt;() {</span>
    @Override
    public Date apply(Date date) {
<span class="fc" id="L500">      return granulate(getRepositoryTimeGranularity(), date);</span>
    }
  };

  /** &quot;Cut&quot; a date to the repositories supported granularity. Cutting behaves similar to the mathematical floor function. */
  public static Date granulate(Granularity g, Date d) {
<span class="pc bpc" id="L506" title="1 of 3 branches missed.">    switch (g) {</span>
      case SECOND: {
<span class="fc" id="L508">        Calendar c = Calendar.getInstance();</span>
<span class="fc" id="L509">        c.setTimeZone(OaiPmhUtil.newDateFormat().getTimeZone());</span>
<span class="fc" id="L510">        c.setTime(d);</span>
<span class="fc" id="L511">        c.set(Calendar.MILLISECOND, 0);</span>
<span class="fc" id="L512">        return c.getTime();</span>
      }
      case DAY: {
<span class="fc" id="L515">        final Calendar c = Calendar.getInstance();</span>
<span class="fc" id="L516">        c.setTimeZone(OaiPmhUtil.newDateFormat().getTimeZone());</span>
<span class="fc" id="L517">        c.setTime(d);</span>
<span class="fc" id="L518">        c.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="fc" id="L519">        c.set(Calendar.MINUTE, 0);</span>
<span class="fc" id="L520">        c.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L521">        c.set(Calendar.MILLISECOND, 0);</span>
<span class="fc" id="L522">        return c.getTime();</span>
      }
      default:
<span class="nc" id="L525">        return unexhaustiveMatch();</span>
    }
  }

<span class="nc" id="L529">  static class BadArgumentException extends RuntimeException {</span>
  }

  /**
   * Environment for the list verbs ListIdentifiers and ListRecords. Handles the boilerplate of getting, validating and
   * providing the parameters, creating error responses etc. Call {@link #apply(Params)} to create the XML. Also use
   * {@link org.opencastproject.oaipmh.server.OaiPmhRepository.ListItemsEnv.ListXmlGen} for the XML generation.
   */
  abstract class ListItemsEnv {
<span class="fc" id="L538">    ListItemsEnv() {</span>
<span class="fc" id="L539">    }</span>

    /** Create the regular response from the given parameters. */
    protected abstract ListXmlGen respond(ListGenParams params);

    /** Call this method to create the XML. */
    public XmlGen apply(final Params p) {
      // check parameters
<span class="pc bpc" id="L547" title="3 of 4 branches missed.">      if (p.getSet().isSome() &amp;&amp; sets.isEmpty()) {</span>
<span class="nc" id="L548">        return createNoSetHierarchyResponse(p);</span>
      }
<span class="fc" id="L550">      final boolean resumptionTokenExists = p.getResumptionToken().isSome();</span>
<span class="pc bpc" id="L551" title="2 of 6 branches missed.">      final boolean otherParamExists = p.getMetadataPrefix().isSome() || p.getFrom().isSome() || p.getUntil().isSome()</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">              || p.getSet().isSome();</span>

<span class="pc bpc" id="L554" title="4 of 8 branches missed.">      if (resumptionTokenExists &amp;&amp; otherParamExists || !resumptionTokenExists &amp;&amp; !otherParamExists)</span>
<span class="fc" id="L555">        return createBadArgumentResponse(p);</span>
<span class="fc" id="L556">      final Option&lt;Date&gt; from = p.getFrom().map(asDate).map(granulate);</span>

<span class="fc bfc" id="L558" title="All 2 branches covered.">      final Function&lt;Date, Date&gt; untilAdjustment = getRepositoryTimeGranularity() == Granularity.DAY ? addDay(1)</span>
<span class="fc" id="L559">              : org.opencastproject.util.data.functions.Functions.&lt;Date&gt;identity();</span>
<span class="fc" id="L560">      final Option&lt;Date&gt; untilGranularity = p.getUntil().map(asDate).map(granulate).map(untilAdjustment);</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">      for (Tuple&lt;Date, Date&gt; fromUntil : from.and(untilGranularity)) {</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">        if (!fromUntil.getA().before(fromUntil.getB())) {</span>
<span class="fc" id="L563">          return createBadArgumentResponse(p);</span>
        }
<span class="fc" id="L565">      }</span>
<span class="pc bpc" id="L566" title="2 of 4 branches missed.">      if (otherParamExists &amp;&amp; p.getMetadataPrefix().isNone())</span>
<span class="nc" id="L567">        return createBadArgumentResponse(p);</span>
      // &lt;- params are ok

<span class="fc" id="L570">      final Option&lt;Date&gt; until = untilGranularity.orElse(some(currentDate()));</span>

<span class="fc" id="L572">      final String metadataPrefix = p.getResumptionToken().flatMap(getMetadataPrefixFromToken)</span>
<span class="fc" id="L573">              .getOrElse(getMetadataPrefix(p));</span>

<span class="pc bpc" id="L575" title="1 of 2 branches missed.">      for (MetadataProvider metadataProvider : p.getResumptionToken()</span>
<span class="fc" id="L576">              .flatMap(getMetadataProviderFromToken)</span>
<span class="fc" id="L577">              .orElse(getMetadataProvider.curry(metadataPrefix))) {</span>
        try {
          final SearchResult result;
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L581">          final Option&lt;String&gt;[] set = new Option[]{p.getSet()};</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">          if (!resumptionTokenExists) {</span>
            // start a new query
<span class="pc bpc" id="L584" title="3 of 4 branches missed.">            if (p.getSet().isSome() &amp;&amp; !sets.stream().anyMatch(</span>
<span class="nc" id="L585">                setDef -&gt; StringUtils.equals(setDef.getSetSpec(), p.getSet().get()))) {</span>
              // If there is no set specification, immediately return a no result response
<span class="nc" id="L587">              return createNoRecordsMatchResponse(p);</span>
            }
<span class="fc" id="L589">            result = getPersistence().search(</span>
<span class="fc" id="L590">                    queryRepo(getRepositoryId())</span>
<span class="fc" id="L591">                            .setDefinitions(sets)</span>
<span class="fc" id="L592">                            .setSpec(p.getSet().getOrElseNull())</span>
<span class="fc" id="L593">                            .modifiedAfter(from)</span>
<span class="fc" id="L594">                            .modifiedBefore(until)</span>
<span class="fc" id="L595">                            .limit(getResultLimit()).build());</span>
          } else {
            // resume query
<span class="nc" id="L598">            result = getSavedQuery(p.getResumptionToken().get()).fold(new Option.Match&lt;ResumableQuery, SearchResult&gt;() {</span>
              @Override
              public SearchResult some(ResumableQuery rq) {
<span class="nc" id="L601">                set[0] = rq.getSet();</span>
<span class="nc" id="L602">                return getPersistence().search(</span>
<span class="nc" id="L603">                        queryRepo(getRepositoryId())</span>
<span class="nc" id="L604">                                .setDefinitions(sets)</span>
<span class="nc" id="L605">                                .setSpec(rq.getSet().getOrElseNull())</span>
<span class="nc" id="L606">                                .modifiedAfter(rq.getLastResult())</span>
<span class="nc" id="L607">                                .modifiedBefore(rq.getUntil())</span>
<span class="nc" id="L608">                                .limit(getResultLimit())</span>
<span class="nc" id="L609">                                .subsequentRequest(true).build());</span>
              }

              @Override
              public SearchResult none() {
                // no resumable query found
<span class="nc" id="L615">                throw new BadResumptionTokenException();</span>
              }
            });
          }
<span class="fc bfc" id="L619" title="All 2 branches covered.">          if (result.size() &gt; 0) {</span>
<span class="fc" id="L620">            return respond(new ListGenParams(OaiPmhRepository.this,</span>
                                             result,
                                             metadataProvider,
                                             metadataPrefix,
<span class="fc" id="L624">                                             p.getResumptionToken(),</span>
<span class="fc" id="L625">                                             from, until.get(),</span>
                                             set[0],
                                             p));
          } else {
<span class="fc" id="L629">            return createNoRecordsMatchResponse(p);</span>
          }
<span class="nc" id="L631">        } catch (BadResumptionTokenException e) {</span>
<span class="nc" id="L632">          return createBadResumptionTokenResponse(p);</span>
        }
      }
      // no metadata provider found
<span class="nc" id="L636">      return createCannotDisseminateFormatResponse(p);</span>
    }

    /** Get a metadata prefix from a resumption token. */
<span class="fc" id="L640">    private final Function&lt;String, Option&lt;String&gt;&gt; getMetadataPrefixFromToken = new Function&lt;String, Option&lt;String&gt;&gt;() {</span>
      @Override
      public Option&lt;String&gt; apply(String token) {
<span class="nc" id="L643">        return getSavedQuery(token).map(new Function&lt;ResumableQuery, String&gt;() {</span>
          @Override
          public String apply(ResumableQuery resumableQuery) {
<span class="nc" id="L646">            return resumableQuery.getMetadataPrefix();</span>
          }
        });
      }
    };

    /** Get a metadata provider from a resumption token. */
<span class="fc" id="L653">    private final Function&lt;String, Option&lt;MetadataProvider&gt;&gt; getMetadataProviderFromToken = new Function&lt;String, Option&lt;MetadataProvider&gt;&gt;() {</span>
      @Override
      public Option&lt;MetadataProvider&gt; apply(String token) {
<span class="nc" id="L656">        return getSavedQuery(token).flatMap(new Function&lt;ResumableQuery, Option&lt;MetadataProvider&gt;&gt;() {</span>
          @Override
          public Option&lt;MetadataProvider&gt; apply(ResumableQuery resumableQuery) {
<span class="nc" id="L659">            return getMetadataProvider(resumableQuery.getMetadataPrefix());</span>
          }
        });
      }
    };

    /** Get the metadata prefix lazily. */
    private Function0&lt;String&gt; getMetadataPrefix(final Params p) {
<span class="fc" id="L667">      return new Function0&lt;String&gt;() {</span>
        @Override
        public String apply() {
<span class="fc" id="L670">          return p.getMetadataPrefix().getOrElse(OaiPmhConstants.OAI_DC_METADATA_FORMAT.getPrefix());</span>
        }
      };
    }

    /** OAI XML response generation environment for list responses. */
    abstract class ListXmlGen extends OaiVerbXmlGen {

      protected final ListGenParams params;

<span class="fc" id="L680">      ListXmlGen(ListGenParams p) {</span>
<span class="fc" id="L681">        super(p.getRepository(), p.getParams());</span>
<span class="fc" id="L682">        this.params = p;</span>
<span class="fc" id="L683">      }</span>

      /** Implement to create your content. Gets placed as children of the verb node. */
      protected abstract List&lt;Node&gt; createContent(Option&lt;String&gt; set);

      @Override
      public Element create() {
<span class="fc" id="L690">        final List&lt;Node&gt; content = new ArrayList&lt;Node&gt;(createContent(params.getSet()));</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">        if (content.size() == 0)</span>
<span class="nc" id="L692">          return createNoRecordsMatchResponse(params.getParams()).create();</span>
<span class="fc" id="L693">        content.add(resumptionToken(params.getResumptionToken(), params.getMetadataPrefix(), params.getResult(),</span>
<span class="fc" id="L694">                                    params.getUntil(), params.getSet()));</span>
<span class="fc" id="L695">        return oai(</span>
<span class="fc" id="L696">                request($a(&quot;metadataPrefix&quot;, params.getMetadataPrefix()),</span>
<span class="fc" id="L697">                        $aSome(&quot;from&quot;, params.getFrom().map(toSupportedGranularity)),</span>
<span class="fc" id="L698">                        $aSome(&quot;until&quot;, some(toSupportedGranularity(params.getUntil()))),</span>
<span class="fc" id="L699">                        $aSome(&quot;set&quot;, params.getSet())), verb(content));</span>
      }
    }

<span class="nc" id="L703">    private class BadResumptionTokenException extends RuntimeException {</span>
    }
  }
}

/** Parameter holder for the list generator. */
final class ListGenParams {
  private final OaiPmhRepository repository;
  private final SearchResult result;
  private final MetadataProvider metadataProvider;
  private final String metadataPrefix;
  private final Option&lt;String&gt; resumptionToken;
  private final Option&lt;Date&gt; from;
  private final Date until;
  private final Option&lt;String&gt; set;
  private final Params params;

  // CHECKSTYLE:OFF
  ListGenParams(OaiPmhRepository repository,
                SearchResult result, MetadataProvider metadataProvider,
                String metadataPrefix, Option&lt;String&gt; resumptionToken,
                Option&lt;Date&gt; from, Date until,
                Option&lt;String&gt; set,
<span class="fc" id="L726">                Params params) {</span>
<span class="fc" id="L727">    this.repository = repository;</span>
<span class="fc" id="L728">    this.result = result;</span>
<span class="fc" id="L729">    this.metadataProvider = metadataProvider;</span>
<span class="fc" id="L730">    this.resumptionToken = resumptionToken;</span>
<span class="fc" id="L731">    this.metadataPrefix = metadataPrefix;</span>
<span class="fc" id="L732">    this.from = from;</span>
<span class="fc" id="L733">    this.until = until;</span>
<span class="fc" id="L734">    this.set = set;</span>
<span class="fc" id="L735">    this.params = params;</span>
<span class="fc" id="L736">  }</span>
  // CHECKSTYLE:ON

  public OaiPmhRepository getRepository() {
<span class="fc" id="L740">    return repository;</span>
  }

  public SearchResult getResult() {
<span class="fc" id="L744">    return result;</span>
  }

  public MetadataProvider getMetadataProvider() {
<span class="fc" id="L748">    return metadataProvider;</span>
  }

  public Option&lt;String&gt; getResumptionToken() {
<span class="fc" id="L752">    return resumptionToken;</span>
  }

  public String getMetadataPrefix() {
<span class="fc" id="L756">    return metadataPrefix;</span>
  }

  public Option&lt;Date&gt; getFrom() {
<span class="fc" id="L760">    return from;</span>
  }

  public Date getUntil() {
<span class="fc" id="L764">    return until;</span>
  }

  public Option&lt;String&gt; getSet() {
<span class="fc" id="L768">    return set;</span>
  }

  /** The request parameters. */
  public Params getParams() {
<span class="fc" id="L773">    return params;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>