<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EventIndexUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-elasticsearch-index</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.elasticsearch.index.objects.event</a> &gt; <span class="el_source">EventIndexUtils.java</span></div><h1>EventIndexUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.elasticsearch.index.objects.event;

import static org.opencastproject.security.util.SecurityUtil.getEpisodeRoleId;

import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchMetadata;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.impl.SearchMetadataCollection;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.series.Series;
import org.opencastproject.elasticsearch.index.objects.series.SeriesIndexSchema;
import org.opencastproject.elasticsearch.index.objects.series.SeriesSearchQuery;
import org.opencastproject.list.api.ListProviderException;
import org.opencastproject.list.api.ListProvidersService;
import org.opencastproject.list.api.ResourceListQuery;
import org.opencastproject.list.impl.ResourceListQueryImpl;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.EName;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.Publication;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.metadata.dublincore.DCMIPeriod;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.EncodingSchemeUtils;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.Permissions.Action;
import org.opencastproject.security.api.User;
import org.opencastproject.util.DateTimeSupport;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import javax.xml.bind.Unmarshaller;

/**
 * Utility implementation to deal with the conversion of recording events and its corresponding index data structures.
 */
public final class EventIndexUtils {

<span class="fc" id="L81">  private static final Logger logger = LoggerFactory.getLogger(EventIndexUtils.class);</span>

  // The number of attempts to get the series title in case it hasn't been added to the index.
  public static final int DEFAULT_ATTEMPTS = 10;
  // The amount of time in ms to wait before trying to get the series title again.
  public static final long DEFAULT_SLEEP = 100L;

  /**
   * This is a utility class and should therefore not be instantiated.
   */
  private EventIndexUtils() {
  }

  /**
   * Creates a search result item based on the data returned from the search index.
   *
   * @param metadata
   *          the search metadata
   * @param unmarshaller the unmarshaller to use
   * @return the search result item
   * @throws IOException
   *           if unmarshalling fails
   */
  public static Event toRecordingEvent(SearchMetadataCollection metadata, Unmarshaller unmarshaller)
          throws IOException {
<span class="nc" id="L106">    Map&lt;String, SearchMetadata&lt;?&gt;&gt; metadataMap = metadata.toMap();</span>
<span class="nc" id="L107">    String eventJson = (String) metadataMap.get(EventIndexSchema.OBJECT).getValue();</span>
<span class="nc" id="L108">    return Event.valueOf(IOUtils.toInputStream(eventJson, Charset.defaultCharset()), unmarshaller);</span>
  }

  /**
   * Creates search metadata from a recording event such that the event can be stored in the search index.
   *
   * @param event
   *          the recording event
   * @return the set of metadata
   */
  public static SearchMetadataCollection toSearchMetadata(Event event, ListProvidersService listProviderService,
      boolean episodeIdRole) {
<span class="nc" id="L120">    SearchMetadataCollection metadata = new SearchMetadataCollection(</span>
<span class="nc" id="L121">            event.getIdentifier().concat(event.getOrganization()), Event.DOCUMENT_TYPE);</span>
<span class="nc" id="L122">    metadata.addField(EventIndexSchema.UID, event.getIdentifier(), true);</span>
<span class="nc" id="L123">    metadata.addField(EventIndexSchema.ORGANIZATION, event.getOrganization(), false);</span>
<span class="nc" id="L124">    metadata.addField(EventIndexSchema.OBJECT, event.toXML(), false);</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getTitle())) {</span>
<span class="nc" id="L126">      metadata.addField(EventIndexSchema.TITLE, event.getTitle(), true);</span>
    }
<span class="nc bnc" id="L128" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getDescription())) {</span>
<span class="nc" id="L129">      metadata.addField(EventIndexSchema.DESCRIPTION, event.getDescription(), true);</span>
    }
<span class="nc bnc" id="L131" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getLocation())) {</span>
<span class="nc" id="L132">      metadata.addField(EventIndexSchema.LOCATION, event.getLocation(), true);</span>
    }
<span class="nc bnc" id="L134" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getSeriesId())) {</span>
<span class="nc" id="L135">      metadata.addField(EventIndexSchema.SERIES_ID, event.getSeriesId(), true);</span>
    }
<span class="nc bnc" id="L137" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getSeriesName())) {</span>
<span class="nc" id="L138">      metadata.addField(EventIndexSchema.SERIES_NAME, event.getSeriesName(), true);</span>
    }
<span class="nc bnc" id="L140" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getLanguage())) {</span>
<span class="nc" id="L141">      metadata.addField(EventIndexSchema.LANGUAGE, event.getLanguage(), true);</span>
    }
<span class="nc bnc" id="L143" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getSubject())) {</span>
<span class="nc" id="L144">      metadata.addField(EventIndexSchema.SUBJECT, event.getSubject(), true);</span>
    }
<span class="nc bnc" id="L146" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getSource())) {</span>
<span class="nc" id="L147">      metadata.addField(EventIndexSchema.SOURCE, event.getSource(), true);</span>
    }
<span class="nc bnc" id="L149" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getCreated())) {</span>
<span class="nc" id="L150">      metadata.addField(EventIndexSchema.CREATED, event.getCreated(), true);</span>
    }
<span class="nc bnc" id="L152" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getCreator())) {</span>
<span class="nc" id="L153">      metadata.addField(EventIndexSchema.CREATOR, event.getCreator(), true);</span>
    }
<span class="nc bnc" id="L155" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getPublisher())) {</span>
<span class="nc" id="L156">      metadata.addField(EventIndexSchema.PUBLISHER, event.getPublisher(), true);</span>
    }
<span class="nc bnc" id="L158" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getLicense())) {</span>
<span class="nc" id="L159">      metadata.addField(EventIndexSchema.LICENSE, event.getLicense(), true);</span>
    }
<span class="nc bnc" id="L161" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getRights())) {</span>
<span class="nc" id="L162">      metadata.addField(EventIndexSchema.RIGHTS, event.getRights(), true);</span>
    }
<span class="nc bnc" id="L164" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getManagedAcl())) {</span>
<span class="nc" id="L165">      metadata.addField(EventIndexSchema.MANAGED_ACL, event.getManagedAcl(), true);</span>
    }
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getWorkflowState())) {</span>
<span class="nc" id="L168">      metadata.addField(EventIndexSchema.WORKFLOW_STATE, event.getWorkflowState(), true);</span>
    }
<span class="nc bnc" id="L170" title="All 2 branches missed.">    if (event.getWorkflowId() != null) {</span>
<span class="nc" id="L171">      metadata.addField(EventIndexSchema.WORKFLOW_ID, event.getWorkflowId(), true);</span>
    }
<span class="nc bnc" id="L173" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getWorkflowDefinitionId())) {</span>
<span class="nc" id="L174">      metadata.addField(EventIndexSchema.WORKFLOW_DEFINITION_ID, event.getWorkflowDefinitionId(), true);</span>
    }
<span class="nc bnc" id="L176" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getRecordingStartDate())) {</span>
<span class="nc" id="L177">      metadata.addField(EventIndexSchema.START_DATE, event.getRecordingStartDate(), true);</span>
    }
<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getRecordingEndDate())) {</span>
<span class="nc" id="L180">      metadata.addField(EventIndexSchema.END_DATE, event.getRecordingEndDate(), true);</span>
    }
<span class="nc bnc" id="L182" title="All 2 branches missed.">    if (event.getDuration() != null) {</span>
<span class="nc" id="L183">      metadata.addField(EventIndexSchema.DURATION, event.getDuration(), true);</span>
    }
<span class="nc bnc" id="L185" title="All 2 branches missed.">    if (event.getArchiveVersion() != null) {</span>
<span class="nc" id="L186">      metadata.addField(EventIndexSchema.ARCHIVE_VERSION, event.getArchiveVersion(), true);</span>
    }
<span class="nc bnc" id="L188" title="All 2 branches missed.">    if (event.getRecordingStatus() != null) {</span>
<span class="nc" id="L189">      metadata.addField(EventIndexSchema.RECORDING_STATUS, event.getRecordingStatus(), true);</span>
    }

<span class="nc" id="L192">    metadata.addField(EventIndexSchema.EVENT_STATUS, event.getEventStatus(), true);</span>

<span class="nc" id="L194">    metadata.addField(EventIndexSchema.HAS_COMMENTS, event.hasComments(), true);</span>
<span class="nc" id="L195">    metadata.addField(EventIndexSchema.HAS_OPEN_COMMENTS, event.hasOpenComments(), true);</span>

<span class="nc bnc" id="L197" title="All 2 branches missed.">    if (event.comments() != null) {</span>
<span class="nc" id="L198">      List&lt;Comment&gt; comments = event.comments();</span>
<span class="nc" id="L199">      HashMap&lt;String, Object&gt;[] commentsArray = new HashMap[comments.size()];</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">      for (int i = 0; i &lt; comments.size(); i++) {</span>
<span class="nc" id="L201">        Comment comment = comments.get(i);</span>
<span class="nc" id="L202">        HashMap&lt;String, Object&gt; myMap = new HashMap&lt;String, Object&gt;() {{</span>
<span class="nc" id="L203">            put(CommentIndexSchema.ID, comment.getId());</span>
<span class="nc" id="L204">            put(CommentIndexSchema.REASON, comment.getReason());</span>
<span class="nc" id="L205">            put(CommentIndexSchema.TEXT, comment.getText());</span>
<span class="nc" id="L206">            put(CommentIndexSchema.RESOLVED_STATUS, comment.isResolvedStatus());</span>
<span class="nc" id="L207">          }};</span>
<span class="nc" id="L208">        commentsArray[i] = myMap;</span>
//        generatePublicationDoc(comments.get(i).getType());
      }

<span class="nc" id="L212">      metadata.addField(EventIndexSchema.COMMENTS, commentsArray, true);</span>
    }

<span class="nc" id="L215">    metadata.addField(EventIndexSchema.NEEDS_CUTTING, event.needsCutting(), true);</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">    if (event.getPublications() != null) {</span>
<span class="nc" id="L218">      List&lt;Publication&gt; publications = event.getPublications();</span>
<span class="nc" id="L219">      HashMap&lt;String, Object&gt;[] publicationsArray = new HashMap[publications.size()];</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">      for (int i = 0; i &lt; publications.size(); i++) {</span>
<span class="nc" id="L221">        publicationsArray[i] = generatePublicationDoc(publications.get(i));</span>
      }

<span class="nc bnc" id="L224" title="All 6 branches missed.">      if (publications.size() == 1 &amp;&amp; !publications.get(0).getChannel().equals(&quot;internal&quot;) || publications.size() &gt; 1) {</span>
<span class="nc" id="L225">        metadata.addField(EventIndexSchema.IS_PUBLISHED, true, true);</span>
      } else {
<span class="nc" id="L227">        metadata.addField(EventIndexSchema.IS_PUBLISHED, false, true);</span>
      }

<span class="nc" id="L230">      metadata.addField(EventIndexSchema.PUBLICATION, publicationsArray, true);</span>

    }

<span class="nc bnc" id="L234" title="All 2 branches missed.">    if (event.getPresenters() != null) {</span>
<span class="nc" id="L235">      List&lt;String&gt; presenters = event.getPresenters();</span>
<span class="nc" id="L236">      metadata.addField(EventIndexSchema.PRESENTER, presenters.toArray(new String[presenters.size()]), true);</span>
    }

<span class="nc bnc" id="L239" title="All 2 branches missed.">    if (event.getContributors() != null) {</span>
<span class="nc" id="L240">      List&lt;String&gt; contributors = event.getContributors();</span>
<span class="nc" id="L241">      metadata.addField(EventIndexSchema.CONTRIBUTOR, contributors.toArray(new String[contributors.size()]), true);</span>
    }

<span class="nc bnc" id="L244" title="All 2 branches missed.">    if (!event.getExtendedMetadata().isEmpty()) {</span>
<span class="nc" id="L245">      addExtendedMetadata(metadata, event.getExtendedMetadata());</span>
    }

<span class="nc bnc" id="L248" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getAccessPolicy())) {</span>
<span class="nc" id="L249">      metadata.addField(EventIndexSchema.ACCESS_POLICY, event.getAccessPolicy(), true);</span>
<span class="nc" id="L250">      addAuthorization(metadata, event.getAccessPolicy(), event.getIdentifier(), listProviderService, episodeIdRole);</span>
    }

<span class="nc bnc" id="L253" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getAgentId())) {</span>
<span class="nc" id="L254">      metadata.addField(EventIndexSchema.AGENT_ID, event.getAgentId(), true);</span>
    }

<span class="nc bnc" id="L257" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getTechnicalStartTime())) {</span>
<span class="nc" id="L258">      metadata.addField(EventIndexSchema.TECHNICAL_START, event.getTechnicalStartTime(), true);</span>
    }

<span class="nc bnc" id="L261" title="All 2 branches missed.">    if (StringUtils.isNotBlank(event.getTechnicalEndTime())) {</span>
<span class="nc" id="L262">      metadata.addField(EventIndexSchema.TECHNICAL_END, event.getTechnicalEndTime(), true);</span>
    }

<span class="nc bnc" id="L265" title="All 2 branches missed.">    if (event.getTechnicalPresenters() != null) {</span>
<span class="nc" id="L266">      metadata.addField(EventIndexSchema.TECHNICAL_PRESENTERS,</span>
<span class="nc" id="L267">              event.getTechnicalPresenters().toArray(new String[event.getTechnicalPresenters().size()]), true);</span>
    }

<span class="nc" id="L270">    return metadata;</span>
  }

  private static void addObjectStringtToMap(HashMap&lt;String, Object&gt; map, String key, Object value) {
<span class="nc bnc" id="L274" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L275">      map.put(key, &quot;&quot;);</span>
    } else {
<span class="nc" id="L277">      map.put(key, value.toString());</span>
    }
<span class="nc" id="L279">  }</span>

  /**
   * Generate the document structure for the publication element
   *
   * @param publication
   *          the source publication element
   * @return a map representing the ES document structure of the publication element
   */
  private static HashMap&lt;String, Object&gt; generatePublicationDoc(Publication publication) {
<span class="nc" id="L289">    HashMap&lt;String, Object&gt; pMap = new HashMap&lt;String, Object&gt;();</span>

    // Add first level elements
<span class="nc" id="L292">    pMap.put(PublicationIndexSchema.CHANNEL, publication.getChannel());</span>
<span class="nc" id="L293">    addObjectStringtToMap(pMap, PublicationIndexSchema.MIMETYPE, publication.getMimeType());</span>

    // Attachments
<span class="nc" id="L296">    Attachment[] attachments = publication.getAttachments();</span>
<span class="nc" id="L297">    HashMap&lt;String, Object&gt;[] attachmentsArray = new HashMap[attachments.length];</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">    for (int i = 0; i &lt; attachmentsArray.length; i++) {</span>
<span class="nc" id="L299">      Attachment attachment = attachments[i];</span>
<span class="nc" id="L300">      HashMap&lt;String, Object&gt; element = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L301">      element.put(PublicationIndexSchema.ELEMENT_ID, attachment.getIdentifier());</span>
<span class="nc" id="L302">      addObjectStringtToMap(element, PublicationIndexSchema.ELEMENT_MIMETYPE, attachment.getMimeType());</span>
<span class="nc" id="L303">      addObjectStringtToMap(element, PublicationIndexSchema.ELEMENT_TYPE, attachment.getElementType());</span>
<span class="nc" id="L304">      element.put(PublicationIndexSchema.ELEMENT_TAG, attachment.getTags());</span>
<span class="nc" id="L305">      addObjectStringtToMap(element, PublicationIndexSchema.ELEMENT_URL, attachment.getURI());</span>
<span class="nc" id="L306">      element.put(PublicationIndexSchema.ELEMENT_SIZE, attachment.getSize());</span>
<span class="nc" id="L307">      attachmentsArray[i] = element;</span>
    }
<span class="nc" id="L309">    pMap.put(PublicationIndexSchema.ATTACHMENT, attachmentsArray);</span>

    // Catalogs
<span class="nc" id="L312">    Catalog[] catalogs = publication.getCatalogs();</span>
<span class="nc" id="L313">    HashMap&lt;String, Object&gt;[] catalogsArray = new HashMap[catalogs.length];</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">    for (int i = 0; i &lt; catalogsArray.length; i++) {</span>
<span class="nc" id="L315">      Catalog catalog = catalogs[i];</span>
<span class="nc" id="L316">      HashMap&lt;String, Object&gt; element = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L317">      element.put(PublicationIndexSchema.ELEMENT_ID, catalog.getIdentifier());</span>
<span class="nc" id="L318">      addObjectStringtToMap(element, PublicationIndexSchema.ELEMENT_MIMETYPE, catalog.getMimeType());</span>
<span class="nc" id="L319">      addObjectStringtToMap(element, PublicationIndexSchema.ELEMENT_TYPE, catalog.getElementType());</span>
<span class="nc" id="L320">      element.put(PublicationIndexSchema.ELEMENT_TAG, catalog.getTags());</span>
<span class="nc" id="L321">      addObjectStringtToMap(element, PublicationIndexSchema.ELEMENT_URL, catalog.getURI());</span>
<span class="nc" id="L322">      element.put(PublicationIndexSchema.ELEMENT_SIZE, catalog.getSize());</span>
<span class="nc" id="L323">      catalogsArray[i] = element;</span>
    }
<span class="nc" id="L325">    pMap.put(PublicationIndexSchema.CATALOG, catalogsArray);</span>

    // Tracks
<span class="nc" id="L328">    Track[] tracks = publication.getTracks();</span>
<span class="nc" id="L329">    HashMap&lt;String, Object&gt;[] tracksArray = new HashMap[tracks.length];</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">    for (int i = 0; i &lt; tracksArray.length; i++) {</span>
<span class="nc" id="L331">      Track track = tracks[i];</span>
<span class="nc" id="L332">      HashMap&lt;String, Object&gt; element = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L333">      element.put(PublicationIndexSchema.ELEMENT_ID, track.getIdentifier());</span>
<span class="nc" id="L334">      addObjectStringtToMap(element, PublicationIndexSchema.ELEMENT_MIMETYPE, track.getMimeType());</span>
<span class="nc" id="L335">      addObjectStringtToMap(element, PublicationIndexSchema.ELEMENT_TYPE, track.getElementType());</span>
<span class="nc" id="L336">      element.put(PublicationIndexSchema.ELEMENT_TAG, track.getTags());</span>
<span class="nc" id="L337">      addObjectStringtToMap(element, PublicationIndexSchema.ELEMENT_URL, track.getURI());</span>
<span class="nc" id="L338">      element.put(PublicationIndexSchema.ELEMENT_SIZE, track.getSize());</span>
<span class="nc" id="L339">      element.put(PublicationIndexSchema.TRACK_DURATION, track.getDuration());</span>
<span class="nc" id="L340">      tracksArray[i] = element;</span>
    }
<span class="nc" id="L342">    pMap.put(PublicationIndexSchema.TRACK, tracksArray);</span>

<span class="nc" id="L344">    return pMap;</span>
  }

  /**
   * Adds extended metadata fields to the input document
   *
   * @param doc
   *          the input document
   * @param extendedMetadata
   *          the extended metadata map
   */
  private static void addExtendedMetadata(SearchMetadataCollection doc, Map&lt;String, Map&lt;String,
          List&lt;String&gt;&gt;&gt; extendedMetadata) {
<span class="nc bnc" id="L357" title="All 2 branches missed.">    for (String type: extendedMetadata.keySet()) {</span>
<span class="nc" id="L358">      Map&lt;String, List&lt;String&gt;&gt; extendedMetadataByType = extendedMetadata.get(type);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">      for (String name: extendedMetadataByType.keySet()) {</span>
<span class="nc" id="L360">        List&lt;String&gt; values = extendedMetadataByType.get(name);</span>
<span class="nc" id="L361">        String fieldName = SeriesIndexSchema.EXTENDED_METADATA_PREFIX.concat(type + &quot;_&quot; + name);</span>
<span class="nc" id="L362">        doc.addField(fieldName, values, true);</span>
<span class="nc" id="L363">      }</span>
<span class="nc" id="L364">    }</span>
<span class="nc" id="L365">  }</span>

  /**
   * Adds authorization fields to the input document.
   *
   * @param doc
   *          the input document
   * @param aclString
   *          the access control list string
   */
  private static void addAuthorization(SearchMetadataCollection doc, String aclString,
      String eventId, ListProvidersService listProvidersService, boolean episodeIdRole) {
<span class="nc" id="L377">    Map&lt;String, List&lt;String&gt;&gt; permissions = new HashMap&lt;&gt;();</span>

    // Define containers for common permissions
<span class="nc bnc" id="L380" title="All 2 branches missed.">    for (Action action : Permissions.Action.values()) {</span>
<span class="nc" id="L381">      permissions.put(action.toString(), new ArrayList&lt;&gt;());</span>
    }

    // Add roles from acl
<span class="nc" id="L385">    AccessControlList acl = AccessControlParser.parseAclSilent(aclString);</span>
<span class="nc" id="L386">    List&lt;AccessControlEntry&gt; entries = acl.getEntries();</span>

    // Add special action roles for episode id roles
<span class="nc bnc" id="L389" title="All 2 branches missed.">    if (episodeIdRole) {</span>
<span class="nc" id="L390">      Set&lt;AccessControlEntry&gt; customEntries = new HashSet&lt;&gt;();</span>
<span class="nc" id="L391">      customEntries.add(new AccessControlEntry(getEpisodeRoleId(eventId, &quot;READ&quot;), &quot;read&quot;, true));</span>
<span class="nc" id="L392">      customEntries.add(new AccessControlEntry(getEpisodeRoleId(eventId, &quot;WRITE&quot;), &quot;write&quot;, true));</span>

<span class="nc" id="L394">      ResourceListQuery query = new ResourceListQueryImpl();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">      if (listProvidersService.hasProvider(&quot;ACL.ACTIONS&quot;)) {</span>
<span class="nc" id="L396">        Map&lt;String, String&gt; actions = new HashMap&lt;&gt;();</span>
        try {
<span class="nc" id="L398">          actions = listProvidersService.getList(&quot;ACL.ACTIONS&quot;, query, true);</span>
<span class="nc" id="L399">        } catch (ListProviderException e) {</span>
<span class="nc" id="L400">          logger.error(&quot;Listproviders not loaded. &quot; + e);</span>
<span class="nc" id="L401">        }</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        for (String action : actions.keySet()) {</span>
<span class="nc" id="L403">          customEntries.add(new AccessControlEntry(getEpisodeRoleId(eventId, action), action, true));</span>
<span class="nc" id="L404">        }</span>
      }

<span class="nc" id="L407">      entries.addAll(customEntries);</span>
    }

    // Convert roles to permission blocks
<span class="nc bnc" id="L411" title="All 2 branches missed.">    for (AccessControlEntry entry : entries) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">      if (!entry.isAllow()) {</span>
<span class="nc" id="L413">        logger.info(&quot;Event index does not support denial via ACL, ignoring {}&quot;, entry);</span>
<span class="nc" id="L414">        continue;</span>
      }
<span class="nc" id="L416">      List&lt;String&gt; actionPermissions = permissions.get(entry.getAction());</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">      if (actionPermissions == null) {</span>
<span class="nc" id="L418">        actionPermissions = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L419">        permissions.put(entry.getAction(), actionPermissions);</span>
      }
<span class="nc" id="L421">      actionPermissions.add(entry.getRole());</span>
<span class="nc" id="L422">    }</span>

    // Write the permissions to the input document
<span class="nc bnc" id="L425" title="All 2 branches missed.">    for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : permissions.entrySet()) {</span>
<span class="nc" id="L426">      String fieldName = EventIndexSchema.ACL_PERMISSION_PREFIX.concat(entry.getKey());</span>
<span class="nc" id="L427">      doc.addField(fieldName, entry.getValue(), false);</span>
<span class="nc" id="L428">    }</span>
<span class="nc" id="L429">  }</span>

  /**
   * Update extended metadata for event from dublin core catalog.
   *
   * @param event
   *         The event
   * @param dc
   *         The dublin core catalog with extended metadata
   * @param flavor
   *         The flavor of the extended metadata
   * @return
   *         The updated event
   */
  public static Event updateEventExtendedMetadata(Event event, DublinCoreCatalog dc, MediaPackageElementFlavor flavor) {
<span class="nc" id="L444">    Map&lt;String, List&lt;String&gt;&gt; map = new HashMap();</span>
<span class="nc" id="L445">    Set&lt;EName&gt; eNames = dc.getProperties();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">    for (EName eName: eNames) {</span>
<span class="nc" id="L447">      String name = eName.getLocalName();</span>
<span class="nc" id="L448">      List&lt;String&gt; values = dc.get(eName, DublinCore.LANGUAGE_ANY);</span>
<span class="nc" id="L449">      map.put(name, values);</span>
<span class="nc" id="L450">    }</span>
<span class="nc" id="L451">    event.setExtendedMetadata(flavor.toString(), map);</span>
<span class="nc" id="L452">    return event;</span>
  }

  /**
   * Update the given {@link Event} with the given {@link DublinCore}.
   *
   * @param event
   *          the event to update
   * @param dc
   *          the catalog with the metadata for the update
   * @return the updated event
   */
  public static Event updateEvent(Event event, DublinCore dc) {
<span class="fc" id="L465">    event.setTitle(dc.getFirst(DublinCore.PROPERTY_TITLE));</span>
<span class="fc" id="L466">    event.setDescription(dc.getFirst(DublinCore.PROPERTY_DESCRIPTION));</span>
<span class="fc" id="L467">    event.setSubject(dc.getFirst(DublinCore.PROPERTY_SUBJECT));</span>
<span class="fc" id="L468">    event.setLocation(dc.getFirst(DublinCore.PROPERTY_SPATIAL));</span>
<span class="fc" id="L469">    event.setLanguage(dc.getFirst(DublinCore.PROPERTY_LANGUAGE));</span>
<span class="fc" id="L470">    event.setSource(dc.getFirst(DublinCore.PROPERTY_SOURCE));</span>
<span class="fc" id="L471">    event.setSeriesId(dc.getFirst(DublinCore.PROPERTY_IS_PART_OF));</span>
<span class="fc" id="L472">    event.setLicense(dc.getFirst(DublinCore.PROPERTY_LICENSE));</span>
<span class="fc" id="L473">    event.setRights(dc.getFirst(DublinCore.PROPERTY_RIGHTS_HOLDER));</span>
<span class="fc" id="L474">    event.setPublisher(dc.getFirst(DublinCore.PROPERTY_PUBLISHER));</span>
    Date created;
<span class="fc" id="L476">    String encodedDate = dc.getFirst(DublinCore.PROPERTY_CREATED);</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">    if (StringUtils.isBlank(encodedDate)) {</span>
<span class="nc" id="L478">      created = new Date();</span>
    } else {
<span class="fc" id="L480">      created = EncodingSchemeUtils.decodeDate(encodedDate);</span>
    }
<span class="fc" id="L482">    event.setCreated(DateTimeSupport.toUTC(created.getTime()));</span>
<span class="fc" id="L483">    String strPeriod = dc.getFirst(DublinCore.PROPERTY_TEMPORAL);</span>
    try {
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(strPeriod)) {</span>
<span class="fc" id="L486">        DCMIPeriod period = EncodingSchemeUtils.decodeMandatoryPeriod(strPeriod);</span>
<span class="fc" id="L487">        event.setRecordingStartDate(DateTimeSupport.toUTC(period.getStart().getTime()));</span>
<span class="fc" id="L488">        event.setRecordingEndDate(DateTimeSupport.toUTC(period.getEnd().getTime()));</span>
<span class="fc" id="L489">        event.setDuration(period.getEnd().getTime() - period.getStart().getTime());</span>
<span class="fc" id="L490">      } else {</span>
<span class="nc" id="L491">        event.setRecordingStartDate(DateTimeSupport.toUTC(created.getTime()));</span>
      }
<span class="nc" id="L493">    } catch (Exception e) {</span>
<span class="nc" id="L494">      logger.warn(&quot;Invalid start and end date/time for event {}: {}&quot;, event.getIdentifier(), strPeriod);</span>
<span class="nc" id="L495">      event.setRecordingStartDate(DateTimeSupport.toUTC(created.getTime()));</span>
<span class="fc" id="L496">    }</span>

<span class="fc" id="L498">    updateTechnicalDate(event);</span>

    // TODO: Add support for language
<span class="fc" id="L501">    event.setContributors(dc.get(DublinCore.PROPERTY_CONTRIBUTOR, DublinCore.LANGUAGE_ANY));</span>
<span class="fc" id="L502">    event.setPresenters(dc.get(DublinCore.PROPERTY_CREATOR, DublinCore.LANGUAGE_ANY));</span>
<span class="fc" id="L503">    return event;</span>
  }

  public static Event updateTechnicalDate(Event event) {
<span class="pc bpc" id="L507" title="3 of 4 branches missed.">    if (event.isScheduledEvent() &amp;&amp; event.hasRecordingStarted()) {</span>
      // Override technical dates from recording if already started
<span class="nc" id="L509">      event.setTechnicalStartTime(event.getRecordingStartDate());</span>
<span class="nc" id="L510">      event.setTechnicalEndTime(event.getRecordingEndDate());</span>
    } else {
      // If this is an upload where the start time is not set, set the start time to same as dublin core
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">      if (StringUtils.isBlank(event.getTechnicalStartTime())) {</span>
<span class="fc" id="L514">        event.setTechnicalStartTime(event.getRecordingStartDate());</span>
      }
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">      if (StringUtils.isBlank(event.getTechnicalEndTime())) {</span>
<span class="fc" id="L517">        event.setTechnicalEndTime(event.getRecordingEndDate());</span>
      }
    }
<span class="fc" id="L520">    return event;</span>
  }

  /**
   * Update the given {@link Event} with the given {@link MediaPackage}.
   *
   * @param event
   *          the event to update
   * @param mp
   *          the mediapackage containing the metadata for the update
   * @return the updated event
   */
  public static Event updateEvent(Event event, MediaPackage mp) {
<span class="nc" id="L533">    event.setPublications(Arrays.asList(mp.getPublications()));</span>
<span class="nc" id="L534">    event.setSeriesName(mp.getSeriesTitle());</span>
<span class="nc" id="L535">    return event;</span>
  }

  /**
   * A function to update the series title within an event. Uses the default number of attempts to get the series title
   * and the default amount of time to sleep between attempts.
   *
   * @param event
   *          The event to update the series name in
   * @param organization
   *          The organization for this event and series
   * @param user
   *          The user
   * @param searchIndex
   *          The index to search for the series
   */
  public static void updateSeriesName(Event event, String organization, User user, ElasticsearchIndex searchIndex)
          throws SearchIndexException {
<span class="fc" id="L553">    updateSeriesName(event, organization, user, searchIndex, DEFAULT_ATTEMPTS, DEFAULT_SLEEP);</span>
<span class="fc" id="L554">  }</span>

  /**
   * A function to update the series title within an event.
   *
   * @param event
   *          The event to update the series name in
   * @param organization
   *          The organization for this event and series
   * @param user
   *          The user
   * @param searchIndex
   *          The index to search for the series
   * @param tries
   *          The number of attempts to try to get the series title
   * @param sleep
   *          The amount of time in ms to sleep between attempts to get the series title.
   */
  public static void updateSeriesName(Event event, String organization, User user, ElasticsearchIndex searchIndex,
          int tries, long sleep) throws SearchIndexException {
<span class="fc bfc" id="L574" title="All 2 branches covered.">    if (event.getSeriesId() != null) {</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">      for (int i = 1; i &lt;= tries; i++) {</span>
<span class="fc" id="L576">        SearchResult&lt;Series&gt; result = searchIndex.getByQuery(</span>
<span class="fc" id="L577">                new SeriesSearchQuery(organization, user).withoutActions().withIdentifier(event.getSeriesId()));</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">        if (result.getHitCount() &gt; 0) {</span>
<span class="fc" id="L579">          event.setSeriesName(result.getItems()[0].getSource().getTitle());</span>
<span class="fc" id="L580">          break;</span>
        } else {
<span class="fc" id="L582">          Integer triesLeft = tries - i;</span>
<span class="fc" id="L583">          logger.debug(&quot;Not able to find the series {} in the search index for the event {}. Will try {} more times.&quot;,</span>
<span class="fc" id="L584">                  event.getSeriesId(), event.getIdentifier(), triesLeft);</span>
          try {
<span class="fc" id="L586">            Thread.sleep(sleep);</span>
<span class="nc" id="L587">          } catch (InterruptedException e) {</span>
<span class="nc" id="L588">            logger.warn(&quot;Interrupted while sleeping before checking for the series being added to the index&quot;, e);</span>
<span class="fc" id="L589">          }</span>
        }

      }
    }
<span class="fc" id="L594">  }</span>

 /**
   * Gets all of the MediaPackageElement's flavors.
   *
   * @param publications
   *          The list of publication elements to get the flavors from.
   * @return An array of {@link String} representation of the MediaPackageElementFlavors
   */
  private static String[] getPublicationFlavors(List&lt;Publication&gt; publications) {
<span class="nc" id="L604">    Set&lt;String&gt; allPublicationFlavors = new TreeSet&lt;String&gt;();</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">    for (Publication p : publications) {</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">      for (Attachment attachment : p.getAttachments()) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (attachment.getFlavor() != null) {</span>
<span class="nc" id="L608">          allPublicationFlavors.add(attachment.getFlavor().toString());</span>
        }
      }
<span class="nc bnc" id="L611" title="All 2 branches missed.">      for (Catalog catalog : p.getCatalogs()) {</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (catalog.getFlavor() != null) {</span>
<span class="nc" id="L613">          allPublicationFlavors.add(catalog.getFlavor().toString());</span>
        }
      }
<span class="nc bnc" id="L616" title="All 2 branches missed.">      for (Track track : p.getTracks()) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (track.getFlavor() != null) {</span>
<span class="nc" id="L618">          allPublicationFlavors.add(track.getFlavor().toString());</span>
        }
      }
<span class="nc" id="L621">    }</span>
<span class="nc" id="L622">    return allPublicationFlavors.toArray(new String[allPublicationFlavors.size()]);</span>
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if the previewSubtype matches any of the publicationFlavors.
   *
   * @param publications
   * @param previewSubtype
   * @return
   */
  public static Boolean subflavorMatches(List&lt;Publication&gt; publications, String previewSubtype) {
<span class="nc" id="L633">    String[] publicationFlavors = getPublicationFlavors(publications);</span>
<span class="nc bnc" id="L634" title="All 4 branches missed.">    if (publicationFlavors != null &amp;&amp; previewSubtype != null) {</span>
<span class="nc" id="L635">      final String subtype = &quot;/&quot; + previewSubtype;</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">      for (String flavor : publicationFlavors) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">        if (flavor.endsWith(subtype)) {</span>
<span class="nc" id="L638">          return true;</span>
        }
      }
    }
<span class="nc" id="L642">    return false;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>