<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EventSearchQuery.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-elasticsearch-index</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.elasticsearch.index.objects.event</a> &gt; <span class="el_source">EventSearchQuery.java</span></div><h1>EventSearchQuery.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.elasticsearch.index.objects.event;

import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;

import org.opencastproject.elasticsearch.impl.AbstractSearchQuery;
import org.opencastproject.elasticsearch.impl.IndexSchema;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.Permissions.Action;
import org.opencastproject.security.api.User;
import org.opencastproject.util.requests.SortCriterion.Order;

import org.apache.commons.lang3.StringUtils;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * This interface defines a fluent api for a query object used to lookup recording events in the search index.
 */
public class EventSearchQuery extends AbstractSearchQuery {

<span class="pc" id="L47">  private final List&lt;String&gt; identifiers = new ArrayList&lt;String&gt;();</span>
<span class="pc" id="L48">  private String organization = null;</span>
<span class="pc" id="L49">  private User user = null;</span>
<span class="pc" id="L50">  private String title = null;</span>
<span class="pc" id="L51">  private String description = null;</span>
<span class="pc" id="L52">  private final Set&lt;String&gt; actions = new HashSet&lt;String&gt;();</span>
<span class="pc" id="L53">  private final List&lt;String&gt; presenters = new ArrayList&lt;String&gt;();</span>
<span class="pc" id="L54">  private final List&lt;String&gt; contributors = new ArrayList&lt;String&gt;();</span>
<span class="pc" id="L55">  private String subject = null;</span>
<span class="pc" id="L56">  private String location = null;</span>
<span class="pc" id="L57">  private String seriesId = null;</span>
<span class="pc" id="L58">  private String seriesName = null;</span>
<span class="pc" id="L59">  private String language = null;</span>
<span class="pc" id="L60">  private String source = null;</span>
<span class="pc" id="L61">  private String created = null;</span>
<span class="pc" id="L62">  private Date startFrom = null;</span>
<span class="pc" id="L63">  private Date startTo = null;</span>
<span class="pc" id="L64">  private Date technicalStartFrom = null;</span>
<span class="pc" id="L65">  private Date technicalStartTo = null;</span>
<span class="pc" id="L66">  private String creator = null;</span>
<span class="pc" id="L67">  private String publisher = null;</span>
<span class="pc" id="L68">  private String license = null;</span>
<span class="pc" id="L69">  private String rights = null;</span>
<span class="pc" id="L70">  private String accessPolicy = null;</span>
<span class="pc" id="L71">  private String managedAcl = null;</span>
<span class="pc" id="L72">  private String workflowState = null;</span>
<span class="pc" id="L73">  private Long workflowId = null;</span>
<span class="pc" id="L74">  private String workflowDefinition = null;</span>
<span class="pc" id="L75">  private Long duration = null;</span>
<span class="pc" id="L76">  private String startDate = null;</span>
<span class="pc" id="L77">  private String eventStatus = null;</span>
<span class="pc" id="L78">  private Boolean hasComments = null;</span>
<span class="pc" id="L79">  private Boolean hasOpenComments = null;</span>
<span class="pc" id="L80">  private final List&lt;String&gt; comments = new ArrayList&lt;&gt;();</span>
<span class="pc" id="L81">  private Boolean needsCutting = null;</span>
<span class="pc" id="L82">  private final List&lt;String&gt; publications = new ArrayList&lt;String&gt;();</span>
<span class="pc" id="L83">  private Boolean isPublished = null;</span>
<span class="pc" id="L84">  private Long archiveVersion = null;</span>
<span class="pc" id="L85">  private String agentId = null;</span>
<span class="pc" id="L86">  private Date technicalStartTime = null;</span>
<span class="pc" id="L87">  private Date technicalEndTime = null;</span>
<span class="pc" id="L88">  private final List&lt;String&gt; technicalPresenters = new ArrayList&lt;String&gt;();</span>

<span class="fc" id="L90">  private static final Map&lt;String, String&gt; SORT_FIELDS = Map.of(</span>
<span class="fc" id="L91">          EventIndexSchema.TITLE, EventIndexSchema.TITLE.concat(IndexSchema.SORT_FIELD_NAME_EXTENSION),</span>
<span class="fc" id="L92">          EventIndexSchema.CONTRIBUTOR, EventIndexSchema.CONTRIBUTOR.concat(IndexSchema.SORT_FIELD_NAME_EXTENSION),</span>
<span class="fc" id="L93">          EventIndexSchema.PRESENTER, EventIndexSchema.PRESENTER.concat(IndexSchema.SORT_FIELD_NAME_EXTENSION),</span>
<span class="fc" id="L94">          EventIndexSchema.SUBJECT, EventIndexSchema.SUBJECT.concat(IndexSchema.SORT_FIELD_NAME_EXTENSION),</span>
<span class="fc" id="L95">          EventIndexSchema.DESCRIPTION, EventIndexSchema.DESCRIPTION.concat(IndexSchema.SORT_FIELD_NAME_EXTENSION),</span>
<span class="fc" id="L96">          EventIndexSchema.LOCATION, EventIndexSchema.LOCATION.concat(IndexSchema.SORT_FIELD_NAME_EXTENSION),</span>
<span class="fc" id="L97">          EventIndexSchema.SERIES_NAME, EventIndexSchema.SERIES_NAME.concat(IndexSchema.SORT_FIELD_NAME_EXTENSION),</span>
<span class="fc" id="L98">          EventIndexSchema.CREATOR, EventIndexSchema.CREATOR.concat(IndexSchema.SORT_FIELD_NAME_EXTENSION),</span>
<span class="fc" id="L99">          EventIndexSchema.PUBLISHER, EventIndexSchema.PUBLISHER.concat(IndexSchema.SORT_FIELD_NAME_EXTENSION)</span>
  );

  @SuppressWarnings(&quot;unused&quot;)
<span class="nc" id="L103">  private EventSearchQuery() {</span>
<span class="nc" id="L104">  }</span>

  @Override
  protected String sortOrderFieldName(String field) {
<span class="nc bnc" id="L108" title="All 2 branches missed.">    if (SORT_FIELDS.containsKey(field)) {</span>
<span class="nc" id="L109">      return SORT_FIELDS.get(field);</span>
    }
<span class="nc" id="L111">    return field;</span>
  }

  /**
   * Creates a query that will return event documents.
   */
  public EventSearchQuery(String organization, User user) {
<span class="fc" id="L118">    super(Event.DOCUMENT_TYPE);</span>
<span class="fc" id="L119">    this.organization = organization;</span>
<span class="fc" id="L120">    this.user = user;</span>
<span class="fc" id="L121">    this.actions.add(Permissions.Action.READ.toString());</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">    if (!user.hasRole(GLOBAL_ADMIN_ROLE)) {</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">      if (!user.getOrganization().getId().equals(organization)) {</span>
<span class="nc" id="L124">        throw new IllegalStateException(&quot;User's organization must match search organization&quot;);</span>
      }
    }
<span class="fc" id="L127">  }</span>

  /**
   * Selects recording events with the given identifier.
   * &lt;p&gt;
   * Note that this method may be called multiple times to support selection of multiple recording events.
   *
   * @param id
   *          the recording identifier
   * @return the enhanced search query
   */
  public EventSearchQuery withIdentifier(String id) {
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">    if (StringUtils.isBlank(id)) {</span>
<span class="nc" id="L140">      throw new IllegalArgumentException(&quot;Identifier cannot be null&quot;);</span>
    }
<span class="fc" id="L142">    this.identifiers.add(id);</span>
<span class="fc" id="L143">    return this;</span>
  }

  /**
   * Returns the list of recording identifiers or an empty array if no identifiers have been specified.
   *
   * @return the identifiers
   */
  public String[] getIdentifier() {
<span class="nc" id="L152">    return identifiers.toArray(new String[identifiers.size()]);</span>
  }

  /**
   * Returns the organization of the recording
   *
   * @return the organization
   */
  public String getOrganization() {
<span class="nc" id="L161">    return organization;</span>
  }

  /**
   * Returns the user of this search query
   *
   * @return the user of this search query
   */
  public User getUser() {
<span class="nc" id="L170">    return user;</span>
  }

  /**
   * Selects recordings with the given title.
   *
   * @param title
   *          the title
   * @return the enhanced search query
   */
  public EventSearchQuery withTitle(String title) {
<span class="nc" id="L181">    this.title = title;</span>
<span class="nc" id="L182">    return this;</span>
  }

  /**
   * Returns the title of the recording.
   *
   * @return the title
   */
  public String getTitle() {
<span class="nc" id="L191">    return title;</span>
  }

  /**
   * Filter the recording events without any action checked.
   *
   * @return the enhanced search query
   */
  public EventSearchQuery withoutActions() {
<span class="fc" id="L200">    this.actions.clear();</span>
<span class="fc" id="L201">    return this;</span>
  }

  /**
   * Filter the recording events with the given action.
   * &lt;p&gt;
   * Note that this method may be called multiple times to support filtering by multiple actions.
   *
   * @param action
   *          the action
   * @return the enhanced search query
   */
  public EventSearchQuery withAction(Action action) {
<span class="nc bnc" id="L214" title="All 2 branches missed.">    if (action == null) {</span>
<span class="nc" id="L215">      throw new IllegalArgumentException(&quot;Action cannot be null&quot;);</span>
    }
<span class="nc" id="L217">    this.actions.add(action.toString());</span>
<span class="nc" id="L218">    return this;</span>
  }

  /**
   * Returns the list of actions or an empty array if no actions have been specified.
   *
   * @return the actions
   */
  public String[] getActions() {
<span class="nc" id="L227">    return actions.toArray(new String[actions.size()]);</span>
  }

  /**
   * Selects recording events with the given presenter.
   * &lt;p&gt;
   * Note that this method may be called multiple times to support selection of multiple recording events.
   *
   * @param presenter
   *          the presenter
   * @return the enhanced search query
   */
  public EventSearchQuery withPresenter(String presenter) {
<span class="nc bnc" id="L240" title="All 2 branches missed.">    if (StringUtils.isBlank(presenter)) {</span>
<span class="nc" id="L241">      throw new IllegalArgumentException(&quot;Presenter cannot be null&quot;);</span>
    }
<span class="nc" id="L243">    this.presenters.add(presenter);</span>
<span class="nc" id="L244">    return this;</span>
  }

  /**
   * Returns the list of recording presenters or an empty array if no presenter have been specified.
   *
   * @return the presenters
   */
  public String[] getPresenters() {
<span class="nc" id="L253">    return presenters.toArray(new String[presenters.size()]);</span>
  }

  /**
   * Selects recording events with the given contributor.
   * &lt;p&gt;
   * Note that this method may be called multiple times to support selection of multiple recording events.
   *
   * @param contributor
   *          the contributor
   * @return the enhanced search query
   */
  public EventSearchQuery withContributor(String contributor) {
<span class="nc bnc" id="L266" title="All 2 branches missed.">    if (StringUtils.isBlank(contributor)) {</span>
<span class="nc" id="L267">      throw new IllegalArgumentException(&quot;Contributor cannot be null&quot;);</span>
    }
<span class="nc" id="L269">    this.contributors.add(contributor);</span>
<span class="nc" id="L270">    return this;</span>
  }

  /**
   * Returns the list of recording contributors or an empty array if no contributors have been specified.
   *
   * @return the contributors
   */
  public String[] getContributors() {
<span class="nc" id="L279">    return contributors.toArray(new String[contributors.size()]);</span>
  }

  /**
   * Selects recording events with the given subject.
   *
   * @param subject
   *          the subject
   * @return the enhanced search query
   */
  public EventSearchQuery withSubject(String subject) {
<span class="nc" id="L290">    this.subject = subject;</span>
<span class="nc" id="L291">    return this;</span>
  }

  /**
   * Returns the subject of the recording.
   *
   * @return the subject
   */
  public String getSubject() {
<span class="nc" id="L300">    return subject;</span>
  }

  /**
   * Selects recordings with the given description.
   *
   * @param description
   *          the description
   * @return the enhanced search query
   */
  public EventSearchQuery withDescription(String description) {
<span class="nc" id="L311">    this.description = description;</span>
<span class="nc" id="L312">    return this;</span>
  }

  /**
   * Returns the description of the recording.
   *
   * @return the description
   */
  public String getDescription() {
<span class="nc" id="L321">    return description;</span>
  }

  /**
   * Selects recordings with the given location.
   *
   * @param location
   *          the location
   * @return the enhanced search query
   */
  public EventSearchQuery withLocation(String location) {
<span class="nc" id="L332">    this.location = location;</span>
<span class="nc" id="L333">    return this;</span>
  }

  /**
   * Returns the location of the recording.
   *
   * @return the location
   */
  public String getLocation() {
<span class="nc" id="L342">    return location;</span>
  }

  /**
   * Selects recordings with the given series identifier.
   *
   * @param seriesId
   *          the series identifier
   * @return the enhanced search query
   */
  public EventSearchQuery withSeriesId(String seriesId) {
<span class="fc" id="L353">    this.seriesId = seriesId;</span>
<span class="fc" id="L354">    return this;</span>
  }

  /**
   * Returns the series identifier of the recording.
   *
   * @return the series identifier
   */
  public String getSeriesId() {
<span class="fc" id="L363">    return seriesId;</span>
  }

  /**
   * Selects recordings with the given series name.
   *
   * @param seriesName
   *          the series name
   * @return the enhanced search query
   */
  public EventSearchQuery withSeriesName(String seriesName) {
<span class="nc" id="L374">    this.seriesName = seriesName;</span>
<span class="nc" id="L375">    return this;</span>
  }

  /**
   * Returns the series name of the recording.
   *
   * @return the series name
   */
  public String getSeriesName() {
<span class="nc" id="L384">    return seriesName;</span>
  }

  /**
   * Selects recordings with the given language.
   *
   * @param language
   *          the language
   * @return the enhanced search query
   */
  public EventSearchQuery withLanguage(String language) {
<span class="nc" id="L395">    this.language = language;</span>
<span class="nc" id="L396">    return this;</span>
  }

  /**
   * Returns the language of the recording.
   *
   * @return the language
   */
  public String getLanguage() {
<span class="nc" id="L405">    return language;</span>
  }

  /**
   * Selects recordings with the given source type.
   *
   * @param source
   *          the source
   * @return the enhanced search query
   */
  public EventSearchQuery withSource(String source) {
<span class="nc" id="L416">    this.source = source;</span>
<span class="nc" id="L417">    return this;</span>
  }

  /**
   * Returns the source of the recording.
   *
   * @return the source
   */
  public String getSource() {
<span class="nc" id="L426">    return source;</span>
  }

  /**
   * Selects recordings with the given creation date.
   *
   * @param created
   *          the creation date
   * @return the enhanced search query
   */
  public EventSearchQuery withCreated(String created) {
<span class="nc" id="L437">    this.created = created;</span>
<span class="nc" id="L438">    return this;</span>
  }

  /**
   * Returns the creation date of the recording.
   *
   * @return the creation date
   */
  public String getCreated() {
<span class="nc" id="L447">    return created;</span>
  }

  /**
   * The start date to start looking for events.
   *
   * @param startFrom
   *          The start date to start looking for events
   * @return the enhanced search query
   */
  public EventSearchQuery withStartFrom(Date startFrom) {
<span class="nc" id="L458">    this.startFrom = startFrom;</span>
<span class="nc" id="L459">    return this;</span>
  }

  /**
   * @return The Date after which all events returned should have been started
   */
  public Date getStartFrom() {
<span class="nc" id="L466">    return startFrom;</span>
  }

  /**
   * The start date to stop looking for events.
   *
   * @param startTo
   *          The start date to stop looking for events
   * @return the enhanced search query
   */
  public EventSearchQuery withStartTo(Date startTo) {
<span class="nc" id="L477">    this.startTo = startTo;</span>
<span class="nc" id="L478">    return this;</span>
  }

  /**
   * @return The Date before which all events returned should have been started
   */
  public Date getStartTo() {
<span class="nc" id="L485">    return startTo;</span>
  }

  /**
   * The technical start date to start looking for events.
   *
   * @param startFrom
   *          The technical start date to start looking for events
   * @return the enhanced search query
   */
  public EventSearchQuery withTechnicalStartFrom(Date startFrom) {
<span class="nc" id="L496">    this.technicalStartFrom = startFrom;</span>
<span class="nc" id="L497">    return this;</span>
  }

  /**
   * @return The technical date after which all events returned should have been started
   */
  public Date getTechnicalStartFrom() {
<span class="nc" id="L504">    return technicalStartFrom;</span>
  }

  /**
   * The technical start date to stop looking for events.
   *
   * @param startTo
   *          The technical start date to stop looking for events
   * @return the enhanced search query
   */
  public EventSearchQuery withTechnicalStartTo(Date startTo) {
<span class="nc" id="L515">    this.technicalStartTo = startTo;</span>
<span class="nc" id="L516">    return this;</span>
  }

  /**
   * @return The technical date before which all events returned should have been started
   */
  public Date getTechnicalStartTo() {
<span class="nc" id="L523">    return technicalStartTo;</span>
  }

  /**
   * Selects recordings with the given creator.
   *
   * @param creator
   *          the creator
   * @return the enhanced search query
   */
  public EventSearchQuery withCreator(String creator) {
<span class="nc" id="L534">    this.creator = creator;</span>
<span class="nc" id="L535">    return this;</span>
  }

  /**
   * Returns the creator of the recording.
   *
   * @return the creator
   */
  public String getCreator() {
<span class="nc" id="L544">    return creator;</span>
  }

  /**
   * Selects recordings with the given publisher.
   *
   * @param publisher
   *          the publisher
   * @return the enhanced search query
   */
  public EventSearchQuery withPublisher(String publisher) {
<span class="nc" id="L555">    this.publisher = publisher;</span>
<span class="nc" id="L556">    return this;</span>
  }

  /**
   * Returns the publisher of the recording.
   *
   * @return the publisher
   */
  public String getPublisher() {
<span class="nc" id="L565">    return publisher;</span>
  }

  /**
   * Selects recordings with the given license.
   *
   * @param license
   *          the license
   * @return the enhanced search query
   */
  public EventSearchQuery withLicense(String license) {
<span class="nc" id="L576">    this.license = license;</span>
<span class="nc" id="L577">    return this;</span>
  }

  /**
   * Returns the license of the recording.
   *
   * @return the license
   */
  public String getLicense() {
<span class="nc" id="L586">    return license;</span>
  }

  /**
   * Selects recordings with the given rights.
   *
   * @param rights
   *          the rights
   * @return the enhanced search query
   */
  public EventSearchQuery withRights(String rights) {
<span class="nc" id="L597">    this.rights = rights;</span>
<span class="nc" id="L598">    return this;</span>
  }

  /**
   * Returns the rights of the recording.
   *
   * @return the rights
   */
  public String getRights() {
<span class="nc" id="L607">    return rights;</span>
  }

  /**
   * Selects recordings with the given access policy.
   *
   * @param accessPolicy
   *          the access policy
   * @return the enhanced search query
   */
  public EventSearchQuery withAccessPolicy(String accessPolicy) {
<span class="nc" id="L618">    this.accessPolicy = accessPolicy;</span>
<span class="nc" id="L619">    return this;</span>
  }

  /**
   * Returns the access policy of the recording.
   *
   * @return the access policy
   */
  public String getAccessPolicy() {
<span class="nc" id="L628">    return accessPolicy;</span>
  }

  /**
   * Selects recordings with the given managed ACL name.
   *
   * @param managedAcl
   *          the name of the managed ACL
   * @return the enhanced search query
   */
  public EventSearchQuery withManagedAcl(String managedAcl) {
<span class="fc" id="L639">    this.managedAcl = managedAcl;</span>
<span class="fc" id="L640">    return this;</span>
  }

  /**
   * Returns the name of the managed ACL set to the recording.
   *
   * @return the name of the managed ACL
   */
  public String getManagedAcl() {
<span class="nc" id="L649">    return managedAcl;</span>
  }

  /**
   * Selects recordings with the given workflow state.
   *
   * @param workflowState
   *          the workflow state
   * @return the enhanced search query
   */
  public EventSearchQuery withWorkflowState(String workflowState) {
<span class="fc" id="L660">    this.workflowState = workflowState;</span>
<span class="fc" id="L661">    return this;</span>
  }

  /**
   * Returns the workflow state of the recording.
   *
   * @return the workflow state
   */
  public String getWorkflowState() {
<span class="fc" id="L670">    return workflowState;</span>
  }

  /**
   * Selects recordings with the given workflow id.
   *
   * @param workflowId
   *          the workflow id
   * @return the enhanced search query
   */
  public EventSearchQuery withWorkflowId(long workflowId) {
<span class="fc" id="L681">    this.workflowId = workflowId;</span>
<span class="fc" id="L682">    return this;</span>
  }

  /**
   * Returns the workflow id of the recording.
   *
   * @return the workflow id
   */
  public Long getWorkflowId() {
<span class="nc" id="L691">    return workflowId;</span>
  }

  /**
   * Selects recordings with the given workflow definition.
   *
   * @param workflowDefinition
   *          the workflow definition
   * @return the enhanced search query
   */
  public EventSearchQuery withWorkflowDefinition(String workflowDefinition) {
<span class="nc" id="L702">    this.workflowDefinition = workflowDefinition;</span>
<span class="nc" id="L703">    return this;</span>
  }

  /**
   * Returns the workflow definition of the recording.
   *
   * @return the workflow definition
   */
  public String getWorkflowDefinition() {
<span class="nc" id="L712">    return workflowDefinition;</span>
  }

  /**
   * Selects recordings with the given start date.
   *
   * @param startDate
   *          the start date
   * @return the enhanced search query
   */
  public EventSearchQuery withStartDate(String startDate) {
<span class="nc" id="L723">    this.startDate = startDate;</span>
<span class="nc" id="L724">    return this;</span>
  }

  /**
   * Returns the start date of the recording.
   *
   * @return the start date
   */
  public String getStartDate() {
<span class="nc" id="L733">    return startDate;</span>
  }

  /**
   * Selects recordings with the given duration.
   *
   * @param duration
   *          the duration
   * @return the enhanced search query
   */
  public EventSearchQuery withDuration(long duration) {
<span class="nc" id="L744">    this.duration = duration;</span>
<span class="nc" id="L745">    return this;</span>
  }

  /**
   * Returns the duration of the recording.
   *
   * @return the duration
   */
  public Long getDuration() {
<span class="nc" id="L754">    return duration;</span>
  }

  /**
   * Selects recordings with the given event status.
   *
   * @param eventStatus
   *          the event status
   * @return the enhanced search query
   */
  public EventSearchQuery withEventStatus(String eventStatus) {
<span class="nc" id="L765">    this.eventStatus = eventStatus;</span>
<span class="nc" id="L766">    return this;</span>
  }

  /**
   * Returns the event status of the recording.
   *
   * @return the event status
   */
  public String getEventStatus() {
<span class="nc" id="L775">    return eventStatus;</span>
  }

  /**
   * Selects recordings with the given has comments status.
   *
   * @param hasComments
   *          the has comments status
   * @return the enhanced search query
   */
  public EventSearchQuery withComments(boolean hasComments) {
<span class="nc" id="L786">    this.hasComments = hasComments;</span>
<span class="nc" id="L787">    return this;</span>
  }

  /**
   * Selects recordings with the given has open comments status.
   *
   * @param hasOpenComments
   *          the has open comments status
   * @return the enhanced search query
   */
  public EventSearchQuery withOpenComments(boolean hasOpenComments) {
<span class="nc" id="L798">    this.hasOpenComments = hasOpenComments;</span>
<span class="nc" id="L799">    return this;</span>
  }

  /**
   * Selects recordings with the given has comment need cutting status.
   *
   * @param needsCutting
   *          the event has the comments status that it needs cutting
   * @return the enhanced search query
   */
  public EventSearchQuery withNeedsCutting(boolean needsCutting) {
<span class="nc" id="L810">    this.needsCutting = needsCutting;</span>
<span class="nc" id="L811">    return this;</span>
  }

  /**
   * Returns the has comments status of the recording.
   *
   * @return the recording has comments status
   */
  public Boolean getHasComments() {
<span class="nc" id="L820">    return hasComments;</span>
  }

  /**
   * Returns the has open comments status of the recording.
   *
   * @return the recording has open comments status
   */
  public Boolean getHasOpenComments() {
<span class="nc" id="L829">    return hasOpenComments;</span>
  }

  public EventSearchQuery withComments(String comment) {
<span class="nc bnc" id="L833" title="All 2 branches missed.">    if (StringUtils.isBlank(comment)) {</span>
<span class="nc" id="L834">      throw new IllegalArgumentException(&quot;Comment cannot be null&quot;);</span>
    }
<span class="nc" id="L836">    this.comments.add(comment);</span>
<span class="nc" id="L837">    return this;</span>
  }

  public String[] getComments() {
<span class="nc" id="L841">    return comments.toArray(new String[comments.size()]);</span>
  }

  /**
   * Returns the has open comments reason that it needs cutting of the recording.
   *
   * @return the event has the open comments status that it needs cutting
   */
  public Boolean needsCutting() {
<span class="nc" id="L850">    return needsCutting;</span>
  }

  /**
   * Selects recording events with the given publication.
   * &lt;p&gt;
   * Note that this method may be called multiple times to support selection of multiple recording events.
   *
   * @param publication
   *          the publication
   * @return the enhanced search query
   */
  public EventSearchQuery withPublications(String publication) {
<span class="nc bnc" id="L863" title="All 2 branches missed.">    if (StringUtils.isBlank(publication)) {</span>
<span class="nc" id="L864">      throw new IllegalArgumentException(&quot;Publication cannot be null&quot;);</span>
    }
<span class="nc" id="L866">    this.publications.add(publication);</span>
<span class="nc" id="L867">    return this;</span>
  }

  /**
   * Returns the list of event publications or an empty array if no publications have been specified.
   *
   * @return the publications
   */
  public String[] getPublications() {
<span class="nc" id="L876">    return publications.toArray(new String[publications.size()]);</span>
  }

  /**
   * Selects recordings with the given is published status.
   *
   * @param isPublished
   *          the is published status
   * @return the enhanced search query
   */
  public EventSearchQuery withIsPublished(boolean isPublished) {
<span class="nc" id="L887">    this.isPublished = isPublished;</span>
<span class="nc" id="L888">    return this;</span>
  }

  /**
   * Returns the is published status of the recording.
   *
   * @return the recording is published status
   */
  public Boolean getIsPublished() {
<span class="nc" id="L897">    return isPublished;</span>
  }

  /**
   * Selects events with the given archive version.
   *
   * @param archiveVersion
   *          the archive version
   * @return the enhanced search query
   */
  public EventSearchQuery withArchiveVersion(long archiveVersion) {
<span class="nc" id="L908">    this.archiveVersion = archiveVersion;</span>
<span class="nc" id="L909">    return this;</span>
  }

  /**
   * Returns the archive version of the event.
   *
   * @return the archive version
   */
  public Long getArchiveVersion() {
<span class="nc" id="L918">    return archiveVersion;</span>
  }

  /**
   * Selects recordings with the given agent id.
   *
   * @param agentId
   *          the agent id
   * @return the enhanced search query
   */
  public EventSearchQuery withAgentId(String agentId) {
<span class="nc" id="L929">    this.agentId = agentId;</span>
<span class="nc" id="L930">    return this;</span>
  }

  /**
   * Returns the agent id of the recording.
   *
   * @return the agent id
   */
  public String getAgentId() {
<span class="nc" id="L939">    return agentId;</span>
  }

  /**
   * Selects recordings with the given technical start date.
   *
   * @param technicalStartTime
   *          the start date
   * @return the enhanced search query
   */
  public EventSearchQuery withTechnicalStartTime(Date technicalStartTime) {
<span class="nc" id="L950">    this.technicalStartTime = technicalStartTime;</span>
<span class="nc" id="L951">    return this;</span>
  }

  /**
   * Returns the technical start date of the recording.
   *
   * @return the technical start date
   */
  public Date getTechnicalStartTime() {
<span class="nc" id="L960">    return technicalStartTime;</span>
  }

  /**
   * Selects recordings with the given technical end date.
   *
   * @param technicalEndTime
   *          the end date
   * @return
   * @return the enhanced search query
   */
  public EventSearchQuery withTechnicalEndTime(Date technicalEndTime) {
<span class="nc" id="L972">    this.technicalEndTime = technicalEndTime;</span>
<span class="nc" id="L973">    return this;</span>
  }

  /**
   * Returns the technical end date of the recording.
   *
   * @return the technical end date
   */
  public Date getTechnicalEndTime() {
<span class="nc" id="L982">    return technicalEndTime;</span>
  }

  /**
   * Selects recording events with the given technical presenters.
   * &lt;p&gt;
   * Note that this method may be called multiple times to support selection of multiple recording events.
   *
   * @param presenter
   *          the presenter
   * @return the enhanced search query
   */
  public EventSearchQuery withTechnicalPresenters(String presenter) {
<span class="nc bnc" id="L995" title="All 2 branches missed.">    if (StringUtils.isBlank(presenter)) {</span>
<span class="nc" id="L996">      throw new IllegalArgumentException(&quot;Presenter cannot be null&quot;);</span>
    }
<span class="nc" id="L998">    this.technicalPresenters.add(presenter);</span>
<span class="nc" id="L999">    return this;</span>
  }

  /**
   * Returns the list of technical presenters or an empty array if no presenters have been specified.
   *
   * @return the technical presenters
   */
  public String[] getTechnicalPresenters() {
<span class="nc" id="L1008">    return technicalPresenters.toArray(new String[technicalPresenters.size()]);</span>
  }

  /**
   * Defines the sort order for the recording start date.
   *
   * @param order
   *          the order
   * @return the enhanced search query
   */
  public EventSearchQuery sortByStartDate(Order order) {
<span class="nc" id="L1019">    withSortOrder(EventIndexSchema.START_DATE, order);</span>
<span class="nc" id="L1020">    return this;</span>
  }

  /**
   * Returns the sort order for the recording start date.
   *
   * @return the sort order
   */
  public Order getStartDateSortOrder() {
<span class="nc" id="L1029">    return getSortOrder(EventIndexSchema.START_DATE);</span>
  }

  /**
   * Defines the sort order for the technical recording start date.
   *
   * @param order
   *          the order
   * @return the enhanced search query
   */
  public EventSearchQuery sortByTechnicalStartDate(Order order) {
<span class="nc" id="L1040">    withSortOrder(EventIndexSchema.TECHNICAL_START, order);</span>
<span class="nc" id="L1041">    return this;</span>
  }

  /**
   * Returns the sort order for the technical recording start date.
   *
   * @return the sort order
   */
  public Order getTechnicalStartDateSortOrder() {
<span class="nc" id="L1050">    return getSortOrder(EventIndexSchema.TECHNICAL_START);</span>
  }

  /**
   * Defines the sort order for the recording end date.
   *
   * @param order
   *          the order
   * @return the enhanced search query
   */
  public EventSearchQuery sortByEndDate(Order order) {
<span class="nc" id="L1061">    withSortOrder(EventIndexSchema.END_DATE, order);</span>
<span class="nc" id="L1062">    return this;</span>
  }

  /**
   * Returns the sort order for the recording end date.
   *
   * @return the sort order
   */
  public Order getEndDateSortOrder() {
<span class="nc" id="L1071">    return getSortOrder(EventIndexSchema.END_DATE);</span>
  }

  /**
   * Defines the sort order for the technical recording end date.
   *
   * @param order
   *          the order
   * @return the enhanced search query
   */
  public EventSearchQuery sortByTechnicalEndDate(Order order) {
<span class="nc" id="L1082">    withSortOrder(EventIndexSchema.TECHNICAL_END, order);</span>
<span class="nc" id="L1083">    return this;</span>
  }

  /**
   * Returns the sort order for the technical recording end date.
   *
   * @return the sort order
   */
  public Order getTechnicalEndDateSortOrder() {
<span class="nc" id="L1092">    return getSortOrder(EventIndexSchema.TECHNICAL_END);</span>
  }

  /**
   * Defines the sort order for the recording date.
   *
   * @param order
   *          the order
   * @return the enhanced search query
   */
  public EventSearchQuery sortByDate(Order order) {
<span class="nc" id="L1103">    withSortOrder(EventIndexSchema.END_DATE, order);</span>
<span class="nc" id="L1104">    return this;</span>
  }

  /**
   * Returns the sort order for the recording date.
   *
   * @return the sort order
   */
  public Order getDateSortOrder() {
<span class="nc" id="L1113">    return getSortOrder(EventIndexSchema.END_DATE);</span>
  }

  /**
   * Defines the sort order for the recording date.
   *
   * @param order
   *          the order
   * @return the enhanced search query
   */
  public EventSearchQuery sortByTitle(Order order) {
<span class="nc" id="L1124">    withSortOrder(EventIndexSchema.TITLE, order);</span>
<span class="nc" id="L1125">    return this;</span>
  }

  /**
   * Returns the sort order for the recording start date.
   *
   * @return the sort order
   */
  public Order getTitleSortOrder() {
<span class="nc" id="L1134">    return getSortOrder(EventIndexSchema.TITLE);</span>
  }

  public EventSearchQuery sortByUID(Order order) {
<span class="nc" id="L1138">    withSortOrder(EventIndexSchema.UID, order);</span>
<span class="nc" id="L1139">    return this;</span>
  }

  public Order getUIDSortOrder() {
<span class="nc" id="L1143">    return getSortOrder(EventIndexSchema.UID);</span>
  }

  /**
   * Defines the sort order for the recording date.
   *
   * @param order
   *          the order
   * @return the enhanced search query
   */
  public EventSearchQuery sortByPresenter(Order order) {
<span class="nc" id="L1154">    withSortOrder(EventIndexSchema.PRESENTER, order);</span>
<span class="nc" id="L1155">    return this;</span>
  }

  /**
   * Returns the sort order for the recording start date.
   *
   * @return the sort order
   */
  public Order getPresentersSortOrder() {
<span class="nc" id="L1164">    return getSortOrder(EventIndexSchema.PRESENTER);</span>
  }

  /**
   * Defines the sort order for the location.
   *
   * @param order
   *          the sort order
   * @return the updated query
   */
  public EventSearchQuery sortByLocation(Order order) {
<span class="nc" id="L1175">    withSortOrder(EventIndexSchema.LOCATION, order);</span>
<span class="nc" id="L1176">    return this;</span>
  }

  /**
   * Returns the sort order for the location.
   *
   * @return the sort order
   */
  public Order getLocationSortOrder() {
<span class="nc" id="L1185">    return getSortOrder(EventIndexSchema.LOCATION);</span>
  }

  /**
   * Defines the sort order for the series name.
   *
   * @param order
   *          the sort order
   * @return the updated query
   */
  public EventSearchQuery sortBySeriesName(Order order) {
<span class="nc" id="L1196">    withSortOrder(EventIndexSchema.SERIES_NAME, order);</span>
<span class="nc" id="L1197">    return this;</span>
  }

  /**
   * Returns the sort order for the series name.
   *
   * @return the sort order
   */
  public Order getSeriesNameSortOrder() {
<span class="nc" id="L1206">    return getSortOrder(EventIndexSchema.SERIES_NAME);</span>
  }

  /**
   * Defines the sort order for the managed ACL.
   *
   * @param order
   *          the order
   * @return the enhanced search query
   */
  public EventSearchQuery sortByManagedAcl(Order order) {
<span class="nc" id="L1217">    withSortOrder(EventIndexSchema.MANAGED_ACL, order);</span>
<span class="nc" id="L1218">    return this;</span>
  }

  /**
   * Returns the sort order for the series managed ACL.
   *
   * @return the sort order
   */
  public Order getManagedAclSortOrder() {
<span class="nc" id="L1227">    return getSortOrder(EventIndexSchema.MANAGED_ACL);</span>
  }

  /**
   * Defines the sort order for the workflow state.
   *
   * @param order
   *          the sort order
   * @return the updated query
   */
  public EventSearchQuery sortByWorkflowState(Order order) {
<span class="nc" id="L1238">    withSortOrder(EventIndexSchema.WORKFLOW_STATE, order);</span>
<span class="nc" id="L1239">    return this;</span>
  }

  /**
   * Returns the sort order for the workflow state.
   *
   * @return the sort order
   */
  public Order getWorkflowStateSortOrder() {
<span class="nc" id="L1248">    return getSortOrder(EventIndexSchema.WORKFLOW_STATE);</span>
  }

  /**
   * Defines the sort order for the event status.
   *
   * @param order
   *          the sort order
   * @return the updated query
   */
  public EventSearchQuery sortByEventStatus(Order order) {
<span class="nc" id="L1259">    withSortOrder(EventIndexSchema.EVENT_STATUS, order);</span>
<span class="nc" id="L1260">    return this;</span>
  }

  /**
   * Returns the sort order for the event status.
   *
   * @return the sort order
   */
  public Order getEventStatusSortOrder() {
<span class="nc" id="L1269">    return getSortOrder(EventIndexSchema.EVENT_STATUS);</span>
  }

  /**
   * Defines the sort order for publication.
   *
   * @param order
   *          the sort order
   * @return the updated query
   */
  public EventSearchQuery sortByPublicationIgnoringInternal(Order order) {
    // TODO implement sort By Publication Ignoring Internal
<span class="nc" id="L1281">    withSortOrder(EventIndexSchema.PUBLICATION, order);</span>
<span class="nc" id="L1282">    return this;</span>
  }

  /**
   * Returns the sort order for the publication.
   *
   * @return the sort order
   */
  public Order getPublicationSortOrder() {
    // TODO implement getPublicationSortOrder
<span class="nc" id="L1292">    return getSortOrder(EventIndexSchema.PUBLICATION);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>