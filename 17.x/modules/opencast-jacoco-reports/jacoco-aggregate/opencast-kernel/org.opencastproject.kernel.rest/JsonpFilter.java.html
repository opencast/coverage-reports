<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>JsonpFilter.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-kernel</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.kernel.rest</a> &gt; <span class="el_source">JsonpFilter.java</span></div><h1>JsonpFilter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.kernel.rest;

import static javax.ws.rs.core.MediaType.APPLICATION_JSON;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.ServiceScope;
import org.osgi.service.component.propertytypes.ServiceRanking;
import org.osgi.service.http.whiteboard.propertytypes.HttpWhiteboardContextSelect;
import org.osgi.service.http.whiteboard.propertytypes.HttpWhiteboardFilterName;
import org.osgi.service.http.whiteboard.propertytypes.HttpWhiteboardFilterPattern;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.regex.Pattern;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.WriteListener;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

/**
 * Adds padding to json responses when the 'jsonp' parameter is specified.
 */
@Component(
    service = Filter.class,
    scope = ServiceScope.PROTOTYPE,
    property = {
        &quot;service.description=JSONP Filter&quot;,
    }
)
@ServiceRanking(5)
@HttpWhiteboardFilterName(&quot;JsonpFilter&quot;)
@HttpWhiteboardFilterPattern(&quot;/*&quot;)
@HttpWhiteboardContextSelect(&quot;(osgi.http.whiteboard.context.name=opencast)&quot;)
<span class="nc" id="L67">public class JsonpFilter implements Filter {</span>
  /** The logger */
<span class="fc" id="L69">  private static final Logger logger = LoggerFactory.getLogger(JsonpFilter.class);</span>

  /** The content type HTTP header name */
  public static final String CONTENT_TYPE_HEADER = &quot;Content-Type&quot;;

  /** The querystring parameter that indicates the response should be padded */
  public static final String CALLBACK_PARAM = &quot;jsonp&quot;;

  /** The regular expression to ensure that the callback is safe for display to a browser */
<span class="fc" id="L78">  public static final Pattern SAFE_PATTERN = Pattern.compile(&quot;[a-zA-Z0-9\\.\\_]+&quot;);</span>

  /** The content type for jsonp is &quot;application/x-javascript&quot;, not &quot;application/json&quot;. */
  public static final String JS_CONTENT_TYPE = &quot;application/x-javascript&quot;;

  /** The character encoding. */
  public static final String CHARACTER_ENCODING = &quot;UTF-8&quot;;

  /** The default padding to use if the specified padding contains invalid characters */
  public static final String DEFAULT_CALLBACK = &quot;handleMatterhornData&quot;;

  /** The '(' constant. */
  public static final String OPEN_PARENS = &quot;(&quot;;

  /** The post padding, which is always ');' no matter what the pre-padding looks like */
  public static final String POST_PADDING = &quot;);&quot;;

  /**
   * {@inheritDoc}
   *
   * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)
   */
  @Override
  public void init(FilterConfig config) throws ServletException {
<span class="nc" id="L102">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see javax.servlet.Filter#destroy()
   */
  @Override
  public void destroy() {
<span class="nc" id="L111">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse,
   *      javax.servlet.FilterChain)
   */
  @Override
  public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException,
          ServletException {

    // Cast the request and response to HTTP versions
<span class="nc" id="L124">    HttpServletRequest request = (HttpServletRequest) req;</span>

    // Determine whether the response must be wrapped
<span class="nc" id="L127">    String callbackValue = request.getParameter(CALLBACK_PARAM);</span>
<span class="nc bnc" id="L128" title="All 4 branches missed.">    if (callbackValue == null || callbackValue.isEmpty()) {</span>
<span class="nc" id="L129">      logger.debug(&quot;No json padding requested from {}&quot;, request);</span>
<span class="nc" id="L130">      chain.doFilter(request, resp);</span>
    } else {
<span class="nc" id="L132">      logger.debug(&quot;Json padding '{}' requested from {}&quot;, callbackValue, request);</span>

      // Ensure the callback value contains only safe characters
<span class="nc bnc" id="L135" title="All 2 branches missed.">      if (!SAFE_PATTERN.matcher(callbackValue).matches()) {</span>
<span class="nc" id="L136">        callbackValue = DEFAULT_CALLBACK;</span>
      }

      // Write the padded response
<span class="nc" id="L140">      HttpServletResponse originalResponse = (HttpServletResponse) resp;</span>
<span class="nc" id="L141">      HttpServletResponseContentWrapper wrapper = new HttpServletResponseContentWrapper(originalResponse, callbackValue);</span>
<span class="nc" id="L142">      chain.doFilter(request, wrapper);</span>
<span class="nc" id="L143">      wrapper.flushWrapper();</span>
    }
<span class="nc" id="L145">  }</span>

  /**
   * A response wrapper that allows for json padding.
   */
  static class HttpServletResponseContentWrapper extends HttpServletResponseWrapper {

    protected ByteArrayServletOutputStream buffer;
    protected PrintWriter bufferWriter;
<span class="nc" id="L154">    protected boolean committed = false;</span>
<span class="nc" id="L155">    protected boolean enableWrapping = false;</span>
    protected String preWrapper;

    /**
     * Construct a response wrapper.
     *
     * @param response
     *          the response
     * @param callbackValue
     *          the jsonp callback value
     */
    HttpServletResponseContentWrapper(HttpServletResponse response, String callbackValue) {
<span class="nc" id="L167">      super(response);</span>
<span class="nc" id="L168">      this.preWrapper = callbackValue + OPEN_PARENS;</span>
<span class="nc" id="L169">      this.buffer = new ByteArrayServletOutputStream();</span>
<span class="nc" id="L170">    }</span>

    /**
     * Flush the buffer for this response wrapper.
     *
     * @throws IOException
     */
    public void flushWrapper() throws IOException {
<span class="nc bnc" id="L178" title="All 2 branches missed.">      if (enableWrapping) {</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (bufferWriter != null)</span>
<span class="nc" id="L180">          bufferWriter.close();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (buffer != null)</span>
<span class="nc" id="L182">          buffer.close();</span>
<span class="nc" id="L183">        getResponse().setContentType(JS_CONTENT_TYPE);</span>
<span class="nc" id="L184">        getResponse().setContentLength(</span>
<span class="nc" id="L185">                preWrapper.getBytes(CHARACTER_ENCODING).length + buffer.size() + POST_PADDING.getBytes().length);</span>
<span class="nc" id="L186">        getResponse().setCharacterEncoding(CHARACTER_ENCODING);</span>
<span class="nc" id="L187">        getResponse().getOutputStream().write(preWrapper.getBytes(CHARACTER_ENCODING));</span>
<span class="nc" id="L188">        getResponse().getOutputStream().write(buffer.toByteArray());</span>
<span class="nc" id="L189">        getResponse().getOutputStream().write(POST_PADDING.getBytes());</span>
<span class="nc" id="L190">        getResponse().flushBuffer();</span>
<span class="nc" id="L191">        committed = true;</span>
      }
<span class="nc" id="L193">    }</span>

    /**
     * If we set a {@link javax.ws.rs.core.MediaType#APPLICATION_JSON} {@link JsonpFilter#CONTENT_TYPE_HEADER} header,
     * enable padding.
     *
     * {@inheritDoc}
     *
     * @see javax.servlet.http.HttpServletResponseWrapper#setHeader(java.lang.String, java.lang.String)
     */
    @Override
    public void setHeader(String name, String value) {
<span class="nc bnc" id="L205" title="All 4 branches missed.">      if (CONTENT_TYPE_HEADER.equalsIgnoreCase(name) &amp;&amp; APPLICATION_JSON.equals(value)) {</span>
<span class="nc" id="L206">        enableWrapping = true;</span>
      }
<span class="nc" id="L208">      super.setHeader(name, value);</span>
<span class="nc" id="L209">    }</span>

    /**
     * If we add a {@link javax.ws.rs.core.MediaType#APPLICATION_JSON} {@link JsonpFilter#CONTENT_TYPE_HEADER} header,
     * enable padding.
     *
     * {@inheritDoc}
     *
     * @see javax.servlet.http.HttpServletResponseWrapper#addHeader(java.lang.String, java.lang.String)
     */
    @Override
    public void addHeader(String name, String value) {
<span class="nc bnc" id="L221" title="All 4 branches missed.">      if (CONTENT_TYPE_HEADER.equalsIgnoreCase(name) &amp;&amp; APPLICATION_JSON.equals(value)) {</span>
<span class="nc" id="L222">        enableWrapping = true;</span>
      }
<span class="nc" id="L224">      super.addHeader(name, value);</span>
<span class="nc" id="L225">    }</span>

    /**
     * Returns the content type. If we are wrapping json with padding, return {@link JsonpFilter#JS_CONTENT_TYPE}.
     *
     * {@inheritDoc}
     *
     * @see javax.servlet.ServletResponseWrapper#getContentType()
     */
    @Override
    public String getContentType() {
<span class="nc bnc" id="L236" title="All 2 branches missed.">      return enableWrapping ? JS_CONTENT_TYPE : getResponse().getContentType();</span>
    }

    /**
     * If the content type is set to JSON, we enable wrapping. Otherwise, we leave it disabled.
     *
     * {@inheritDoc}
     *
     * @see javax.servlet.ServletResponseWrapper#setContentType(java.lang.String)
     */
    @Override
    public void setContentType(String type) {
<span class="nc" id="L248">      enableWrapping = APPLICATION_JSON.equals(type);</span>
<span class="nc" id="L249">      super.setContentType(type);</span>
<span class="nc" id="L250">    }</span>

    /**
     * If we are wrapping json with padding, , return the wrapped buffer. Otherwise, return the original outputstream.
     *
     * {@inheritDoc}
     *
     * @see javax.servlet.ServletResponseWrapper#getOutputStream()
     */
    @Override
    public ServletOutputStream getOutputStream() throws IOException {
<span class="nc bnc" id="L261" title="All 2 branches missed.">      return enableWrapping ? buffer : getResponse().getOutputStream();</span>
    }

    /**
     * If we are wrapping json with padding, , return the wrapped writer. Otherwise, return the original writer.
     *
     * {@inheritDoc}
     *
     * @see javax.servlet.ServletResponseWrapper#getWriter()
     */
    @Override
    public PrintWriter getWriter() throws IOException {
<span class="nc bnc" id="L273" title="All 2 branches missed.">      if (enableWrapping) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (bufferWriter == null) {</span>
<span class="nc" id="L275">          bufferWriter = new PrintWriter(new OutputStreamWriter(buffer, this.getCharacterEncoding()));</span>
        }
<span class="nc" id="L277">        return bufferWriter;</span>
      } else {
<span class="nc" id="L279">        return getResponse().getWriter();</span>
      }
    }

    /**
     * {@inheritDoc}
     *
     * @see javax.servlet.ServletResponseWrapper#setBufferSize(int)
     */
    @Override
    public void setBufferSize(int size) {
<span class="nc bnc" id="L290" title="All 2 branches missed.">      if (enableWrapping) {</span>
<span class="nc" id="L291">        buffer.enlarge(size);</span>
      } else {
<span class="nc" id="L293">        getResponse().setBufferSize(size);</span>
      }
<span class="nc" id="L295">    }</span>

    /**
     * {@inheritDoc}
     *
     * @see javax.servlet.ServletResponseWrapper#getBufferSize()
     */
    @Override
    public int getBufferSize() {
<span class="nc bnc" id="L304" title="All 2 branches missed.">      return enableWrapping ? buffer.size() : getResponse().getBufferSize();</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see javax.servlet.ServletResponseWrapper#flushBuffer()
     */
    @Override
    public void flushBuffer() throws IOException {
<span class="nc bnc" id="L314" title="All 2 branches missed.">      if (!enableWrapping)</span>
<span class="nc" id="L315">        getResponse().flushBuffer();</span>
<span class="nc" id="L316">    }</span>

    /**
     * {@inheritDoc}
     *
     * @see javax.servlet.ServletResponseWrapper#isCommitted()
     */
    @Override
    public boolean isCommitted() {
<span class="nc bnc" id="L325" title="All 2 branches missed.">      return enableWrapping ? committed : getResponse().isCommitted();</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see javax.servlet.ServletResponseWrapper#reset()
     */
    @Override
    public void reset() {
<span class="nc" id="L335">      getResponse().reset();</span>
<span class="nc" id="L336">      buffer.reset();</span>
<span class="nc" id="L337">    }</span>

    /**
     * {@inheritDoc}
     *
     * @see javax.servlet.ServletResponseWrapper#resetBuffer()
     */
    @Override
    public void resetBuffer() {
<span class="nc" id="L346">      getResponse().resetBuffer();</span>
<span class="nc" id="L347">      buffer.reset();</span>
<span class="nc" id="L348">    }</span>
  }

  /**
   * A buffered output stream for jsonp padding.
   */
  static class ByteArrayServletOutputStream extends ServletOutputStream {

    /** The buffer */
    protected byte[] buf;

    /** The current write count */
    protected int count;

    /**
     * Creates a new buffered stream with the default size (32).
     */
    ByteArrayServletOutputStream() {
<span class="nc" id="L366">      this(32);</span>
<span class="nc" id="L367">    }</span>

    /**
     * Creates a new buffered stream with the specified size.
     *
     * @param size
     *          the buffer size
     */
<span class="nc" id="L375">    ByteArrayServletOutputStream(int size) {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">      if (size &lt; 0) {</span>
<span class="nc" id="L377">        throw new IllegalArgumentException(&quot;Negative initial size: &quot; + size);</span>
      }
<span class="nc" id="L379">      buf = new byte[size];</span>
<span class="nc" id="L380">    }</span>

    /**
     * Returns a copy of the buffer as an array.
     *
     * @return the buffer as a byte array
     */
    public synchronized byte[] toByteArray() {
<span class="nc" id="L388">      return Arrays.copyOf(buf, count);</span>
    }

    /**
     * Resets the stream.
     */
    public synchronized void reset() {
<span class="nc" id="L395">      count = 0;</span>
<span class="nc" id="L396">    }</span>

    /**
     * Gets the size of the stream
     *
     * @return the stream size
     */
    public synchronized int size() {
<span class="nc" id="L404">      return count;</span>
    }

    /**
     * Expands the size of the stream.
     *
     * @param size
     *          the new size of the buffer
     */
    public void enlarge(int size) {
<span class="nc bnc" id="L414" title="All 2 branches missed.">      if (size &gt; buf.length) {</span>
<span class="nc" id="L415">        buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; 1, size));</span>
      }
<span class="nc" id="L417">    }</span>

    @Override
    public synchronized void write(int b) throws IOException {
<span class="nc" id="L421">      int newcount = count + 1;</span>
<span class="nc" id="L422">      enlarge(newcount);</span>
<span class="nc" id="L423">      buf[count] = (byte) b;</span>
<span class="nc" id="L424">      count = newcount;</span>
<span class="nc" id="L425">    }</span>

    @Override
    public boolean isReady() {
<span class="nc" id="L429">      return false;</span>
    }

    @Override
    public void setWriteListener(WriteListener arg0) {
<span class="nc" id="L434">    }</span>

  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>