<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SearchServiceIndex.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-search-service-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.search.impl</a> &gt; <span class="el_source">SearchServiceIndex.java</span></div><h1>SearchServiceIndex.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.search.impl;

import static org.opencastproject.security.util.SecurityUtil.getEpisodeRoleId;

import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.rebuild.AbstractIndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildException;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildService;
import org.opencastproject.list.api.ListProviderException;
import org.opencastproject.list.api.ListProvidersService;
import org.opencastproject.list.api.ResourceListQuery;
import org.opencastproject.list.impl.ResourceListQueryImpl;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreUtil;
import org.opencastproject.metadata.dublincore.DublinCoreValue;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.search.api.SearchException;
import org.opencastproject.search.api.SearchResult;
import org.opencastproject.search.api.SearchService;
import org.opencastproject.search.impl.persistence.SearchServiceDatabase;
import org.opencastproject.search.impl.persistence.SearchServiceDatabaseException;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.Role;
import org.opencastproject.security.api.SecurityConstants;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.api.User;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.series.api.SeriesException;
import org.opencastproject.series.api.SeriesService;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.workspace.api.Workspace;

import com.google.gson.Gson;
import com.google.gson.JsonElement;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.elasticsearch.ElasticsearchStatusException;
import org.elasticsearch.action.DocWriteResponse;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.update.UpdateRequest;
import org.elasticsearch.action.update.UpdateResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.indices.CreateIndexRequest;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.rest.RestStatus;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * A Elasticsearch-based {@link SearchService} implementation.
 */
@Component(
        immediate = true,
        service = { SearchServiceIndex.class, IndexProducer.class },
        property = {
                &quot;service.description=Search Service Index&quot;,
                &quot;service.pid=org.opencastproject.search.impl.SearchServiceIndex&quot;
        }
)
public final class SearchServiceIndex extends AbstractIndexProducer implements IndexProducer {

  @Override
  public IndexRebuildService.Service getService() {
<span class="nc" id="L120">    return IndexRebuildService.Service.Search;</span>
  }

  /** Log facility */
<span class="nc" id="L124">  private static final Logger logger = LoggerFactory.getLogger(SearchServiceIndex.class);</span>

  public static final String INDEX_NAME = &quot;opencast_search&quot;;

<span class="nc" id="L128">  private final Gson gson = new Gson();</span>

  private ElasticsearchIndex esIndex;

  private SeriesService seriesService;

  /** The local workspace */
  private Workspace workspace;

  /** The security service */
  private SecurityService securityService;

  /** The authorization service */
  private AuthorizationService authorizationService;

  /** Persistent storage */
  private SearchServiceDatabase persistence;

  /** The organization directory service */
<span class="nc" id="L147">  private OrganizationDirectoryService organizationDirectory = null;</span>

  private ListProvidersService listProvidersService;

  private static final String CONFIG_EPISODE_ID_ROLE = &quot;org.opencastproject.episode.id.role.access&quot;;

<span class="nc" id="L153">  private boolean episodeIdRole = false;</span>

<span class="nc" id="L155">  private String systemUserName = null;</span>


  /**
   * Creates a new instance of the search service index.
   */
<span class="nc" id="L161">  public SearchServiceIndex() {</span>
<span class="nc" id="L162">  }</span>

  /**
   * Service activator, called via declarative services configuration.
   *
   * @param cc
   *          the component context
   */
  @Activate
  public void activate(final ComponentContext cc) throws IllegalStateException {
<span class="nc" id="L172">    episodeIdRole = BooleanUtils.toBoolean(Objects.toString(</span>
<span class="nc" id="L173">        cc.getBundleContext().getProperty(CONFIG_EPISODE_ID_ROLE), &quot;false&quot;));</span>
<span class="nc" id="L174">    logger.debug(&quot;Usage of episode ID roles is set to {}&quot;, episodeIdRole);</span>

<span class="nc" id="L176">    createIndex();</span>
<span class="nc" id="L177">    systemUserName = SecurityUtil.getSystemUserName(cc);</span>
<span class="nc" id="L178">  }</span>

  private void createIndex() {
<span class="nc" id="L181">    var mapping = &quot;&quot;;</span>
<span class="nc" id="L182">    try (var in = this.getClass().getResourceAsStream(&quot;/search-mapping.json&quot;)) {</span>
<span class="nc" id="L183">      mapping = IOUtils.toString(in, StandardCharsets.UTF_8);</span>
<span class="nc" id="L184">    } catch (IOException e) {</span>
<span class="nc" id="L185">      throw new SearchException(&quot;Could not read mapping.&quot;, e);</span>
<span class="nc" id="L186">    }</span>
    try {
<span class="nc" id="L188">      logger.debug(&quot;Trying to create index for '{}'&quot;, INDEX_NAME);</span>
<span class="nc" id="L189">      InputStream is = getClass().getResourceAsStream(&quot;/elasticsearch/indexSettings.json&quot;);</span>
<span class="nc" id="L190">      String indexSettings = IOUtils.toString(is, StandardCharsets.UTF_8);</span>
<span class="nc" id="L191">      final CreateIndexRequest request = new CreateIndexRequest(INDEX_NAME)</span>
<span class="nc" id="L192">          .settings(indexSettings, XContentType.JSON)</span>
<span class="nc" id="L193">          .mapping(mapping, XContentType.JSON);</span>
<span class="nc" id="L194">      var response = esIndex.getClient().indices().create(request, RequestOptions.DEFAULT);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      if (!response.isAcknowledged()) {</span>
<span class="nc" id="L196">        throw new SearchException(&quot;Unable to create index for '&quot; + INDEX_NAME + &quot;'&quot;);</span>
      }
<span class="nc" id="L198">    } catch (ElasticsearchStatusException e) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">      if (e.getDetailedMessage().contains(&quot;already_exists_exception&quot;)) {</span>
<span class="nc" id="L200">        logger.info(&quot;Detected existing index '{}'&quot;, INDEX_NAME);</span>
      } else {
<span class="nc" id="L202">        throw e;</span>
      }
<span class="nc" id="L204">    } catch (IOException e) {</span>
<span class="nc" id="L205">      throw new SearchException(e);</span>
<span class="nc" id="L206">    }</span>
<span class="nc" id="L207">  }</span>

  @Reference
  public void setEsIndex(ElasticsearchIndex esIndex) {
<span class="nc" id="L211">    this.esIndex = esIndex;</span>
<span class="nc" id="L212">  }</span>


  public SearchResponse search(SearchSourceBuilder searchSource) throws SearchException {
<span class="nc" id="L216">    SearchRequest searchRequest = new SearchRequest(INDEX_NAME);</span>
<span class="nc" id="L217">    logger.debug(&quot;Sending for query: {}&quot;, searchSource.query());</span>
<span class="nc" id="L218">    searchRequest.source(searchSource);</span>
    try {
<span class="nc" id="L220">      return esIndex.getClient().search(searchRequest, RequestOptions.DEFAULT);</span>
<span class="nc" id="L221">    } catch (IOException e) {</span>
<span class="nc" id="L222">      throw new SearchException(e);</span>
    }
  }

  /**
   * Immediately adds the mediapackage to the search index.
   *
   * @param mediaPackage
   *          the media package
   * @throws SearchException
   *           if the media package cannot be added to the search index
   * @throws IllegalArgumentException
   *           if the media package is &lt;code&gt;null&lt;/code&gt;
   * @throws UnauthorizedException
   *           if the user does not have the rights to add the mediapackage
   */
  public void addSynchronously(MediaPackage mediaPackage)
          throws SearchException, IllegalArgumentException, UnauthorizedException, SearchServiceDatabaseException {
<span class="nc bnc" id="L240" title="All 2 branches missed.">    if (mediaPackage == null) {</span>
<span class="nc" id="L241">      throw new IllegalArgumentException(&quot;Unable to add a null mediapackage&quot;);</span>
    }
<span class="nc" id="L243">    var mediaPackageId = mediaPackage.getIdentifier().toString();</span>

<span class="nc" id="L245">    checkSearchEntityWritePermission(mediaPackageId);</span>

<span class="nc" id="L247">    logger.debug(&quot;Attempting to add media package {} to search index&quot;, mediaPackageId);</span>
<span class="nc" id="L248">    final var acls = new AccessControlList[1];</span>
<span class="nc" id="L249">    final var org = securityService.getOrganization();</span>
<span class="nc" id="L250">    final var systemUser = SecurityUtil.createSystemUser(systemUserName, org);</span>
    // Ensure we always get the actual acl by forcing access
<span class="nc" id="L252">    SecurityUtil.runAs(securityService, org, systemUser, () -&gt; {</span>
<span class="nc" id="L253">      acls[0] = authorizationService.getActiveAcl(mediaPackage).getA();</span>
<span class="nc" id="L254">    });</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">    var acl = acls[0] == null ? new AccessControlList() : acls[0];</span>
<span class="nc" id="L256">    var now = new Date();</span>

    try {
<span class="nc" id="L259">      persistence.storeMediaPackage(mediaPackage, acl, now);</span>
<span class="nc" id="L260">    } catch (SearchServiceDatabaseException e) {</span>
<span class="nc" id="L261">      throw new SearchException(String.format(&quot;Could not store media package to search database %s&quot;, mediaPackageId),</span>
          e);
<span class="nc" id="L263">    }</span>

<span class="nc" id="L265">    indexMediaPackage(mediaPackage, acl);</span>
<span class="nc" id="L266">  }</span>

  public void indexMediaPackage(String mediaPackageId)
          throws SearchException, SearchServiceDatabaseException, UnauthorizedException, NotFoundException {
<span class="nc bnc" id="L270" title="All 2 branches missed.">    if (!securityService.getUser().hasRole(&quot;ROLE_ADMIN&quot;)) {</span>
<span class="nc" id="L271">      throw new UnauthorizedException(&quot;Only global administrators may trigger manual event updates.&quot;);</span>
    }
    try {
<span class="nc" id="L274">      MediaPackage mp = persistence.getMediaPackage(mediaPackageId);</span>
<span class="nc" id="L275">      AccessControlList acl = persistence.getAccessControlList(mediaPackageId);</span>
<span class="nc" id="L276">      Date modificationDate = persistence.getModificationDate(mediaPackageId);</span>
<span class="nc" id="L277">      Date deletionDate = persistence.getDeletionDate(mediaPackageId);</span>
<span class="nc" id="L278">      indexMediaPackage(mp, acl, modificationDate, deletionDate);</span>
<span class="nc" id="L279">    } catch (RuntimeException e) {</span>
<span class="nc" id="L280">      logSkippingElement(logger, &quot;event&quot;, mediaPackageId, e);</span>
<span class="nc" id="L281">    }</span>
<span class="nc" id="L282">  }</span>

  private void indexMediaPackage(MediaPackage mediaPackage, AccessControlList acl)
          throws SearchException, SearchServiceDatabaseException {
<span class="nc" id="L286">    indexMediaPackage(mediaPackage, acl, null, null);</span>
<span class="nc" id="L287">  }</span>

  private void indexMediaPackage(MediaPackage mediaPackage, AccessControlList acl, Date modDate, Date delDate)
          throws SearchException, SearchServiceDatabaseException {
<span class="nc" id="L291">    String mediaPackageId = mediaPackage.getIdentifier().toString();</span>
<span class="nc" id="L292">    String orgId = securityService.getOrganization().getId();</span>
    //If the entry has been deleted then there's *probably* no dc file to load.
<span class="nc bnc" id="L294" title="All 2 branches missed.">    DublinCoreCatalog dc = null == delDate</span>
<span class="nc" id="L295">        ? DublinCoreUtil.loadEpisodeDublinCore(workspace, mediaPackage).orElse(DublinCores.mkSimple())</span>
<span class="nc" id="L296">        : DublinCores.mkSimple();</span>

<span class="nc" id="L298">    List&lt;DublinCoreCatalog&gt; seriesList = Collections.emptyList();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">    if (dc.hasValue(DublinCore.PROPERTY_IS_PART_OF)) {</span>
      //Find the series (if any), filter for those which exist to prevent linking non-existent series
<span class="nc" id="L301">      seriesList = dc.get(DublinCore.PROPERTY_IS_PART_OF).stream().map(DublinCoreValue::getValue).map(s -&gt; {</span>
        try {
<span class="nc" id="L303">          return seriesService.getSeries(s);</span>
<span class="nc" id="L304">        } catch (NotFoundException e) {</span>
<span class="nc" id="L305">          logger.warn(&quot;Series {} not found during index of event {}, omitting the link from the indexed data&quot;, s,</span>
              mediaPackageId);
<span class="nc" id="L307">        } catch (UnauthorizedException e) {</span>
<span class="nc" id="L308">          logger.warn(&quot;Not authorized for series {} during index of event {}, omitting the link from the indexed data&quot;,</span>
              s, mediaPackageId);
<span class="nc" id="L310">        } catch (SeriesException e) {</span>
<span class="nc" id="L311">          throw new SearchException(e);</span>
<span class="nc" id="L312">        }</span>
<span class="nc" id="L313">        return null;</span>
<span class="nc" id="L314">      }).filter(Objects::nonNull).collect(Collectors.toList());</span>
    }

    // Add custom roles if enabled
<span class="nc" id="L318">    acl = addCustomAclRoles(mediaPackageId, acl);</span>

<span class="nc" id="L320">    SearchResult item = new SearchResult(SearchService.IndexEntryType.Episode, dc, acl, orgId, mediaPackage,</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">        null != modDate ? modDate.toInstant() : Instant.now(),</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        null != delDate ? delDate.toInstant() : null);</span>
<span class="nc" id="L323">    Map&lt;String, Object&gt; metadata = item.dehydrateForIndex();</span>
    try {
<span class="nc" id="L325">      var request = new IndexRequest(INDEX_NAME);</span>
<span class="nc" id="L326">      request.id(mediaPackageId);</span>
<span class="nc" id="L327">      request.source(metadata);</span>
<span class="nc" id="L328">      esIndex.getClient().index(request, RequestOptions.DEFAULT);</span>
<span class="nc" id="L329">      logger.debug(&quot;Indexed episode {}&quot;, mediaPackageId);</span>
<span class="nc" id="L330">    } catch (IOException e) {</span>
<span class="nc" id="L331">      throw new SearchException(e);</span>
<span class="nc" id="L332">    }</span>

    // Elasticsearch series
<span class="nc bnc" id="L335" title="All 2 branches missed.">    for (DublinCoreCatalog seriesDc : seriesList) {</span>
<span class="nc" id="L336">      String seriesId = seriesDc.getFirst(DublinCore.PROPERTY_IDENTIFIER);</span>
<span class="nc" id="L337">      AccessControlList seriesAcl = persistence.getAccessControlLists(seriesId, mediaPackageId).stream()</span>
<span class="nc" id="L338">          .map(aclPair -&gt; addCustomAclRoles(aclPair.getKey(), aclPair.getValue()))</span>
<span class="nc" id="L339">          .reduce(new AccessControlList(acl.getEntries()), AccessControlList::mergeActions);</span>
<span class="nc" id="L340">      item = new SearchResult(SearchService.IndexEntryType.Series, seriesDc, seriesAcl, orgId,</span>
<span class="nc" id="L341">          null, Instant.now(), null);</span>

<span class="nc" id="L343">      Map&lt;String, Object&gt; seriesData = item.dehydrateForIndex();</span>
      try {
<span class="nc" id="L345">        var request = new IndexRequest(INDEX_NAME);</span>
<span class="nc" id="L346">        request.id(seriesId);</span>
<span class="nc" id="L347">        request.source(seriesData);</span>
<span class="nc" id="L348">        esIndex.getClient().index(request, RequestOptions.DEFAULT);</span>
<span class="nc" id="L349">        logger.debug(&quot;Indexed series {} related to episode {}&quot;, seriesId, mediaPackageId);</span>
<span class="nc" id="L350">      } catch (IOException e) {</span>
<span class="nc" id="L351">        throw new SearchException(e);</span>
<span class="nc" id="L352">      }</span>
<span class="nc" id="L353">    }</span>
<span class="nc" id="L354">  }</span>

  /**
   * Add custom roles of the media package to the passed ACL
   *
   * @param mediaPackageId
   *          the media package
   * @param acl
   *          the existing access control list
   * @return {@link AccessControlList} containing the passed and the custom roles merged together
   *
   */
  private AccessControlList addCustomAclRoles(String mediaPackageId, AccessControlList acl) {
    // This allows users with a role of the form ROLE_EPISODE_&lt;ID&gt;_&lt;ACTION&gt; to access the event through the index
<span class="nc bnc" id="L368" title="All 2 branches missed.">    if (episodeIdRole) {</span>
<span class="nc" id="L369">      Set&lt;AccessControlEntry&gt; customEntries = new HashSet&lt;&gt;();</span>
<span class="nc" id="L370">      customEntries.add(new AccessControlEntry(getEpisodeRoleId(mediaPackageId, &quot;READ&quot;), &quot;read&quot;, true));</span>
<span class="nc" id="L371">      customEntries.add(new AccessControlEntry(getEpisodeRoleId(mediaPackageId, &quot;WRITE&quot;), &quot;write&quot;, true));</span>

<span class="nc" id="L373">      ResourceListQuery query = new ResourceListQueryImpl();</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">      if (listProvidersService.hasProvider(&quot;ACL.ACTIONS&quot;)) {</span>
<span class="nc" id="L375">        Map&lt;String, String&gt; actions = new HashMap&lt;&gt;();</span>
        try {
<span class="nc" id="L377">          actions = listProvidersService.getList(&quot;ACL.ACTIONS&quot;, query, true);</span>
<span class="nc" id="L378">        } catch (ListProviderException e) {</span>
<span class="nc" id="L379">          throw new SearchException(&quot;Listproviders not loaded. &quot; + e);</span>
<span class="nc" id="L380">        }</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        for (String action : actions.keySet()) {</span>
<span class="nc" id="L382">          customEntries.add(</span>
<span class="nc" id="L383">              new AccessControlEntry(getEpisodeRoleId(mediaPackageId, action), action, true));</span>
<span class="nc" id="L384">        }</span>
      }

<span class="nc" id="L387">      AccessControlList customRoles = new AccessControlList(new ArrayList&lt;&gt;(customEntries));</span>
<span class="nc" id="L388">      acl = customRoles.merge(acl);</span>
    }

<span class="nc" id="L391">    return acl;</span>
  }

  private void checkSearchEntityWritePermission(final String mediaPackageId) throws SearchException {
<span class="nc" id="L395">    User user = securityService.getUser();</span>
    try {
<span class="nc" id="L397">      AccessControlList acl = persistence.getAccessControlList(mediaPackageId);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">      if (!authorizationService.hasPermission(acl, Permissions.Action.WRITE.toString())) {</span>
<span class="nc" id="L399">        boolean isAdmin = user.getRoles().stream()</span>
<span class="nc" id="L400">            .map(Role::getName)</span>
<span class="nc" id="L401">            .anyMatch(r -&gt; r.equals(SecurityConstants.GLOBAL_ADMIN_ROLE));</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (!isAdmin) {</span>
<span class="nc" id="L403">          throw new UnauthorizedException(user, &quot;Write permission denied for &quot; + mediaPackageId, acl);</span>
        } else {
<span class="nc" id="L405">          logger.debug(&quot;Write for {} is not allowed by ACL, but user has {}&quot;,</span>
              mediaPackageId, SecurityConstants.GLOBAL_ADMIN_ROLE);
        }
      }
<span class="nc" id="L409">    } catch (NotFoundException e) {</span>
<span class="nc" id="L410">      logger.debug(&quot;Mediapackage {} does not exist or was deleted, allowing writes for user {}&quot;, mediaPackageId, user);</span>
<span class="nc" id="L411">    } catch (SearchServiceDatabaseException | UnauthorizedException e) {</span>
<span class="nc" id="L412">      throw new SearchException(e);</span>
<span class="nc" id="L413">    }</span>
<span class="nc" id="L414">  }</span>

  /**
   * Immediately removes the given mediapackage from the search service.
   *
   * @param mediaPackageId
   *          the media package identifier
   * @return &lt;code&gt;true&lt;/code&gt; if the mediapackage was deleted
   * @throws SearchException
   *           if deletion failed
   */
  public boolean deleteSynchronously(final String mediaPackageId) throws SearchException {

<span class="nc" id="L427">    checkSearchEntityWritePermission(mediaPackageId);</span>

<span class="nc" id="L429">    String deletionString = DateTimeFormatter.ISO_INSTANT.format(Instant.now());</span>

    try {
<span class="nc" id="L432">      logger.info(&quot;Marking media package {} as deleted in search index&quot;, mediaPackageId);</span>
<span class="nc" id="L433">      JsonElement json = gson.toJsonTree(Map.of(</span>
          SearchResult.DELETED_DATE, deletionString,
          SearchResult.MODIFIED_DATE, deletionString));
<span class="nc" id="L436">      var updateRequst = new UpdateRequest(INDEX_NAME, mediaPackageId)</span>
<span class="nc" id="L437">          .doc(gson.toJson(json), XContentType.JSON);</span>
<span class="nc" id="L438">      esIndex.getClient().update(updateRequst, RequestOptions.DEFAULT);</span>
<span class="nc" id="L439">    } catch (ElasticsearchStatusException e) {</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">      if (e.status().getStatus() != RestStatus.NOT_FOUND.getStatus()) {</span>
<span class="nc" id="L441">        throw e;</span>
      }
<span class="nc" id="L443">      logger.warn(&quot;Event {} is not in the search index. Skipping deletion&quot;, mediaPackageId);</span>
<span class="nc" id="L444">    } catch (IOException e) {</span>
<span class="nc" id="L445">      throw new SearchException(&quot;Could not delete episode &quot; + mediaPackageId + &quot; from index&quot;, e);</span>
<span class="nc" id="L446">    }</span>

    try {
<span class="nc" id="L449">      logger.info(&quot;Marking media package {} as deleted in search database&quot;, mediaPackageId);</span>

<span class="nc" id="L451">      String seriesId = null;</span>
<span class="nc" id="L452">      Date now = new Date();</span>
      try {
<span class="nc" id="L454">        seriesId = persistence.getMediaPackage(mediaPackageId).getSeries();</span>
<span class="nc" id="L455">        persistence.deleteMediaPackage(mediaPackageId, now);</span>
<span class="nc" id="L456">        logger.info(&quot;Removed media package {} from search persistence&quot;, mediaPackageId);</span>
<span class="nc" id="L457">      } catch (NotFoundException e) {</span>
        // even if mp not found in persistence, it might still exist in search index.
<span class="nc" id="L459">        logger.info(&quot;Could not find media package with id {} in persistence, but will try remove it from index anyway.&quot;,</span>
            mediaPackageId);
<span class="nc" id="L461">      } catch (SearchServiceDatabaseException | UnauthorizedException e) {</span>
<span class="nc" id="L462">        throw new SearchException(</span>
<span class="nc" id="L463">            String.format(&quot;Could not delete media package with id %s from persistence storage&quot;, mediaPackageId), e);</span>
<span class="nc" id="L464">      }</span>

      // Update series
<span class="nc bnc" id="L467" title="All 2 branches missed.">      if (seriesId != null) {</span>
        try {
<span class="nc bnc" id="L469" title="All 2 branches missed.">          if (!persistence.getSeries(seriesId).isEmpty()) {</span>
            // Update series acl if there are still episodes in the series
<span class="nc" id="L471">            final AccessControlList seriesAcl = persistence.getAccessControlLists(seriesId).stream()</span>
<span class="nc" id="L472">                .map(aclPair -&gt; addCustomAclRoles(aclPair.getKey(), aclPair.getValue()))</span>
<span class="nc" id="L473">                .reduce(new AccessControlList(), AccessControlList::mergeActions);</span>
<span class="nc" id="L474">            JsonElement json = gson.toJsonTree(Map.of(</span>
<span class="nc" id="L475">                SearchResult.INDEX_ACL, SearchResult.dehydrateAclForIndex(seriesAcl),</span>
                SearchResult.MODIFIED_DATE, deletionString));
<span class="nc" id="L477">            var updateRequest = new UpdateRequest(INDEX_NAME, seriesId).doc(gson.toJson(json), XContentType.JSON);</span>
            try {
<span class="nc" id="L479">              esIndex.getClient().update(updateRequest, RequestOptions.DEFAULT);</span>
<span class="nc" id="L480">            } catch (ElasticsearchStatusException e) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">              if (RestStatus.NOT_FOUND == e.status()) {</span>
<span class="nc" id="L482">                logger.warn(&quot;Attempted to modify {}, but that series does not exist in the index.&quot;, seriesId);</span>
              }
<span class="nc" id="L484">            }</span>
<span class="nc" id="L485">          } else {</span>
            // Remove series if there are no episodes in the series any longer
<span class="nc" id="L487">            deleteSeriesSynchronously(seriesId);</span>
          }
<span class="nc" id="L489">        } catch (IOException e) {</span>
<span class="nc" id="L490">          throw new SearchException(e);</span>
<span class="nc" id="L491">        }</span>
      }

<span class="nc" id="L494">      return true;</span>
<span class="nc" id="L495">    } catch (SearchServiceDatabaseException e) {</span>
<span class="nc" id="L496">      logger.info(&quot;Could not delete media package with id {} from search index&quot;, mediaPackageId);</span>
<span class="nc" id="L497">      throw new SearchException(e);</span>
    }
  }

  /**
   * Immediately removes the given series from the search service.
   *
   * @param seriesId
   *          the series
   * @throws SearchException
   */
  public boolean deleteSeriesSynchronously(String seriesId) throws SearchException {
    try {
<span class="nc" id="L510">      logger.info(&quot;Marking {} as deleted in the search index&quot;, seriesId);</span>
<span class="nc" id="L511">      JsonElement json = gson.toJsonTree(Map.of(</span>
<span class="nc" id="L512">          &quot;deleted&quot;, Instant.now().getEpochSecond(),</span>
<span class="nc" id="L513">          &quot;modified&quot;, Instant.now().toString()));</span>
<span class="nc" id="L514">      var updateRequest = new UpdateRequest(INDEX_NAME, seriesId).doc(gson.toJson(json), XContentType.JSON);</span>
      try {
<span class="nc" id="L516">        UpdateResponse response = esIndex.getClient().update(updateRequest, RequestOptions.DEFAULT);</span>
        //NB: We're marking things as deleted but *not actually deleting them**
<span class="nc bnc" id="L518" title="All 2 branches missed.">        return DocWriteResponse.Result.UPDATED == response.getResult();</span>
<span class="nc" id="L519">      } catch (ElasticsearchStatusException e) {</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (RestStatus.NOT_FOUND == e.status()) {</span>
<span class="nc" id="L521">          logger.debug(&quot;Attempted to delete {}, but that series does not exist in the index.&quot;, seriesId);</span>
<span class="nc" id="L522">          return true;</span>
        }
<span class="nc" id="L524">        throw new SearchException(e);</span>
      }
<span class="nc" id="L526">    } catch (IOException e) {</span>
<span class="nc" id="L527">      throw new SearchException(&quot;Could not delete series &quot; + seriesId + &quot; from index&quot;, e);</span>
    }
  }

  @Override
  public void repopulate(IndexRebuildService.DataType type) throws IndexRebuildException {
<span class="nc" id="L533">    final Organization originalOrg = securityService.getOrganization();</span>
<span class="nc" id="L534">    final User originalUser = securityService.getUser();</span>

    try {
<span class="nc" id="L537">      int total = persistence.countMediaPackages();</span>
<span class="nc" id="L538">      int pageSize = 50;</span>
<span class="nc" id="L539">      int pageOffset = 0;</span>
<span class="nc" id="L540">      AtomicInteger current = new AtomicInteger(1);</span>
<span class="nc" id="L541">      logIndexRebuildBegin(logger, total, &quot;search&quot;);</span>
<span class="nc" id="L542">      List&lt;Tuple&lt;MediaPackage, String&gt;&gt; page = null;</span>

      do {
<span class="nc" id="L545">        page = persistence.getAllMediaPackages(pageSize, pageOffset).collect(Collectors.toList());</span>
<span class="nc" id="L546">        page.forEach(tuple -&gt; {</span>
          try {
<span class="nc" id="L548">            MediaPackage mediaPackage = tuple.getA();</span>
<span class="nc" id="L549">            Organization organization = organizationDirectory.getOrganization(tuple.getB());</span>
<span class="nc" id="L550">            final var systemUser = SecurityUtil.createSystemUser(systemUserName, organization);</span>
<span class="nc" id="L551">            securityService.setUser(systemUser);</span>
<span class="nc" id="L552">            securityService.setOrganization(organization);</span>

<span class="nc" id="L554">            String mediaPackageId = mediaPackage.getIdentifier().toString();</span>

<span class="nc" id="L556">            AccessControlList acl = persistence.getAccessControlList(mediaPackageId);</span>
<span class="nc" id="L557">            Date modificationDate = persistence.getModificationDate(mediaPackageId);</span>
<span class="nc" id="L558">            Date deletionDate = persistence.getDeletionDate(mediaPackageId);</span>

<span class="nc" id="L560">            current.getAndIncrement();</span>

<span class="nc" id="L562">            indexMediaPackage(mediaPackage, acl, modificationDate, deletionDate);</span>
<span class="nc" id="L563">          } catch (SearchServiceDatabaseException e) {</span>
<span class="nc" id="L564">            logIndexRebuildError(logger, total, current.get(), e);</span>
            //NB: Runtime exception thrown to escape the functional interfacing
<span class="nc" id="L566">            throw new RuntimeException(&quot;Internal Index Rebuild Failure&quot;, e);</span>
<span class="nc" id="L567">          } catch (RuntimeException | NotFoundException e) {</span>
<span class="nc" id="L568">            logSkippingElement(logger, &quot;event&quot;, tuple.getA().getIdentifier().toString(), e);</span>
<span class="nc" id="L569">          }</span>
<span class="nc" id="L570">        });</span>
        //Current is the *page* index, so we remove one since each page only has pageSize entries
<span class="nc" id="L572">        logIndexRebuildProgress(logger, total, current.get() - 1, pageSize);</span>
<span class="nc" id="L573">        pageOffset += 1;</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">      } while (pageOffset * pageSize &lt;= total);</span>
      //NB: Catching RuntimeException since it can be thrown inside the functional forEach here
<span class="nc" id="L576">    } catch (SearchServiceDatabaseException | RuntimeException e) {</span>
<span class="nc" id="L577">      logIndexRebuildError(logger, e);</span>
<span class="nc" id="L578">      throw new IndexRebuildException(&quot;Index Rebuild Failure&quot;, e);</span>
    } finally {
<span class="nc" id="L580">      securityService.setUser(originalUser);</span>
<span class="nc" id="L581">      securityService.setOrganization(originalOrg);</span>
    }
<span class="nc" id="L583">  }</span>

  @Reference
  public void setPersistence(SearchServiceDatabase persistence) {
<span class="nc" id="L587">    this.persistence = persistence;</span>
<span class="nc" id="L588">  }</span>

  @Reference
  public void setSeriesService(SeriesService seriesService) {
<span class="nc" id="L592">    this.seriesService = seriesService;</span>
<span class="nc" id="L593">  }</span>

  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="nc" id="L597">    this.workspace = workspace;</span>
<span class="nc" id="L598">  }</span>

  @Reference
  public void setAuthorizationService(AuthorizationService authorizationService) {
<span class="nc" id="L602">    this.authorizationService = authorizationService;</span>
<span class="nc" id="L603">  }</span>

  /**
   * Callback for setting the security service.
   *
   * @param securityService
   *          the securityService to set
   */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="nc" id="L613">    this.securityService = securityService;</span>
<span class="nc" id="L614">  }</span>

  /**
   * Sets a reference to the organization directory service.
   *
   * @param organizationDirectory
   *          the organization directory
   */
  @Reference
  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectory) {
<span class="nc" id="L624">    this.organizationDirectory = organizationDirectory;</span>
<span class="nc" id="L625">  }</span>

  @Reference
  public void setListProvidersService(ListProvidersService listProvidersService) {
<span class="nc" id="L629">    this.listProvidersService = listProvidersService;</span>
<span class="nc" id="L630">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>