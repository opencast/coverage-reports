<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WorkingFileRepositoryRestEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-working-file-repository-service-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.workingfilerepository.impl</a> &gt; <span class="el_source">WorkingFileRepositoryRestEndpoint.java</span></div><h1>WorkingFileRepositoryRestEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.workingfilerepository.impl;

import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
import static javax.servlet.http.HttpServletResponse.SC_NOT_MODIFIED;
import static javax.servlet.http.HttpServletResponse.SC_NO_CONTENT;
import static javax.servlet.http.HttpServletResponse.SC_OK;
import static org.opencastproject.util.MimeTypes.getMimeType;
import static org.opencastproject.util.RestUtil.R.ok;
import static org.opencastproject.util.RestUtil.fileResponse;
import static org.opencastproject.util.RestUtil.partialFileResponse;
import static org.opencastproject.util.data.Option.none;
import static org.opencastproject.util.data.Option.some;
import static org.opencastproject.util.doc.rest.RestParameter.Type.FILE;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;

import org.opencastproject.security.api.SecurityService;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.util.MimeTypes;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.UnknownFileTypeException;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.workingfilerepository.api.PathMappable;
import org.opencastproject.workingfilerepository.api.WorkingFileRepository;

import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpStatus;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.net.URI;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.DELETE;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path(&quot;/files&quot;)
@RestService(name = &quot;filerepo&quot;, title = &quot;Working File Repository&quot;, abstractText = &quot;Stores and retrieves files for use during media processing.&quot;, notes = {
        &quot;All paths above are relative to the REST endpoint base (something like http://your.server/files)&quot;,
        &quot;If the service is down or not working it will return a status 503, this means the the underlying service is &quot;
                + &quot;not working and is either restarting or has failed&quot;,
        &quot;A status code 500 means a general failure has occurred which is not recoverable and was not anticipated. In &quot;
                + &quot;other words, there is a bug! You should file an error report with your server logs from the time when the &quot;
                + &quot;error occurred: &lt;a href=\&quot;https://github.com/opencast/opencast/issues\&quot;&gt;Opencast Issue Tracker&lt;/a&gt;&quot; })
@Component(
  name = &quot;org.opencastproject.workingfilerepository.impl.WorkingFileRepository&quot;,
  property = {
    &quot;service.description=Working File Repository REST Endpoint&quot;,
    &quot;opencast.service.type=org.opencastproject.files&quot;,
    &quot;opencast.service.path=/files&quot;
  },
  immediate = true,
  service = { WorkingFileRepositoryRestEndpoint.class, WorkingFileRepository.class, PathMappable.class }
)
@JaxrsResource
<span class="fc" id="L102">public class WorkingFileRepositoryRestEndpoint extends WorkingFileRepositoryImpl {</span>

<span class="fc" id="L104">  private static final Logger logger = LoggerFactory.getLogger(WorkingFileRepositoryRestEndpoint.class);</span>

  /**
   * Callback from OSGi that is called when this service is activated.
   *
   * @param cc
   *          OSGi component context
   */
  @Override
  @Activate
  public void activate(ComponentContext cc) throws IOException {
<span class="nc" id="L115">    super.activate(cc);</span>
<span class="nc" id="L116">  }</span>

  /**
   * Callback from OSGi that is called when this service is deactivated.
   */
  @Override
  @Deactivate
  public void deactivate() {
<span class="nc" id="L124">    super.deactivate();</span>
<span class="nc" id="L125">  }</span>

  /**
   * Sets the remote service manager.
   *
   * @param remoteServiceManager
   */
  @Override
  @Reference
  public void setRemoteServiceManager(ServiceRegistry remoteServiceManager) {
<span class="nc" id="L135">    super.setRemoteServiceManager(remoteServiceManager);</span>
<span class="nc" id="L136">  }</span>

  @Override
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L141">    super.setSecurityService(securityService);</span>
<span class="fc" id="L142">  }</span>

  @POST
  @Produces(MediaType.TEXT_HTML)
  @Path(WorkingFileRepository.MEDIAPACKAGE_PATH_PREFIX + &quot;{mediaPackageID}/{mediaPackageElementID}&quot;)
  @RestQuery(name = &quot;put&quot;, description = &quot;Store a file in working repository under ./mediaPackageID/mediaPackageElementID&quot;, returnDescription = &quot;The URL to access the stored file&quot;, pathParameters = {
          @RestParameter(name = &quot;mediaPackageID&quot;, description = &quot;the mediapackage identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;mediaPackageElementID&quot;, description = &quot;the mediapackage element identifier&quot;, isRequired = true, type = STRING) }, responses = { @RestResponse(responseCode = SC_OK, description = &quot;OK, file stored&quot;) }, restParameters = { @RestParameter(name = &quot;file&quot;, description = &quot;the filename&quot;, isRequired = true, type = FILE) })
  public Response restPut(@PathParam(&quot;mediaPackageID&quot;) String mediaPackageID,
          @PathParam(&quot;mediaPackageElementID&quot;) String mediaPackageElementID, @Context HttpServletRequest request)
          throws Exception {
<span class="nc bnc" id="L153" title="All 2 branches missed.">    if (ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">      for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L155">        FileItemStream item = iter.next();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (item.isFormField()) {</span>
<span class="nc" id="L157">          continue;</span>

        }
<span class="nc" id="L160">        URI url = this.put(mediaPackageID, mediaPackageElementID, item.getName(), item.openStream());</span>
<span class="nc" id="L161">        return Response.ok(url.toString()).build();</span>
      }
    }
<span class="nc" id="L164">    return Response.serverError().status(400).build();</span>
  }

  @POST
  @Produces(MediaType.TEXT_HTML)
  @Path(WorkingFileRepository.MEDIAPACKAGE_PATH_PREFIX + &quot;{mediaPackageID}/{mediaPackageElementID}/{filename}&quot;)
  @RestQuery(name = &quot;putWithFilename&quot;, description = &quot;Store a file in working repository under ./mediaPackageID/mediaPackageElementID/filename&quot;, returnDescription = &quot;The URL to access the stored file&quot;, pathParameters = {
          @RestParameter(name = &quot;mediaPackageID&quot;, description = &quot;the mediapackage identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;mediaPackageElementID&quot;, description = &quot;the mediapackage element identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;filename&quot;, description = &quot;the filename&quot;, isRequired = true, type = FILE) }, responses = { @RestResponse(responseCode = SC_OK, description = &quot;OK, file stored&quot;) })
  public Response restPutURLEncoded(@Context HttpServletRequest request,
          @PathParam(&quot;mediaPackageID&quot;) String mediaPackageID,
          @PathParam(&quot;mediaPackageElementID&quot;) String mediaPackageElementID, @PathParam(&quot;filename&quot;) String filename,
          @FormParam(&quot;content&quot;) String content) throws Exception {
<span class="nc" id="L178">    String encoding = request.getCharacterEncoding();</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (encoding == null)</span>
<span class="nc" id="L180">      encoding = &quot;utf-8&quot;;</span>

<span class="nc" id="L182">    URI url = this.put(mediaPackageID, mediaPackageElementID, filename, IOUtils.toInputStream(content, encoding));</span>
<span class="nc" id="L183">    return Response.ok(url.toString()).build();</span>
  }

  @POST
  @Produces(MediaType.TEXT_HTML)
  @Path(WorkingFileRepository.COLLECTION_PATH_PREFIX + &quot;{collectionId}&quot;)
  @RestQuery(name = &quot;putInCollection&quot;, description = &quot;Store a file in working repository under ./collectionId/filename&quot;, returnDescription = &quot;The URL to access the stored file&quot;, pathParameters = { @RestParameter(name = &quot;collectionId&quot;, description = &quot;the colection identifier&quot;, isRequired = true, type = STRING) }, restParameters = { @RestParameter(name = &quot;file&quot;, description = &quot;the filename&quot;, isRequired = true, type = FILE) }, responses = { @RestResponse(responseCode = SC_OK, description = &quot;OK, file stored&quot;) })
  public Response restPutInCollection(@PathParam(&quot;collectionId&quot;) String collectionId,
          @Context HttpServletRequest request) throws Exception {
<span class="nc bnc" id="L192" title="All 2 branches missed.">    if (ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">      for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="nc" id="L194">        FileItemStream item = iter.next();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (item.isFormField()) {</span>
<span class="nc" id="L196">          continue;</span>

        }
<span class="nc" id="L199">        URI url = this.putInCollection(collectionId, item.getName(), item.openStream());</span>
<span class="nc" id="L200">        return Response.ok(url.toString()).build();</span>
      }
    }
<span class="nc" id="L203">    return Response.serverError().status(400).build();</span>
  }

  @DELETE
  @Path(WorkingFileRepository.MEDIAPACKAGE_PATH_PREFIX + &quot;{mediaPackageID}/{mediaPackageElementID}&quot;)
  @RestQuery(name = &quot;delete&quot;, description = &quot;Remove the file from the working repository under /mediaPackageID/mediaPackageElementID&quot;, returnDescription = &quot;No content&quot;, pathParameters = {
          @RestParameter(name = &quot;mediaPackageID&quot;, description = &quot;the mediapackage identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;mediaPackageElementID&quot;, description = &quot;the mediapackage element identifier&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;File deleted&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;File did not exist&quot;) })
  public Response restDelete(@PathParam(&quot;mediaPackageID&quot;) String mediaPackageID,
          @PathParam(&quot;mediaPackageElementID&quot;) String mediaPackageElementID) {
    try {
<span class="nc bnc" id="L216" title="All 2 branches missed.">      if (delete(mediaPackageID, mediaPackageElementID))</span>
<span class="nc" id="L217">        return Response.ok().build();</span>
      else
<span class="nc" id="L219">        return Response.status(HttpStatus.SC_NOT_FOUND).build();</span>
<span class="nc" id="L220">    } catch (Exception e) {</span>
<span class="nc" id="L221">      logger.error(&quot;Unable to delete element '{}' from mediapackage '{}'&quot;, mediaPackageElementID,</span>
              mediaPackageID, e);
<span class="nc" id="L223">      return Response.serverError().entity(e.getMessage()).build();</span>
    }
  }

  @DELETE
  @Path(WorkingFileRepository.COLLECTION_PATH_PREFIX + &quot;{collectionId}/{fileName}&quot;)
  @RestQuery(name = &quot;deleteFromCollection&quot;, description = &quot;Remove the file from the working repository under /collectionId/filename&quot;, returnDescription = &quot;No content&quot;, pathParameters = {
          @RestParameter(name = &quot;collectionId&quot;, description = &quot;the collection identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;fileName&quot;, description = &quot;the file name&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;File deleted&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;Collection or file not found&quot;) })
  public Response restDeleteFromCollection(@PathParam(&quot;collectionId&quot;) String collectionId,
          @PathParam(&quot;fileName&quot;) String fileName) {
    try {
<span class="nc bnc" id="L237" title="All 2 branches missed.">      if (this.deleteFromCollection(collectionId, fileName))</span>
<span class="nc" id="L238">        return Response.noContent().build();</span>
      else
<span class="nc" id="L240">        return Response.status(SC_NOT_FOUND).build();</span>
<span class="nc" id="L241">    } catch (Exception e) {</span>
<span class="nc" id="L242">      logger.error(&quot;Unable to delete element '{}' from collection '{}'&quot;, fileName, collectionId, e);</span>
<span class="nc" id="L243">      return Response.serverError().entity(e.getMessage()).build();</span>
    }
  }

  @DELETE
  @Path(WorkingFileRepository.COLLECTION_PATH_PREFIX + &quot;cleanup/{collectionId}/{numberOfDays}&quot;)
  @RestQuery(name = &quot;cleanupOldFilesFromCollection&quot;, description = &quot;Remove the files from the working repository under /collectionId that are older than N days&quot;, returnDescription = &quot;No content&quot;, pathParameters = {
          @RestParameter(name = &quot;collectionId&quot;, description = &quot;the collection identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;numberOfDays&quot;, description = &quot;files older than this number of days will be deleted&quot;, isRequired = true, type = STRING) }, responses = {
                  @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;Files deleted&quot;),
                  @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;Collection not found&quot;) })
  public Response restCleanupOldFilesFromCollection(@PathParam(&quot;collectionId&quot;) String collectionId,
          @PathParam(&quot;numberOfDays&quot;) long days) {
    try {
<span class="nc bnc" id="L257" title="All 2 branches missed.">      if (this.cleanupOldFilesFromCollection(collectionId, days))</span>
<span class="nc" id="L258">        return Response.noContent().build();</span>
      else
<span class="nc" id="L260">        return Response.status(SC_NOT_FOUND).build();</span>
<span class="nc" id="L261">    } catch (Exception e) {</span>
<span class="nc" id="L262">      logger.error(&quot;Unable to delete files older than '{}' days from collection '{}'&quot;,</span>
<span class="nc" id="L263">              days, collectionId, e);</span>
<span class="nc" id="L264">      return Response.serverError().entity(e.getMessage()).build();</span>
    }
  }

  @DELETE
  @Path(WorkingFileRepository.COLLECTION_PATH_PREFIX + &quot;cleanup/mediapackage/{numberOfDays}&quot;)
  @RestQuery(name = &quot;cleanupOldFilesFromMediaPackage&quot;, description = &quot;Remove files and directories from the working file repository under /mediapackage that are older than N days&quot;, returnDescription = &quot;No content&quot;, pathParameters = {
          @RestParameter(name = &quot;numberOfDays&quot;, description = &quot;files older than this number of days will be deleted&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_NO_CONTENT, description = &quot;Files deleted&quot;)})
  public Response restCleanupOldFilesFromMediaPackage(@PathParam(&quot;numberOfDays&quot;) long days) {
    try {
<span class="nc" id="L275">      this.cleanupOldFilesFromMediaPackage(days);</span>
<span class="nc" id="L276">      return Response.noContent().build();</span>
<span class="nc" id="L277">    } catch (Exception e) {</span>
<span class="nc" id="L278">      return Response.serverError().entity(e.getMessage()).build();</span>
    }
  }

  @GET
  @Path(WorkingFileRepository.MEDIAPACKAGE_PATH_PREFIX + &quot;{mediaPackageID}/{mediaPackageElementID}&quot;)
  @RestQuery(name = &quot;get&quot;, description = &quot;Gets the file from the working repository under /mediaPackageID/mediaPackageElementID&quot;, returnDescription = &quot;The file&quot;, pathParameters = {
          @RestParameter(name = &quot;mediaPackageID&quot;, description = &quot;the mediapackage identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;mediaPackageElementID&quot;, description = &quot;the mediapackage element identifier&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;File returned&quot;),
          @RestResponse(responseCode = SC_NOT_MODIFIED, description = &quot;If file not modified&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;Not found&quot;) })
  public Response restGet(@PathParam(&quot;mediaPackageID&quot;) final String mediaPackageID,
          @PathParam(&quot;mediaPackageElementID&quot;) final String mediaPackageElementID,
          @HeaderParam(&quot;If-None-Match&quot;) String ifNoneMatch) throws NotFoundException {
    // Check the If-None-Match header first
<span class="fc" id="L294">    String md5 = null;</span>
    try {
<span class="fc" id="L296">      md5 = getMediaPackageElementDigest(mediaPackageID, mediaPackageElementID);</span>
<span class="pc bpc" id="L297" title="3 of 4 branches missed.">      if (StringUtils.isNotBlank(ifNoneMatch) &amp;&amp; md5.equals(ifNoneMatch)) {</span>
<span class="nc" id="L298">        return Response.notModified(md5).build();</span>
      }
<span class="nc" id="L300">    } catch (IOException e) {</span>
<span class="nc" id="L301">      logger.warn(&quot;Error reading digest of {}/{}&quot;, mediaPackageElementID, mediaPackageElementID);</span>
<span class="fc" id="L302">    }</span>
    try {
      String contentType;
<span class="fc" id="L305">      File file = getFile(mediaPackageID, mediaPackageElementID);</span>
      try {
<span class="fc" id="L307">        contentType = MimeTypes.fromString(file.getPath()).toString();</span>
<span class="nc" id="L308">      } catch (UnknownFileTypeException e) {</span>
<span class="nc" id="L309">        contentType = &quot;application/octet-stream&quot;;</span>
<span class="fc" id="L310">      }</span>
      try {
<span class="fc" id="L312">        return ok(get(mediaPackageID, mediaPackageElementID), contentType, some(file.length()), none(&quot;&quot;));</span>
<span class="nc" id="L313">      } catch (IOException e) {</span>
<span class="nc" id="L314">        throw new NotFoundException();</span>
      }
<span class="nc" id="L316">    } catch (IllegalStateException e) {</span>
<span class="nc" id="L317">      logger.error(&quot;Unable to provide element '{}' from mediapackage '{}'&quot;, mediaPackageElementID,</span>
              mediaPackageID, e);
<span class="nc" id="L319">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @GET
  @Path(WorkingFileRepository.MEDIAPACKAGE_PATH_PREFIX + &quot;{mediaPackageID}/{mediaPackageElementID}/{fileName}&quot;)
  @RestQuery(name = &quot;getWithFilename&quot;, description = &quot;Gets the file from the working repository under /mediaPackageID/mediaPackageElementID/filename&quot;, returnDescription = &quot;The file&quot;, pathParameters = {
          @RestParameter(name = &quot;mediaPackageID&quot;, description = &quot;the mediapackage identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;mediaPackageElementID&quot;, description = &quot;the mediapackage element identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;fileName&quot;, description = &quot;the file name&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;File returned&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;Not found&quot;) })
  public Response restGet(@PathParam(&quot;mediaPackageID&quot;) String mediaPackageID,
          @PathParam(&quot;mediaPackageElementID&quot;) String mediaPackageElementID, @PathParam(&quot;fileName&quot;) String fileName,
          @HeaderParam(&quot;If-None-Match&quot;) String ifNoneMatch, @HeaderParam(&quot;Range&quot;) String range)
          throws NotFoundException {
<span class="nc" id="L335">    String md5 = null;</span>
    // Check the If-None-Match header first
    try {
<span class="nc" id="L338">      md5 = getMediaPackageElementDigest(mediaPackageID, mediaPackageElementID);</span>
<span class="nc bnc" id="L339" title="All 4 branches missed.">      if (StringUtils.isNotBlank(ifNoneMatch) &amp;&amp; md5.equals(ifNoneMatch)) {</span>
<span class="nc" id="L340">        return Response.notModified(md5).build();</span>
      }
<span class="nc" id="L342">    } catch (IOException e) {</span>
<span class="nc" id="L343">      logger.warn(&quot;Error reading digest of {}/{}/{}&quot;, mediaPackageElementID, mediaPackageElementID,</span>
              fileName);
<span class="nc" id="L345">    }</span>

    try {
<span class="nc bnc" id="L348" title="All 2 branches missed.">      if (StringUtils.isNotBlank(range)) {</span>
<span class="nc" id="L349">        logger.debug(&quot;trying to retrieve range: {}&quot;, range);</span>
<span class="nc" id="L350">        return partialFileResponse(getFile(mediaPackageID, mediaPackageElementID), getMimeType(fileName),</span>
<span class="nc" id="L351">                some(fileName), range).tag(md5).build();</span>

      } else {
        // No If-Non-Match header provided, or the file changed in the meantime
<span class="nc" id="L355">        return fileResponse(getFile(mediaPackageID, mediaPackageElementID), getMimeType(fileName),</span>
<span class="nc" id="L356">                some(fileName)).tag(md5).build();</span>
      }
<span class="nc" id="L358">    } catch (Exception e) {</span>
<span class="nc" id="L359">      logger.error(&quot;Unable to provide element '{}' from mediapackage '{}'&quot;, mediaPackageElementID,</span>
              mediaPackageID, e);
<span class="nc" id="L361">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @GET
  @Path(WorkingFileRepository.COLLECTION_PATH_PREFIX + &quot;{collectionId}/{fileName}&quot;)
  @RestQuery(name = &quot;getFromCollection&quot;, description = &quot;Gets the file from the working repository under /collectionId/filename&quot;, returnDescription = &quot;The file&quot;, pathParameters = {
          @RestParameter(name = &quot;collectionId&quot;, description = &quot;the collection identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;fileName&quot;, description = &quot;the file name&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;File returned&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;Not found&quot;) })
  public Response restGetFromCollection(@PathParam(&quot;collectionId&quot;) String collectionId,
          @PathParam(&quot;fileName&quot;) String fileName) throws NotFoundException {
<span class="fc" id="L374">    return fileResponse(getFileFromCollection(collectionId, fileName), getMimeType(fileName), some(fileName))</span>
<span class="fc" id="L375">            .build();</span>
  }

  @GET
  @Path(&quot;/collectionuri/{collectionID}/{fileName}&quot;)
  @RestQuery(name = &quot;getUriFromCollection&quot;, description = &quot;Gets the URL for a file to be stored in the working repository under /collectionId/filename&quot;, returnDescription = &quot;The url to this file&quot;, pathParameters = {
          @RestParameter(name = &quot;collectionID&quot;, description = &quot;the collection identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;fileName&quot;, description = &quot;the file name&quot;, isRequired = true, type = STRING) }, responses = { @RestResponse(responseCode = SC_OK, description = &quot;URL returned&quot;) })
  public Response restGetCollectionUri(@PathParam(&quot;collectionID&quot;) String collectionId,
          @PathParam(&quot;fileName&quot;) String fileName) {
<span class="nc" id="L385">    URI uri = this.getCollectionURI(collectionId, fileName);</span>
<span class="nc" id="L386">    return Response.ok(uri.toString()).build();</span>
  }

  @GET
  @Path(&quot;/uri/{mediaPackageID}/{mediaPackageElementID}&quot;)
  @RestQuery(name = &quot;getUri&quot;, description = &quot;Gets the URL for a file to be stored in the working repository under /mediaPackageID&quot;, returnDescription = &quot;The url to this file&quot;, pathParameters = {
          @RestParameter(name = &quot;mediaPackageID&quot;, description = &quot;the mediaPackage identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;mediaPackageElementID&quot;, description = &quot;the mediaPackage element identifier&quot;, isRequired = true, type = STRING) }, responses = { @RestResponse(responseCode = SC_OK, description = &quot;URL returned&quot;) })
  public Response restGetUri(@PathParam(&quot;mediaPackageID&quot;) String mediaPackageID,
          @PathParam(&quot;mediaPackageElementID&quot;) String mediaPackageElementID) {
<span class="nc" id="L396">    URI uri = this.getURI(mediaPackageID, mediaPackageElementID);</span>
<span class="nc" id="L397">    return Response.ok(uri.toString()).build();</span>
  }

  @GET
  @Path(&quot;/uri/{mediaPackageID}/{mediaPackageElementID}/{fileName}&quot;)
  @RestQuery(name = &quot;getUriWithFilename&quot;, description = &quot;Gets the URL for a file to be stored in the working repository under /mediaPackageID&quot;, returnDescription = &quot;The url to this file&quot;, pathParameters = {
          @RestParameter(name = &quot;mediaPackageID&quot;, description = &quot;the mediaPackage identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;mediaPackageElementID&quot;, description = &quot;the mediaPackage element identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;fileName&quot;, description = &quot;the filename&quot;, isRequired = true, type = STRING) }, responses = { @RestResponse(responseCode = SC_OK, description = &quot;URL returned&quot;) })
  public Response restGetUri(@PathParam(&quot;mediaPackageID&quot;) String mediaPackageID,
          @PathParam(&quot;mediaPackageElementID&quot;) String mediaPackageElementID, @PathParam(&quot;fileName&quot;) String fileName) {
<span class="nc" id="L408">    URI uri = this.getURI(mediaPackageID, mediaPackageElementID, fileName);</span>
<span class="nc" id="L409">    return Response.ok(uri.toString()).build();</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;/list/{collectionId}.json&quot;)
  @RestQuery(name = &quot;filesInCollection&quot;, description = &quot;Lists files in a collection&quot;, returnDescription = &quot;Links to the URLs in a collection&quot;, pathParameters = { @RestParameter(name = &quot;collectionId&quot;, description = &quot;the collection identifier&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;URLs returned&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;Collection not found&quot;) })
  public Response restGetCollectionContents(@PathParam(&quot;collectionId&quot;) String collectionId) throws NotFoundException {
<span class="nc" id="L420">    URI[] uris = super.getCollectionContents(collectionId);</span>
<span class="nc" id="L421">    JSONArray jsonArray = new JSONArray();</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">    for (URI uri : uris) {</span>
<span class="nc" id="L423">      jsonArray.add(uri.toString());</span>
    }
<span class="nc" id="L425">    return Response.ok(jsonArray.toJSONString()).build();</span>
  }

  @POST
  @Path(&quot;/copy/{fromCollection}/{fromFileName}/{toMediaPackage}/{toMediaPackageElement}/{toFileName}&quot;)
  @RestQuery(name = &quot;copy&quot;, description = &quot;Copies a file from a collection to a mediapackage&quot;, returnDescription = &quot;A URL to the copied file&quot;, pathParameters = {
          @RestParameter(name = &quot;fromCollection&quot;, description = &quot;the collection identifier hosting the source&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;fromFileName&quot;, description = &quot;the source file name&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;toMediaPackage&quot;, description = &quot;the destination mediapackage identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;toMediaPackageElement&quot;, description = &quot;the destination mediapackage element identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;toFileName&quot;, description = &quot;the destination file name&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;URL returned&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;File to copy not found&quot;) })
  public Response restCopyTo(@PathParam(&quot;fromCollection&quot;) String fromCollection,
          @PathParam(&quot;fromFileName&quot;) String fromFileName, @PathParam(&quot;toMediaPackage&quot;) String toMediaPackage,
          @PathParam(&quot;toMediaPackageElement&quot;) String toMediaPackageElement, @PathParam(&quot;toFileName&quot;) String toFileName)
          throws NotFoundException {
    try {
<span class="nc" id="L443">      URI uri = super.copyTo(fromCollection, fromFileName, toMediaPackage, toMediaPackageElement, toFileName);</span>
<span class="nc" id="L444">      return Response.ok().entity(uri.toString()).build();</span>
<span class="nc" id="L445">    } catch (IOException e) {</span>
<span class="nc" id="L446">      logger.error(&quot;Unable to copy file '{}' from collection '{}' to mediapackage {}/{}&quot;,</span>
              fromFileName, fromCollection, toMediaPackage, toMediaPackageElement, e);
<span class="nc" id="L448">      return Response.serverError().entity(e.getMessage()).build();</span>
    }
  }

  @POST
  @Path(&quot;/move/{fromCollection}/{fromFileName}/{toMediaPackage}/{toMediaPackageElement}/{toFileName}&quot;)
  @RestQuery(name = &quot;move&quot;, description = &quot;Moves a file from a collection to a mediapackage&quot;, returnDescription = &quot;A URL to the moved file&quot;, pathParameters = {
          @RestParameter(name = &quot;fromCollection&quot;, description = &quot;the collection identifier hosting the source&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;fromFileName&quot;, description = &quot;the source file name&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;toMediaPackage&quot;, description = &quot;the destination mediapackage identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;toMediaPackageElement&quot;, description = &quot;the destination mediapackage element identifier&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;toFileName&quot;, description = &quot;the destination file name&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;URL returned&quot;),
          @RestResponse(responseCode = SC_NOT_FOUND, description = &quot;File to move not found&quot;) })
  public Response restMoveTo(@PathParam(&quot;fromCollection&quot;) String fromCollection,
          @PathParam(&quot;fromFileName&quot;) String fromFileName, @PathParam(&quot;toMediaPackage&quot;) String toMediaPackage,
          @PathParam(&quot;toMediaPackageElement&quot;) String toMediaPackageElement, @PathParam(&quot;toFileName&quot;) String toFileName)
          throws NotFoundException {
    try {
<span class="nc" id="L467">      URI uri = super.moveTo(fromCollection, fromFileName, toMediaPackage, toMediaPackageElement, toFileName);</span>
<span class="nc" id="L468">      return Response.ok().entity(uri.toString()).build();</span>
<span class="nc" id="L469">    } catch (IOException e) {</span>
<span class="nc" id="L470">      logger.error(&quot;Unable to move file '{}' from collection '{}' to mediapackage {}/{}&quot;,</span>
              fromFileName, fromCollection, toMediaPackage, toMediaPackageElement, e);
<span class="nc" id="L472">      return Response.serverError().entity(e.getMessage()).build();</span>
    }
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;storage&quot;)
  @RestQuery(name = &quot;storage&quot;, description = &quot;Returns a report on the disk usage and availability&quot;, returnDescription = &quot;Plain text containing the report&quot;, responses = { @RestResponse(responseCode = SC_OK, description = &quot;Report returned&quot;) })
  public Response restGetTotalStorage() {
<span class="nc" id="L482">    long total = this.getTotalSpace().get();</span>
<span class="nc" id="L483">    long usable = this.getUsableSpace().get();</span>
<span class="nc" id="L484">    long used = this.getUsedSpace().get();</span>
<span class="nc" id="L485">    String summary = this.getDiskSpace();</span>
<span class="nc" id="L486">    JSONObject json = new JSONObject();</span>
<span class="nc" id="L487">    json.put(&quot;size&quot;, total);</span>
<span class="nc" id="L488">    json.put(&quot;usable&quot;, usable);</span>
<span class="nc" id="L489">    json.put(&quot;used&quot;, used);</span>
<span class="nc" id="L490">    json.put(&quot;summary&quot;, summary);</span>
<span class="nc" id="L491">    return Response.ok(json.toJSONString()).build();</span>
  }

  @GET
  @Produces(MediaType.TEXT_PLAIN)
  @Path(&quot;/baseUri&quot;)
  @RestQuery(name = &quot;baseuri&quot;, description = &quot;Returns a base URI for this repository&quot;, returnDescription = &quot;Plain text containing the base URI&quot;, responses = { @RestResponse(responseCode = SC_OK, description = &quot;Base URI returned&quot;) })
  public Response restGetBaseUri() {
<span class="nc" id="L499">    return Response.ok(super.getBaseUri().toString()).build();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>