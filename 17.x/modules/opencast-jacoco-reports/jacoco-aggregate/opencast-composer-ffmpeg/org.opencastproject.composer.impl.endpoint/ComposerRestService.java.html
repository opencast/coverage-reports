<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ComposerRestService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-composer-ffmpeg</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.composer.impl.endpoint</a> &gt; <span class="el_source">ComposerRestService.java</span></div><h1>ComposerRestService.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.composer.impl.endpoint;

import static org.opencastproject.util.doc.rest.RestParameter.Type.TEXT;

import org.opencastproject.composer.api.ComposerService;
import org.opencastproject.composer.api.EncoderException;
import org.opencastproject.composer.api.EncodingProfile;
import org.opencastproject.composer.api.EncodingProfileImpl;
import org.opencastproject.composer.api.EncodingProfileList;
import org.opencastproject.composer.api.LaidOutElement;
import org.opencastproject.composer.layout.Dimension;
import org.opencastproject.composer.layout.Layout;
import org.opencastproject.composer.layout.Serializer;
import org.opencastproject.job.api.JaxbJob;
import org.opencastproject.job.api.Job;
import org.opencastproject.job.api.JobProducer;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.rest.AbstractJobProducerEndpoint;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.smil.api.SmilService;
import org.opencastproject.smil.entity.api.Smil;
import org.opencastproject.util.JsonObj;
import org.opencastproject.util.LocalHashMap;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestParameter.Type;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

/**
 * A REST endpoint delegating functionality to the {@link ComposerService}
 */
@Path(&quot;/composer/ffmpeg&quot;)
@RestService(name = &quot;composer&quot;, title = &quot;Composer&quot;, abstractText = &quot;This service creates and augments Opencast media packages that include media tracks, metadata &quot;
        + &quot;catalogs and attachments.&quot;, notes = {
        &quot;All paths above are relative to the REST endpoint base (something like http://your.server/files)&quot;,
        &quot;If the service is down or not working it will return a status 503, this means the the underlying service is &quot;
                + &quot;not working and is either restarting or has failed&quot;,
        &quot;A status code 500 means a general failure has occurred which is not recoverable and was not anticipated. In &quot;
                + &quot;other words, there is a bug! You should file an error report with your server logs from the time when the &quot;
                + &quot;error occurred: &lt;a href=\&quot;https://github.com/opencast/opencast/issues\&quot;&gt;Opencast Issue Tracker&lt;/a&gt;&quot; })
@Component(
  property = {
    &quot;service.description=Composer REST Endpoint&quot;,
    &quot;opencast.service.type=org.opencastproject.composer&quot;,
    &quot;opencast.service.path=/composer/ffmpeg&quot;,
    &quot;opencast.service.jobproducer=true&quot;
  },
  immediate = true,
  service = ComposerRestService.class
)
@JaxrsResource
<span class="fc" id="L105">public class ComposerRestService extends AbstractJobProducerEndpoint {</span>

  /** The logger */
<span class="fc" id="L108">  private static final Logger logger = LoggerFactory.getLogger(ComposerRestService.class);</span>

  private static final String VIDEO_TRACK_DEFAULT = &quot;&lt;track id=\&quot;track-1\&quot; type=\&quot;presentation/source\&quot;&gt;\n&quot;
          + &quot;  &lt;mimetype&gt;video/quicktime&lt;/mimetype&gt;\n&quot;
          + &quot;  &lt;url&gt;http://localhost:8080/workflow/samples/camera.mpg&lt;/url&gt;\n&quot;
          + &quot;  &lt;checksum type=\&quot;md5\&quot;&gt;43b7d843b02c4a429b2f547a4f230d31&lt;/checksum&gt;\n&quot;
          + &quot;  &lt;duration&gt;14546&lt;/duration&gt;\n&quot; + &quot;  &lt;video&gt;\n&quot;
          + &quot;    &lt;device type=\&quot;UFG03\&quot; version=\&quot;30112007\&quot; vendor=\&quot;Unigraf\&quot; /&gt;\n&quot;
          + &quot;    &lt;encoder type=\&quot;H.264\&quot; version=\&quot;7.4\&quot; vendor=\&quot;Apple Inc\&quot; /&gt;\n&quot;
          + &quot;    &lt;resolution&gt;640x480&lt;/resolution&gt;\n&quot;
          + &quot;    &lt;scanType type=\&quot;progressive\&quot; /&gt;\n&quot;
          + &quot;    &lt;bitrate&gt;540520&lt;/bitrate&gt;\n&quot;
          + &quot;    &lt;frameRate&gt;2&lt;/frameRate&gt;\n&quot;
          + &quot;  &lt;/video&gt;\n&quot;
          + &quot;&lt;/track&gt;&quot;;

  private static final String AUDIO_TRACK_DEFAULT = &quot;&lt;track id=\&quot;track-2\&quot; type=\&quot;presentation/source\&quot;&gt;\n&quot;
          + &quot;  &lt;mimetype&gt;audio/mp3&lt;/mimetype&gt;\n&quot;
          + &quot;  &lt;url&gt;serverUrl/workflow/samples/audio.mp3&lt;/url&gt;\n&quot;
          + &quot;  &lt;checksum type=\&quot;md5\&quot;&gt;950f9fa49caa8f1c5bbc36892f6fd062&lt;/checksum&gt;\n&quot;
          + &quot;  &lt;duration&gt;10472&lt;/duration&gt;\n&quot;
          + &quot;  &lt;audio&gt;\n&quot;
          + &quot;    &lt;channels&gt;2&lt;/channels&gt;\n&quot;
          + &quot;    &lt;bitdepth&gt;0&lt;/bitdepth&gt;\n&quot;
          + &quot;    &lt;bitrate&gt;128004.0&lt;/bitrate&gt;\n&quot;
          + &quot;    &lt;samplingrate&gt;44100&lt;/samplingrate&gt;\n&quot;
          + &quot;  &lt;/audio&gt;\n&quot;
          + &quot;&lt;/track&gt;&quot;;

  private static final String IMAGE_ATTACHMENT_DEFAULT = &quot;&lt;attachment id=\&quot;track-3\&quot;&gt;\n&quot;
          + &quot;  &lt;mimetype&gt;image/jpeg&lt;/mimetype&gt;\n&quot;
          + &quot;  &lt;url&gt;serverUrl/workflow/samples/image.jpg&lt;/url&gt;\n&quot;
          + &quot;&lt;/attachment&gt;&quot;;

  /** The base server URL */
  protected String serverUrl;

  /** The composer service */
<span class="fc" id="L146">  protected ComposerService composerService = null;</span>

  /** The service registry */
<span class="fc" id="L149">  protected ServiceRegistry serviceRegistry = null;</span>

  /** The smil service */
<span class="fc" id="L152">  protected SmilService smilService = null;</span>

  @Reference
  public void setSmilService(SmilService smilService) {
<span class="nc" id="L156">    this.smilService = smilService;</span>
<span class="nc" id="L157">  }</span>

  /**
   * Callback from the OSGi declarative services to set the service registry.
   *
   * @param serviceRegistry
   *          the service registry
   */
  @Reference
  protected void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="nc" id="L167">    this.serviceRegistry = serviceRegistry;</span>
<span class="nc" id="L168">  }</span>

  /**
   * Sets the composer service.
   *
   * @param composerService
   *          the composer service
   */
  @Reference
  public void setComposerService(ComposerService composerService) {
<span class="fc" id="L178">    this.composerService = composerService;</span>
<span class="fc" id="L179">  }</span>

  /**
   * Callback from OSGi that is called when this service is activated.
   *
   * @param cc
   *          OSGi component context
   */
  public void activate(ComponentContext cc) {
<span class="pc bpc" id="L188" title="3 of 4 branches missed.">    if (cc == null || cc.getBundleContext().getProperty(&quot;org.opencastproject.server.url&quot;) == null) {</span>
<span class="fc" id="L189">      serverUrl = UrlSupport.DEFAULT_BASE_URL;</span>
    } else {
<span class="nc" id="L191">      serverUrl = cc.getBundleContext().getProperty(&quot;org.opencastproject.server.url&quot;);</span>
    }
<span class="fc" id="L193">  }</span>

  /**
   * Encodes a track.
   *
   * @param sourceTrackAsXml
   *          The source track
   * @param profileId
   *          The profile to use in encoding this track
   * @return A response containing the job for this encoding job in the response body.
   * @throws Exception
   */
  @POST
  @Path(&quot;encode&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;encode&quot;, description = &quot;Starts an encoding process, based on the specified encoding profile ID and the track&quot;, restParameters = {
          @RestParameter(description = &quot;The track containing the stream&quot;, isRequired = true, name = &quot;sourceTrack&quot;, type = Type.TEXT, defaultValue = VIDEO_TRACK_DEFAULT),
          @RestParameter(description = &quot;The encoding profile to use&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING, defaultValue = &quot;mp4-medium.http&quot;)
    }, responses = {
          @RestResponse(description = &quot;Results in an xml document containing the job for the encoding task&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;If required parameters aren't set or if sourceTrack isn't from the type Track&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;&quot;)
  public Response encode(@FormParam(&quot;sourceTrack&quot;) String sourceTrackAsXml, @FormParam(&quot;profileId&quot;) String profileId)
          throws Exception {
    // Ensure that the POST parameters are present
<span class="fc bfc" id="L217" title="All 4 branches covered.">    if (StringUtils.isBlank(sourceTrackAsXml) || StringUtils.isBlank(profileId))</span>
<span class="fc" id="L218">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack and profileId must not be null&quot;).build();</span>

    // Deserialize the track
<span class="fc" id="L221">    MediaPackageElement sourceTrack = MediaPackageElementParser.getFromXml(sourceTrackAsXml);</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">    if (!Track.TYPE.equals(sourceTrack.getElementType()))</span>
<span class="nc" id="L223">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack element must be of type track&quot;).build();</span>

    try {
      // Asynchronously encode the specified tracks
<span class="fc" id="L227">      Job job = composerService.encode((Track) sourceTrack, profileId);</span>
<span class="fc" id="L228">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L229">    } catch (EncoderException e) {</span>
<span class="nc" id="L230">      logger.warn(&quot;Unable to encode the track: &quot; + e.getMessage());</span>
<span class="nc" id="L231">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * Encodes a track to multiple tracks in parallel.
   *
   * @param sourceTrackAsXml
   *          The source track
   * @param profileId
   *          The profile to use in encoding this track
   * @return A response containing the job for this encoding job in the response body.
   * @throws Exception
   */
  @POST
  @Path(&quot;parallelencode&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;parallelencode&quot;, description = &quot;Starts an encoding process, based on the specified encoding profile ID and the track&quot;,
    restParameters = {
      @RestParameter(description = &quot;The track containing the stream&quot;, isRequired = true, name = &quot;sourceTrack&quot;, type = Type.TEXT, defaultValue = VIDEO_TRACK_DEFAULT),
      @RestParameter(description = &quot;The encoding profile to use&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING, defaultValue = &quot;mp4-medium.http&quot;)
    }, responses = {
      @RestResponse(description = &quot;Results in an xml document containing the job for the encoding task&quot;, responseCode = HttpServletResponse.SC_OK)
    }, returnDescription = &quot;&quot;)
  public Response parallelencode(@FormParam(&quot;sourceTrack&quot;) String sourceTrackAsXml, @FormParam(&quot;profileId&quot;) String profileId)
          throws Exception {
    // Ensure that the POST parameters are present
<span class="nc bnc" id="L258" title="All 4 branches missed.">    if (sourceTrackAsXml == null || profileId == null) {</span>
<span class="nc" id="L259">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack and profileId must not be null&quot;).build();</span>
    }

    // Deserialize the track
<span class="nc" id="L263">    MediaPackageElement sourceTrack = MediaPackageElementParser.getFromXml(sourceTrackAsXml);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">    if (!Track.TYPE.equals(sourceTrack.getElementType())) {</span>
<span class="nc" id="L265">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack element must be of type track&quot;).build();</span>
    }

    // Asynchronously encode the specified tracks
<span class="nc" id="L269">    Job job = composerService.parallelEncode((Track) sourceTrack, profileId);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">    if (job == null)</span>
<span class="nc" id="L271">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(&quot;Encoding failed&quot;).build();</span>
<span class="nc" id="L272">    return Response.ok().entity(new JaxbJob(job)).build();</span>
  }

  /**
   * Trims a track to a new length.
   *
   * @param sourceTrackAsXml
   *          The source track
   * @param profileId
   *          the encoding profile to use for trimming
   * @param start
   *          the new trimming start time
   * @param duration
   *          the new video duration
   * @return A response containing the job for this encoding job in the response body.
   * @throws Exception
   */
  @POST
  @Path(&quot;trim&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;trim&quot;, description = &quot;Starts a trimming process, based on the specified track, start time and duration in ms&quot;, restParameters = {
          @RestParameter(description = &quot;The track containing the stream&quot;, isRequired = true, name = &quot;sourceTrack&quot;, type = Type.TEXT, defaultValue = VIDEO_TRACK_DEFAULT),
          @RestParameter(description = &quot;The encoding profile to use for trimming&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING, defaultValue = &quot;trim.work&quot;),
          @RestParameter(description = &quot;The start time in milisecond&quot;, isRequired = true, name = &quot;start&quot;, type = Type.STRING, defaultValue = &quot;0&quot;),
          @RestParameter(description = &quot;The duration in milisecond&quot;, isRequired = true, name = &quot;duration&quot;, type = Type.STRING, defaultValue = &quot;10000&quot;) }, responses = {
          @RestResponse(description = &quot;Results in an xml document containing the job for the trimming task&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;If the start time is negative or exceeds the track duration&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          @RestResponse(description = &quot;If the duration is negative or, including the new start time, exceeds the track duration&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;&quot;)
  public Response trim(@FormParam(&quot;sourceTrack&quot;) String sourceTrackAsXml, @FormParam(&quot;profileId&quot;) String profileId,
          @FormParam(&quot;start&quot;) long start, @FormParam(&quot;duration&quot;) long duration) throws Exception {
    // Ensure that the POST parameters are present
<span class="nc bnc" id="L303" title="All 4 branches missed.">    if (StringUtils.isBlank(sourceTrackAsXml) || StringUtils.isBlank(profileId))</span>
<span class="nc" id="L304">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack and profileId must not be null&quot;).build();</span>

    // Deserialize the track
<span class="nc" id="L307">    MediaPackageElement sourceElement = MediaPackageElementParser.getFromXml(sourceTrackAsXml);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">    if (!Track.TYPE.equals(sourceElement.getElementType()))</span>
<span class="nc" id="L309">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack element must be of type track&quot;).build();</span>

    // Make sure the trim times make sense
<span class="nc" id="L312">    Track sourceTrack = (Track) sourceElement;</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">    if (sourceTrack.getDuration() == null)</span>
<span class="nc" id="L315">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack element does not have a duration&quot;)</span>
<span class="nc" id="L316">              .build();</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">    if (start &lt; 0) {</span>
<span class="nc" id="L319">      start = 0;</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">    } else if (duration &lt;= 0) {</span>
<span class="nc" id="L321">      duration = (sourceTrack.getDuration() - start);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">    } else if (start + duration &gt; sourceTrack.getDuration()) {</span>
<span class="nc" id="L323">      duration = (sourceTrack.getDuration() - start);</span>
    }

    try {
      // Asynchronously encode the specified tracks
<span class="nc" id="L328">      Job job = composerService.trim(sourceTrack, profileId, start, duration);</span>
<span class="nc" id="L329">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L330">    } catch (EncoderException e) {</span>
<span class="nc" id="L331">      logger.warn(&quot;Unable to trim the track: &quot; + e.getMessage());</span>
<span class="nc" id="L332">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * Encodes a track.
   *
   * @param audioSourceTrackXml
   *          The audio source track
   * @param videoSourceTrackXml
   *          The video source track
   * @param profileId
   *          The profile to use in encoding this track
   * @return A response containing the job for this encoding job in the response body.
   * @throws Exception
   */
  @POST
  @Path(&quot;mux&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;mux&quot;, description = &quot;Starts an encoding process, which will mux the two tracks using the given encoding profile&quot;, restParameters = {
          @RestParameter(description = &quot;The track containing the audio stream&quot;, isRequired = true, name = &quot;sourceAudioTrack&quot;, type = Type.TEXT, defaultValue = AUDIO_TRACK_DEFAULT),
          @RestParameter(description = &quot;The track containing the video stream&quot;, isRequired = true, name = &quot;sourceVideoTrack&quot;, type = Type.TEXT, defaultValue = VIDEO_TRACK_DEFAULT),
          @RestParameter(description = &quot;The encoding profile to use&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING, defaultValue = &quot;mp4-medium.http&quot;) }, responses = {
          @RestResponse(description = &quot;Results in an xml document containing the job for the encoding task&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;If required parameters aren't set or if the source tracks aren't from the type Track&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;&quot;)
  public Response mux(@FormParam(&quot;audioSourceTrack&quot;) String audioSourceTrackXml,
          @FormParam(&quot;videoSourceTrack&quot;) String videoSourceTrackXml, @FormParam(&quot;profileId&quot;) String profileId)
          throws Exception {
    // Ensure that the POST parameters are present
<span class="fc bfc" id="L361" title="All 4 branches covered.">    if (StringUtils.isBlank(audioSourceTrackXml) || StringUtils.isBlank(videoSourceTrackXml)</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            || StringUtils.isBlank(profileId)) {</span>
<span class="fc" id="L363">      return Response.status(Response.Status.BAD_REQUEST)</span>
<span class="fc" id="L364">              .entity(&quot;audioSourceTrack, videoSourceTrack, and profileId must not be null&quot;).build();</span>
    }

    // Deserialize the audio track
<span class="fc" id="L368">    MediaPackageElement audioSourceTrack = MediaPackageElementParser.getFromXml(audioSourceTrackXml);</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">    if (!Track.TYPE.equals(audioSourceTrack.getElementType()))</span>
<span class="nc" id="L370">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;audioSourceTrack must be of type track&quot;).build();</span>

    // Deserialize the video track
<span class="fc" id="L373">    MediaPackageElement videoSourceTrack = MediaPackageElementParser.getFromXml(videoSourceTrackXml);</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">    if (!Track.TYPE.equals(videoSourceTrack.getElementType()))</span>
<span class="nc" id="L375">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;videoSourceTrack must be of type track&quot;).build();</span>

    try {
      // Asynchronously encode the specified tracks
<span class="fc" id="L379">      Job job = composerService.mux((Track) videoSourceTrack, (Track) audioSourceTrack, profileId);</span>
<span class="fc" id="L380">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L381">    } catch (EncoderException e) {</span>
<span class="nc" id="L382">      logger.warn(&quot;Unable to mux tracks: &quot; + e.getMessage());</span>
<span class="nc" id="L383">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * Encodes a track in a media package.
   *
   * @param sourceTrackXml
   *          The source track
   * @param profileId
   *          The profile to use in encoding this track
   * @param times
   *          one or more times in seconds separated by comma
   * @return A {@link Response} with the resulting track in the response body
   * @throws Exception
   */
  @POST
  @Path(&quot;image&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;image&quot;, description = &quot;Starts an image extraction process, based on the specified encoding profile ID and the source track&quot;, restParameters = {
          @RestParameter(description = &quot;The track containing the video stream&quot;, isRequired = true, name = &quot;sourceTrack&quot;, type = Type.TEXT, defaultValue = VIDEO_TRACK_DEFAULT),
          @RestParameter(description = &quot;The encoding profile to use&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING, defaultValue = &quot;player-preview.http&quot;),
          @RestParameter(description = &quot;The number of seconds (many numbers can be specified, separated by semicolon) into the video to extract the image&quot;, isRequired = false, name = &quot;time&quot;, type = Type.STRING),
          @RestParameter(description = &quot;An optional set of key=value\\n properties&quot;, isRequired = false, name = &quot;properties&quot;, type = TEXT) }, responses = {
          @RestResponse(description = &quot;Results in an xml document containing the image attachment&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;If required parameters aren't set or if sourceTrack isn't from the type Track&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;The image extraction job&quot;)
  public Response image(@FormParam(&quot;sourceTrack&quot;) String sourceTrackXml, @FormParam(&quot;profileId&quot;) String profileId,
          @FormParam(&quot;time&quot;) String times, @FormParam(&quot;properties&quot;) LocalHashMap localMap) throws Exception {
    // Ensure that the POST parameters are present
<span class="nc bnc" id="L412" title="All 4 branches missed.">    if (StringUtils.isBlank(sourceTrackXml) || StringUtils.isBlank(profileId))</span>
<span class="nc" id="L413">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack and profileId must not be null&quot;).build();</span>

    // Deserialize the source track
<span class="nc" id="L416">    MediaPackageElement sourceTrack = MediaPackageElementParser.getFromXml(sourceTrackXml);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">    if (!Track.TYPE.equals(sourceTrack.getElementType()))</span>
<span class="nc" id="L418">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack element must be of type track&quot;).build();</span>

<span class="nc" id="L420">    boolean timeBased = false;</span>
<span class="nc" id="L421">    double[] timeArray = null;</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">    if (StringUtils.isNotBlank(times)) {</span>
      // parse time codes
      try {
<span class="nc" id="L425">        timeArray = parseTimeArray(times);</span>
<span class="nc" id="L426">      } catch (Exception e) {</span>
<span class="nc" id="L427">        return Response.status(Response.Status.BAD_REQUEST).entity(&quot;could not parse times: invalid format&quot;).build();</span>
<span class="nc" id="L428">      }</span>
<span class="nc" id="L429">      timeBased = true;</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">    } else if (localMap == null) {</span>
<span class="nc" id="L431">      return Response.status(Response.Status.BAD_REQUEST).build();</span>
    }

    try {
      // Asynchronously encode the specified tracks
      Job job;
<span class="nc bnc" id="L437" title="All 2 branches missed.">      if (timeBased) {</span>
<span class="nc" id="L438">        job = composerService.image((Track) sourceTrack, profileId, timeArray);</span>
      } else {
<span class="nc" id="L440">        job = composerService.image((Track) sourceTrack, profileId, localMap.getMap());</span>
      }
<span class="nc" id="L442">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L443">    } catch (EncoderException e) {</span>
<span class="nc" id="L444">      logger.warn(&quot;Unable to extract image(s): &quot; + e.getMessage());</span>
<span class="nc" id="L445">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * Encodes a track in a media package.
   *
   * @param sourceTrackXml
   *          The source track
   * @param profileId
   *          The profile to use in encoding this track
   * @param times
   *          one or more times in seconds separated by comma
   * @return A {@link Response} with the resulting track in the response body
   * @throws Exception
   */
  @POST
  @Path(&quot;imagesync&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;imagesync&quot;, description = &quot;Synchronously extracts an image, based on the specified encoding profile ID and the source track&quot;, restParameters = {
      @RestParameter(description = &quot;The track containing the video stream&quot;, isRequired = true, name = &quot;sourceTrack&quot;, type = Type.TEXT, defaultValue = VIDEO_TRACK_DEFAULT),
      @RestParameter(description = &quot;The encoding profile to use&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING, defaultValue = &quot;player-preview.http&quot;),
      @RestParameter(description = &quot;The number of seconds (many numbers can be specified, separated by semicolon) into the video to extract the image&quot;, isRequired = false, name = &quot;time&quot;, type = Type.STRING)}, responses = {
      @RestResponse(description = &quot;Results in an xml document containing the image attachment&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;If required parameters aren't set or if sourceTrack isn't from the type Track&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;The extracted image&quot;)
  public Response imageSync(@FormParam(&quot;sourceTrack&quot;) String sourceTrackXml, @FormParam(&quot;profileId&quot;) String profileId,
                        @FormParam(&quot;time&quot;) String times) throws Exception {
    // Ensure that the POST parameters are present
<span class="nc bnc" id="L473" title="All 6 branches missed.">    if (StringUtils.isBlank(sourceTrackXml) || StringUtils.isBlank(profileId) || StringUtils.isBlank(times)) {</span>
<span class="nc" id="L474">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack, times, and profileId must not be null&quot;).build();</span>
    }

    // Deserialize the source track
<span class="nc" id="L478">    MediaPackageElement sourceTrack = MediaPackageElementParser.getFromXml(sourceTrackXml);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">    if (!Track.TYPE.equals(sourceTrack.getElementType())) {</span>
<span class="nc" id="L480">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack element must be of type track&quot;).build();</span>
    }

<span class="nc" id="L483">    double[] timeArray = null;</span>
    // parse time codes
    try {
<span class="nc" id="L486">      timeArray = parseTimeArray(times);</span>
<span class="nc" id="L487">    } catch (Exception e) {</span>
<span class="nc" id="L488">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;could not parse times: invalid format&quot;).build();</span>
<span class="nc" id="L489">    }</span>

    try {
<span class="nc" id="L492">      List&lt;Attachment&gt; result = composerService.imageSync((Track) sourceTrack, profileId, timeArray);</span>
<span class="nc" id="L493">      return Response.ok().entity(MediaPackageElementParser.getArrayAsXml(result)).build();</span>
<span class="nc" id="L494">    } catch (EncoderException e) {</span>
<span class="nc" id="L495">      logger.warn(&quot;Unable to extract image(s): &quot; + e.getMessage());</span>
<span class="nc" id="L496">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * Compose two videos into one with an optional watermark.
   *
   * @param compositeSizeJson
   *          The composite track dimension as JSON
   * @param lowerTrackXml
   *          The lower track of the composition as XML
   * @param lowerLayoutJson
   *          The lower layout as JSON
   * @param upperTrackXml
   *          The upper track of the composition as XML
   * @param upperLayoutJson
   *          The upper layout as JSON
   * @param watermarkAttachmentXml
   *          The watermark image attachment of the composition as XML
   * @param watermarkLayoutJson
   *          The watermark layout as JSON
   * @param profileId
   *          The encoding profile to use
   * @param background
   *          The background color
   * @return A {@link Response} with the resulting track in the response body
   * @throws Exception
   */
  @POST
  @Path(&quot;composite&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;composite&quot;, description = &quot;Starts a video compositing process, based on the specified resolution, encoding profile ID, the source elements and their layouts&quot;, restParameters = {
          @RestParameter(description = &quot;The resolution size of the resulting video as JSON&quot;, isRequired = true, name = &quot;compositeSize&quot;, type = Type.STRING),
          @RestParameter(description = &quot;The lower source track containing the lower video&quot;, isRequired = true, name = &quot;lowerTrack&quot;, type = Type.TEXT),
          @RestParameter(description = &quot;The lower layout containing the JSON definition of the layout&quot;, isRequired = true, name = &quot;lowerLayout&quot;, type = Type.TEXT),
          @RestParameter(description = &quot;The upper source track containing the upper video&quot;, isRequired = false, name = &quot;upperTrack&quot;, type = Type.TEXT),
          @RestParameter(description = &quot;The upper layout containing the JSON definition of the layout&quot;, isRequired = false, name = &quot;upperLayout&quot;, type = Type.TEXT),
          @RestParameter(description = &quot;The watermark source attachment containing watermark image&quot;, isRequired = false, name = &quot;watermarkTrack&quot;, type = Type.TEXT),
          @RestParameter(description = &quot;The watermark layout containing the JSON definition of the layout&quot;, isRequired = false, name = &quot;watermarkLayout&quot;, type = Type.TEXT),
          @RestParameter(description = &quot;The background color&quot;, isRequired = false, name = &quot;background&quot;, type = Type.TEXT, defaultValue = &quot;black&quot;),
          @RestParameter(description = &quot;The name of the audio source (lower or upper or both)&quot;, isRequired = false, name = &quot;audioSourceName&quot;, type = Type.TEXT, defaultValue = ComposerService.BOTH),
          @RestParameter(description = &quot;The encoding profile to use&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING) }, responses = {
          @RestResponse(description = &quot;Results in an xml document containing the compound video track&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;If required parameters aren't set or if the source elements aren't from the right type&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;&quot;)
  public Response composite(@FormParam(&quot;compositeSize&quot;) String compositeSizeJson,
          @FormParam(&quot;lowerTrack&quot;) String lowerTrackXml, @FormParam(&quot;lowerLayout&quot;) String lowerLayoutJson,
          @FormParam(&quot;upperTrack&quot;) String upperTrackXml, @FormParam(&quot;upperLayout&quot;) String upperLayoutJson,
          @FormParam(&quot;watermarkAttachment&quot;) String watermarkAttachmentXml,
          @FormParam(&quot;watermarkLayout&quot;) String watermarkLayoutJson, @FormParam(&quot;profileId&quot;) String profileId,
          @FormParam(&quot;background&quot;) @DefaultValue(&quot;black&quot;) String background,
          @FormParam(&quot;sourceAudioName&quot;) @DefaultValue(ComposerService.BOTH) String sourceAudioName) throws Exception {
    // Ensure that the POST parameters are present
<span class="nc bnc" id="L548" title="All 4 branches missed.">    if (StringUtils.isBlank(compositeSizeJson) || StringUtils.isBlank(lowerTrackXml)</span>
<span class="nc bnc" id="L549" title="All 4 branches missed.">            || StringUtils.isBlank(lowerLayoutJson) || StringUtils.isBlank(profileId))</span>
<span class="nc" id="L550">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;One of the required parameters must not be null&quot;)</span>
<span class="nc" id="L551">              .build();</span>

    // Deserialize the source elements
<span class="nc" id="L554">    MediaPackageElement lowerTrack = MediaPackageElementParser.getFromXml(lowerTrackXml);</span>
<span class="nc" id="L555">    Layout lowerLayout = Serializer.layout(JsonObj.jsonObj(lowerLayoutJson));</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">    if (!Track.TYPE.equals(lowerTrack.getElementType()))</span>
<span class="nc" id="L557">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;lowerTrack element must be of type track&quot;).build();</span>
<span class="nc" id="L558">    LaidOutElement&lt;Track&gt; lowerLaidOutElement = new LaidOutElement&lt;Track&gt;((Track) lowerTrack, lowerLayout);</span>

<span class="nc" id="L560">    Option&lt;LaidOutElement&lt;Track&gt;&gt; upperLaidOutElement = Option.&lt;LaidOutElement&lt;Track&gt;&gt; none();</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">    if (StringUtils.isNotBlank(upperTrackXml)) {</span>
<span class="nc" id="L562">      MediaPackageElement upperTrack = MediaPackageElementParser.getFromXml(upperTrackXml);</span>
<span class="nc" id="L563">      Layout upperLayout = Serializer.layout(JsonObj.jsonObj(upperLayoutJson));</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">      if (!Track.TYPE.equals(upperTrack.getElementType())) {</span>
<span class="nc" id="L565">        return Response.status(Response.Status.BAD_REQUEST).entity(&quot;upperTrack element must be of type track&quot;).build();</span>
      }
<span class="nc" id="L567">      upperLaidOutElement = Option.option(new LaidOutElement&lt;Track&gt;((Track) upperTrack, upperLayout));</span>
    }
<span class="nc" id="L569">    Option&lt;LaidOutElement&lt;Attachment&gt;&gt; watermarkLaidOutElement = Option.&lt;LaidOutElement&lt;Attachment&gt;&gt; none();</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">    if (StringUtils.isNotBlank(watermarkAttachmentXml)) {</span>
<span class="nc" id="L571">      Layout watermarkLayout = Serializer.layout(JsonObj.jsonObj(watermarkLayoutJson));</span>
<span class="nc" id="L572">      MediaPackageElement watermarkAttachment = MediaPackageElementParser.getFromXml(watermarkAttachmentXml);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">      if (!Attachment.TYPE.equals(watermarkAttachment.getElementType()))</span>
<span class="nc" id="L574">        return Response.status(Response.Status.BAD_REQUEST).entity(&quot;watermarkTrack element must be of type track&quot;)</span>
<span class="nc" id="L575">                .build();</span>
<span class="nc" id="L576">      watermarkLaidOutElement = Option.some(new LaidOutElement&lt;Attachment&gt;((Attachment) watermarkAttachment,</span>
              watermarkLayout));
    }

<span class="nc" id="L580">    Dimension compositeTrackSize = Serializer.dimension(JsonObj.jsonObj(compositeSizeJson));</span>

    try {
      // Asynchronously composite the specified source elements
<span class="nc" id="L584">      Job job = composerService.composite(compositeTrackSize, upperLaidOutElement, lowerLaidOutElement,</span>
              watermarkLaidOutElement, profileId, background, sourceAudioName);
<span class="nc" id="L586">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L587">    } catch (EncoderException e) {</span>
<span class="nc" id="L588">      logger.warn(&quot;Unable to composite video: &quot; + e.getMessage());</span>
<span class="nc" id="L589">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * Concat multiple tracks having the same codec to a single track.
   *
   * @param sourceTracksXml
   *          an array of track to concat in order of the array as XML
   * @param profileId
   *          The encoding profile to use
   * @param outputDimension
   *          The output dimension as JSON
   * @return A {@link Response} with the resulting track in the response body
   * @throws Exception
   */
  @POST
  @Path(&quot;concat&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;concat&quot;, description = &quot;Starts a video concating process from multiple videos, based on the specified encoding profile ID and the source tracks&quot;, restParameters = {
          @RestParameter(description = &quot;The source tracks to concat as XML&quot;, isRequired = true, name = &quot;sourceTracks&quot;, type = Type.TEXT),
          @RestParameter(description = &quot;The encoding profile to use&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING),
          @RestParameter(description = &quot;The resolution dimension of the concat video as JSON&quot;, isRequired = false, name = &quot;outputDimension&quot;, type = Type.STRING),
          @RestParameter(description = &quot;The  frame rate of the concat video (should be positive, e.g. 25.0). Negative values and zero will cause no FFmpeg fps filter to be used in the filter chain.&quot;,
      isRequired = false, name = &quot;outputFrameRate&quot;, type = Type.STRING),
          @RestParameter(description = &quot;The source files have the same codecs and should not be re-encoded&quot;, isRequired = false, name = &quot;sameCodec&quot;,type = Type.TEXT, defaultValue = &quot;false&quot;)}, responses = {
    @RestResponse(description = &quot;Results in an xml document containing the video track&quot;, responseCode = HttpServletResponse.SC_OK),
    @RestResponse(description = &quot;If required parameters aren't set or if sourceTracks aren't from the type Track or not at least two tracks are present&quot;,
            responseCode = HttpServletResponse.SC_BAD_REQUEST)}, returnDescription = &quot;&quot;)
  public Response concat(@FormParam(&quot;sourceTracks&quot;) String sourceTracksXml, @FormParam(&quot;profileId&quot;) String profileId,
          @FormParam(&quot;outputDimension&quot;) String outputDimension, @FormParam(&quot;outputFrameRate&quot;) String outputFrameRate,
          @FormParam(&quot;sameCodec&quot;) String sameCodec) throws Exception {
    // Ensure that the POST parameters are present
<span class="pc bpc" id="L622" title="2 of 4 branches missed.">    if (StringUtils.isBlank(sourceTracksXml) || StringUtils.isBlank(profileId))</span>
<span class="nc" id="L623">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTracks and profileId must not be null&quot;).build();</span>

    // Deserialize the source track
<span class="fc" id="L626">    List&lt;? extends MediaPackageElement&gt; tracks = MediaPackageElementParser.getArrayFromXml(sourceTracksXml);</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">    if (tracks.size() &lt; 2)</span>
<span class="nc" id="L628">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;At least two tracks must be set to concat&quot;).build();</span>

<span class="fc bfc" id="L630" title="All 2 branches covered.">    for (MediaPackageElement elem : tracks) {</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">      if (!Track.TYPE.equals(elem.getElementType()))</span>
<span class="nc" id="L632">        return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTracks must be of type track&quot;).build();</span>
<span class="fc" id="L633">    }</span>
<span class="fc" id="L634">    float fps = NumberUtils.toFloat(outputFrameRate, -1.0f);</span>
    try {
      // Asynchronously concat the specified tracks together
<span class="fc" id="L637">      Dimension dimension = null;</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(outputDimension)) {</span>
<span class="fc" id="L639">        dimension = Serializer.dimension(JsonObj.jsonObj(outputDimension));</span>
      }
<span class="fc" id="L641">      boolean hasSameCodec = Boolean.parseBoolean(sameCodec);</span>
<span class="fc" id="L642">      Job job = null;</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">      if (fps &gt; 0) {</span>
<span class="fc" id="L644">        job = composerService.concat(profileId, dimension, fps, hasSameCodec, tracks.toArray(new Track[tracks.size()]));</span>
      } else {
<span class="nc" id="L646">        job = composerService.concat(profileId, dimension, hasSameCodec, tracks.toArray(new Track[tracks.size()]));</span>
      }
<span class="fc" id="L648">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L649">    } catch (EncoderException e) {</span>
<span class="nc" id="L650">      logger.warn(&quot;Unable to concat videos: &quot; + e.getMessage());</span>
<span class="nc" id="L651">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * Transforms an image attachment to a video track
   *
   * @param sourceAttachmentXml
   *          The source image attachment
   * @param profileId
   *          The profile to use for encoding
   * @param timeString
   *          the length of the resulting video track in seconds
   * @return A {@link Response} with the resulting track in the response body
   * @throws Exception
   */
  @POST
  @Path(&quot;imagetovideo&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;imagetovideo&quot;, description = &quot;Starts an image converting process to a video, based on the specified encoding profile ID and the source image attachment&quot;, restParameters = {
          @RestParameter(description = &quot;The resulting video time in seconds&quot;, isRequired = false, name = &quot;time&quot;, type = Type.STRING, defaultValue = &quot;1&quot;),
          @RestParameter(description = &quot;The attachment containing the image to convert&quot;, isRequired = true, name = &quot;sourceAttachment&quot;, type = Type.TEXT),
          @RestParameter(description = &quot;The encoding profile to use&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING) }, responses = {
          @RestResponse(description = &quot;Results in an xml document containing the video track&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;If required parameters aren't set or if sourceAttachment isn't from the type Attachment&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;&quot;)
  public Response imageToVideo(@FormParam(&quot;sourceAttachment&quot;) String sourceAttachmentXml,
          @FormParam(&quot;profileId&quot;) String profileId, @FormParam(&quot;time&quot;) @DefaultValue(&quot;1&quot;) String timeString)
          throws Exception {
    // Ensure that the POST parameters are present
<span class="nc bnc" id="L680" title="All 4 branches missed.">    if (StringUtils.isBlank(sourceAttachmentXml) || StringUtils.isBlank(profileId))</span>
<span class="nc" id="L681">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceAttachment and profileId must not be null&quot;)</span>
<span class="nc" id="L682">              .build();</span>

    // parse time
    Double time;
    try {
<span class="nc" id="L687">      time = Double.parseDouble(timeString);</span>
<span class="nc" id="L688">    } catch (Exception e) {</span>
<span class="nc" id="L689">      logger.info(&quot;Unable to parse time {} as long value!&quot;, timeString);</span>
<span class="nc" id="L690">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;Could not parse time: invalid format&quot;).build();</span>
<span class="nc" id="L691">    }</span>

    // Deserialize the source track
<span class="nc" id="L694">    MediaPackageElement sourceAttachment = MediaPackageElementParser.getFromXml(sourceAttachmentXml);</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">    if (!Attachment.TYPE.equals(sourceAttachment.getElementType()))</span>
<span class="nc" id="L696">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceAttachment element must be of type attachment&quot;)</span>
<span class="nc" id="L697">              .build();</span>

    try {
      // Asynchronously convert the specified attachment to a video
<span class="nc" id="L701">      Job job = composerService.imageToVideo((Attachment) sourceAttachment, profileId, time);</span>
<span class="nc" id="L702">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L703">    } catch (EncoderException e) {</span>
<span class="nc" id="L704">      logger.warn(&quot;Unable to convert image to video: &quot; + e.getMessage());</span>
<span class="nc" id="L705">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * Converts an image to another format.
   *
   * @param sourceImageXml
   *          The source image
   * @param profileId
   *          The profile to use in image conversion
   * @return A {@link Response} with the resulting image in the response body
   * @throws Exception
   */
  @POST
  @Path(&quot;convertimage&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;convertimage&quot;, description = &quot;Starts an image conversion process, based on the specified encoding profile ID and the source image&quot;, restParameters = {
          @RestParameter(description = &quot;The original image&quot;, isRequired = true, name = &quot;sourceImage&quot;, type = Type.TEXT, defaultValue = IMAGE_ATTACHMENT_DEFAULT),
          @RestParameter(description = &quot;A comma separated list of encoding profiles to use&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING, defaultValue = &quot;image-conversion.http&quot;) }, responses = {
          @RestResponse(description = &quot;Results in an xml document containing the image attachment&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;If required parameters aren't set or if sourceImage isn't from the type Attachment&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;&quot;)
  public Response convertImage(@FormParam(&quot;sourceImage&quot;) String sourceImageXml, @FormParam(&quot;profileId&quot;) String profileId)
          throws Exception {
    // Ensure that the POST parameters are present
<span class="nc bnc" id="L730" title="All 4 branches missed.">    if (StringUtils.isBlank(sourceImageXml) || StringUtils.isBlank(profileId))</span>
<span class="nc" id="L731">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceImage and profileId must not be null&quot;).build();</span>

    // Deserialize the source track
<span class="nc" id="L734">    MediaPackageElement sourceImage = MediaPackageElementParser.getFromXml(sourceImageXml);</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">    if (!Attachment.TYPE.equals(sourceImage.getElementType()))</span>
<span class="nc" id="L736">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceImage element must be of type track&quot;).build();</span>

    try {
      // Asynchronously convert the specified image
<span class="nc" id="L740">      Job job = composerService.convertImage((Attachment) sourceImage, StringUtils.split(profileId, ','));</span>
<span class="nc" id="L741">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L742">    } catch (EncoderException e) {</span>
<span class="nc" id="L743">      logger.warn(&quot;Unable to convert image: &quot; + e.getMessage());</span>
<span class="nc" id="L744">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * Demuxes a track into multiple outputs
   *
   * @param sourceTrackAsXml
   *          The source track
   * @param profileId
   *          The profile to use in encoding this track
   * @return A response containing the job for this encoding job in the response body.
   * @throws Exception
   *           - if it fails
   */
  @POST
  @Path(&quot;demux&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;demux&quot;, description = &quot;Starts an demux process that produces multiple outputs, based on the specified encoding profile ID and the track&quot;, restParameters = {
          @RestParameter(description = &quot;The track containing the stream&quot;, isRequired = true, name = &quot;sourceTrack&quot;, type = Type.TEXT, defaultValue = VIDEO_TRACK_DEFAULT),
          @RestParameter(description = &quot;The encoding profile to use&quot;, isRequired = true, name = &quot;profileId&quot;, type = Type.STRING, defaultValue = &quot;demux.work&quot;) }, responses = {
                  @RestResponse(description = &quot;Results in an xml document containing the job for the encoding task&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;If required parameters aren't set or if sourceTrack isn't from the type Track&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;&quot;)
  public Response demux(@FormParam(&quot;sourceTrack&quot;) String sourceTrackAsXml, @FormParam(&quot;profileId&quot;) String profileId)
          throws Exception {
    // Ensure that the POST parameters are present
<span class="nc bnc" id="L770" title="All 4 branches missed.">    if (StringUtils.isBlank(sourceTrackAsXml) || StringUtils.isBlank(profileId))</span>
<span class="nc" id="L771">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack and profileId must not be null&quot;).build();</span>

    // Deserialize the track
<span class="nc" id="L774">    MediaPackageElement sourceTrack = MediaPackageElementParser.getFromXml(sourceTrackAsXml);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">    if (!Track.TYPE.equals(sourceTrack.getElementType()))</span>
<span class="nc" id="L776">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack element must be of type track&quot;).build();</span>

    try {
      // Asynchronously encode the specified tracks
<span class="nc" id="L780">      Job job = composerService.demux((Track) sourceTrack, profileId);</span>
<span class="nc" id="L781">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L782">    } catch (EncoderException e) {</span>
<span class="nc" id="L783">      logger.warn(&quot;Unable to encode the track: &quot; + e);</span>
<span class="nc" id="L784">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * ProcessSmil - encode a video based on descriptions in a smil file into all format in the profileIds
   *
   * @param smilAsXml
   *          - smil describing a list of videos and clips in them to make up one video
   * @param trackId
   *          - a paramGroup Id in the smil file describing a track
   * @param mediaType
   *          - audio only, video only or both
   * @param profileIds
   *          - list of encoding profile ids
   * @return a job running the process
   * @throws Exception
   *           if it fails
   */
  @POST
  @Path(&quot;processsmil&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;processsmil&quot;, description = &quot;Starts an encoding process, based on the tracks and edit points in the smil and specified encoding profile IDs&quot;, restParameters = {
          @RestParameter(description = &quot;The smil containing the tracks and edit points&quot;, isRequired = true, name = &quot;smilAsXml&quot;, type = Type.TEXT),
          @RestParameter(description = &quot;The id (paramgroup) of the track to encode&quot;, isRequired = false, name = &quot;trackId&quot;, type = Type.STRING, defaultValue = &quot;&quot;),
          @RestParameter(description = &quot;MediaType - v for video only, a for audio only, audiovisual otherwise&quot;, isRequired = false, name = &quot;mediaType&quot;, type = Type.STRING, defaultValue = &quot;o&quot;),
          @RestParameter(description = &quot;The encoding profiles to use&quot;, isRequired = true, name = &quot;profileIds&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(description = &quot;Results in an xml document containing the job for the encoding task&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;If required parameters aren't set or if sourceTrack isn't from the type Track&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;&quot;)
  public Response processSmil(@FormParam(&quot;smilAsXml&quot;) String smilAsXml, @FormParam(&quot;trackId&quot;) String trackId,
          @FormParam(&quot;mediaType&quot;) String mediaType, @FormParam(&quot;profileIds&quot;) String profileIds) throws Exception {
    // Ensure that the POST parameters are present
<span class="nc bnc" id="L816" title="All 4 branches missed.">    if (StringUtils.isBlank(smilAsXml) || StringUtils.isBlank(profileIds))</span>
<span class="nc" id="L817">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;smil and profileId must not be null&quot;).build();</span>

    // Deserialize the data
<span class="nc" id="L820">    String[] profiles = StringUtils.split(profileIds, &quot;,&quot;);</span>
    Smil smil;
    try {
<span class="nc" id="L823">      smil = smilService.fromXml(smilAsXml).getSmil();</span>
<span class="nc" id="L824">    } catch (Exception e) {</span>
<span class="nc" id="L825">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;smil must be readable&quot;).build();</span>
<span class="nc" id="L826">    }</span>

    try {
      // Encode the specified tracks
<span class="nc" id="L830">      Job job = composerService.processSmil(smil, trackId, mediaType, Arrays.asList(profiles));</span>
<span class="nc" id="L831">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L832">    } catch (EncoderException e) {</span>
<span class="nc" id="L833">      logger.warn(&quot;Unable to process the smil: &quot; + e);</span>
<span class="nc" id="L834">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @POST
  @Path(&quot;multiencode&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;multiencode&quot;, description = &quot;Starts an encoding process that produces multiple outputs, based on the specified encoding profile ID and the track&quot;,
    restParameters = {
      @RestParameter(description = &quot;The track containing the stream&quot;, isRequired = true, name = &quot;sourceTrack&quot;, type = Type.TEXT, defaultValue = VIDEO_TRACK_DEFAULT),
      @RestParameter(description = &quot;The comma-delimited encoding profiles to use&quot;, isRequired = true, name = &quot;profileIds&quot;, type = Type.STRING, defaultValue = &quot;mp4-medium.http,mp4-low.http&quot;)
    }, responses = {
      @RestResponse(description = &quot;Results in an xml document containing the job for the encoding task&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;If required parameters aren't set or if sourceTrack isn't from the type Track&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST)
    }, returnDescription = &quot;&quot;)
  public Response multiEncode(@FormParam(&quot;sourceTrack&quot;) String sourceTrackAsXml,
          @FormParam(&quot;profileIds&quot;) String profileIds) throws Exception {
    // Ensure that the POST parameters are present
<span class="pc bpc" id="L852" title="2 of 4 branches missed.">    if (StringUtils.isBlank(sourceTrackAsXml) || StringUtils.isBlank(profileIds))</span>
<span class="nc" id="L853">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack and profileIds must not be null&quot;).build();</span>

    // Deserialize the track
<span class="fc" id="L856">    MediaPackageElement sourceTrack = MediaPackageElementParser.getFromXml(sourceTrackAsXml);</span>
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">    if (!Track.TYPE.equals(sourceTrack.getElementType()))</span>
<span class="nc" id="L858">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceTrack element must be of type track&quot;).build();</span>

    try {
      // Encode the specified track with the profiles
<span class="fc" id="L862">      String[] profiles = StringUtils.split(profileIds, &quot;,&quot;);</span>
<span class="fc" id="L863">      Job job = composerService.multiEncode((Track) sourceTrack, Arrays.asList(profiles));</span>
<span class="fc" id="L864">      return Response.ok().entity(new JaxbJob(job)).build();</span>
<span class="nc" id="L865">    } catch (EncoderException e) {</span>
<span class="nc" id="L866">      logger.warn(&quot;Unable to encode the track: &quot;, e);</span>
<span class="nc" id="L867">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  /**
   * Synchronously converts an image to another format.
   *
   * @param sourceImageXml
   *          The source image
   * @param profileIds
   *          The encoding profiles to use in image conversion
   * @return A {@link Response} with the resulting image in the response body
   * @throws Exception
   */
  @POST
  @Path(&quot;convertimagesync&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;convertimagesync&quot;, description = &quot;Synchronously converts an image, based on the specified encoding profiles and the source image&quot;, restParameters = {
      @RestParameter(description = &quot;The original image&quot;, isRequired = true, name = &quot;sourceImage&quot;, type = Type.TEXT, defaultValue = IMAGE_ATTACHMENT_DEFAULT),
      @RestParameter(description = &quot;The encoding profiles to use&quot;, isRequired = true, name = &quot;profileIds&quot;, type = Type.STRING, defaultValue = &quot;image-conversion.http&quot;) }, responses = {
      @RestResponse(description = &quot;Results in an xml document containing the image attachments&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;If required parameters aren't set or if sourceImage isn't from the type attachment&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) }, returnDescription = &quot;&quot;)
  public Response convertImageSync(@FormParam(&quot;sourceImage&quot;) String sourceImageXml, @FormParam(&quot;profileIds&quot;)
      String profileIds) throws Exception {
    // Ensure that the POST parameters are present
<span class="nc bnc" id="L892" title="All 4 branches missed.">    if (StringUtils.isBlank(sourceImageXml) || StringUtils.isBlank(profileIds))</span>
<span class="nc" id="L893">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceImage and profileIds must not be null&quot;).build();</span>

    // Deserialize the source track
<span class="nc" id="L896">    MediaPackageElement sourceImage = MediaPackageElementParser.getFromXml(sourceImageXml);</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">    if (!Attachment.TYPE.equals(sourceImage.getElementType()))</span>
<span class="nc" id="L898">      return Response.status(Response.Status.BAD_REQUEST).entity(&quot;sourceImage element must be of type track&quot;).build();</span>

    try {
<span class="nc" id="L901">      List&lt;Attachment&gt; results = composerService.convertImageSync((Attachment) sourceImage,</span>
<span class="nc" id="L902">          StringUtils.split(profileIds, ','));</span>
<span class="nc" id="L903">      return Response.ok().entity(MediaPackageElementParser.getArrayAsXml(results)).build();</span>
<span class="nc" id="L904">    } catch (EncoderException e) {</span>
<span class="nc" id="L905">      logger.warn(&quot;Unable to convert image: &quot; + e.getMessage());</span>
<span class="nc" id="L906">      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</span>
    }
  }

  @GET
  @Path(&quot;profiles.xml&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;profiles&quot;, description = &quot;Retrieve the encoding profiles&quot;, responses = { @RestResponse(description = &quot;Results in an xml document describing the available encoding profiles&quot;, responseCode = HttpServletResponse.SC_OK) }, returnDescription = &quot;&quot;)
  public EncodingProfileList listProfiles() {
<span class="fc" id="L915">    List&lt;EncodingProfileImpl&gt; list = new ArrayList&lt;EncodingProfileImpl&gt;();</span>
<span class="fc bfc" id="L916" title="All 2 branches covered.">    for (EncodingProfile p : composerService.listProfiles()) {</span>
<span class="fc" id="L917">      list.add((EncodingProfileImpl) p);</span>
    }
<span class="fc" id="L919">    return new EncodingProfileList(list);</span>
  }

  @GET
  @Path(&quot;profile/{id}.xml&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;profilesID&quot;, description = &quot;Retrieve an encoding profile&quot;, pathParameters = { @RestParameter(name = &quot;id&quot;, description = &quot;the profile ID&quot;, isRequired = false, type = RestParameter.Type.STRING) }, responses = {
          @RestResponse(description = &quot;Results in an xml document describing the requested encoding profile&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;If profile has not been found&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) }, returnDescription = &quot;&quot;)
  public Response getProfile(@PathParam(&quot;id&quot;) String profileId) throws NotFoundException {
<span class="fc" id="L929">    EncodingProfileImpl profile = (EncodingProfileImpl) composerService.getProfile(profileId);</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">    if (profile == null)</span>
<span class="fc" id="L931">      throw new NotFoundException();</span>
<span class="fc" id="L932">    return Response.ok(profile).build();</span>
  }

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.rest.AbstractJobProducerEndpoint#getService()
   */
  @Override
  public JobProducer getService() {
<span class="nc bnc" id="L942" title="All 2 branches missed.">    if (composerService instanceof JobProducer)</span>
<span class="nc" id="L943">      return (JobProducer) composerService;</span>
    else
<span class="nc" id="L945">      return null;</span>
  }

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.rest.AbstractJobProducerEndpoint#getServiceRegistry()
   */
  @Override
  public ServiceRegistry getServiceRegistry() {
<span class="nc" id="L955">    return serviceRegistry;</span>
  }

  /**
   * Parses string containing times in seconds separated by comma.
   *
   * @param times
   *          string to be parsed
   * @return array of times in seconds
   */
  protected double[] parseTimeArray(String times) {
<span class="nc" id="L966">    String[] timeStringArray = times.split(&quot;;&quot;);</span>
<span class="nc" id="L967">    List&lt;Double&gt; parsedTimeArray = new LinkedList&lt;Double&gt;();</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">    for (String timeString : timeStringArray) {</span>
<span class="nc" id="L969">      String trimmed = StringUtils.trim(timeString);</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">      if (StringUtils.isNotBlank(trimmed)) {</span>
<span class="nc" id="L971">        parsedTimeArray.add(Double.parseDouble(timeString));</span>
      }
    }
<span class="nc" id="L974">    double[] timeArray = new double[parsedTimeArray.size()];</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">    for (int i = 0; i &lt; parsedTimeArray.size(); i++) {</span>
<span class="nc" id="L976">      timeArray[i] = parsedTimeArray.get(i);</span>
    }
<span class="nc" id="L978">    return timeArray;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>