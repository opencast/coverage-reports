<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EventsEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-external-api</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.external.endpoint</a> &gt; <span class="el_source">EventsEndpoint.java</span></div><h1>EventsEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.external.endpoint;

import static com.entwinemedia.fn.Stream.$;
import static com.entwinemedia.fn.data.json.Jsons.BLANK;
import static com.entwinemedia.fn.data.json.Jsons.NULL;
import static com.entwinemedia.fn.data.json.Jsons.arr;
import static com.entwinemedia.fn.data.json.Jsons.f;
import static com.entwinemedia.fn.data.json.Jsons.obj;
import static com.entwinemedia.fn.data.json.Jsons.v;
import static org.apache.commons.lang3.StringUtils.trimToNull;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_11_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_1_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_4_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_7_0;
import static org.opencastproject.external.util.SchedulingUtils.SchedulingInfo;
import static org.opencastproject.external.util.SchedulingUtils.convertConflictingEvents;
import static org.opencastproject.external.util.SchedulingUtils.getConflictingEvents;
import static org.opencastproject.util.RestUtil.getEndpointUrl;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;

import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.AssetManagerException;
import org.opencastproject.capture.CaptureParameters;
import org.opencastproject.capture.admin.api.CaptureAgentStateService;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.api.SearchResultItem;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.QueryPreprocessor;
import org.opencastproject.elasticsearch.index.objects.IndexObject;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.objects.event.EventIndexSchema;
import org.opencastproject.elasticsearch.index.objects.event.EventSearchQuery;
import org.opencastproject.external.common.ApiMediaType;
import org.opencastproject.external.common.ApiResponseBuilder;
import org.opencastproject.external.common.ApiVersion;
import org.opencastproject.external.util.AclUtils;
import org.opencastproject.external.util.ExternalMetadataUtils;
import org.opencastproject.index.service.api.IndexService;
import org.opencastproject.index.service.catalog.adapter.DublinCoreMetadataUtil;
import org.opencastproject.index.service.exception.IndexServiceException;
import org.opencastproject.index.service.impl.util.EventHttpServletRequest;
import org.opencastproject.index.service.impl.util.EventUtils;
import org.opencastproject.index.service.util.RequestUtils;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.ingest.api.IngestException;
import org.opencastproject.ingest.api.IngestService;
import org.opencastproject.list.impl.EmptyResourceListQuery;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.AudioStream;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Publication;
import org.opencastproject.mediapackage.Stream;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.TrackSupport;
import org.opencastproject.mediapackage.VideoStream;
import org.opencastproject.mediapackage.track.TrackImpl;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.EventCatalogUIAdapter;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.MetadataJson;
import org.opencastproject.metadata.dublincore.MetadataList;
import org.opencastproject.metadata.dublincore.MetadataList.Locked;
import org.opencastproject.rest.RestConstants;
import org.opencastproject.scheduler.api.SchedulerConflictException;
import org.opencastproject.scheduler.api.SchedulerException;
import org.opencastproject.scheduler.api.SchedulerService;
import org.opencastproject.scheduler.api.TechnicalMetadata;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.urlsigning.exception.UrlSigningException;
import org.opencastproject.security.urlsigning.service.UrlSigningService;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.util.DateTimeSupport;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RestUtil;
import org.opencastproject.util.RestUtil.R;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestParameter.Type;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.util.requests.SortCriterion;
import org.opencastproject.workflow.api.WorkflowDatabaseException;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowService;

import com.entwinemedia.fn.Fn;
import com.entwinemedia.fn.data.Opt;
import com.entwinemedia.fn.data.json.Field;
import com.entwinemedia.fn.data.json.JObject;
import com.entwinemedia.fn.data.json.JValue;
import com.entwinemedia.fn.data.json.Jsons;
import com.entwinemedia.fn.data.json.Jsons.Functions;

import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.lang3.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.osgi.service.cm.ConfigurationException;
import org.osgi.service.cm.ManagedService;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.URI;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@Path(&quot;/api/events&quot;)
@Produces({ ApiMediaType.JSON, ApiMediaType.VERSION_1_0_0, ApiMediaType.VERSION_1_1_0, ApiMediaType.VERSION_1_2_0,
            ApiMediaType.VERSION_1_3_0, ApiMediaType.VERSION_1_4_0, ApiMediaType.VERSION_1_5_0,
            ApiMediaType.VERSION_1_6_0, ApiMediaType.VERSION_1_7_0, ApiMediaType.VERSION_1_8_0,
            ApiMediaType.VERSION_1_9_0, ApiMediaType.VERSION_1_10_0, ApiMediaType.VERSION_1_11_0 })
@RestService(name = &quot;externalapievents&quot;, title = &quot;External API Events Service&quot;, notes = {},
             abstractText = &quot;Provides resources and operations related to the events&quot;)
@Tag(name = &quot;External API&quot;)
@Tag(name = &quot;External API - Events&quot;,
    description = &quot;The events endpoint provides resources and operations related to the events&quot;)
@Component(
    immediate = true,
    service = { EventsEndpoint.class,ManagedService.class },
    property = {
        &quot;service.description=External API - Events Endpoint&quot;,
        &quot;opencast.service.type=org.opencastproject.external.events&quot;,
        &quot;opencast.service.path=/api/events&quot;
    }
)
@JaxrsResource
<span class="fc" id="L218">public class EventsEndpoint implements ManagedService {</span>

  protected static final String URL_SIGNING_EXPIRES_DURATION_SECONDS_KEY = &quot;url.signing.expires.seconds&quot;;

  /** The default time before a piece of signed content expires. 2 Hours. */
<span class="fc" id="L223">  protected static final Long DEFAULT_URL_SIGNING_EXPIRE_DURATION = 2 * 60 * 60L;</span>

  /** Subtype of previews required by the video editor */
  private static final String PREVIEW_SUBTYPE = &quot;preview.subtype&quot;;

  /** Subtype of previews required by the video editor */
  private static final String DEFAULT_PREVIEW_SUBTYPE = &quot;preview&quot;;

  /** ID of the workflow used to retract published events */
  private static final String RETRACT_WORKFLOW = &quot;retract.workflow.id&quot;;

  /** Default ID of the workflow used to retract published events */
  private static final String DEFAULT_RETRACT_WORKFLOW = &quot;delete&quot;;

  /** The logging facility */
<span class="fc" id="L238">  private static final Logger logger = LoggerFactory.getLogger(EventsEndpoint.class);</span>

  /** Base URL of this endpoint */
  protected String endpointBaseUrl;

<span class="fc" id="L243">  private static long expireSeconds = DEFAULT_URL_SIGNING_EXPIRE_DURATION;</span>

<span class="fc" id="L245">  private String previewSubtype = DEFAULT_PREVIEW_SUBTYPE;</span>

<span class="fc" id="L247">  private Map&lt;String, MetadataField&gt; configuredMetadataFields = new TreeMap&lt;&gt;();</span>

<span class="fc" id="L249">  private String retractWorkflowId = DEFAULT_RETRACT_WORKFLOW;</span>

  /** The resolutions */
<span class="nc" id="L252">  private enum CommentResolution {</span>
<span class="nc" id="L253">    ALL, UNRESOLVED, RESOLVED;</span>
  };

  /* OSGi service references */
  private AssetManager assetManager;
  private ElasticsearchIndex elasticsearchIndex;
  private IndexService indexService;
  private IngestService ingestService;
  private SecurityService securityService;
<span class="fc" id="L262">  private final List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L263">  private final Map&lt;String, List&lt;EventCatalogUIAdapter&gt;&gt; orgCatalogUIAdaptersMap = new ConcurrentHashMap&lt;&gt;();</span>
  private UrlSigningService urlSigningService;
  private SchedulerService schedulerService;
  private CaptureAgentStateService agentStateService;
  private WorkflowService workflowService;

  /** OSGi DI */
  @Reference
  public void setAssetManager(AssetManager assetManager) {
<span class="fc" id="L272">    this.assetManager = assetManager;</span>
<span class="fc" id="L273">  }</span>

  /** OSGi DI */
  @Reference
  void setElasticsearchIndex(ElasticsearchIndex elasticsearchIndex) {
<span class="fc" id="L278">    this.elasticsearchIndex = elasticsearchIndex;</span>
<span class="fc" id="L279">  }</span>

  /** OSGi DI */
  @Reference
  public void setIndexService(IndexService indexService) {
<span class="fc" id="L284">    this.indexService = indexService;</span>
<span class="fc" id="L285">  }</span>

  /** OSGi DI */
  @Reference
  public void setIngestService(IngestService ingestService) {
<span class="fc" id="L290">    this.ingestService = ingestService;</span>
<span class="fc" id="L291">  }</span>

  /** OSGi DI */
  @Reference
  void setSecurityService(SecurityService securityService) {
<span class="fc" id="L296">    this.securityService = securityService;</span>
<span class="fc" id="L297">  }</span>

  /** OSGi DI */
  @Reference
  public void setUrlSigningService(UrlSigningService urlSigningService) {
<span class="nc" id="L302">    this.urlSigningService = urlSigningService;</span>
<span class="nc" id="L303">  }</span>

  public SecurityService getSecurityService() {
<span class="fc" id="L306">    return securityService;</span>
  }

  public SchedulerService getSchedulerService() {
<span class="nc" id="L310">    return schedulerService;</span>
  }

  @Reference
  public void setSchedulerService(SchedulerService schedulerService) {
<span class="fc" id="L315">    this.schedulerService = schedulerService;</span>
<span class="fc" id="L316">  }</span>

  /** OSGi DI. */
  @Reference(
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeCatalogUIAdapter&quot;
  )
  public void addCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="fc" id="L325">    catalogUIAdapters.add(catalogUIAdapter);</span>
<span class="fc" id="L326">    invalidateOrgCatalogUIAdaptersMapFor(catalogUIAdapter);</span>
<span class="fc" id="L327">  }</span>

  /** OSGi DI. */
  public void removeCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L331">    catalogUIAdapters.remove(catalogUIAdapter);</span>
<span class="nc" id="L332">    invalidateOrgCatalogUIAdaptersMapFor(catalogUIAdapter);</span>
<span class="nc" id="L333">  }</span>

  /**
   * Invalidates caches for organizations that are handled by given catalog.
   *
   * @param catalogUIAdapter catalog used to identify affected organizations.
   */
  private void invalidateOrgCatalogUIAdaptersMapFor(EventCatalogUIAdapter catalogUIAdapter) {
    // clean cached org to catalog map
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">    for (String orgName : orgCatalogUIAdaptersMap.keySet()) {</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">      if (catalogUIAdapter.handlesOrganization(orgName)) {</span>
<span class="nc" id="L344">        orgCatalogUIAdaptersMap.remove(orgName);</span>
      }
<span class="nc" id="L346">    }</span>
<span class="fc" id="L347">  }</span>

  /** OSGi DI */
  public CaptureAgentStateService getAgentStateService() {
<span class="nc" id="L351">    return agentStateService;</span>
  }

  /** OSGi DI */
  @Reference
  public void setAgentStateService(CaptureAgentStateService agentStateService) {
<span class="nc" id="L357">    this.agentStateService = agentStateService;</span>
<span class="nc" id="L358">  }</span>

  /** OSGi DI */
  @Reference
  public void setWorkflowService(WorkflowService workflowService) {
<span class="fc" id="L363">    this.workflowService = workflowService;</span>
<span class="fc" id="L364">  }</span>


  private List&lt;EventCatalogUIAdapter&gt; getEventCatalogUIAdapters() {
<span class="fc" id="L368">    return getEventCatalogUIAdapters(getSecurityService().getOrganization().getId());</span>
  }

  public List&lt;EventCatalogUIAdapter&gt; getEventCatalogUIAdapters(String organization) {
<span class="fc" id="L372">    List&lt;EventCatalogUIAdapter&gt; cachedCatalogUIAdapters = orgCatalogUIAdaptersMap.computeIfAbsent(organization,</span>
<span class="fc" id="L373">        org -&gt; new ArrayList&lt;&gt;(catalogUIAdapters.stream()</span>
<span class="fc" id="L374">            .filter(a -&gt; a.handlesOrganization(org))</span>
<span class="fc" id="L375">            .collect(Collectors.toList())));</span>
    // create a shallow copy as callers may change it
<span class="fc" id="L377">    return new ArrayList&lt;&gt;(cachedCatalogUIAdapters);</span>
  }

  /** OSGi activation method */
  @Activate
  void activate(ComponentContext cc) {
<span class="nc" id="L383">    logger.info(&quot;Activating External API - Events Endpoint&quot;);</span>

<span class="nc" id="L385">    final Tuple&lt;String, String&gt; endpointUrl = getEndpointUrl(cc, OpencastConstants.EXTERNAL_API_URL_ORG_PROPERTY,</span>
            RestConstants.SERVICE_PATH_PROPERTY);
<span class="nc" id="L387">    endpointBaseUrl = UrlSupport.concat(endpointUrl.getA(), endpointUrl.getB());</span>
<span class="nc" id="L388">    logger.debug(&quot;Configured service endpoint is {}&quot;, endpointBaseUrl);</span>
<span class="nc" id="L389">  }</span>

  /** OSGi callback if properties file is present */
  @Override
  public void updated(Dictionary&lt;String, ?&gt; properties) throws ConfigurationException {
    // Ensure properties is not null
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">    if (properties == null) {</span>
<span class="nc" id="L396">      properties = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L397">      logger.debug(&quot;No configuration set&quot;);</span>
    }

    // Read URL Signing Expiration duration
    // Default to DEFAULT_URL_SIGNING_EXPIRE_DURATION.toString()));
<span class="fc" id="L402">    expireSeconds = Long.parseLong(Objects.toString(</span>
<span class="fc" id="L403">        properties.get(URL_SIGNING_EXPIRES_DURATION_SECONDS_KEY),</span>
<span class="fc" id="L404">        DEFAULT_URL_SIGNING_EXPIRE_DURATION.toString()));</span>
<span class="fc" id="L405">    logger.debug(&quot;URLs signatures are configured to expire in {}.&quot;, DateTimeSupport.humanReadableTime(expireSeconds));</span>

    // Read preview subtype configuration
    // Default to DEFAULT_PREVIEW_SUBTYPE
<span class="fc" id="L409">    previewSubtype = StringUtils.defaultString((String) properties.get(PREVIEW_SUBTYPE), DEFAULT_PREVIEW_SUBTYPE);</span>
<span class="fc" id="L410">    logger.debug(&quot;Preview subtype is '{}'&quot;, previewSubtype);</span>

<span class="fc" id="L412">    configuredMetadataFields = DublinCoreMetadataUtil.getDublinCoreProperties(properties);</span>

<span class="fc" id="L414">    retractWorkflowId = StringUtils.defaultString((String) properties.get(RETRACT_WORKFLOW), DEFAULT_RETRACT_WORKFLOW);</span>
<span class="fc" id="L415">    logger.debug(&quot;Retract Workflow is '{}'&quot;, retractWorkflowId);</span>
<span class="fc" id="L416">  }</span>

  public static &lt;T&gt; boolean isNullOrEmpty(List&lt;String&gt; list) {
<span class="nc bnc" id="L419" title="All 4 branches missed.">    return list == null || list.isEmpty();</span>
  }

  @GET
  @Path(&quot;{eventId}&quot;)
  @RestQuery(name = &quot;getevent&quot;, description = &quot;Returns a single event. By setting the optional sign parameter to true, the method will pre-sign distribution urls if signing is turned on in Opencast. Remember to consider the maximum validity of signed URLs when caching this response.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;sign&quot;, isRequired = false, description = &quot;Whether public distribution urls should be signed.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withacl&quot;, isRequired = false, description = &quot;Whether the acl metadata should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withmetadata&quot;, isRequired = false, description = &quot;Whether the metadata catalogs should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withscheduling&quot;, isRequired = false, description = &quot;Whether the scheduling information should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;withpublications&quot;, isRequired = false, description = &quot;Whether the publication ids and urls should be included in the response.&quot;, type = Type.BOOLEAN),
                  @RestParameter(name = &quot;includeInternalPublication&quot;, isRequired = false, description = &quot;Whether internal publications should be included.&quot;, type = Type.BOOLEAN)}, responses = {
                          @RestResponse(description = &quot;The event is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  @Operation(summary = &quot;Get a single event&quot;, description = &quot;Returns a single event. By setting the optional sign parameter to true, the method will pre-sign distribution urls if signing is turned on in Opencast. Remember to consider the maximum validity of signed URLs when caching this response.&quot;)
  public Response getEvent(
      @HeaderParam(&quot;Accept&quot;) String acceptHeader,
      @Parameter(description = &quot;The event id&quot;, required = true)
      @PathParam(&quot;eventId&quot;) String id,
      @Parameter(description = &quot;Whether public distribution urls should be signed.&quot;)
      @QueryParam(&quot;sign&quot;) boolean sign,
      @Parameter(description = &quot;Whether the acl metadata should be included in the response.&quot;)
      @QueryParam(&quot;withacl&quot;) Boolean withAcl,
      @Parameter(description = &quot;Whether the metadata catalogs should be included in the response.&quot;)
      @QueryParam(&quot;withmetadata&quot;) Boolean withMetadata,
      @Parameter(description = &quot;Whether the scheduling information should be included in the response.&quot;)
      @QueryParam(&quot;withscheduling&quot;) Boolean withScheduling,
      @Parameter(description = &quot;Whether the publication ids and urls should be included in the response.&quot;)
      @QueryParam(&quot;withpublications&quot;) Boolean withPublications,
      @Parameter(description = &quot;Whether internal publications should be included.&quot;)
      @QueryParam(&quot;includeInternalPublication&quot;) Boolean includeInternalPublication)
        throws Exception {
<span class="nc" id="L452">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
      // withScheduling was added in version 1.1.0 and should be ignored for smaller versions
<span class="nc" id="L455">      withScheduling = false;</span>
    }
<span class="nc bnc" id="L457" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L458">      event.updatePreview(previewSubtype);</span>
<span class="nc" id="L459">      return ApiResponseBuilder.Json.ok(</span>
<span class="nc" id="L460">          requestedVersion, eventToJSON(event, withAcl, withMetadata, withScheduling, withPublications, includeInternalPublication, sign, requestedVersion));</span>
    }
<span class="nc" id="L462">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @GET
  @Path(&quot;{eventId}/media&quot;)
  @RestQuery(name = &quot;geteventmedia&quot;, description = &quot;Returns media tracks of specific single event.&quot;, returnDescription = &quot;&quot;, pathParameters = {
      @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
      @RestResponse(description = &quot;The event's media is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  @Operation(summary = &quot;Get media tracks of a single event&quot;, description = &quot;Returns media tracks of specific single event.&quot;)
  @Parameters({
      @Parameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, required = true, in = ParameterIn.PATH),
      @Parameter(name = &quot;Accept&quot;, description = &quot;The accept header&quot;, required = true, in = ParameterIn.HEADER)
  })
  @ApiResponses(value = {
      @ApiResponse(responseCode = &quot;200&quot;, description = &quot;The event's media is returned.&quot;),
      @ApiResponse(responseCode = &quot;404&quot;, description = &quot;The specified event does not exist.&quot;)
  })
  public Response getEventMedia(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
          throws Exception {
<span class="nc" id="L482">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc" id="L483">    ArrayList&lt;TrackImpl&gt; tracks = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L485" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L486">      final MediaPackage mp = indexService.getEventMediapackage(event);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">      for (Track track : mp.getTracks()) {</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (track instanceof TrackImpl) {</span>
<span class="nc" id="L489">          tracks.add((TrackImpl) track);</span>
        }
      }

<span class="nc" id="L493">      List&lt;JValue&gt; tracksJson = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">      for (Track track : tracks) {</span>
<span class="nc" id="L495">        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (track.getChecksum() != null)</span>
<span class="nc" id="L497">          fields.add(f(&quot;checksum&quot;, v(track.getChecksum().toString())));</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (track.getDescription() != null)</span>
<span class="nc" id="L499">          fields.add(f(&quot;description&quot;, v(track.getDescription())));</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (track.getDuration() != null)</span>
<span class="nc" id="L501">          fields.add(f(&quot;duration&quot;, v(track.getDuration())));</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (track.getElementDescription() != null)</span>
<span class="nc" id="L503">          fields.add(f(&quot;element-description&quot;, v(track.getElementDescription())));</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (track.getFlavor() != null)</span>
<span class="nc" id="L505">          fields.add(f(&quot;flavor&quot;, v(track.getFlavor().toString())));</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (track.getIdentifier() != null)</span>
<span class="nc" id="L507">          fields.add(f(&quot;identifier&quot;, v(track.getIdentifier())));</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (track.getMimeType() != null)</span>
<span class="nc" id="L509">          fields.add(f(&quot;mimetype&quot;, v(track.getMimeType().toString())));</span>
<span class="nc" id="L510">        fields.add(f(&quot;size&quot;, v(track.getSize())));</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (!requestedVersion.isSmallerThan(VERSION_1_7_0)) {</span>
<span class="nc" id="L512">          fields.add(f(&quot;has_video&quot;, v(track.hasVideo())));</span>
<span class="nc" id="L513">          fields.add(f(&quot;has_audio&quot;, v(track.hasAudio())));</span>
<span class="nc" id="L514">          fields.add(f(&quot;is_master_playlist&quot;, v(track.isMaster())));</span>
<span class="nc" id="L515">          fields.add(f(&quot;is_live&quot;, v(track.isLive())));</span>
        }
<span class="nc bnc" id="L517" title="All 2 branches missed.">        if (track.getStreams() != null) {</span>
<span class="nc" id="L518">          List&lt;Field&gt; streams = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">          for (Stream stream : track.getStreams()) {</span>
<span class="nc" id="L520">            streams.add(f(stream.getIdentifier(), getJsonStream(stream)));</span>
          }
<span class="nc" id="L522">          fields.add(f(&quot;streams&quot;, obj(streams)));</span>
        }
<span class="nc bnc" id="L524" title="All 2 branches missed.">        if (track.getTags() != null) {</span>
<span class="nc" id="L525">          List&lt;JValue&gt; tags = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">          for (String tag : track.getTags()) {</span>
<span class="nc" id="L527">            tags.add(v(tag));</span>
          }
<span class="nc" id="L529">          fields.add(f(&quot;tags&quot;, arr(tags)));</span>
        }
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (track.getURI() != null)</span>
<span class="nc" id="L532">          fields.add(f(&quot;uri&quot;, v(track.getURI().toString())));</span>
<span class="nc" id="L533">        tracksJson.add(obj(fields));</span>
<span class="nc" id="L534">      }</span>
<span class="nc" id="L535">      return ApiResponseBuilder.Json.ok(acceptHeader, arr(tracksJson));</span>
    }
<span class="nc" id="L537">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @DELETE
  @Path(&quot;{eventId}&quot;)
  @RestQuery(name = &quot;deleteevent&quot;, description = &quot;Deletes an event.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
          @RestResponse(description = &quot;The event has been deleted.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
          @RestResponse(description = &quot;The retraction of publications has started.&quot;, responseCode = HttpServletResponse.SC_ACCEPTED),
          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteEvent(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
          throws SearchIndexException, UnauthorizedException {
<span class="nc" id="L549">    final Opt&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">    if (event.isNone()) {</span>
<span class="nc" id="L551">      return RestUtil.R.notFound(id);</span>
    }
    final IndexService.EventRemovalResult result;
    try {
<span class="nc" id="L555">      result = indexService.removeEvent(event.get(), retractWorkflowId);</span>
<span class="nc" id="L556">    } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L557">      logger.error(&quot;Workflow database is not reachable. This may be a temporary problem.&quot;);</span>
<span class="nc" id="L558">      return RestUtil.R.serverError();</span>
<span class="nc" id="L559">    } catch (NotFoundException e) {</span>
<span class="nc" id="L560">      logger.error(&quot;Configured retract workflow not found. Check your configuration.&quot;);</span>
<span class="nc" id="L561">      return RestUtil.R.serverError();</span>
<span class="nc" id="L562">    }</span>
<span class="nc bnc" id="L563" title="All 5 branches missed.">    switch (result) {</span>
      case SUCCESS:
<span class="nc" id="L565">        return Response.noContent().build();</span>
      case RETRACTING:
<span class="nc" id="L567">        return Response.accepted().build();</span>
      case GENERAL_FAILURE:
<span class="nc" id="L569">        return Response.serverError().build();</span>
      case NOT_FOUND:
<span class="nc" id="L571">        return RestUtil.R.notFound(id);</span>
      default:
<span class="nc" id="L573">        throw new RuntimeException(&quot;Unknown EventRemovalResult type: &quot; + result.name());</span>
    }
  }

  @POST
  @Path(&quot;{eventId}&quot;)
  @RestQuery(name = &quot;updateeventmetadata&quot;, description = &quot;Updates an event.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;acl&quot;, isRequired = false, description = &quot;A collection of roles with their possible action&quot;, type = Type.STRING),
                  @RestParameter(name = &quot;metadata&quot;, isRequired = false, description = &quot;Event metadata as Form param&quot;, type = Type.STRING),
                  @RestParameter(name = &quot;scheduling&quot;, isRequired = false, description = &quot;Scheduling information as Form param&quot;, type = Type.STRING),
                  @RestParameter(name = &quot;presenter&quot;, isRequired = false, description = &quot;Presenter movie track&quot;, type = Type.FILE),
                  @RestParameter(name = &quot;presentation&quot;, isRequired = false, description = &quot;Presentation movie track&quot;, type = Type.FILE),
                  @RestParameter(name = &quot;audio&quot;, isRequired = false, description = &quot;Audio track&quot;, type = Type.FILE),
                  @RestParameter(name = &quot;processing&quot;, isRequired = false, description = &quot;Processing instructions task configuration&quot;, type = Type.STRING), }, responses = {
                          @RestResponse(description = &quot;The event has been updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The event could not be updated due to a scheduling conflict.&quot;, responseCode = HttpServletResponse.SC_CONFLICT),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventMetadata(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @Context HttpServletRequest request,
          @PathParam(&quot;eventId&quot;) String eventId) {
<span class="fc" id="L593">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
    try {
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">      String startDatePattern = configuredMetadataFields.containsKey(&quot;startDate&quot;) ? configuredMetadataFields.get(&quot;startDate&quot;).getPattern() : null;</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">      String startTimePattern = configuredMetadataFields.containsKey(&quot;startTime&quot;) ? configuredMetadataFields.get(&quot;startTime&quot;).getPattern() : null;</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">      for (final Event event : indexService.getEvent(eventId, elasticsearchIndex)) {</span>
<span class="fc" id="L598">        EventHttpServletRequest eventHttpServletRequest = EventHttpServletRequest.updateFromHttpServletRequest(event,</span>
<span class="fc" id="L599">                request, getEventCatalogUIAdapters(), startDatePattern, startTimePattern);</span>

        // FIXME: All of these update operations should be a part of a transaction to avoid a partially updated event.
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (eventHttpServletRequest.getMetadataList().isSome()) {</span>
<span class="fc" id="L603">          indexService.updateEventMetadata(eventId, eventHttpServletRequest.getMetadataList().get(), elasticsearchIndex);</span>
        }

<span class="pc bpc" id="L606" title="1 of 2 branches missed.">        if (eventHttpServletRequest.getAcl().isSome()) {</span>
<span class="nc" id="L607">          indexService.updateEventAcl(eventId, eventHttpServletRequest.getAcl().get(), elasticsearchIndex);</span>
        }

<span class="pc bpc" id="L610" title="1 of 2 branches missed.">        if (eventHttpServletRequest.getProcessing().isSome()) {</span>

<span class="nc bnc" id="L612" title="All 4 branches missed.">          if (!event.isScheduledEvent() || event.hasRecordingStarted()) {</span>
<span class="nc" id="L613">            return RestUtil.R.badRequest(&quot;Processing can't be updated for events that are already uploaded.&quot;);</span>
          }
<span class="nc" id="L615">          JSONObject processing = eventHttpServletRequest.getProcessing().get();</span>

<span class="nc" id="L617">          String workflowId = (String) processing.get(&quot;workflow&quot;);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">          if (workflowId == null)</span>
<span class="nc" id="L619">            throw new IllegalArgumentException(&quot;No workflow template in metadata&quot;);</span>

<span class="nc" id="L621">          Map&lt;String, String&gt; configuration = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">          if (eventHttpServletRequest.getProcessing().get().get(&quot;configuration&quot;) != null) {</span>
<span class="nc" id="L623">            configuration = new HashMap&lt;&gt;((JSONObject) eventHttpServletRequest.getProcessing().get().get(&quot;configuration&quot;));</span>
          }

<span class="nc" id="L626">          Opt&lt;Map&lt;String, String&gt;&gt; caMetadataOpt = Opt.none();</span>
<span class="nc" id="L627">          Opt&lt;Map&lt;String, String&gt;&gt; workflowConfigOpt = Opt.none();</span>

<span class="nc" id="L629">          Map&lt;String, String&gt; caMetadata = new HashMap&lt;&gt;(getSchedulerService().getCaptureAgentConfiguration(eventId));</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">          if (!workflowId.equals(caMetadata.get(CaptureParameters.INGEST_WORKFLOW_DEFINITION))) {</span>
<span class="nc" id="L631">            caMetadata.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, workflowId);</span>
<span class="nc" id="L632">            caMetadataOpt = Opt.some(caMetadata);</span>
          }

<span class="nc" id="L635">          Map&lt;String, String&gt; oldWorkflowConfig = new HashMap&lt;&gt;(getSchedulerService().getWorkflowConfig(eventId));</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">          if (!oldWorkflowConfig.equals(configuration))</span>
<span class="nc" id="L637">            workflowConfigOpt = Opt.some(configuration);</span>

<span class="nc bnc" id="L639" title="All 4 branches missed.">          if (!caMetadataOpt.isNone() || !workflowConfigOpt.isNone()) {</span>
<span class="nc" id="L640">            getSchedulerService().updateEvent(eventId, Opt.none(), Opt.none(), Opt.none(),</span>
<span class="nc" id="L641">                    Opt.none(), Opt.none(), workflowConfigOpt, caMetadataOpt);</span>
          }
        }

<span class="pc bpc" id="L645" title="3 of 4 branches missed.">        if (eventHttpServletRequest.getScheduling().isSome() &amp;&amp; !requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
          // Scheduling is only available for version 1.1.0 and above
<span class="nc" id="L647">          Optional&lt;Response&gt; clientError = updateSchedulingInformation(</span>
<span class="nc" id="L648">              eventHttpServletRequest.getScheduling().get(), eventId, requestedVersion, false);</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">          if (clientError.isPresent()) {</span>
<span class="nc" id="L650">            return clientError.get();</span>
          }
        }

<span class="fc" id="L654">        return Response.noContent().build();</span>
      }
<span class="nc" id="L656">      return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
<span class="nc" id="L657">    } catch (NotFoundException e) {</span>
<span class="nc" id="L658">      return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, eventId);</span>
<span class="nc" id="L659">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L660">      return Response.status(Status.UNAUTHORIZED).build();</span>
<span class="nc" id="L661">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L662">      logger.debug(&quot;Unable to update event '{}'&quot;, eventId, e);</span>
<span class="nc" id="L663">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L664">    } catch (IndexServiceException e) {</span>
<span class="nc" id="L665">      logger.error(&quot;Unable to get multi part fields or file for event '{}'&quot;, eventId, e);</span>
<span class="nc" id="L666">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L667">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L668">      logger.error(&quot;Unable to update event '{}'&quot;, eventId, e);</span>
<span class="nc" id="L669">      throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L670">    } catch (Exception e) {</span>
<span class="nc" id="L671">      throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @POST
  @Path(&quot;/&quot;)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @RestQuery(name = &quot;createevent&quot;, description = &quot;Creates an event by sending metadata, access control list, processing instructions and files in a multipart request.&quot;, returnDescription = &quot;&quot;, restParameters = {
          @RestParameter(name = &quot;acl&quot;, isRequired = false, description = &quot;A collection of roles with their possible action&quot;, type = STRING),
          @RestParameter(name = &quot;metadata&quot;, description = &quot;Event metadata as Form param&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;scheduling&quot;, description = &quot;Scheduling information as Form param&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;presenter&quot;, description = &quot;Presenter movie track&quot;, isRequired = false, type = Type.FILE),
          @RestParameter(name = &quot;presentation&quot;, description = &quot;Presentation movie track&quot;, isRequired = false, type = Type.FILE),
          @RestParameter(name = &quot;audio&quot;, description = &quot;Audio track&quot;, isRequired = false, type = Type.FILE),
          @RestParameter(name = &quot;processing&quot;, description = &quot;Processing instructions task configuration&quot;, isRequired = false, type = STRING) }, responses = {
                  @RestResponse(description = &quot;A new event is created and its identifier is returned in the Location header.&quot;, responseCode = HttpServletResponse.SC_CREATED),
                  @RestResponse(description = &quot;The event could not be created due to a scheduling conflict.&quot;, responseCode = HttpServletResponse.SC_CONFLICT),
                  @RestResponse(description = &quot;The request is invalid or inconsistent..&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST) })
  public Response createNewEvent(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @Context HttpServletRequest request) {
<span class="nc" id="L690">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
    try {
<span class="nc bnc" id="L692" title="All 2 branches missed.">      String startDatePattern = configuredMetadataFields.containsKey(&quot;startDate&quot;) ? configuredMetadataFields.get(&quot;startDate&quot;).getPattern() : null;</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">      String startTimePattern = configuredMetadataFields.containsKey(&quot;startTime&quot;) ? configuredMetadataFields.get(&quot;startTime&quot;).getPattern() : null;</span>
<span class="nc" id="L694">      EventHttpServletRequest eventHttpServletRequest = EventHttpServletRequest.createFromHttpServletRequest(request,</span>
<span class="nc" id="L695">          ingestService, getEventCatalogUIAdapters(), startDatePattern, startTimePattern);</span>

      // If scheduling information is provided, the source has to be &quot;SCHEDULE_SINGLE&quot; or &quot;SCHEDULE_MULTIPLE&quot;.
<span class="nc bnc" id="L698" title="All 4 branches missed.">      if (eventHttpServletRequest.getScheduling().isSome() &amp;&amp; !requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
        // Scheduling is only available for version 1.1.0 and above
<span class="nc" id="L700">        return scheduleNewEvent(eventHttpServletRequest, eventHttpServletRequest.getScheduling().get(), requestedVersion);</span>
      }

<span class="nc" id="L703">      JSONObject source = new JSONObject();</span>
<span class="nc" id="L704">      source.put(&quot;type&quot;, &quot;UPLOAD&quot;);</span>
<span class="nc" id="L705">      eventHttpServletRequest.setSource(source);</span>
<span class="nc" id="L706">      String eventId = indexService.createEvent(eventHttpServletRequest);</span>
<span class="nc" id="L707">      return ApiResponseBuilder.Json.created(requestedVersion, URI.create(getEventUrl(eventId)), obj(f(&quot;identifier&quot;, v(eventId))));</span>
<span class="nc" id="L708">    } catch (IllegalArgumentException | DateTimeParseException e) {</span>
<span class="nc" id="L709">      logger.debug(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L710">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L711">    } catch (SchedulerException | IndexServiceException e) {</span>
<span class="nc bnc" id="L712" title="All 4 branches missed.">      if (e.getCause() != null &amp;&amp; e.getCause() instanceof NotFoundException</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">              || e.getCause() instanceof IllegalArgumentException) {</span>
<span class="nc" id="L714">        logger.debug(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L715">        return RestUtil.R.badRequest(e.getCause().getMessage());</span>
      } else {
<span class="nc" id="L717">        logger.error(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L718">        throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
      }
<span class="nc" id="L720">    } catch (Exception e) {</span>
<span class="nc" id="L721">      logger.error(&quot;Unable to create event&quot;, e);</span>
<span class="nc" id="L722">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  private Response scheduleNewEvent(EventHttpServletRequest request, JSONObject scheduling, ApiVersion requestedVersion) throws
      MediaPackageException, IOException, IngestException, SchedulerException,
      NotFoundException, UnauthorizedException, SearchIndexException, java.text.ParseException {

<span class="nc" id="L730">    final SchedulingInfo schedulingInfo = SchedulingInfo.of(scheduling);</span>
<span class="nc" id="L731">    final JSONObject source = schedulingInfo.toSource();</span>
<span class="nc" id="L732">    request.setSource(source);</span>

    try {
<span class="nc" id="L735">      final String eventId = indexService.createEvent(request);</span>

<span class="nc bnc" id="L737" title="All 2 branches missed.">      if (StringUtils.isEmpty(eventId)) {</span>
<span class="nc" id="L738">        return RestUtil.R.badRequest(&quot;The date range provided did not include any events&quot;);</span>
      }

<span class="nc bnc" id="L741" title="All 2 branches missed.">      if (eventId.contains(&quot;,&quot;)) {</span>
        // This the case when SCHEDULE_MULTIPLE is performed.
<span class="nc" id="L743">        return ApiResponseBuilder.Json.ok(requestedVersion, arr(</span>
<span class="nc" id="L744">            Arrays.stream(eventId.split(&quot;,&quot;))</span>
<span class="nc" id="L745">                .map(s -&gt; obj(f(&quot;identifier&quot;, v(s))))</span>
<span class="nc" id="L746">                .collect(Collectors.toList()))</span>
        );
      }

<span class="nc" id="L750">      return ApiResponseBuilder.Json.created(requestedVersion, URI.create(getEventUrl(eventId)), obj(f(&quot;identifier&quot;, v(eventId))));</span>
<span class="nc" id="L751">    } catch (SchedulerConflictException e) {</span>
<span class="nc" id="L752">      final List&lt;MediaPackage&gt; conflictingEvents =</span>
<span class="nc" id="L753">          getConflictingEvents(schedulingInfo, agentStateService, schedulerService);</span>
<span class="nc" id="L754">      logger.debug(&quot;Client tried to schedule conflicting event(s).&quot;);</span>
<span class="nc" id="L755">      return ApiResponseBuilder.Json.conflict(requestedVersion,</span>
<span class="nc" id="L756">          arr(convertConflictingEvents(Optional.empty(), conflictingEvents, indexService, elasticsearchIndex)));</span>
    }
  }

  @GET
  @Path(&quot;/&quot;)
  @RestQuery(name = &quot;getevents&quot;, description = &quot;Returns a list of events. By setting the optional sign parameter to true, the method will pre-sign distribution urls if signing is turned on in Opencast. Remember to consider the maximum validity of signed URLs when caching this response.&quot;, returnDescription = &quot;&quot;, restParameters = {
          @RestParameter(name = &quot;sign&quot;, isRequired = false, description = &quot;Whether public distribution urls should be signed.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withacl&quot;, isRequired = false, description = &quot;Whether the acl metadata should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withmetadata&quot;, isRequired = false, description = &quot;Whether the metadata catalogs should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withscheduling&quot;, isRequired = false, description = &quot;Whether the scheduling information should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;withpublications&quot;, isRequired = false, description = &quot;Whether the publication ids and urls should be included in the response.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;includeInternalPublication&quot;, description = &quot;Whether internal publications should be included.&quot;, isRequired = false, type = Type.BOOLEAN),
          @RestParameter(name = &quot;onlyWithWriteAccess&quot;, isRequired = false, description = &quot;Whether only to get the events to which we have write access.&quot;, type = Type.BOOLEAN),
          @RestParameter(name = &quot;filter&quot;, isRequired = false, description = &quot;Usage [Filter Name]:[Value to Filter With]. Multiple filters can be used by combining them with commas \&quot;,\&quot;. Available Filters: presenters, contributors, location, textFilter, series, subject. If API ver &gt; 1.1.0 also: identifier, title, description, series_name, language, created, license, rightsholder, is_part_of, source, status, agent_id, start, technical_start.&quot;, type = STRING),
          @RestParameter(name = &quot;sort&quot;, description = &quot;Sort the results based upon a list of comma seperated sorting criteria. In the comma seperated list each type of sorting is specified as a pair such as: &lt;Sort Name&gt;:ASC or &lt;Sort Name&gt;:DESC. Adding the suffix ASC or DESC sets the order as ascending or descending order and is mandatory.&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;limit&quot;, description = &quot;The maximum number of results to return for a single request.&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;offset&quot;, description = &quot;The index of the first result to return.&quot;, isRequired = false, type = RestParameter.Type.INTEGER) }, responses = {
                  @RestResponse(description = &quot;A (potentially empty) list of events is returned.&quot;, responseCode = HttpServletResponse.SC_OK) })
  public Response getEvents(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @QueryParam(&quot;id&quot;) String id,
          @QueryParam(&quot;commentReason&quot;) String reasonFilter, @QueryParam(&quot;commentResolution&quot;) String resolutionFilter,
          @QueryParam(&quot;filter&quot;) List&lt;String&gt; filter, @QueryParam(&quot;sort&quot;) String sort, @QueryParam(&quot;offset&quot;) Integer offset,
          @QueryParam(&quot;limit&quot;) Integer limit, @QueryParam(&quot;sign&quot;) boolean sign, @QueryParam(&quot;withacl&quot;) Boolean withAcl,
          @QueryParam(&quot;withmetadata&quot;) Boolean withMetadata, @QueryParam(&quot;withscheduling&quot;) Boolean withScheduling,
          @QueryParam(&quot;onlyWithWriteAccess&quot;) Boolean onlyWithWriteAccess, @QueryParam(&quot;withpublications&quot;) Boolean withPublications, @QueryParam(&quot;includeInternalPublication&quot;) Boolean includeInternalPublication) {
<span class="nc" id="L781">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
      // withscheduling was added for version 1.1.0 and should be ignored for smaller versions.
<span class="nc" id="L784">      withScheduling = false;</span>
    }

<span class="nc" id="L787">    Option&lt;Integer&gt; optLimit = Option.option(limit);</span>
<span class="nc" id="L788">    Option&lt;Integer&gt; optOffset = Option.option(offset);</span>
<span class="nc" id="L789">    Option&lt;String&gt; optSort = Option.option(trimToNull(sort));</span>
<span class="nc" id="L790">    EventSearchQuery query = new EventSearchQuery(getSecurityService().getOrganization().getId(),</span>
<span class="nc" id="L791">            getSecurityService().getUser());</span>
    // If the limit is set to 0, this is not taken into account
<span class="nc bnc" id="L793" title="All 4 branches missed.">    if (optLimit.isSome() &amp;&amp; limit == 0) {</span>
<span class="nc" id="L794">      optLimit = Option.none();</span>
    }

    //List of all events from the filters
<span class="nc" id="L798">    List&lt;IndexObject&gt; allEvents = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L800" title="All 2 branches missed.">    if (!isNullOrEmpty(filter)) {</span>
      // API version 1.5.0: Additive filter
<span class="nc bnc" id="L802" title="All 2 branches missed.">      if (!requestedVersion.isSmallerThan(ApiVersion.VERSION_1_5_0)) {</span>
<span class="nc" id="L803">        filter = filter.subList(0,1);</span>
      }
<span class="nc bnc" id="L805" title="All 2 branches missed.">      for (String filterPart : filter) {</span>
        // Parse the filters

<span class="nc bnc" id="L808" title="All 2 branches missed.">        for (String f : filterPart.split(&quot;,&quot;)) {</span>
<span class="nc" id="L809">          String[] filterTuple = f.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">          if (filterTuple.length &lt; 2) {</span>
<span class="nc" id="L811">            logger.debug(&quot;No value for filter {} in filters list: {}&quot;, filterTuple[0], filter);</span>
<span class="nc" id="L812">            continue;</span>
          }

<span class="nc" id="L815">          String name = filterTuple[0];</span>
          String value;

<span class="nc bnc" id="L818" title="All 2 branches missed.">          if (!requestedVersion.isSmallerThan(ApiVersion.VERSION_1_1_0)) {</span>
            // MH-13038 - 1.1.0 and higher support colons in values
<span class="nc" id="L820">            value = f.substring(name.length() + 1);</span>
          } else {
<span class="nc" id="L822">            value = filterTuple[1];</span>
          }

<span class="nc bnc" id="L825" title="All 2 branches missed.">          if (&quot;presenters&quot;.equals(name)) {</span>
<span class="nc" id="L826">            query.withPresenter(value);</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">          } else if (&quot;contributors&quot;.equals(name)) {</span>
<span class="nc" id="L828">            query.withContributor(value);</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">          } else if (&quot;location&quot;.equals(name)) {</span>
<span class="nc" id="L830">            query.withLocation(value);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">          } else if (&quot;textFilter&quot;.equals(name)) {</span>
<span class="nc" id="L832">            query.withText(QueryPreprocessor.sanitize(value));</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">          } else if (&quot;series&quot;.equals(name)) {</span>
<span class="nc" id="L834">            query.withSeriesId(value);</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">          } else if (&quot;subject&quot;.equals(name)) {</span>
<span class="nc" id="L836">            query.withSubject(value);</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">          } else if (!requestedVersion.isSmallerThan(ApiVersion.VERSION_1_1_0)) {</span>
            // additional filters only available with Version 1.1.0 or higher
<span class="nc bnc" id="L839" title="All 2 branches missed.">            if (&quot;identifier&quot;.equals(name)) {</span>
<span class="nc" id="L840">              query.withIdentifier(value);</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">            } else if (&quot;title&quot;.equals(name)) {</span>
<span class="nc" id="L842">              query.withTitle(value);</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">            } else if (&quot;description&quot;.equals(name)) {</span>
<span class="nc" id="L844">              query.withDescription(value);</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">            } else if (&quot;series_name&quot;.equals(name)) {</span>
<span class="nc" id="L846">              query.withSeriesName(value);</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">            } else if (&quot;language&quot;.equals(name)) {</span>
<span class="nc" id="L848">              query.withLanguage(value);</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">            } else if (&quot;created&quot;.equals(name)) {</span>
<span class="nc" id="L850">              query.withCreated(value);</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">            } else if (&quot;license&quot;.equals(name)) {</span>
<span class="nc" id="L852">              query.withLicense(value);</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">            } else if (&quot;rightsholder&quot;.equals(name)) {</span>
<span class="nc" id="L854">              query.withRights(value);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">            } else if (&quot;is_part_of&quot;.equals(name)) {</span>
<span class="nc" id="L856">              query.withSeriesId(value);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">            } else if (&quot;source&quot;.equals(name)) {</span>
<span class="nc" id="L858">              query.withSource(value);</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            } else if (&quot;status&quot;.equals(name)) {</span>
<span class="nc" id="L860">              query.withEventStatus(value);</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">            } else if (&quot;agent_id&quot;.equals(name)) {</span>
<span class="nc" id="L862">              query.withAgentId(value);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">            } else if (&quot;start&quot;.equals(name)) {</span>
              try {
<span class="nc" id="L865">                Tuple&lt;Date, Date&gt; fromAndToCreationRange = RestUtils.getFromAndToDateRange(value);</span>
<span class="nc" id="L866">                query.withStartFrom(fromAndToCreationRange.getA());</span>
<span class="nc" id="L867">                query.withStartTo(fromAndToCreationRange.getB());</span>
<span class="nc" id="L868">              } catch (Exception e) {</span>
<span class="nc" id="L869">                return RestUtil.R</span>
<span class="nc" id="L870">                        .badRequest(String.format(&quot;Filter 'start' could not be parsed: %s&quot;, e.getMessage()));</span>

<span class="nc" id="L872">              }</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">            } else if (&quot;technical_start&quot;.equals(name)) {</span>
              try {
<span class="nc" id="L875">                Tuple&lt;Date, Date&gt; fromAndToCreationRange = RestUtils.getFromAndToDateRange(value);</span>
<span class="nc" id="L876">                query.withTechnicalStartFrom(fromAndToCreationRange.getA());</span>
<span class="nc" id="L877">                query.withTechnicalStartTo(fromAndToCreationRange.getB());</span>
<span class="nc" id="L878">              } catch (Exception e) {</span>
<span class="nc" id="L879">                return RestUtil.R</span>
<span class="nc" id="L880">                        .badRequest(String.format(&quot;Filter 'technical_start' could not be parsed: %s&quot;, e.getMessage()));</span>

<span class="nc" id="L882">              }</span>
            } else {
<span class="nc" id="L884">              logger.warn(&quot;Unknown filter criteria {}&quot;, name);</span>
<span class="nc" id="L885">              return RestUtil.R.badRequest(String.format(&quot;Unknown filter criterion in request: %s&quot;, name));</span>

            }
          }
        }

<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (optSort.isSome()) {</span>
<span class="nc" id="L892">          ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(optSort.get());</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">          for (SortCriterion criterion : sortCriteria) {</span>

<span class="nc bnc" id="L895" title="All 11 branches missed.">            switch (criterion.getFieldName()) {</span>
              case EventIndexSchema.TITLE:
<span class="nc" id="L897">                query.sortByTitle(criterion.getOrder());</span>
<span class="nc" id="L898">                break;</span>
              case EventIndexSchema.PRESENTER:
<span class="nc" id="L900">                query.sortByPresenter(criterion.getOrder());</span>
<span class="nc" id="L901">                break;</span>
              case EventIndexSchema.TECHNICAL_START:
              case &quot;technical_date&quot;:
<span class="nc" id="L904">                query.sortByTechnicalStartDate(criterion.getOrder());</span>
<span class="nc" id="L905">                break;</span>
              case EventIndexSchema.TECHNICAL_END:
<span class="nc" id="L907">                query.sortByTechnicalEndDate(criterion.getOrder());</span>
<span class="nc" id="L908">                break;</span>
              case EventIndexSchema.START_DATE:
              case &quot;date&quot;:
<span class="nc" id="L911">                query.sortByStartDate(criterion.getOrder());</span>
<span class="nc" id="L912">                break;</span>
              case EventIndexSchema.END_DATE:
<span class="nc" id="L914">                query.sortByEndDate(criterion.getOrder());</span>
<span class="nc" id="L915">                break;</span>
              case EventIndexSchema.WORKFLOW_STATE:
<span class="nc" id="L917">                query.sortByWorkflowState(criterion.getOrder());</span>
<span class="nc" id="L918">                break;</span>
              case EventIndexSchema.SERIES_NAME:
<span class="nc" id="L920">                query.sortBySeriesName(criterion.getOrder());</span>
<span class="nc" id="L921">                break;</span>
              case EventIndexSchema.LOCATION:
<span class="nc" id="L923">                query.sortByLocation(criterion.getOrder());</span>
<span class="nc" id="L924">                break;</span>
              // For compatibility, we mimic to support the old review_status and scheduling_status sort criteria (MH-13407)
              case &quot;review_status&quot;:
              case &quot;scheduling_status&quot;:
<span class="nc" id="L928">                break;</span>
              default:
<span class="nc" id="L930">                return RestUtil.R.badRequest(String.format(&quot;Unknown sort criterion in request: %s&quot;, criterion.getFieldName()));</span>
            }
<span class="nc" id="L932">          }</span>
        }

        // TODO: Add the comment resolution filter to the query
<span class="nc bnc" id="L936" title="All 2 branches missed.">        if (StringUtils.isNotBlank(resolutionFilter)) {</span>
          try {
<span class="nc" id="L938">            CommentResolution.valueOf(resolutionFilter);</span>
<span class="nc" id="L939">          } catch (Exception e) {</span>
<span class="nc" id="L940">            logger.debug(&quot;Unable to parse comment resolution filter {}&quot;, resolutionFilter);</span>
<span class="nc" id="L941">            return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L942">          }</span>
        }

<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (optLimit.isSome())</span>
<span class="nc" id="L946">          query.withLimit(optLimit.get());</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">        if (optOffset.isSome())</span>
<span class="nc" id="L948">          query.withOffset(offset);</span>
        // TODO: Add other filters to the query

<span class="nc" id="L951">        SearchResult&lt;Event&gt; results = null;</span>
        try {
<span class="nc" id="L953">          results = elasticsearchIndex.getByQuery(query);</span>
<span class="nc" id="L954">        } catch (SearchIndexException e) {</span>
<span class="nc" id="L955">          logger.error(&quot;The External Search Index was not able to get the events list&quot;, e);</span>
<span class="nc" id="L956">          throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L957">        }</span>

<span class="nc" id="L959">        SearchResultItem&lt;Event&gt;[] items = results.getItems();</span>
<span class="nc" id="L960">        List&lt;IndexObject&gt; events = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">        for (SearchResultItem&lt;Event&gt; item : items) {</span>
<span class="nc" id="L962">          Event source = item.getSource();</span>
<span class="nc" id="L963">          source.updatePreview(previewSubtype);</span>
<span class="nc" id="L964">          events.add(source);</span>
        }
        //Append  filtered results to the list
<span class="nc" id="L967">        allEvents.addAll(events);</span>
<span class="nc" id="L968">      }</span>
    } else {
<span class="nc bnc" id="L970" title="All 2 branches missed.">      if (optSort.isSome()) {</span>
<span class="nc" id="L971">        ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(optSort.get());</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">        for (SortCriterion criterion : sortCriteria) {</span>

<span class="nc bnc" id="L974" title="All 11 branches missed.">          switch (criterion.getFieldName()) {</span>
            case EventIndexSchema.TITLE:
<span class="nc" id="L976">              query.sortByTitle(criterion.getOrder());</span>
<span class="nc" id="L977">              break;</span>
            case EventIndexSchema.PRESENTER:
<span class="nc" id="L979">              query.sortByPresenter(criterion.getOrder());</span>
<span class="nc" id="L980">              break;</span>
            case EventIndexSchema.TECHNICAL_START:
            case &quot;technical_date&quot;:
<span class="nc" id="L983">              query.sortByTechnicalStartDate(criterion.getOrder());</span>
<span class="nc" id="L984">              break;</span>
            case EventIndexSchema.TECHNICAL_END:
<span class="nc" id="L986">              query.sortByTechnicalEndDate(criterion.getOrder());</span>
<span class="nc" id="L987">              break;</span>
            case EventIndexSchema.START_DATE:
            case &quot;date&quot;:
<span class="nc" id="L990">              query.sortByStartDate(criterion.getOrder());</span>
<span class="nc" id="L991">              break;</span>
            case EventIndexSchema.END_DATE:
<span class="nc" id="L993">              query.sortByEndDate(criterion.getOrder());</span>
<span class="nc" id="L994">              break;</span>
            case EventIndexSchema.WORKFLOW_STATE:
<span class="nc" id="L996">              query.sortByWorkflowState(criterion.getOrder());</span>
<span class="nc" id="L997">              break;</span>
            case EventIndexSchema.SERIES_NAME:
<span class="nc" id="L999">              query.sortBySeriesName(criterion.getOrder());</span>
<span class="nc" id="L1000">              break;</span>
            case EventIndexSchema.LOCATION:
<span class="nc" id="L1002">              query.sortByLocation(criterion.getOrder());</span>
<span class="nc" id="L1003">              break;</span>
            // For compatibility, we mimic to support the old review_status and scheduling_status sort criteria (MH-13407)
            case &quot;review_status&quot;:
            case &quot;scheduling_status&quot;:
<span class="nc" id="L1007">              break;</span>
            default:
<span class="nc" id="L1009">              return RestUtil.R.badRequest(String.format(&quot;Unknown sort criterion in request: %s&quot;, criterion.getFieldName()));</span>
          }
<span class="nc" id="L1011">        }</span>
      }

      // TODO: Add the comment resolution filter to the query
<span class="nc bnc" id="L1015" title="All 2 branches missed.">      if (StringUtils.isNotBlank(resolutionFilter)) {</span>
        try {
<span class="nc" id="L1017">          CommentResolution.valueOf(resolutionFilter);</span>
<span class="nc" id="L1018">        } catch (Exception e) {</span>
<span class="nc" id="L1019">          logger.debug(&quot;Unable to parse comment resolution filter {}&quot;, resolutionFilter);</span>
<span class="nc" id="L1020">          return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L1021">        }</span>
      }

<span class="nc bnc" id="L1024" title="All 2 branches missed.">      if (optLimit.isSome())</span>
<span class="nc" id="L1025">        query.withLimit(optLimit.get());</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">      if (optOffset.isSome())</span>
<span class="nc" id="L1027">        query.withOffset(offset);</span>

<span class="nc bnc" id="L1029" title="All 4 branches missed.">      if (onlyWithWriteAccess != null &amp;&amp; onlyWithWriteAccess) {</span>
<span class="nc" id="L1030">        query.withoutActions();</span>
<span class="nc" id="L1031">        query.withAction(Permissions.Action.WRITE);</span>
      }
      // TODO: Add other filters to the query

<span class="nc" id="L1035">      SearchResult&lt;Event&gt; results = null;</span>
      try {
<span class="nc" id="L1037">        results = elasticsearchIndex.getByQuery(query);</span>
<span class="nc" id="L1038">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L1039">        logger.error(&quot;The External Search Index was not able to get the events list&quot;, e);</span>
<span class="nc" id="L1040">        throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L1041">      }</span>

<span class="nc" id="L1043">      SearchResultItem&lt;Event&gt;[] items = results.getItems();</span>
<span class="nc" id="L1044">      List&lt;IndexObject&gt; events = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">      for (SearchResultItem&lt;Event&gt; item : items) {</span>
<span class="nc" id="L1046">        Event source = item.getSource();</span>
<span class="nc" id="L1047">        source.updatePreview(previewSubtype);</span>
<span class="nc" id="L1048">        events.add(source);</span>
      }
      //Append  filtered results to the list
<span class="nc" id="L1051">      allEvents.addAll(events);</span>
    }
    try {
<span class="nc" id="L1054">      return getJsonEvents(</span>
<span class="nc" id="L1055">          acceptHeader, allEvents, withAcl, withMetadata, withScheduling, withPublications, includeInternalPublication, sign, requestedVersion);</span>
<span class="nc" id="L1056">    } catch (Exception e) {</span>
<span class="nc" id="L1057">      logger.error(&quot;Unable to get events&quot;, e);</span>
<span class="nc" id="L1058">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Render a collection of {@link Event}s into a json array.
   *
   * @param acceptHeader
   *          The accept header to return to the client.
   * @param events
   *          The {@link List} of {@link Event}s to render into json.
   * @param withAcl
   *          Whether to include the events' ACLs.
   * @param withMetadata
   *          Whether to include the events' metadata.
   * @param withScheduling
   *          Whether to include the events' scheduling information.
   * @param withPublications
   *          Whether to include the events' publications.
   * @param withSignedUrls
   *          Whether to sign the included urls.
   * @return A {@link Response} with the accept header and body as the Json array of {@link Event}s.
   * @throws IndexServiceException
   * @throws SchedulerException
   * @throws UnauthorizedException
   */
  protected Response getJsonEvents(String acceptHeader, List&lt;IndexObject&gt; events, Boolean withAcl, Boolean withMetadata,
          Boolean withScheduling, Boolean withPublications,Boolean includeInternalPublication, Boolean withSignedUrls, ApiVersion requestedVersion)
      throws IndexServiceException, UnauthorizedException, SchedulerException {
<span class="nc" id="L1087">    List&lt;JValue&gt; eventsList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">    for (IndexObject item : events) {</span>
<span class="nc" id="L1089">      eventsList.add(eventToJSON((Event) item, withAcl, withMetadata, withScheduling, withPublications, includeInternalPublication, withSignedUrls,</span>
              requestedVersion));
<span class="nc" id="L1091">    }</span>
<span class="nc" id="L1092">    return ApiResponseBuilder.Json.ok(requestedVersion, arr(eventsList));</span>
  }

  /**
   * Transform an {@link Event} to Json
   *
   * @param event
   *          The event to transform into json
   * @param withAcl
   *          Whether to add the acl information for the event
   * @param withMetadata
   *          Whether to add all the metadata for the event
   * @param withScheduling
   *          Whether to add the scheduling information for the event
   * @param withPublications
   *          Whether to add the publications
   * @param withSignedUrls
   *          Whether to sign the urls if they are protected by stream security.
   * @return The event in json format.
   * @throws IndexServiceException
   *           Thrown if unable to get the metadata for the event.
   * @throws SchedulerException
   * @throws UnauthorizedException
   */
  protected JValue eventToJSON(Event event, Boolean withAcl, Boolean withMetadata, Boolean withScheduling,
          Boolean withPublications, Boolean includeInternalPublication, Boolean withSignedUrls, ApiVersion requestedVersion) throws IndexServiceException, SchedulerException, UnauthorizedException {
<span class="nc" id="L1118">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">    if (event.getArchiveVersion() != null)</span>
<span class="nc" id="L1120">      fields.add(f(&quot;archive_version&quot;, v(event.getArchiveVersion())));</span>
<span class="nc" id="L1121">    fields.add(f(&quot;created&quot;, v(event.getCreated(), Jsons.BLANK)));</span>
<span class="nc" id="L1122">    fields.add(f(&quot;creator&quot;, v(event.getCreator(), Jsons.BLANK)));</span>
<span class="nc" id="L1123">    fields.add(f(&quot;contributor&quot;, arr($(event.getContributors()).map(Functions.stringToJValue))));</span>
<span class="nc" id="L1124">    fields.add(f(&quot;description&quot;, v(event.getDescription(), Jsons.BLANK)));</span>
<span class="nc" id="L1125">    fields.add(f(&quot;has_previews&quot;, v(event.hasPreview())));</span>
<span class="nc" id="L1126">    fields.add(f(&quot;identifier&quot;, v(event.getIdentifier(), BLANK)));</span>
<span class="nc" id="L1127">    fields.add(f(&quot;location&quot;, v(event.getLocation(), BLANK)));</span>
<span class="nc" id="L1128">    fields.add(f(&quot;presenter&quot;, arr($(event.getPresenters()).map(Functions.stringToJValue))));</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">    if (!requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
<span class="nc" id="L1130">      fields.add(f(&quot;language&quot;, v(event.getLanguage(), BLANK)));</span>
<span class="nc" id="L1131">      fields.add(f(&quot;rightsholder&quot;, v(event.getRights(), BLANK)));</span>
<span class="nc" id="L1132">      fields.add(f(&quot;license&quot;, v(event.getLicense(), BLANK)));</span>
<span class="nc" id="L1133">      fields.add(f(&quot;is_part_of&quot;, v(event.getSeriesId(), BLANK)));</span>
<span class="nc" id="L1134">      fields.add(f(&quot;series&quot;, v(event.getSeriesName(),BLANK)));</span>
<span class="nc" id="L1135">      fields.add(f(&quot;source&quot;, v(event.getSource(), BLANK)));</span>
<span class="nc" id="L1136">      fields.add(f(&quot;status&quot;, v(event.getEventStatus(), BLANK)));</span>
    }
<span class="nc" id="L1138">    List&lt;JValue&gt; publicationIds = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">    if (event.getPublications() != null) {</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">      for (Publication publication : event.getPublications()) {</span>
<span class="nc" id="L1141">        publicationIds.add(v(publication.getChannel()));</span>
<span class="nc" id="L1142">      }</span>
    }
<span class="nc" id="L1144">    fields.add(f(&quot;publication_status&quot;, arr(publicationIds)));</span>
<span class="nc" id="L1145">    fields.add(f(&quot;processing_state&quot;, v(event.getWorkflowState(), BLANK)));</span>

<span class="nc bnc" id="L1147" title="All 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_4_0)) {</span>
<span class="nc" id="L1148">      fields.add(f(&quot;start&quot;, v(event.getTechnicalStartTime(), BLANK)));</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">      if (event.getTechnicalEndTime() != null) {</span>
<span class="nc" id="L1150">        long duration = new DateTime(event.getTechnicalEndTime()).getMillis()</span>
<span class="nc" id="L1151">                - new DateTime(event.getTechnicalStartTime()).getMillis();</span>
<span class="nc" id="L1152">        fields.add(f(&quot;duration&quot;, v(duration)));</span>
<span class="nc" id="L1153">      }</span>
    } else {
<span class="nc" id="L1155">      fields.add(f(&quot;start&quot;, v(event.getRecordingStartDate(), BLANK)));</span>
<span class="nc" id="L1156">      fields.add(f(&quot;duration&quot;, v(event.getDuration(), NULL)));</span>
    }

<span class="nc bnc" id="L1159" title="All 2 branches missed.">    if (StringUtils.trimToNull(event.getSubject()) != null) {</span>
<span class="nc" id="L1160">      fields.add(f(&quot;subjects&quot;, arr(splitSubjectIntoArray(event.getSubject()))));</span>
    } else {
<span class="nc" id="L1162">      fields.add(f(&quot;subjects&quot;, arr()));</span>
    }
<span class="nc" id="L1164">    fields.add(f(&quot;title&quot;, v(event.getTitle(), BLANK)));</span>
<span class="nc bnc" id="L1165" title="All 4 branches missed.">    if (withAcl != null &amp;&amp; withAcl) {</span>
<span class="nc" id="L1166">      AccessControlList acl = getAclFromEvent(event);</span>
<span class="nc" id="L1167">      fields.add(f(&quot;acl&quot;, arr(AclUtils.serializeAclToJson(acl))));</span>
    }
<span class="nc bnc" id="L1169" title="All 4 branches missed.">    if (withMetadata != null &amp;&amp; withMetadata) {</span>
      try {
<span class="nc" id="L1171">        Opt&lt;MetadataList&gt; metadata = getEventMetadata(event);</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">        if (metadata.isSome()) {</span>
<span class="nc" id="L1173">          fields.add(f(&quot;metadata&quot;, MetadataJson.listToJson(metadata.get(), true)));</span>
        }
<span class="nc" id="L1175">      } catch (Exception e) {</span>
<span class="nc" id="L1176">        logger.error(&quot;Unable to get metadata for event '{}'&quot;, event.getIdentifier(), e);</span>
<span class="nc" id="L1177">        throw new IndexServiceException(&quot;Unable to add metadata to event&quot;, e);</span>
<span class="nc" id="L1178">      }</span>
    }
<span class="nc bnc" id="L1180" title="All 4 branches missed.">    if (withScheduling != null &amp;&amp; withScheduling) {</span>
<span class="nc" id="L1181">      fields.add(f(&quot;scheduling&quot;, SchedulingInfo.of(event.getIdentifier(), schedulerService).toJson()));</span>
    }
<span class="nc bnc" id="L1183" title="All 4 branches missed.">    if (withPublications != null &amp;&amp; withPublications) {</span>
<span class="nc" id="L1184">      List&lt;JValue&gt; publications = getPublications(event, withSignedUrls, includeInternalPublication,requestedVersion);</span>
<span class="nc" id="L1185">      fields.add(f(&quot;publications&quot;, arr(publications)));</span>
    }
<span class="nc" id="L1187">    return obj(fields);</span>
  }

  private List&lt;JValue&gt; splitSubjectIntoArray(final String subject) {
<span class="nc" id="L1191">    return com.entwinemedia.fn.Stream.$(subject.split(&quot;,&quot;)).map(new Fn&lt;String, JValue&gt;() {</span>
      @Override
      public JValue apply(String a) {
<span class="nc" id="L1194">        return v(a.trim());</span>
      }
<span class="nc" id="L1196">    }).toList();</span>
  }

  @GET
  @Path(&quot;{eventId}/acl&quot;)
  @RestQuery(name = &quot;geteventacl&quot;, description = &quot;Returns an event's access policy.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
                  @RestResponse(description = &quot;The access control list for the specified event is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventAcl(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
          throws Exception {
<span class="nc bnc" id="L1207" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L1208">      AccessControlList acl = getAclFromEvent(event);</span>
<span class="nc" id="L1209">      return ApiResponseBuilder.Json.ok(acceptHeader, arr(AclUtils.serializeAclToJson(acl)));</span>
    }
<span class="nc" id="L1211">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @PUT
  @Path(&quot;{eventId}/acl&quot;)
  @RestQuery(name = &quot;updateeventacl&quot;, description = &quot;Update an event's access policy.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;acl&quot;, isRequired = true, description = &quot;Access policy&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The access control list for the specified event is updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventAcl(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @FormParam(&quot;acl&quot;) String acl) throws Exception {
<span class="nc bnc" id="L1223" title="All 2 branches missed.">    if (indexService.getEvent(id, elasticsearchIndex).isSome()) {</span>
      AccessControlList accessControlList;
      try {
<span class="nc" id="L1226">        accessControlList = AclUtils.deserializeJsonToAcl(acl, false);</span>
<span class="nc" id="L1227">      } catch (ParseException e) {</span>
<span class="nc" id="L1228">        logger.debug(&quot;Unable to update event acl to '{}'&quot;, acl, e);</span>
<span class="nc" id="L1229">        return R.badRequest(String.format(&quot;Unable to parse acl '%s' because '%s'&quot;, acl, e.getMessage()));</span>
<span class="nc" id="L1230">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1231">        logger.debug(&quot;Unable to update event acl to '{}'&quot;, acl, e);</span>
<span class="nc" id="L1232">        return R.badRequest(e.getMessage());</span>
<span class="nc" id="L1233">      }</span>
      try {
<span class="nc" id="L1235">        accessControlList = indexService.updateEventAcl(id, accessControlList, elasticsearchIndex);</span>
<span class="nc" id="L1236">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1237">        logger.error(&quot;Unable to update event '{}' acl with '{}'&quot;, id, acl, e);</span>
<span class="nc" id="L1238">        return Response.status(Status.FORBIDDEN).build();</span>
<span class="nc" id="L1239">      }</span>
<span class="nc" id="L1240">      return Response.noContent().build();</span>
    } else {
<span class="nc" id="L1242">      return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
    }
  }

  @POST
  @Path(&quot;{eventId}/acl/{action}&quot;)
  @RestQuery(name = &quot;addeventace&quot;, description = &quot;Grants permission to execute action on the specified event to any user with role role. Note that this is a convenience method to avoid having to build and post a complete access control list.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;action&quot;, description = &quot;The action that is allowed to be executed&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;role&quot;, isRequired = true, description = &quot;The role that is granted permission&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The permission has been created in the access control list of the specified event.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response addEventAce(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @PathParam(&quot;action&quot;) String action, @FormParam(&quot;role&quot;) String role) throws Exception {
<span class="nc" id="L1256">    List&lt;AccessControlEntry&gt; entries = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L1258">      AccessControlList accessControlList = getAclFromEvent(event);</span>
<span class="nc" id="L1259">      AccessControlEntry newAce = new AccessControlEntry(role, action, true);</span>
<span class="nc" id="L1260">      boolean alreadyInAcl = false;</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">      for (AccessControlEntry ace : accessControlList.getEntries()) {</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">        if (ace.equals(newAce)) {</span>
          // We have found an identical access control entry so just return.
<span class="nc" id="L1264">          entries = accessControlList.getEntries();</span>
<span class="nc" id="L1265">          alreadyInAcl = true;</span>
<span class="nc" id="L1266">          break;</span>
<span class="nc bnc" id="L1267" title="All 4 branches missed.">        } else if (ace.getAction().equals(newAce.getAction()) &amp;&amp; ace.getRole().equals(newAce.getRole())</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">                &amp;&amp; !ace.isAllow()) {</span>
<span class="nc" id="L1269">          entries.add(newAce);</span>
<span class="nc" id="L1270">          alreadyInAcl = true;</span>
        } else {
<span class="nc" id="L1272">          entries.add(ace);</span>
        }
<span class="nc" id="L1274">      }</span>

<span class="nc bnc" id="L1276" title="All 2 branches missed.">      if (!alreadyInAcl) {</span>
<span class="nc" id="L1277">        entries.add(newAce);</span>
      }

<span class="nc" id="L1280">      AccessControlList withNewAce = new AccessControlList(entries);</span>
      try {
<span class="nc" id="L1282">        withNewAce = indexService.updateEventAcl(id, withNewAce, elasticsearchIndex);</span>
<span class="nc" id="L1283">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1284">        logger.error(&quot;Unable to update event '{}' acl entry with action '{}' and role '{}'&quot;, id, action, role, e);</span>
<span class="nc" id="L1285">        return Response.status(Status.FORBIDDEN).build();</span>
<span class="nc" id="L1286">      }</span>
<span class="nc" id="L1287">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1289">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @DELETE
  @Path(&quot;{eventId}/acl/{action}/{role}&quot;)
  @RestQuery(name = &quot;deleteeventace&quot;, description = &quot;Revokes permission to execute action on the specified event from any user with role role.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;action&quot;, description = &quot;The action that is no longer allowed to be executed&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;role&quot;, description = &quot;The role that is no longer granted permission&quot;, isRequired = true, type = STRING) }, responses = {
                  @RestResponse(description = &quot;The permission has been revoked from the access control list of the specified event.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteEventAce(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @PathParam(&quot;action&quot;) String action, @PathParam(&quot;role&quot;) String role) throws Exception {
<span class="nc" id="L1302">    List&lt;AccessControlEntry&gt; entries = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L1304">      AccessControlList accessControlList = getAclFromEvent(event);</span>
<span class="nc" id="L1305">      boolean foundDelete = false;</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">      for (AccessControlEntry ace : accessControlList.getEntries()) {</span>
<span class="nc bnc" id="L1307" title="All 4 branches missed.">        if (ace.getAction().equals(action) &amp;&amp; ace.getRole().equals(role)) {</span>
<span class="nc" id="L1308">          foundDelete = true;</span>
        } else {
<span class="nc" id="L1310">          entries.add(ace);</span>
        }
<span class="nc" id="L1312">      }</span>

<span class="nc bnc" id="L1314" title="All 2 branches missed.">      if (!foundDelete) {</span>
<span class="nc" id="L1315">        return ApiResponseBuilder.notFound(&quot;Unable to find an access control entry with action '%s' and role '%s'&quot;, action,</span>
                role);
      }

<span class="nc" id="L1319">      AccessControlList withoutDeleted = new AccessControlList(entries);</span>
      try {
<span class="nc" id="L1321">        withoutDeleted = indexService.updateEventAcl(id, withoutDeleted, elasticsearchIndex);</span>
<span class="nc" id="L1322">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1323">        logger.error(&quot;Unable to delete event's '{}' acl entry with action '{}' and role '{}'&quot;, id, action, role, e);</span>
<span class="nc" id="L1324">        return Response.status(Status.FORBIDDEN).build();</span>
<span class="nc" id="L1325">      }</span>
<span class="nc" id="L1326">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1328">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @GET
  @Path(&quot;{eventId}/metadata&quot;)
  @RestQuery(name = &quot;geteventmetadata&quot;, description = &quot;Returns the event's metadata of the specified type. For a metadata catalog there is the flavor such as 'dublincore/episode' and this is the unique type.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = false, description = &quot;The type of metadata to get&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The metadata collection is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getAllEventMetadata(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type) throws Exception {
<span class="fc" id="L1340">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="pc bpc" id="L1341" title="1 of 2 branches missed.">    if (StringUtils.trimToNull(type) == null) {</span>
<span class="fc" id="L1342">      Opt&lt;MetadataList&gt; metadataList = getEventMetadataById(id);</span>
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">      if (metadataList.isSome()) {</span>
<span class="fc" id="L1344">        MetadataList actualList = metadataList.get();</span>

        // API v1 should return a two separate fields for start date and start time. Since those fields were merged in index service, we have to split them up.
<span class="fc" id="L1347">        final DublinCoreMetadataCollection collection = actualList.getMetadataByFlavor(&quot;dublincore/episode&quot;);</span>
<span class="pc bpc" id="L1348" title="1 of 2 branches missed.">        final boolean withOrderedText = collection == null;</span>
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">        if (collection != null) {</span>
<span class="fc" id="L1350">          convertStartDateTimeToApiV1(collection);</span>
        }

<span class="fc" id="L1353">        return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.listToJson(actualList, withOrderedText));</span>
      }
      else
<span class="nc" id="L1356">        return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
    } else {
<span class="nc" id="L1358">      return getEventMetadataByType(id, type, requestedVersion);</span>
    }
  }

  private void convertStartDateTimeToApiV1(DublinCoreMetadataCollection collection) throws java.text.ParseException {

<span class="pc bpc" id="L1364" title="1 of 2 branches missed.">    if (!collection.getOutputFields().containsKey(&quot;startDate&quot;)) return;</span>

<span class="fc" id="L1366">    MetadataField oldStartDateField = collection.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="fc" id="L1367">    SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(oldStartDateField.getPattern());</span>
<span class="fc" id="L1368">    Date startDate = sdf.parse((String) oldStartDateField.getValue());</span>

<span class="pc bpc" id="L1370" title="1 of 2 branches missed.">    if (configuredMetadataFields.containsKey(&quot;startDate&quot;)) {</span>
<span class="fc" id="L1371">      MetadataField startDateField = configuredMetadataFields.get(&quot;startDate&quot;);</span>
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">      final String pattern = startDateField.getPattern() == null ? &quot;yyyy-MM-dd&quot; : startDateField.getPattern();</span>
<span class="fc" id="L1373">      startDateField = new MetadataField(startDateField);</span>
<span class="fc" id="L1374">      startDateField.setPattern(pattern);</span>
<span class="fc" id="L1375">      sdf.applyPattern(startDateField.getPattern());</span>
<span class="fc" id="L1376">      startDateField.setValue(sdf.format(startDate));</span>
<span class="fc" id="L1377">      collection.removeField(oldStartDateField);</span>
<span class="fc" id="L1378">      collection.addField(startDateField);</span>
    }

<span class="pc bpc" id="L1381" title="1 of 2 branches missed.">    if (configuredMetadataFields.containsKey(&quot;startTime&quot;)) {</span>
<span class="fc" id="L1382">      MetadataField startTimeField = configuredMetadataFields.get(&quot;startTime&quot;);</span>
<span class="pc bpc" id="L1383" title="1 of 2 branches missed.">      final String pattern = startTimeField.getPattern() == null ? &quot;HH:mm&quot; : startTimeField.getPattern();</span>
<span class="fc" id="L1384">      startTimeField = new MetadataField(startTimeField);</span>
<span class="fc" id="L1385">      startTimeField.setPattern(pattern);</span>
<span class="fc" id="L1386">      sdf.applyPattern(startTimeField.getPattern());</span>
<span class="fc" id="L1387">      startTimeField.setValue(sdf.format(startDate));</span>
<span class="fc" id="L1388">      collection.addField(startTimeField);</span>
    }
<span class="fc" id="L1390">  }</span>

  protected Opt&lt;MetadataList&gt; getEventMetadataById(String id) throws IndexServiceException, Exception {
<span class="pc bpc" id="L1393" title="1 of 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="fc" id="L1394">      return getEventMetadata(event);</span>
    }
<span class="nc" id="L1396">    return Opt.&lt;MetadataList&gt; none();</span>
  }

  protected Opt&lt;MetadataList&gt; getEventMetadata(Event event) throws IndexServiceException, Exception {
<span class="fc" id="L1400">    MetadataList metadataList = new MetadataList();</span>
<span class="fc" id="L1401">    List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = getEventCatalogUIAdapters();</span>
<span class="fc" id="L1402">    EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="fc" id="L1403">    catalogUIAdapters.remove(eventCatalogUIAdapter);</span>
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">    if (catalogUIAdapters.size() &gt; 0) {</span>
<span class="fc" id="L1405">      MediaPackage mediaPackage = indexService.getEventMediapackage(event);</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">      for (EventCatalogUIAdapter catalogUIAdapter : catalogUIAdapters) {</span>
        // TODO: This is very slow:
<span class="fc" id="L1408">        DublinCoreMetadataCollection fields = catalogUIAdapter.getFields(mediaPackage);</span>
<span class="pc bpc" id="L1409" title="1 of 2 branches missed.">        if (fields != null) {</span>
<span class="nc" id="L1410">          ExternalMetadataUtils.removeCollectionList(fields);</span>
<span class="nc" id="L1411">          metadataList.add(catalogUIAdapter, fields);</span>
        }
<span class="fc" id="L1413">      }</span>
    }
<span class="fc" id="L1415">    DublinCoreMetadataCollection collection = EventUtils.getEventMetadata(event, eventCatalogUIAdapter,</span>
        new EmptyResourceListQuery());
<span class="fc" id="L1417">    ExternalMetadataUtils.changeSubjectToSubjects(collection);</span>
<span class="fc" id="L1418">    ExternalMetadataUtils.removeCollectionList(collection);</span>
<span class="fc" id="L1419">    metadataList.add(eventCatalogUIAdapter, collection);</span>
<span class="pc bpc" id="L1420" title="1 of 2 branches missed.">    if (WorkflowInstance.WorkflowState.RUNNING.toString().equals(event.getWorkflowState())) {</span>
<span class="nc" id="L1421">      metadataList.setLocked(Locked.WORKFLOW_RUNNING);</span>
    }
<span class="fc" id="L1423">    return Opt.some(metadataList);</span>
  }

  private Opt&lt;MediaPackageElementFlavor&gt; getFlavor(String flavorString) {
    try {
<span class="fc" id="L1428">      MediaPackageElementFlavor flavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>
<span class="fc" id="L1429">      return Opt.some(flavor);</span>
<span class="nc" id="L1430">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1431">      return Opt.none();</span>
    }
  }

  private Response getEventMetadataByType(String id, String type, ApiVersion requestedVersion) throws Exception {
<span class="nc bnc" id="L1436" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L1437">      Opt&lt;MediaPackageElementFlavor&gt; flavor = getFlavor(type);</span>
<span class="nc bnc" id="L1438" title="All 2 branches missed.">      if (flavor.isNone()) {</span>
<span class="nc" id="L1439">        return R.badRequest(</span>
<span class="nc" id="L1440">                String.format(&quot;Unable to parse type '%s' as a flavor so unable to find the matching catalog.&quot;, type));</span>
      }
      // Try the main catalog first as we load it from the index.
<span class="nc" id="L1443">      EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">      if (flavor.get().equals(eventCatalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1445">        DublinCoreMetadataCollection collection = EventUtils.getEventMetadata(event, eventCatalogUIAdapter,</span>
            new EmptyResourceListQuery());
<span class="nc" id="L1447">        ExternalMetadataUtils.changeSubjectToSubjects(collection);</span>
<span class="nc" id="L1448">        ExternalMetadataUtils.removeCollectionList(collection);</span>
<span class="nc" id="L1449">        convertStartDateTimeToApiV1(collection);</span>
<span class="nc" id="L1450">        return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.collectionToJson(collection, false));</span>
      }
      // Try the other catalogs
<span class="nc" id="L1453">      List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = getEventCatalogUIAdapters();</span>
<span class="nc" id="L1454">      catalogUIAdapters.remove(eventCatalogUIAdapter);</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">      if (catalogUIAdapters.size() &gt; 0) {</span>
<span class="nc" id="L1456">        MediaPackage mediaPackage = indexService.getEventMediapackage(event);</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">        for (EventCatalogUIAdapter catalogUIAdapter : catalogUIAdapters) {</span>
<span class="nc bnc" id="L1458" title="All 2 branches missed.">          if (flavor.get().equals(catalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1459">            DublinCoreMetadataCollection fields = catalogUIAdapter.getFields(mediaPackage);</span>
<span class="nc" id="L1460">            ExternalMetadataUtils.removeCollectionList(fields);</span>
<span class="nc" id="L1461">            convertStartDateTimeToApiV1(fields);</span>
<span class="nc" id="L1462">            return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.collectionToJson(fields, false));</span>
          }
<span class="nc" id="L1464">        }</span>
      }
<span class="nc" id="L1466">      return ApiResponseBuilder.notFound(&quot;Cannot find a catalog with type '%s' for event with id '%s'.&quot;, type, id);</span>
    }
<span class="nc" id="L1468">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @PUT
  @Path(&quot;{eventId}/metadata&quot;)
  @RestQuery(name = &quot;updateeventmetadata&quot;, description = &quot;Update the metadata with the matching type of the specified event. For a metadata catalog there is the flavor such as 'dublincore/episode' and this is the unique type.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = true, description = &quot;The type of metadata to update&quot;, type = STRING),
                  @RestParameter(name = &quot;metadata&quot;, description = &quot;Metadata catalog in JSON format&quot;, isRequired = true, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The metadata of the given namespace has been updated.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The request is invalid or inconsistent.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventMetadataByType(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type, @FormParam(&quot;metadata&quot;) String metadataJSON) throws Exception {
    Map&lt;String, String&gt; updatedFields;
<span class="fc" id="L1483">    JSONParser parser = new JSONParser();</span>
    try {
<span class="fc" id="L1485">      updatedFields = RequestUtils.getKeyValueMap(metadataJSON);</span>
<span class="nc" id="L1486">    } catch (ParseException e) {</span>
<span class="nc" id="L1487">      logger.debug(&quot;Unable to update event '{}' with metadata type '{}' and content '{}'&quot;, id, type, metadataJSON, e);</span>
<span class="nc" id="L1488">      return RestUtil.R.badRequest(String.format(&quot;Unable to parse metadata fields as json from '%s'&quot;, metadataJSON));</span>
<span class="nc" id="L1489">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1490">      logger.debug(&quot;Unable to update event '{}' with metadata type '{}' and content '{}'&quot;, id, type, metadataJSON, e);</span>
<span class="nc" id="L1491">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="fc" id="L1492">    }</span>

<span class="pc bpc" id="L1494" title="2 of 4 branches missed.">    if (updatedFields == null || updatedFields.size() == 0) {</span>
<span class="nc" id="L1495">      return RestUtil.R.badRequest(</span>
<span class="nc" id="L1496">              String.format(&quot;Unable to parse metadata fields as json from '%s' because there were no fields to update.&quot;,</span>
                      metadataJSON));
    }

<span class="fc" id="L1500">    Opt&lt;MediaPackageElementFlavor&gt; flavor = getFlavor(type);</span>
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">    if (flavor.isNone()) {</span>
<span class="nc" id="L1502">      return R.badRequest(</span>
<span class="nc" id="L1503">              String.format(&quot;Unable to parse type '%s' as a flavor so unable to find the matching catalog.&quot;, type));</span>
    }

<span class="fc" id="L1506">    DublinCoreMetadataCollection collection = null;</span>
<span class="fc" id="L1507">    EventCatalogUIAdapter adapter = null;</span>
<span class="pc bpc" id="L1508" title="1 of 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="fc" id="L1509">      MetadataList metadataList = new MetadataList();</span>
      // Try the main catalog first as we load it from the index.
<span class="fc" id="L1511">      EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="pc bpc" id="L1512" title="1 of 2 branches missed.">      if (flavor.get().equals(eventCatalogUIAdapter.getFlavor())) {</span>
<span class="fc" id="L1513">        collection = EventUtils.getEventMetadata(event, eventCatalogUIAdapter);</span>
<span class="fc" id="L1514">        adapter = eventCatalogUIAdapter;</span>
      } else {
<span class="nc" id="L1516">        metadataList.add(eventCatalogUIAdapter, EventUtils.getEventMetadata(event, eventCatalogUIAdapter));</span>
      }

      // Try the other catalogs
<span class="fc" id="L1520">      List&lt;EventCatalogUIAdapter&gt; catalogUIAdapters = getEventCatalogUIAdapters();</span>
<span class="fc" id="L1521">      catalogUIAdapters.remove(eventCatalogUIAdapter);</span>
<span class="pc bpc" id="L1522" title="1 of 2 branches missed.">      if (catalogUIAdapters.size() &gt; 0) {</span>
<span class="fc" id="L1523">        MediaPackage mediaPackage = indexService.getEventMediapackage(event);</span>
<span class="fc bfc" id="L1524" title="All 2 branches covered.">        for (EventCatalogUIAdapter catalogUIAdapter : catalogUIAdapters) {</span>
<span class="pc bpc" id="L1525" title="1 of 2 branches missed.">          if (flavor.get().equals(catalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1526">            collection = catalogUIAdapter.getFields(mediaPackage);</span>
<span class="nc" id="L1527">            adapter = eventCatalogUIAdapter;</span>
          } else {
<span class="fc" id="L1529">            metadataList.add(catalogUIAdapter, catalogUIAdapter.getFields(mediaPackage));</span>
          }
<span class="fc" id="L1531">        }</span>
      }

<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">      if (collection == null) {</span>
<span class="nc" id="L1535">        return ApiResponseBuilder.notFound(&quot;Cannot find a catalog with type '%s' for event with id '%s'.&quot;, type, id);</span>
      }

<span class="fc bfc" id="L1538" title="All 2 branches covered.">      for (String key : updatedFields.keySet()) {</span>
<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">        if (&quot;subjects&quot;.equals(key)) {</span>
<span class="nc" id="L1540">          MetadataField field = collection.getOutputFields().get(DublinCore.PROPERTY_SUBJECT.getLocalName());</span>
<span class="nc" id="L1541">          Opt&lt;Response&gt; error = validateField(field, key, id, type, updatedFields);</span>
<span class="nc bnc" id="L1542" title="All 2 branches missed.">          if (error.isSome()) {</span>
<span class="nc" id="L1543">            return error.get();</span>
          }
<span class="nc" id="L1545">          collection.removeField(field);</span>
<span class="nc" id="L1546">          JSONArray subjectArray = (JSONArray) parser.parse(updatedFields.get(key));</span>
<span class="nc" id="L1547">          collection.addField(</span>
<span class="nc" id="L1548">                  MetadataJson.copyWithDifferentJsonValue(field, StringUtils.join(subjectArray.iterator(), &quot;,&quot;)));</span>
<span class="pc bfc" id="L1549" title="All 2 branches covered.">        } else if (&quot;startDate&quot;.equals(key)) {</span>
          // Special handling for start date since in API v1 we expect start date and start time to be separate fields.
<span class="fc" id="L1551">          MetadataField field = collection.getOutputFields().get(key);</span>
<span class="fc" id="L1552">          Opt&lt;Response&gt; error = validateField(field, key, id, type, updatedFields);</span>
<span class="pc bpc" id="L1553" title="1 of 2 branches missed.">          if (error.isSome()) {</span>
<span class="nc" id="L1554">            return error.get();</span>
          }
<span class="fc" id="L1556">          String apiPattern = field.getPattern();</span>
<span class="pc bpc" id="L1557" title="1 of 2 branches missed.">          if (configuredMetadataFields.containsKey(&quot;startDate&quot;)) {</span>
<span class="fc" id="L1558">            final String startDate = configuredMetadataFields.get(&quot;startDate&quot;).getPattern();</span>
<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">            apiPattern = startDate == null ? apiPattern : startDate;</span>
          }
<span class="fc" id="L1561">          SimpleDateFormat apiSdf = MetadataField.getSimpleDateFormatter(apiPattern);</span>
<span class="fc" id="L1562">          SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L1563">          DateTime oldStartDate = new DateTime(sdf.parse((String) field.getValue()), DateTimeZone.UTC);</span>
<span class="fc" id="L1564">          DateTime newStartDate = new DateTime(apiSdf.parse(updatedFields.get(key)), DateTimeZone.UTC);</span>
<span class="fc" id="L1565">          DateTime updatedStartDate = oldStartDate.withDate(newStartDate.year().get(), newStartDate.monthOfYear().get(), newStartDate.dayOfMonth().get());</span>
<span class="fc" id="L1566">          collection.removeField(field);</span>
<span class="fc" id="L1567">          collection.addField(</span>
<span class="fc" id="L1568">                  MetadataJson.copyWithDifferentJsonValue(field, sdf.format(updatedStartDate.toDate())));</span>
<span class="fc bfc" id="L1569" title="All 2 branches covered.">        } else if (&quot;startTime&quot;.equals(key)) {</span>
          // Special handling for start time since in API v1 we expect start date and start time to be separate fields.
<span class="fc" id="L1571">          MetadataField field = collection.getOutputFields().get(&quot;startDate&quot;);</span>
<span class="fc" id="L1572">          Opt&lt;Response&gt; error = validateField(field, &quot;startDate&quot;, id, type, updatedFields);</span>
<span class="pc bpc" id="L1573" title="1 of 2 branches missed.">          if (error.isSome()) {</span>
<span class="nc" id="L1574">            return error.get();</span>
          }
<span class="fc" id="L1576">          String apiPattern = &quot;HH:mm&quot;;</span>
<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">          if (configuredMetadataFields.containsKey(&quot;startTime&quot;)) {</span>
<span class="fc" id="L1578">            final String startTime = configuredMetadataFields.get(&quot;startTime&quot;).getPattern();</span>
<span class="pc bpc" id="L1579" title="1 of 2 branches missed.">            apiPattern = startTime == null ? apiPattern : startTime;</span>
          }
<span class="fc" id="L1581">          SimpleDateFormat apiSdf = MetadataField.getSimpleDateFormatter(apiPattern);</span>
<span class="fc" id="L1582">          SimpleDateFormat sdf = MetadataField.getSimpleDateFormatter(field.getPattern());</span>
<span class="fc" id="L1583">          DateTime oldStartDate = new DateTime(sdf.parse((String) field.getValue()), DateTimeZone.UTC);</span>
<span class="fc" id="L1584">          DateTime newStartDate = new DateTime(apiSdf.parse(updatedFields.get(key)), DateTimeZone.UTC);</span>
<span class="fc" id="L1585">          DateTime updatedStartDate = oldStartDate.withTime(</span>
<span class="fc" id="L1586">                  newStartDate.hourOfDay().get(),</span>
<span class="fc" id="L1587">                  newStartDate.minuteOfHour().get(),</span>
<span class="fc" id="L1588">                  newStartDate.secondOfMinute().get(),</span>
<span class="fc" id="L1589">                  newStartDate.millisOfSecond().get());</span>
<span class="fc" id="L1590">          collection.removeField(field);</span>
<span class="fc" id="L1591">          collection.addField(</span>
<span class="fc" id="L1592">                  MetadataJson.copyWithDifferentJsonValue(field, sdf.format(updatedStartDate.toDate())));</span>
<span class="fc" id="L1593">        } else {</span>
<span class="fc" id="L1594">          MetadataField field = collection.getOutputFields().get(key);</span>
<span class="fc" id="L1595">          Opt&lt;Response&gt; error = validateField(field, key, id, type, updatedFields);</span>
<span class="pc bpc" id="L1596" title="1 of 2 branches missed.">          if (error.isSome()) {</span>
<span class="nc" id="L1597">            return error.get();</span>
          }
<span class="fc" id="L1599">          collection.removeField(field);</span>
<span class="fc" id="L1600">          collection.addField(</span>
<span class="fc" id="L1601">                  MetadataJson.copyWithDifferentJsonValue(field, updatedFields.get(key)));</span>
        }
<span class="fc" id="L1603">      }</span>

<span class="fc" id="L1605">      metadataList.add(adapter, collection);</span>
<span class="fc" id="L1606">      indexService.updateEventMetadata(id, metadataList, elasticsearchIndex);</span>
<span class="fc" id="L1607">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1609">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  private Opt&lt;Response&gt; validateField(MetadataField field, String key, String id, String type, Map&lt;String, String&gt; updatedFields) {
<span class="pc bpc" id="L1613" title="1 of 2 branches missed.">    if (field == null) {</span>
<span class="nc" id="L1614">      return Opt.some(ApiResponseBuilder.notFound(</span>
              &quot;Cannot find a metadata field with id '%s' from event with id '%s' and the metadata type '%s'.&quot;,
              key, id, type));
<span class="pc bpc" id="L1617" title="1 of 4 branches missed.">    } else if (field.isRequired() &amp;&amp; StringUtils.isBlank(updatedFields.get(key))) {</span>
<span class="nc" id="L1618">      return Opt.some(R.badRequest(String.format(</span>
              &quot;The event metadata field with id '%s' and the metadata type '%s' is required and can not be empty!.&quot;,
              key, type)));
    }
<span class="fc" id="L1622">    return Opt.none();</span>
  }

  @DELETE
  @Path(&quot;{eventId}/metadata&quot;)
  @RestQuery(name = &quot;deleteeventmetadata&quot;, description = &quot;Delete the metadata namespace catalog of the specified event. This will remove all fields and values of the catalog.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = true, description = &quot;The type of metadata to delete&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The metadata of the given namespace has been updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The main metadata catalog dublincore/episode cannot be deleted as it has mandatory fields.&quot;, responseCode = HttpServletResponse.SC_FORBIDDEN),
                          @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteEventMetadataByType(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type) throws SearchIndexException {
<span class="nc bnc" id="L1635" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(id, elasticsearchIndex)) {</span>
<span class="nc" id="L1636">      Opt&lt;MediaPackageElementFlavor&gt; flavor = getFlavor(type);</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">      if (flavor.isNone()) {</span>
<span class="nc" id="L1638">        return R.badRequest(</span>
<span class="nc" id="L1639">                String.format(&quot;Unable to parse type '%s' as a flavor so unable to find the matching catalog.&quot;, type));</span>
      }
<span class="nc" id="L1641">      EventCatalogUIAdapter eventCatalogUIAdapter = indexService.getCommonEventCatalogUIAdapter();</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">      if (flavor.get().equals(eventCatalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L1643">        return Response</span>
<span class="nc" id="L1644">                .status(Status.FORBIDDEN).entity(String</span>
<span class="nc" id="L1645">                        .format(&quot;Unable to delete mandatory metadata catalog with type '%s' for event '%s'&quot;, type, id))</span>
<span class="nc" id="L1646">                .build();</span>
      }
      try {
<span class="nc" id="L1649">        indexService.removeCatalogByFlavor(event, flavor.get());</span>
<span class="nc" id="L1650">      } catch (NotFoundException e) {</span>
<span class="nc" id="L1651">        return ApiResponseBuilder.notFound(e.getMessage());</span>
<span class="nc" id="L1652">      } catch (IndexServiceException e) {</span>
<span class="nc" id="L1653">        logger.error(&quot;Unable to remove metadata catalog with type '{}' from event '{}'&quot;, type, id, e);</span>
<span class="nc" id="L1654">        throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L1655">      } catch (IllegalStateException e) {</span>
<span class="nc" id="L1656">        logger.debug(&quot;Unable to remove metadata catalog with type '{}' from event '{}'&quot;, type, id, e);</span>
<span class="nc" id="L1657">        throw new WebApplicationException(e, Status.BAD_REQUEST);</span>
<span class="nc" id="L1658">      } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1659">        return Response.status(Status.UNAUTHORIZED).build();</span>
<span class="nc" id="L1660">      }</span>
<span class="nc" id="L1661">      return Response.noContent().build();</span>
    }
<span class="nc" id="L1663">    return ApiResponseBuilder.notFound(&quot;Cannot find an event with id '%s'.&quot;, id);</span>
  }

  @GET
  @Path(&quot;{eventId}/publications&quot;)
  @RestQuery(name = &quot;geteventpublications&quot;, description = &quot;Returns an event's list of publications.&quot;,
             returnDescription = &quot;&quot;,
             pathParameters = {
               @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING)
             },
             restParameters = {
               @RestParameter(name = &quot;sign&quot;, description = &quot;Whether public distribution urls should be signed.&quot;,
                              isRequired = false, type = Type.BOOLEAN),
               @RestParameter(name = &quot;includeInternalPublication&quot;, description = &quot;Whether internal publications should be included.&quot;,
                              isRequired = false, type = Type.BOOLEAN)
             },
             responses = {
                  @RestResponse(description = &quot;The list of publications is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })

    public Response getEventPublications(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @QueryParam(&quot;sign&quot;) boolean sign, @QueryParam(&quot;includeInternalPublication&quot;) boolean includeInternalPublication) throws Exception {
    try {
<span class="nc" id="L1686">      final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc" id="L1687">      final Opt&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">      if (event.isSome()) {</span>
<span class="nc" id="L1689">        return ApiResponseBuilder.Json.ok(acceptHeader, arr(getPublications(event.get(), sign, includeInternalPublication, requestedVersion)));</span>
      } else {
<span class="nc" id="L1691">        return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
      }
<span class="nc" id="L1693">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1694">      logger.error(&quot;Unable to get list of publications from event with id '{}'&quot;, id, e);</span>
<span class="nc" id="L1695">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }


  private List&lt;JValue&gt; getPublications(Event event, Boolean withSignedUrls, Boolean includeInternalPublication, ApiVersion requestedVersion) {
<span class="nc" id="L1701">        return event.getPublications().stream()</span>
<span class="nc bnc" id="L1702" title="All 8 branches missed.">        .filter(publication -&gt; ((includeInternalPublication != null &amp;&amp; includeInternalPublication &amp;&amp; !requestedVersion.isSmallerThan(VERSION_1_11_0)) || EventUtils.internalChannelFilter.apply(publication)))</span>
<span class="nc" id="L1703">        .map(p -&gt; getPublication(p, withSignedUrls, requestedVersion))</span>
<span class="nc" id="L1704">        .collect(Collectors.toList());</span>
  }

  public JObject getPublication(Publication publication, Boolean sign, ApiVersion requestedVersion) {
    // signing publication URLs was introduced in 1.7.0
<span class="nc" id="L1709">    URI publicationUrl = publication.getURI();</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">    if (!requestedVersion.isSmallerThan(VERSION_1_7_0)) {</span>
<span class="nc" id="L1711">      publicationUrl = getSignedUrl(publicationUrl, sign);</span>
    }

<span class="nc" id="L1714">    return obj(f(&quot;id&quot;, v(publication.getIdentifier())), f(&quot;channel&quot;, v(publication.getChannel())),</span>
<span class="nc" id="L1715">            f(&quot;mediatype&quot;, v(publication.getMimeType(), BLANK)),</span>
<span class="nc" id="L1716">            f(&quot;url&quot;, v(publicationUrl, BLANK)),</span>
<span class="nc" id="L1717">            f(&quot;media&quot;, arr(getPublicationTracksJson(publication, sign, requestedVersion))),</span>
<span class="nc" id="L1718">            f(&quot;attachments&quot;, arr(getPublicationAttachmentsJson(publication, sign))),</span>
<span class="nc" id="L1719">            f(&quot;metadata&quot;, arr(getPublicationCatalogsJson(publication, sign))));</span>
  }

  private URI getSignedUrl(URI url, boolean sign) {
<span class="nc bnc" id="L1723" title="All 4 branches missed.">    if (url == null || !sign) {</span>
<span class="nc" id="L1724">      return url;</span>
    }

<span class="nc bnc" id="L1727" title="All 2 branches missed.">    if (urlSigningService.accepts(url.toString())) {</span>
      try {
<span class="nc" id="L1729">        return URI.create(urlSigningService.sign(url.toString(), expireSeconds, null, null));</span>
<span class="nc" id="L1730">      } catch (UrlSigningException e) {</span>
<span class="nc" id="L1731">        logger.error(&quot;Unable to sign URI {}&quot;, url, e);</span>
      }
    }
<span class="nc" id="L1734">    return url;</span>
  }

  private List&lt;JValue&gt; getPublicationTracksJson(Publication publication, Boolean sign, ApiVersion requestedVersion) {
<span class="nc" id="L1738">    List&lt;JValue&gt; tracks = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">    for (Track track : publication.getTracks()) {</span>

<span class="nc" id="L1741">      VideoStream[] videoStreams = TrackSupport.byType(track.getStreams(), VideoStream.class);</span>
<span class="nc" id="L1742">      List&lt;Field&gt; trackInfo = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1744" title="All 2 branches missed.">      if (videoStreams.length &gt; 0) {</span>
        // Only supporting one stream, like in many other places...
<span class="nc" id="L1746">        final VideoStream videoStream = videoStreams[0];</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">        if (videoStream.getBitRate() != null)</span>
<span class="nc" id="L1748">          trackInfo.add(f(&quot;bitrate&quot;, v(videoStream.getBitRate())));</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">        if (videoStream.getFrameRate() != null)</span>
<span class="nc" id="L1750">          trackInfo.add(f(&quot;framerate&quot;, v(videoStream.getFrameRate())));</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">        if (videoStream.getFrameCount() != null)</span>
<span class="nc" id="L1752">          trackInfo.add(f(&quot;framecount&quot;, v(videoStream.getFrameCount())));</span>
<span class="nc bnc" id="L1753" title="All 2 branches missed.">        if (videoStream.getFrameWidth() != null)</span>
<span class="nc" id="L1754">          trackInfo.add(f(&quot;width&quot;, v(videoStream.getFrameWidth())));</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">        if (videoStream.getFrameHeight() != null)</span>
<span class="nc" id="L1756">          trackInfo.add(f(&quot;height&quot;, v(videoStream.getFrameHeight())));</span>
      }

<span class="nc bnc" id="L1759" title="All 2 branches missed.">      if (!requestedVersion.isSmallerThan(VERSION_1_7_0)) {</span>
<span class="nc" id="L1760">        trackInfo.add(f(&quot;is_master_playlist&quot;, v(track.isMaster())));</span>
<span class="nc" id="L1761">        trackInfo.add(f(&quot;is_live&quot;, v(track.isLive())));</span>
      }

<span class="nc" id="L1764">      tracks.add(obj(f(&quot;id&quot;, v(track.getIdentifier(), BLANK)), f(&quot;mediatype&quot;, v(track.getMimeType(), BLANK)),</span>
<span class="nc" id="L1765">              f(&quot;url&quot;, v(getSignedUrl(track.getURI(), sign), BLANK)), f(&quot;flavor&quot;, v(track.getFlavor(), BLANK)),</span>
<span class="nc" id="L1766">              f(&quot;size&quot;, v(track.getSize())), f(&quot;checksum&quot;, v(track.getChecksum(), BLANK)),</span>
<span class="nc" id="L1767">              f(&quot;tags&quot;, arr(track.getTags())), f(&quot;has_audio&quot;, v(track.hasAudio())),</span>
<span class="nc" id="L1768">              f(&quot;has_video&quot;, v(track.hasVideo())), f(&quot;duration&quot;, v(track.getDuration(), NULL)),</span>
<span class="nc" id="L1769">              f(&quot;description&quot;, v(track.getDescription(), BLANK))).merge(trackInfo));</span>
    }
<span class="nc" id="L1771">    return tracks;</span>
  }

  private List&lt;JValue&gt; getPublicationAttachmentsJson(Publication publication, Boolean sign) {
<span class="nc" id="L1775">    List&lt;JValue&gt; attachments = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1776" title="All 2 branches missed.">    for (Attachment attachment : publication.getAttachments()) {</span>
<span class="nc" id="L1777">      attachments.add(</span>
<span class="nc" id="L1778">              obj(f(&quot;id&quot;, v(attachment.getIdentifier(), BLANK)), f(&quot;mediatype&quot;, v(attachment.getMimeType(), BLANK)),</span>
<span class="nc" id="L1779">                      f(&quot;url&quot;, v(getSignedUrl(attachment.getURI(), sign), BLANK)),</span>
<span class="nc" id="L1780">                      f(&quot;flavor&quot;, v(attachment.getFlavor(), BLANK)), f(&quot;ref&quot;, v(attachment.getReference(), BLANK)),</span>
<span class="nc" id="L1781">                      f(&quot;size&quot;, v(attachment.getSize())), f(&quot;checksum&quot;, v(attachment.getChecksum(), BLANK)),</span>
<span class="nc" id="L1782">                      f(&quot;tags&quot;, arr(attachment.getTags()))));</span>
    }
<span class="nc" id="L1784">    return attachments;</span>
  }

  private List&lt;JValue&gt; getPublicationCatalogsJson(Publication publication, Boolean sign) {
<span class="nc" id="L1788">    List&lt;JValue&gt; catalogs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1789" title="All 2 branches missed.">    for (Catalog catalog : publication.getCatalogs()) {</span>
<span class="nc" id="L1790">      catalogs.add(obj(f(&quot;id&quot;, v(catalog.getIdentifier(), BLANK)), f(&quot;mediatype&quot;, v(catalog.getMimeType(), BLANK)),</span>
<span class="nc" id="L1791">              f(&quot;url&quot;, v(getSignedUrl(catalog.getURI(), sign), BLANK)),</span>
<span class="nc" id="L1792">              f(&quot;flavor&quot;, v(catalog.getFlavor(), BLANK)), f(&quot;size&quot;, v(catalog.getSize())),</span>
<span class="nc" id="L1793">              f(&quot;checksum&quot;, v(catalog.getChecksum(), BLANK)), f(&quot;tags&quot;, arr(catalog.getTags()))));</span>
    }
<span class="nc" id="L1795">    return catalogs;</span>
  }

  @GET
  @Path(&quot;{eventId}/publications/{publicationId}&quot;)
  @RestQuery(name = &quot;geteventpublication&quot;, description = &quot;Returns a single publication.&quot;, returnDescription = &quot;&quot;,
             pathParameters = {
               @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING),
               @RestParameter(name = &quot;publicationId&quot;, description = &quot;The publication id&quot;, isRequired = true, type = STRING)
             },
             restParameters = {
               @RestParameter(name = &quot;sign&quot;, description = &quot;Whether public distribution urls should be signed.&quot;,
                              isRequired = false, type = Type.BOOLEAN)
             },
             responses = {
                  @RestResponse(description = &quot;The track details are returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified event or publication does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })

  public Response getEventPublication(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String eventId,
          @PathParam(&quot;publicationId&quot;) String publicationId, @QueryParam(&quot;sign&quot;) boolean sign) throws Exception {
    try {
<span class="nc" id="L1816">      final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="nc" id="L1817">      return ApiResponseBuilder.Json.ok(acceptHeader, getPublication(eventId, publicationId, sign, requestedVersion));</span>
<span class="nc" id="L1818">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1819">      return ApiResponseBuilder.notFound(e.getMessage());</span>
<span class="nc" id="L1820">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1821">      logger.error(&quot;Unable to get list of publications from event with id '{}'&quot;, eventId, e);</span>
<span class="nc" id="L1822">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }


  private JObject getPublication(String eventId, String publicationId, Boolean withSignedUrls, ApiVersion requestedVersion)
          throws SearchIndexException, NotFoundException {
<span class="nc bnc" id="L1829" title="All 2 branches missed.">    for (final Event event : indexService.getEvent(eventId, elasticsearchIndex)) {</span>
      List&lt;Publication&gt; publications;
<span class="nc bnc" id="L1831" title="All 4 branches missed.">      publications = event.getPublications().stream().filter(publication -&gt; (!requestedVersion.isSmallerThan(VERSION_1_11_0) || EventUtils.internalChannelFilter.apply(publication))).collect(Collectors.toList());</span>
<span class="nc bnc" id="L1832" title="All 2 branches missed.">      for (Publication publication : publications) {</span>
<span class="nc bnc" id="L1833" title="All 2 branches missed.">        if (publicationId.equals(publication.getIdentifier())) {</span>
<span class="nc" id="L1834">          return getPublication(publication, withSignedUrls, requestedVersion);</span>
        }
<span class="nc" id="L1836">      }</span>
<span class="nc" id="L1837">      throw new NotFoundException(</span>
<span class="nc" id="L1838">              String.format(&quot;Unable to find publication with id '%s' in event with id '%s'&quot;, publicationId, eventId));</span>
    }
<span class="nc" id="L1840">    throw new NotFoundException(String.format(&quot;Unable to find event with id '%s'&quot;, eventId));</span>
  }

  /**
   * Get an {@link AccessControlList} from an {@link Event}.
   *
   * @param event
   *          The {@link Event} to get the ACL from.
   * @return The {@link AccessControlList} stored in the {@link Event}
   */
  protected static AccessControlList getAclFromEvent(Event event) {
<span class="nc" id="L1851">    AccessControlList activeAcl = new AccessControlList();</span>
    try {
<span class="nc bnc" id="L1853" title="All 2 branches missed.">      if (event.getAccessPolicy() != null)</span>
<span class="nc" id="L1854">        activeAcl = AccessControlParser.parseAcl(event.getAccessPolicy());</span>
<span class="nc" id="L1855">    } catch (Exception e) {</span>
<span class="nc" id="L1856">      logger.error(&quot;Unable to parse access policy&quot;, e);</span>
<span class="nc" id="L1857">    }</span>
<span class="nc" id="L1858">    return activeAcl;</span>
  }

  private JValue getJsonStream(Stream stream) {
<span class="nc" id="L1862">    List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">    if (stream instanceof AudioStream) {</span>
<span class="nc" id="L1864">      AudioStream audioStream = (AudioStream) stream;</span>
<span class="nc bnc" id="L1865" title="All 2 branches missed.">      if (audioStream.getBitDepth() != null)</span>
<span class="nc" id="L1866">        fields.add(f(&quot;bitdepth&quot;, v(audioStream.getBitDepth())));</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">      if (audioStream.getBitRate() != null)</span>
<span class="nc" id="L1868">        fields.add(f(&quot;bitrate&quot;, v(audioStream.getBitRate())));</span>
<span class="nc bnc" id="L1869" title="All 2 branches missed.">      if (audioStream.getCaptureDevice() != null)</span>
<span class="nc" id="L1870">        fields.add(f(&quot;capturedevice&quot;, v(audioStream.getCaptureDevice())));</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">      if (audioStream.getCaptureDeviceVendor() != null)</span>
<span class="nc" id="L1872">        fields.add(f(&quot;capturedevicevendor&quot;, v(audioStream.getCaptureDeviceVendor())));</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">      if (audioStream.getCaptureDeviceVersion() != null)</span>
<span class="nc" id="L1874">        fields.add(f(&quot;capturedeviceversion&quot;, v(audioStream.getCaptureDeviceVersion())));</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">      if (audioStream.getChannels() != null)</span>
<span class="nc" id="L1876">        fields.add(f(&quot;channels&quot;, v(audioStream.getChannels())));</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">      if (audioStream.getEncoderLibraryVendor() != null)</span>
<span class="nc" id="L1878">        fields.add(f(&quot;encoderlibraryvendor&quot;, v(audioStream.getEncoderLibraryVendor())));</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">      if (audioStream.getFormat() != null)</span>
<span class="nc" id="L1880">        fields.add(f(&quot;format&quot;, v(audioStream.getFormat())));</span>
<span class="nc bnc" id="L1881" title="All 2 branches missed.">      if (audioStream.getFormatVersion() != null)</span>
<span class="nc" id="L1882">        fields.add(f(&quot;formatversion&quot;, v(audioStream.getFormatVersion())));</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">      if (audioStream.getFrameCount() != null)</span>
<span class="nc" id="L1884">        fields.add(f(&quot;framecount&quot;, v(audioStream.getFrameCount())));</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">      if (audioStream.getIdentifier() != null)</span>
<span class="nc" id="L1886">        fields.add(f(&quot;identifier&quot;, v(audioStream.getIdentifier())));</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">      if (audioStream.getPkLevDb() != null)</span>
<span class="nc" id="L1888">        fields.add(f(&quot;pklevdb&quot;, v(audioStream.getPkLevDb())));</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">      if (audioStream.getRmsLevDb() != null)</span>
<span class="nc" id="L1890">        fields.add(f(&quot;rmslevdb&quot;, v(audioStream.getRmsLevDb())));</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">      if (audioStream.getRmsPkDb() != null)</span>
<span class="nc" id="L1892">        fields.add(f(&quot;rmspkdb&quot;, v(audioStream.getRmsPkDb())));</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">      if (audioStream.getSamplingRate() != null)</span>
<span class="nc" id="L1894">        fields.add(f(&quot;samplingrate&quot;, v(audioStream.getSamplingRate())));</span>
<span class="nc bnc" id="L1895" title="All 2 branches missed.">    } else if (stream instanceof VideoStream) {</span>
<span class="nc" id="L1896">      VideoStream videoStream = (VideoStream) stream;</span>
<span class="nc bnc" id="L1897" title="All 2 branches missed.">      if (videoStream.getBitRate() != null)</span>
<span class="nc" id="L1898">        fields.add(f(&quot;bitrate&quot;, v(videoStream.getBitRate())));</span>
<span class="nc bnc" id="L1899" title="All 2 branches missed.">      if (videoStream.getCaptureDevice() != null)</span>
<span class="nc" id="L1900">        fields.add(f(&quot;capturedevice&quot;, v(videoStream.getCaptureDevice())));</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">      if (videoStream.getCaptureDeviceVendor() != null)</span>
<span class="nc" id="L1902">        fields.add(f(&quot;capturedevicevendor&quot;, v(videoStream.getCaptureDeviceVendor())));</span>
<span class="nc bnc" id="L1903" title="All 2 branches missed.">      if (videoStream.getCaptureDeviceVersion() != null)</span>
<span class="nc" id="L1904">        fields.add(f(&quot;capturedeviceversion&quot;, v(videoStream.getCaptureDeviceVersion())));</span>
<span class="nc bnc" id="L1905" title="All 2 branches missed.">      if (videoStream.getEncoderLibraryVendor() != null)</span>
<span class="nc" id="L1906">        fields.add(f(&quot;encoderlibraryvendor&quot;, v(videoStream.getEncoderLibraryVendor())));</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">      if (videoStream.getFormat() != null)</span>
<span class="nc" id="L1908">        fields.add(f(&quot;format&quot;, v(videoStream.getFormat())));</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">      if (videoStream.getFormatVersion() != null)</span>
<span class="nc" id="L1910">        fields.add(f(&quot;formatversion&quot;, v(videoStream.getFormatVersion())));</span>
<span class="nc bnc" id="L1911" title="All 2 branches missed.">      if (videoStream.getFrameCount() != null)</span>
<span class="nc" id="L1912">        fields.add(f(&quot;framecount&quot;, v(videoStream.getFrameCount())));</span>
<span class="nc bnc" id="L1913" title="All 2 branches missed.">      if (videoStream.getFrameHeight() != null)</span>
<span class="nc" id="L1914">        fields.add(f(&quot;frameheight&quot;, v(videoStream.getFrameHeight())));</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">      if (videoStream.getFrameRate() != null)</span>
<span class="nc" id="L1916">        fields.add(f(&quot;framerate&quot;, v(videoStream.getFrameRate())));</span>
<span class="nc bnc" id="L1917" title="All 2 branches missed.">      if (videoStream.getFrameWidth() != null)</span>
<span class="nc" id="L1918">        fields.add(f(&quot;framewidth&quot;, v(videoStream.getFrameWidth())));</span>
<span class="nc bnc" id="L1919" title="All 2 branches missed.">      if (videoStream.getIdentifier() != null)</span>
<span class="nc" id="L1920">        fields.add(f(&quot;identifier&quot;, v(videoStream.getIdentifier())));</span>
<span class="nc bnc" id="L1921" title="All 2 branches missed.">      if (videoStream.getScanOrder() != null)</span>
<span class="nc" id="L1922">        fields.add(f(&quot;scanorder&quot;, v(videoStream.getScanOrder().toString())));</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">      if (videoStream.getScanType() != null)</span>
<span class="nc" id="L1924">        fields.add(f(&quot;scantype&quot;, v(videoStream.getScanType().toString())));</span>
    }
<span class="nc" id="L1926">    return obj(fields);</span>
  }

  private String getEventUrl(String eventId) {
<span class="nc" id="L1930">    return UrlSupport.concat(endpointBaseUrl, eventId);</span>
  }

  @GET
  @Path(&quot;{eventId}/scheduling&quot;)
  @Produces({ ApiMediaType.JSON, ApiMediaType.VERSION_1_1_0, ApiMediaType.VERSION_1_2_0, ApiMediaType.VERSION_1_3_0,
              ApiMediaType.VERSION_1_4_0, ApiMediaType.VERSION_1_5_0, ApiMediaType.VERSION_1_6_0,
              ApiMediaType.VERSION_1_7_0, ApiMediaType.VERSION_1_8_0, ApiMediaType.VERSION_1_9_0,
              ApiMediaType.VERSION_1_10_0, ApiMediaType.VERSION_1_11_0 })
  @RestQuery(name = &quot;geteventscheduling&quot;, description = &quot;Returns an event's scheduling information.&quot;, returnDescription = &quot;&quot;, pathParameters = {
      @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) }, responses = {
      @RestResponse(description = &quot;The scheduling information for the specified event is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
      @RestResponse(description = &quot;The specified event has no scheduling information.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
      @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getEventScheduling(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id)
      throws Exception {
    try {
<span class="fc" id="L1947">      final Opt&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>

<span class="pc bpc" id="L1949" title="1 of 2 branches missed.">      if (event.isNone()) {</span>
<span class="nc" id="L1950">        return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
      }

<span class="fc" id="L1953">      final JObject scheduling = SchedulingInfo.of(event.get().getIdentifier(), schedulerService).toJson();</span>
<span class="pc bpc" id="L1954" title="1 of 2 branches missed.">      if (!scheduling.isEmpty()) {</span>
<span class="fc" id="L1955">        return ApiResponseBuilder.Json.ok(acceptHeader, scheduling);</span>
      }
<span class="nc" id="L1957">      return Response.noContent().build();</span>
<span class="nc" id="L1958">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1959">      logger.error(&quot;Unable to get list of publications from event with id '{}'&quot;, id, e);</span>
<span class="nc" id="L1960">      throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @PUT
  @Path(&quot;{eventId}/scheduling&quot;)
  @Produces({ ApiMediaType.JSON, ApiMediaType.VERSION_1_1_0, ApiMediaType.VERSION_1_2_0, ApiMediaType.VERSION_1_3_0,
              ApiMediaType.VERSION_1_4_0, ApiMediaType.VERSION_1_5_0, ApiMediaType.VERSION_1_6_0,
              ApiMediaType.VERSION_1_7_0, ApiMediaType.VERSION_1_8_0, ApiMediaType.VERSION_1_9_0,
              ApiMediaType.VERSION_1_10_0, ApiMediaType.VERSION_1_11_0 })
  @RestQuery(name = &quot;updateeventscheduling&quot;, description = &quot;Update an event's scheduling information.&quot;, returnDescription = &quot;&quot;, pathParameters = {
      @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = Type.STRING) }, restParameters = {
      @RestParameter(name = &quot;scheduling&quot;, isRequired = true, description = &quot;Scheduling Information&quot;, type = Type.STRING),
      @RestParameter(name = &quot;allowConflict&quot;, description = &quot;Allow conflicts when updating scheduling&quot;, isRequired = false, type = Type.BOOLEAN) }, responses = {
      @RestResponse(description = &quot;The  scheduling information for the specified event is updated.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
      @RestResponse(description = &quot;The specified event has no scheduling information to update.&quot;, responseCode = HttpServletResponse.SC_NOT_ACCEPTABLE),
      @RestResponse(description = &quot;The scheduling information could not be updated due to a conflict.&quot;, responseCode = HttpServletResponse.SC_CONFLICT),
      @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateEventScheduling(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
                                 @FormParam(&quot;scheduling&quot;) String scheduling,
                                 @FormParam(&quot;allowConflict&quot;) @DefaultValue(&quot;false&quot;) boolean allowConflict) throws Exception {
<span class="fc" id="L1981">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="fc" id="L1982">    final Opt&lt;Event&gt; event = indexService.getEvent(id, elasticsearchIndex);</span>

<span class="pc bpc" id="L1984" title="1 of 2 branches missed.">    if (requestedVersion.isSmallerThan(ApiVersion.VERSION_1_2_0)) {</span>
<span class="nc" id="L1985">        allowConflict = false;</span>
    }
<span class="pc bpc" id="L1987" title="1 of 2 branches missed.">    if (event.isNone()) {</span>
<span class="nc" id="L1988">      return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
    }
<span class="fc" id="L1990">    final JSONParser parser = new JSONParser();</span>
    JSONObject parsedJson;
    try {
<span class="fc" id="L1993">       parsedJson = (JSONObject) parser.parse(scheduling);</span>
<span class="nc" id="L1994">    } catch (ParseException e) {</span>
<span class="nc" id="L1995">      logger.debug(&quot;Client sent unparsable scheduling information for event {}: {}&quot;, id, scheduling);</span>
<span class="nc" id="L1996">      return RestUtil.R.badRequest(&quot;Unparsable scheduling information&quot;);</span>
<span class="fc" id="L1997">    }</span>
<span class="fc" id="L1998">    Optional&lt;Response&gt; clientError = updateSchedulingInformation(parsedJson, id, requestedVersion, allowConflict);</span>
<span class="fc" id="L1999">    return clientError.orElse(Response.noContent().build());</span>
  }

  private Optional&lt;Response&gt; updateSchedulingInformation(
      JSONObject parsedScheduling,
      String id,
      ApiVersion requestedVersion,
      boolean allowConflict) throws Exception {

    SchedulingInfo schedulingInfo;
    try {
<span class="fc" id="L2010">      schedulingInfo = SchedulingInfo.of(parsedScheduling);</span>
<span class="nc" id="L2011">    } catch (DateTimeParseException e) {</span>
<span class="nc" id="L2012">      logger.debug(&quot;Client sent unparsable start or end date for event {}&quot;, id);</span>
<span class="nc" id="L2013">      return Optional.of(RestUtil.R.badRequest(&quot;Unparsable date in scheduling information&quot;));</span>
<span class="fc" id="L2014">    }</span>
<span class="fc" id="L2015">    final TechnicalMetadata technicalMetadata = schedulerService.getTechnicalMetadata(id);</span>

    // When &quot;inputs&quot; is updated, capture agent configuration needs to be merged
<span class="fc" id="L2018">    Opt&lt;Map&lt;String, String&gt;&gt; caConfig = Opt.none();</span>
<span class="pc bpc" id="L2019" title="1 of 2 branches missed.">    if (schedulingInfo.getInputs().isSome()) {</span>
<span class="fc" id="L2020">      final Map&lt;String, String&gt; configMap = new HashMap&lt;&gt;(technicalMetadata.getCaptureAgentConfiguration());</span>
<span class="fc" id="L2021">      configMap.put(CaptureParameters.CAPTURE_DEVICE_NAMES, schedulingInfo.getInputs().get());</span>
<span class="fc" id="L2022">      caConfig = Opt.some(configMap);</span>
    }

    try {
<span class="fc" id="L2026">      schedulerService.updateEvent(</span>
          id,
<span class="fc" id="L2028">          schedulingInfo.getStartDate(),</span>
<span class="fc" id="L2029">          schedulingInfo.getEndDate(),</span>
<span class="fc" id="L2030">          schedulingInfo.getAgentId(),</span>
<span class="fc" id="L2031">          Opt.none(),</span>
<span class="fc" id="L2032">          Opt.none(),</span>
<span class="fc" id="L2033">          Opt.none(),</span>
          caConfig,
          allowConflict);
<span class="nc" id="L2036">    } catch (SchedulerConflictException e) {</span>
<span class="nc" id="L2037">      final List&lt;MediaPackage&gt; conflictingEvents = getConflictingEvents(</span>
<span class="nc" id="L2038">          schedulingInfo.merge(technicalMetadata), agentStateService, schedulerService);</span>
<span class="nc" id="L2039">      logger.debug(&quot;Client tried to change scheduling information causing a conflict for event {}.&quot;, id);</span>
<span class="nc" id="L2040">      return Optional.of(ApiResponseBuilder.Json.conflict(requestedVersion,</span>
<span class="nc" id="L2041">          arr(convertConflictingEvents(Optional.of(id), conflictingEvents, indexService, elasticsearchIndex))));</span>
<span class="fc" id="L2042">    }</span>
<span class="fc" id="L2043">    return Optional.empty();</span>
  }

  @POST
  @Path(&quot;{eventId}/track&quot;)
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @RestQuery(name = &quot;updateFlavorWithTrack&quot;, description = &quot;Update an events track for a given flavor&quot;, returnDescription = &quot;&quot;,
          pathParameters = {
                  @RestParameter(name = &quot;eventId&quot;, description = &quot;The event id&quot;, isRequired = true, type = STRING) },
          restParameters = {
                  @RestParameter(description = &quot;Flavor to add track to, e.g. captions/source&quot;,
                      isRequired = true, name = &quot;flavor&quot;, type = RestParameter.Type.STRING),
                  @RestParameter(description = &quot;Comma separated list of tags for the given track, e.g. archive,publish. &quot;
                      + &quot;If a 'lang:LANG-CODE' tag exists and overwriteExisting=true &quot;
                      + &quot;only tracks with same lang tag and flavor will be replaced. This behavior is used for captions.&quot;,
                      isRequired = false, name = &quot;tags&quot;, type = RestParameter.Type.STRING),
                  @RestParameter(description = &quot;If true, all other tracks in the specified flavor are REMOVED. &quot;
                      + &quot;If tags argument contains a lang:LANG-CODE tag, only elements with same tag would be removed.&quot;,
                      isRequired = true, name = &quot;overwriteExisting&quot;, type = RestParameter.Type.BOOLEAN),
                  @RestParameter(description = &quot;The track file&quot;, isRequired = true, name = &quot;track&quot;, type = RestParameter.Type.FILE),
          },
          responses = {
                  @RestResponse(description = &quot;The specified event does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND),
                  @RestResponse(description = &quot;The track has been added to the event.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The request is invalid or inconsistent.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
          })
  public Response updateFlavorWithTrack(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;eventId&quot;) String id,
          @Context HttpServletRequest request) {
<span class="fc" id="L2071">    logger.debug(&quot;updateFlavorWithTrack called&quot;);</span>
    try {
<span class="fc" id="L2073">      boolean overwriteExisting = false;</span>
<span class="fc" id="L2074">      MediaPackageElementFlavor tmpFlavor = MediaPackageElementFlavor.parseFlavor(&quot;addTrack/temporary&quot;);</span>
<span class="fc" id="L2075">      MediaPackageElementFlavor newFlavor = null;</span>
      Opt&lt;Event&gt; event;
<span class="fc" id="L2077">      List&lt;String&gt; tags = null;</span>
<span class="fc" id="L2078">      String langTag = null;</span>

      try {
<span class="fc" id="L2081">        event = indexService.getEvent(id, elasticsearchIndex);</span>
<span class="nc" id="L2082">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L2083">        return RestUtil.R.badRequest(String.format(&quot;Error while searching for event with id %s; %s&quot;, id, e.getMessage()));</span>
<span class="fc" id="L2084">      }</span>

<span class="pc bpc" id="L2086" title="1 of 2 branches missed.">      if (event.isNone()) {</span>
<span class="nc" id="L2087">        return ApiResponseBuilder.notFound(String.format(&quot;Unable to find event with id '%s'&quot;, id));</span>
      }
<span class="fc" id="L2089">      MediaPackage mp = indexService.getEventMediapackage(event.get());</span>

      try {
<span class="pc bpc" id="L2092" title="1 of 2 branches missed.">        if (workflowService.mediaPackageHasActiveWorkflows(mp.getIdentifier().toString())) {</span>
<span class="nc" id="L2093">          return RestUtil.R.conflict(String.format(&quot;Cannot update while a workflow is running on event '%s'&quot;, id));</span>
        }
<span class="nc" id="L2095">      } catch (WorkflowDatabaseException e) {</span>
<span class="nc" id="L2096">        return RestUtil.R.serverError();</span>
<span class="fc" id="L2097">      }</span>

<span class="pc bpc" id="L2099" title="1 of 2 branches missed.">      if (!ServletFileUpload.isMultipartContent(request)) {</span>
<span class="nc" id="L2100">        throw new IllegalArgumentException(&quot;No multipart content&quot;);</span>
      }
<span class="fc bfc" id="L2102" title="All 2 branches covered.">      for (FileItemIterator iter = new ServletFileUpload().getItemIterator(request); iter.hasNext();) {</span>
<span class="fc" id="L2103">        FileItemStream item = iter.next();</span>
<span class="fc" id="L2104">        String fieldName = item.getFieldName();</span>
<span class="fc bfc" id="L2105" title="All 2 branches covered.">        if (item.isFormField()) {</span>
<span class="fc bfc" id="L2106" title="All 2 branches covered.">          if (&quot;flavor&quot;.equals(fieldName)) {</span>
<span class="fc" id="L2107">            String flavorString = Streams.asString(item.openStream());</span>
            try {
<span class="fc" id="L2109">              newFlavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>
<span class="nc" id="L2110">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L2111">              return RestUtil.R.badRequest(String.format(&quot;Could not parse flavor %s; %s&quot;, flavorString, e.getMessage()));</span>
<span class="fc" id="L2112">            }</span>
<span class="pc bpc" id="L2113" title="1 of 2 branches missed.">          } else if (&quot;tags&quot;.equals(fieldName)) {</span>
<span class="nc" id="L2114">            String tagsString = Streams.asString(item.openStream());</span>
<span class="nc bnc" id="L2115" title="All 2 branches missed.">            if (StringUtils.isNotBlank(tagsString)) {</span>
<span class="nc" id="L2116">              tags = List.of(StringUtils.split(tagsString, ','));</span>
              // find lang tag if exists
<span class="nc bnc" id="L2118" title="All 2 branches missed.">              for (String tag : tags) {</span>
<span class="nc bnc" id="L2119" title="All 2 branches missed.">                if (StringUtils.startsWith(StringUtils.trimToEmpty(tag), &quot;lang:&quot;)) {</span>
                  // lang tag is set
<span class="nc" id="L2121">                  langTag = StringUtils.trimToEmpty(tag);</span>
<span class="nc" id="L2122">                  break;</span>
                }
<span class="nc" id="L2124">              }</span>
            }
<span class="pc bpc" id="L2126" title="1 of 2 branches missed.">          } else if (&quot;overwriteExisting&quot;.equals(fieldName)) {</span>
<span class="fc" id="L2127">            overwriteExisting = Boolean.parseBoolean(Streams.asString(item.openStream()));</span>
          }
        } else {
          // Add track with temporary flavor
<span class="pc bpc" id="L2131" title="1 of 2 branches missed.">          if (&quot;track&quot;.equals(item.getFieldName())) {</span>
<span class="fc" id="L2132">            mp = ingestService.addTrack(item.openStream(), item.getName(), tmpFlavor, mp);</span>
          }
        }
<span class="fc" id="L2135">      }</span>

<span class="pc bpc" id="L2137" title="1 of 2 branches missed.">      if (overwriteExisting) {</span>
        // remove existing attachments of the new flavor
<span class="fc" id="L2139">        Track[] existing = mp.getTracks(newFlavor);</span>
<span class="pc bpc" id="L2140" title="1 of 2 branches missed.">        for (int i = 0; i &lt; existing.length; i++) {</span>
          // if lang tag is set, remove only matching elements
<span class="nc bnc" id="L2142" title="All 4 branches missed.">          if (null == langTag || existing[i].containsTag(langTag)) {</span>
<span class="nc" id="L2143">            mp.remove(existing[i]);</span>
<span class="nc" id="L2144">            logger.debug(&quot;Overwriting existing asset {} {}&quot;, tmpFlavor, newFlavor);</span>
          }
        }
      }
      // correct the flavor of the new attachment
<span class="fc bfc" id="L2149" title="All 2 branches covered.">      for (Track track : mp.getTracks(tmpFlavor)) {</span>
<span class="fc" id="L2150">        track.setFlavor(newFlavor);</span>
<span class="pc bpc" id="L2151" title="1 of 2 branches missed.">        if (null != tags) {</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">          for (String tag : tags) {</span>
<span class="nc" id="L2153">            track.addTag(tag);</span>
<span class="nc" id="L2154">          }</span>
        }
      }
<span class="fc" id="L2157">      logger.debug(&quot;Updated asset {} {}&quot;, tmpFlavor, newFlavor);</span>

      try {
<span class="fc" id="L2160">        assetManager.takeSnapshot(mp);</span>
<span class="nc" id="L2161">      } catch (AssetManagerException e) {</span>
<span class="nc" id="L2162">        logger.error(&quot;Error while adding the updated media package ({}) to the archive&quot;, mp.getIdentifier(), e);</span>
<span class="nc" id="L2163">        return RestUtil.R.badRequest(e.getMessage());</span>
<span class="fc" id="L2164">      }</span>

<span class="fc" id="L2166">      return Response.status(Status.OK).build();</span>
<span class="nc" id="L2167">    } catch (IllegalArgumentException | IOException | FileUploadException | IndexServiceException | IngestException</span>
            | MediaPackageException e) {
<span class="nc" id="L2169">      return RestUtil.R.badRequest(String.format(&quot;Could not add track: %s&quot;, e.getMessage()));</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>