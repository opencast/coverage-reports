<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SeriesEndpoint.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-external-api</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.external.endpoint</a> &gt; <span class="el_source">SeriesEndpoint.java</span></div><h1>SeriesEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.external.endpoint;

import static com.entwinemedia.fn.Stream.$;
import static com.entwinemedia.fn.data.json.Jsons.BLANK;
import static com.entwinemedia.fn.data.json.Jsons.arr;
import static com.entwinemedia.fn.data.json.Jsons.f;
import static com.entwinemedia.fn.data.json.Jsons.obj;
import static com.entwinemedia.fn.data.json.Jsons.v;
import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
import static javax.servlet.http.HttpServletResponse.SC_OK;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.trimToNull;
import static org.apache.http.HttpStatus.SC_UNAUTHORIZED;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_1_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_2_0;
import static org.opencastproject.external.common.ApiVersion.VERSION_1_5_0;
import static org.opencastproject.util.DateTimeSupport.toUTC;
import static org.opencastproject.util.RestUtil.getEndpointUrl;
import static org.opencastproject.util.doc.rest.RestParameter.Type.BOOLEAN;
import static org.opencastproject.util.doc.rest.RestParameter.Type.STRING;

import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.api.SearchResultItem;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.QueryPreprocessor;
import org.opencastproject.elasticsearch.index.objects.event.EventIndexSchema;
import org.opencastproject.elasticsearch.index.objects.series.Series;
import org.opencastproject.elasticsearch.index.objects.series.SeriesIndexSchema;
import org.opencastproject.elasticsearch.index.objects.series.SeriesSearchQuery;
import org.opencastproject.external.common.ApiMediaType;
import org.opencastproject.external.common.ApiResponseBuilder;
import org.opencastproject.external.common.ApiVersion;
import org.opencastproject.external.util.AclUtils;
import org.opencastproject.external.util.ExternalMetadataUtils;
import org.opencastproject.index.service.api.IndexService;
import org.opencastproject.index.service.exception.IndexServiceException;
import org.opencastproject.index.service.util.RequestUtils;
import org.opencastproject.index.service.util.RestUtils;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreMetadataCollection;
import org.opencastproject.metadata.dublincore.MetadataField;
import org.opencastproject.metadata.dublincore.MetadataJson;
import org.opencastproject.metadata.dublincore.MetadataList;
import org.opencastproject.metadata.dublincore.SeriesCatalogUIAdapter;
import org.opencastproject.rest.RestConstants;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.Permissions;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.series.api.SeriesException;
import org.opencastproject.series.api.SeriesService;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.util.DateTimeSupport;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RestUtil;
import org.opencastproject.util.RestUtil.R;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.util.requests.SortCriterion;

import com.entwinemedia.fn.Fn;
import com.entwinemedia.fn.data.Opt;
import com.entwinemedia.fn.data.json.Field;
import com.entwinemedia.fn.data.json.JObject;
import com.entwinemedia.fn.data.json.JValue;
import com.entwinemedia.fn.data.json.Jsons.Functions;

import org.apache.commons.lang3.StringUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.TreeMap;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.DELETE;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Path(&quot;/api/series&quot;)
@Produces({ ApiMediaType.JSON, ApiMediaType.VERSION_1_0_0, ApiMediaType.VERSION_1_1_0, ApiMediaType.VERSION_1_2_0,
            ApiMediaType.VERSION_1_3_0, ApiMediaType.VERSION_1_4_0, ApiMediaType.VERSION_1_5_0,
            ApiMediaType.VERSION_1_6_0, ApiMediaType.VERSION_1_7_0, ApiMediaType.VERSION_1_8_0,
            ApiMediaType.VERSION_1_9_0, ApiMediaType.VERSION_1_10_0, ApiMediaType.VERSION_1_11_0 })
@RestService(name = &quot;externalapiseries&quot;, title = &quot;External API Series Service&quot;, notes = {},
             abstractText = &quot;Provides resources and operations related to the series&quot;)
@Component(
    immediate = true,
    service = SeriesEndpoint.class,
    property = {
        &quot;service.description=External API - Series Endpoint&quot;,
        &quot;opencast.service.type=org.opencastproject.external&quot;,
        &quot;opencast.service.path=/api/series&quot;
    }
)
@JaxrsResource
<span class="fc" id="L155">public class SeriesEndpoint {</span>

  private static final int CREATED_BY_UI_ORDER = 9;
  private static final int DEFAULT_LIMIT = 100;

<span class="fc" id="L160">  private static final Logger logger = LoggerFactory.getLogger(SeriesEndpoint.class);</span>

  /** Base URL of this endpoint */
  protected String endpointBaseUrl;

  /* OSGi service references */
  private ElasticsearchIndex elasticsearchIndex;
  private IndexService indexService;
  private SecurityService securityService;
  private SeriesService seriesService;

  /** OSGi DI */
  @Reference
  void setElasticsearchIndex(ElasticsearchIndex elasticsearchIndex) {
<span class="fc" id="L174">    this.elasticsearchIndex = elasticsearchIndex;</span>
<span class="fc" id="L175">  }</span>

  /** OSGi DI */
  @Reference
  void setIndexService(IndexService indexService) {
<span class="fc" id="L180">    this.indexService = indexService;</span>
<span class="fc" id="L181">  }</span>

  /** OSGi DI */
  @Reference
  void setSecurityService(SecurityService securityService) {
<span class="fc" id="L186">    this.securityService = securityService;</span>
<span class="fc" id="L187">  }</span>

  /** OSGi DI */
  @Reference
  void setSeriesService(SeriesService seriesService) {
<span class="fc" id="L192">    this.seriesService = seriesService;</span>
<span class="fc" id="L193">  }</span>

  /** OSGi activation method */
  @Activate
  void activate(ComponentContext cc) {
<span class="nc" id="L198">    logger.info(&quot;Activating External API - Series Endpoint&quot;);</span>

<span class="nc" id="L200">    final Tuple&lt;String, String&gt; endpointUrl = getEndpointUrl(cc, OpencastConstants.EXTERNAL_API_URL_ORG_PROPERTY,</span>
            RestConstants.SERVICE_PATH_PROPERTY);
<span class="nc" id="L202">    endpointBaseUrl = UrlSupport.concat(endpointUrl.getA(), endpointUrl.getB());</span>
<span class="nc" id="L203">    logger.debug(&quot;Configured service endpoint is {}&quot;, endpointBaseUrl);</span>
<span class="nc" id="L204">  }</span>

  @GET
  @Path(&quot;&quot;)
  @RestQuery(name = &quot;getseries&quot;, description = &quot;Returns a list of series.&quot;, returnDescription = &quot;&quot;, restParameters = {
          @RestParameter(name = &quot;onlyWithWriteAccess&quot;, isRequired = false, description = &quot;Whether only to get the series to which we have write access.&quot;, type = RestParameter.Type.BOOLEAN),
          @RestParameter(name = &quot;filter&quot;, isRequired = false, description = &quot;Usage &lt;Filter Name&gt;:&lt;Value to Filter With&gt;. Filters can combine using a comma \&quot;,\&quot;. Available Filters: managedAcl, contributors, CreationDate, Creator, textFilter, language, license, organizers, subject, title. If API ver &gt; 1.1.0 also: identifier, description, creator, publishers, rightsholder.&quot;, type = STRING),
          @RestParameter(name = &quot;sort&quot;, description = &quot;Sort the results based upon a list of comma seperated sorting criteria. In the comma seperated list each type of sorting is specified as a pair such as: &lt;Sort Name&gt;:ASC or &lt;Sort Name&gt;:DESC. Adding the suffix ASC or DESC sets the order as ascending or descending order and is mandatory.&quot;, isRequired = false, type = STRING),
          @RestParameter(name = &quot;limit&quot;, description = &quot;The maximum number of results to return for a single request.&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;offset&quot;, description = &quot;The index of the first result to return.&quot;, isRequired = false, type = RestParameter.Type.INTEGER),
          @RestParameter(name = &quot;withacl&quot;, isRequired = false, description = &quot;Whether the acl should be included in the response.&quot;, type = RestParameter.Type.BOOLEAN)
        }, responses = {
          @RestResponse(description = &quot;A (potentially empty) list of series is returned.&quot;, responseCode = HttpServletResponse.SC_OK) })
  public Response getSeriesList(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @QueryParam(&quot;filter&quot;) String filter,
          @QueryParam(&quot;sort&quot;) String sort, @QueryParam(&quot;order&quot;) String order, @QueryParam(&quot;offset&quot;) int offset,
          @QueryParam(&quot;limit&quot;) int limit, @QueryParam(&quot;onlyWithWriteAccess&quot;) Boolean onlyWithWriteAccess,
          @QueryParam(&quot;withacl&quot;) Boolean withAcl) throws UnauthorizedException {
<span class="fc" id="L221">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_5_0)) {</span>
      // withAcl was added for version 1.5.0 and should be ignored for smaller versions.
<span class="nc" id="L224">      withAcl = false;</span>
    }
    try {
<span class="fc" id="L227">      SeriesSearchQuery query = new SeriesSearchQuery(securityService.getOrganization().getId(),</span>
<span class="fc" id="L228">              securityService.getUser());</span>
<span class="fc" id="L229">      Option&lt;String&gt; optSort = Option.option(trimToNull(sort));</span>

<span class="pc bpc" id="L231" title="1 of 2 branches missed.">      if (offset &gt; 0) {</span>
<span class="nc" id="L232">        query.withOffset(offset);</span>
      }

      // If limit is 0, we set the default limit
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">      query.withLimit(limit &lt; 1 ? DEFAULT_LIMIT : limit);</span>

      // Parse the filters
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(filter)) {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        for (String f : filter.split(&quot;,&quot;)) {</span>
<span class="nc" id="L241">          String[] filterTuple = f.split(&quot;:&quot;,2);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">          if (filterTuple.length &lt; 2) {</span>
<span class="nc" id="L243">            logger.debug(&quot;Filter {} not valid: {}&quot;, filterTuple[0], filter);</span>
<span class="nc" id="L244">            continue;</span>
          }
<span class="nc" id="L246">          String name = filterTuple[0];</span>

          String value;
<span class="nc bnc" id="L249" title="All 2 branches missed.">          if (!requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
            // MH-13038 - 1.1.0 and higher support semi-colons in values
<span class="nc" id="L251">            value = f.substring(name.length() + 1);</span>
          } else {
<span class="nc" id="L253">            value = filterTuple[1];</span>
          }

<span class="nc bnc" id="L256" title="All 2 branches missed.">          if (&quot;managedAcl&quot;.equals(name)) {</span>
<span class="nc" id="L257">            query.withManagedAcl(value);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">          } else if (&quot;contributors&quot;.equals(name)) {</span>
<span class="nc" id="L259">            query.withContributor(value);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">          } else if (&quot;CreationDate&quot;.equals(name)) {</span>
              try {
<span class="nc" id="L262">                Tuple&lt;Date, Date&gt; fromAndToCreationRange = getFromAndToCreationRange(value.split(&quot;/&quot;)[0],</span>
<span class="nc" id="L263">                        value.split(&quot;/&quot;)[1]);</span>
<span class="nc" id="L264">                query.withCreatedFrom(fromAndToCreationRange.getA());</span>
<span class="nc" id="L265">                query.withCreatedTo(fromAndToCreationRange.getB());</span>
<span class="nc" id="L266">              } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L267">                return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L268">              } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L269">                String dateErrorMsg = String.format(&quot;Filter Series API error: Malformed date period. &quot;</span>
                    + &quot;Correct UTC time period format: yyyy-MM-ddTHH:mm:ssZ/yyyy-MM-ddTHH:mm:ssZ, &quot;
                    + &quot;stated date period string: \&quot;%s\&quot;&quot;, value);
<span class="nc" id="L272">                logger.warn(dateErrorMsg);</span>
<span class="nc" id="L273">                return RestUtil.R.badRequest(dateErrorMsg);</span>
<span class="nc" id="L274">              }</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">          } else if (&quot;Creator&quot;.equals(name)) {</span>
<span class="nc" id="L276">            query.withCreator(value);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">          } else if (&quot;textFilter&quot;.equals(name)) {</span>
<span class="nc" id="L278">            query.withText(QueryPreprocessor.sanitize(value));</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">          } else if (&quot;language&quot;.equals(name)) {</span>
<span class="nc" id="L280">            query.withLanguage(value);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">          } else if (&quot;license&quot;.equals(name)) {</span>
<span class="nc" id="L282">            query.withLicense(value);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">          } else if (&quot;organizers&quot;.equals(name)) {</span>
<span class="nc" id="L284">            query.withOrganizer(value);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">          } else if (&quot;subject&quot;.equals(name)) {</span>
<span class="nc" id="L286">            query.withSubject(value);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">          } else if (&quot;title&quot;.equals(name)) {</span>
<span class="nc" id="L288">            query.withTitle(value);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">          } else if (!requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
            // additional filters only available with Version 1.1.0 or higher
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (&quot;identifier&quot;.equals(name)) {</span>
<span class="nc" id="L292">              query.withIdentifier(value);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            } else if (&quot;description&quot;.equals(name)) {</span>
<span class="nc" id="L294">              query.withDescription(value);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            } else if (&quot;creator&quot;.equals(name)) {</span>
<span class="nc" id="L296">              query.withCreator(value);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            } else if (&quot;publishers&quot;.equals(name)) {</span>
<span class="nc" id="L298">              query.withPublisher(value);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">            } else if (&quot;rightsholder&quot;.equals(name)) {</span>
<span class="nc" id="L300">              query.withRightsHolder(value);</span>
            } else {
<span class="nc" id="L302">              logger.warn(&quot;Unknown filter criteria {}&quot;, name);</span>
<span class="nc" id="L303">              return Response.status(SC_BAD_REQUEST).build();</span>
            }
          }
        }
      }

<span class="pc bpc" id="L309" title="1 of 2 branches missed.">      if (optSort.isSome()) {</span>
<span class="nc" id="L310">        ArrayList&lt;SortCriterion&gt; sortCriteria = RestUtils.parseSortQueryParameter(optSort.get());</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        for (SortCriterion criterion : sortCriteria) {</span>

<span class="nc bnc" id="L313" title="All 5 branches missed.">          switch (criterion.getFieldName()) {</span>
            case SeriesIndexSchema.TITLE:
<span class="nc" id="L315">              query.sortByTitle(criterion.getOrder());</span>
<span class="nc" id="L316">              break;</span>
            case SeriesIndexSchema.CONTRIBUTORS:
<span class="nc" id="L318">              query.sortByContributors(criterion.getOrder());</span>
<span class="nc" id="L319">              break;</span>
            case SeriesIndexSchema.CREATOR:
<span class="nc" id="L321">              query.sortByOrganizers(criterion.getOrder());</span>
<span class="nc" id="L322">              break;</span>
            case EventIndexSchema.CREATED:
<span class="nc" id="L324">              query.sortByCreatedDateTime(criterion.getOrder());</span>
<span class="nc" id="L325">              break;</span>
            default:
<span class="nc" id="L327">              logger.info(&quot;Unknown sort criteria {}&quot;, criterion.getFieldName());</span>
<span class="nc" id="L328">              return Response.status(SC_BAD_REQUEST).build();</span>
          }
<span class="nc" id="L330">        }</span>
      }

<span class="pc bpc" id="L333" title="3 of 4 branches missed.">      if (onlyWithWriteAccess != null &amp;&amp; onlyWithWriteAccess) {</span>
<span class="nc" id="L334">        query.withoutActions();</span>
<span class="nc" id="L335">        query.withAction(Permissions.Action.WRITE);</span>
      }

<span class="fc" id="L338">      logger.trace(&quot;Using Query: &quot; + query.toString());</span>

<span class="fc" id="L340">      SearchResult&lt;Series&gt; result = elasticsearchIndex.getByQuery(query);</span>
<span class="pc bpc" id="L341" title="3 of 4 branches missed.">      final boolean includeAcl = (withAcl != null &amp;&amp; withAcl);</span>
<span class="fc" id="L342">      return queryResultToJson(result, includeAcl, requestedVersion);</span>

<span class="nc" id="L344">    } catch (Exception e) {</span>
<span class="nc" id="L345">      logger.warn(&quot;Could not perform search query&quot;, e);</span>
<span class="nc" id="L346">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  private Response queryResultToJson(SearchResult&lt;Series&gt; result, boolean includeAcl, ApiVersion requestedVersion) {
<span class="fc" id="L351">    return ApiResponseBuilder.Json.ok(requestedVersion, arr($(result.getItems()).map(new Fn&lt;SearchResultItem&lt;Series&gt;, JValue&gt;() {</span>
      @Override
      public JValue apply(SearchResultItem&lt;Series&gt; a) {
<span class="fc" id="L354">        final Series s = a.getSource();</span>
        JValue subjects;
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (s.getSubject() == null) {</span>
<span class="nc" id="L357">          subjects = arr();</span>
        } else {
<span class="fc" id="L359">          subjects = arr(splitSubjectIntoArray(s.getSubject()));</span>
        }
<span class="fc" id="L361">        Date createdDate = s.getCreatedDateTime();</span>
        JObject result;
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        if (requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
<span class="nc" id="L364">          result = obj(</span>
<span class="nc" id="L365">                  f(&quot;identifier&quot;, v(s.getIdentifier())),</span>
<span class="nc" id="L366">                  f(&quot;title&quot;, v(s.getTitle())),</span>
<span class="nc" id="L367">                  f(&quot;creator&quot;, v(s.getCreator(), BLANK)),</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                  f(&quot;created&quot;, v(createdDate != null ? toUTC(createdDate.getTime()) : null, BLANK)),</span>
<span class="nc" id="L369">                  f(&quot;subjects&quot;, subjects),</span>
<span class="nc" id="L370">                  f(&quot;contributors&quot;, arr($(s.getContributors()).map(Functions.stringToJValue))),</span>
<span class="nc" id="L371">                  f(&quot;organizers&quot;, arr($(s.getOrganizers()).map(Functions.stringToJValue))),</span>
<span class="nc" id="L372">                  f(&quot;publishers&quot;, arr($(s.getPublishers()).map(Functions.stringToJValue))));</span>
        }
        else {
<span class="fc" id="L375">          result = obj(</span>
<span class="fc" id="L376">                  f(&quot;identifier&quot;, v(s.getIdentifier())),</span>
<span class="fc" id="L377">                  f(&quot;title&quot;, v(s.getTitle())),</span>
<span class="fc" id="L378">                  f(&quot;description&quot;, v(s.getDescription(), BLANK)),</span>
<span class="fc" id="L379">                  f(&quot;creator&quot;, v(s.getCreator(), BLANK)),</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">                  f(&quot;created&quot;, v(createdDate != null ? toUTC(createdDate.getTime()) : null, BLANK)),</span>
<span class="fc" id="L381">                  f(&quot;subjects&quot;, subjects),</span>
<span class="fc" id="L382">                  f(&quot;contributors&quot;, arr($(s.getContributors()).map(Functions.stringToJValue))),</span>
<span class="fc" id="L383">                  f(&quot;organizers&quot;, arr($(s.getOrganizers()).map(Functions.stringToJValue))),</span>
<span class="fc" id="L384">                  f(&quot;language&quot;, v(s.getLanguage(), BLANK)),</span>
<span class="fc" id="L385">                  f(&quot;license&quot;, v(s.getLicense(), BLANK)),</span>
<span class="fc" id="L386">                  f(&quot;rightsholder&quot;, v(s.getRightsHolder(), BLANK)),</span>
<span class="fc" id="L387">                  f(&quot;publishers&quot;, arr($(s.getPublishers()).map(Functions.stringToJValue))));</span>

<span class="pc bpc" id="L389" title="1 of 2 branches missed.">          if (includeAcl) {</span>
<span class="nc" id="L390">            AccessControlList acl = getAclFromSeries(s);</span>
<span class="nc" id="L391">            result = result.merge(f(&quot;acl&quot;, arr(AclUtils.serializeAclToJson(acl))));</span>
          }
        }

<span class="fc" id="L395">        return result;</span>

      }
<span class="fc" id="L398">    }).toList()));</span>
  }

  /**
   * Get an {@link AccessControlList} from a {@link Series}.
   *
   * @param series
   *          The {@link Series} to get the ACL from.
   * @return The {@link AccessControlList} stored in the {@link Series}
   */
  private static AccessControlList getAclFromSeries(Series series) {
<span class="nc" id="L409">    AccessControlList activeAcl = new AccessControlList();</span>
    try {
<span class="nc bnc" id="L411" title="All 2 branches missed.">      if (series.getAccessPolicy() != null) {</span>
<span class="nc" id="L412">        activeAcl = AccessControlParser.parseAcl(series.getAccessPolicy());</span>
      }
<span class="nc" id="L414">    } catch (Exception e) {</span>
<span class="nc" id="L415">      logger.error(&quot;Unable to parse access policy&quot;, e);</span>
<span class="nc" id="L416">    }</span>
<span class="nc" id="L417">    return activeAcl;</span>
  }

  @GET
  @Path(&quot;{seriesId}&quot;)
  @RestQuery(name = &quot;getseries&quot;, description = &quot;Returns a single series.&quot;, returnDescription = &quot;&quot;,
  pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series id&quot;, isRequired = true, type = STRING)
  }, restParameters = {
          @RestParameter(name = &quot;withacl&quot;, isRequired = false, type = RestParameter.Type.BOOLEAN,
                         description = &quot;Whether the acl should be included in the response.&quot;)
  }, responses = {
          @RestResponse(description = &quot;The series is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
          @RestResponse(description = &quot;The specified series does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND),
  })
  public Response getSeries(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;seriesId&quot;) String id,
                            @QueryParam(&quot;withacl&quot;) Boolean withAcl)
          throws Exception {
<span class="fc" id="L435">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_5_0)) {</span>
      // withAcl was added for version 1.5.0 and should be ignored for smaller versions.
<span class="fc" id="L438">      withAcl = false;</span>
    }

<span class="fc" id="L441">    Optional&lt;Series&gt; optSeries = elasticsearchIndex.getSeries(id, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">    if (optSeries.isPresent()) {</span>
<span class="fc" id="L443">      final Series s = optSeries.get();</span>
      JValue subjects;
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">      if (s.getSubject() == null) {</span>
<span class="nc" id="L446">        subjects = arr();</span>
      } else {
<span class="fc" id="L448">        subjects = arr(splitSubjectIntoArray(s.getSubject()));</span>
      }
<span class="fc" id="L450">      Date createdDate = s.getCreatedDateTime();</span>
      JObject responseContent;
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">      if (requestedVersion.isSmallerThan(VERSION_1_1_0)) {</span>
<span class="fc" id="L453">        responseContent = obj(</span>
<span class="fc" id="L454">                f(&quot;identifier&quot;, v(s.getIdentifier())),</span>
<span class="fc" id="L455">                f(&quot;title&quot;, v(s.getTitle())),</span>
<span class="fc" id="L456">                f(&quot;description&quot;, v(s.getDescription(), BLANK)),</span>
<span class="fc" id="L457">                f(&quot;creator&quot;, v(s.getCreator(), BLANK)),</span>
<span class="fc" id="L458">                f(&quot;subjects&quot;, subjects),</span>
<span class="fc" id="L459">                f(&quot;organization&quot;, v(s.getOrganization())),</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">                f(&quot;created&quot;, v(createdDate != null ? toUTC(createdDate.getTime()) : null, BLANK)),</span>
<span class="fc" id="L461">                f(&quot;contributors&quot;, arr($(s.getContributors()).map(Functions.stringToJValue))),</span>
<span class="fc" id="L462">                f(&quot;organizers&quot;, arr($(s.getOrganizers()).map(Functions.stringToJValue))),</span>
                // For compatibility (MH-13405)
<span class="fc" id="L464">                f(&quot;opt_out&quot;, false),</span>
<span class="fc" id="L465">                f(&quot;publishers&quot;, arr($(s.getPublishers()).map(Functions.stringToJValue))));</span>
      }
      else {
<span class="nc" id="L468">        responseContent = obj(</span>
<span class="nc" id="L469">                f(&quot;identifier&quot;, v(s.getIdentifier())),</span>
<span class="nc" id="L470">                f(&quot;title&quot;, v(s.getTitle())),</span>
<span class="nc" id="L471">                f(&quot;description&quot;, v(s.getDescription(), BLANK)),</span>
<span class="nc" id="L472">                f(&quot;creator&quot;, v(s.getCreator(), BLANK)),</span>
<span class="nc" id="L473">                f(&quot;subjects&quot;, subjects),</span>
<span class="nc" id="L474">                f(&quot;organization&quot;, v(s.getOrganization())),</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">                f(&quot;created&quot;, v(createdDate != null ? toUTC(createdDate.getTime()) : null, BLANK)),</span>
<span class="nc" id="L476">                f(&quot;contributors&quot;, arr($(s.getContributors()).map(Functions.stringToJValue))),</span>
<span class="nc" id="L477">                f(&quot;organizers&quot;, arr($(s.getOrganizers()).map(Functions.stringToJValue))),</span>
                // For compatibility (MH-13405)
<span class="nc" id="L479">                f(&quot;opt_out&quot;, false),</span>
<span class="nc" id="L480">                f(&quot;publishers&quot;, arr($(s.getPublishers()).map(Functions.stringToJValue))),</span>
<span class="nc" id="L481">                f(&quot;language&quot;, v(s.getLanguage(), BLANK)),</span>
<span class="nc" id="L482">                f(&quot;license&quot;, v(s.getLicense(), BLANK)),</span>
<span class="nc" id="L483">                f(&quot;rightsholder&quot;, v(s.getRightsHolder(), BLANK)));</span>

<span class="nc bnc" id="L485" title="All 4 branches missed.">        if (withAcl != null &amp;&amp; withAcl) {</span>
<span class="nc" id="L486">          AccessControlList acl = getAclFromSeries(s);</span>
<span class="nc" id="L487">          responseContent = responseContent.merge(f(&quot;acl&quot;, arr(AclUtils.serializeAclToJson(acl))));</span>
        }
      }

<span class="fc" id="L491">      return ApiResponseBuilder.Json.ok(requestedVersion, responseContent);</span>
    }
<span class="nc" id="L493">    return ApiResponseBuilder.notFound(&quot;Cannot find an series with id '%s'.&quot;, id);</span>
  }

  private List&lt;JValue&gt; splitSubjectIntoArray(final String subject) {
<span class="fc" id="L497">    return com.entwinemedia.fn.Stream.$(subject.split(&quot;,&quot;)).map(new Fn&lt;String, JValue&gt;() {</span>
      @Override
      public JValue apply(String a) {
<span class="fc" id="L500">        return v(a.trim());</span>
      }
<span class="fc" id="L502">    }).toList();</span>
  }

  @GET
  @Path(&quot;{seriesId}/metadata&quot;)
  @RestQuery(name = &quot;getseriesmetadata&quot;, description = &quot;Returns a series' metadata of all types or returns a series' metadata collection of the given type when the query string parameter type is specified. For each metadata catalog there is a unique property called the flavor such as dublincore/series so the type in this example would be 'dublincore/series'&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = false, description = &quot;The type of metadata to return&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The series' metadata are returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The specified series does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getSeriesMetadata(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;seriesId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type) throws Exception {
<span class="fc" id="L514">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">    if (StringUtils.trimToNull(type) == null) {</span>
<span class="fc" id="L516">      return getAllMetadata(id, requestedVersion);</span>
    } else {
<span class="fc" id="L518">      return getMetadataByType(id, type, requestedVersion);</span>
    }
  }

  private Response getAllMetadata(String id, ApiVersion requestedVersion) throws SearchIndexException {
<span class="fc" id="L523">    Optional&lt;Series&gt; optSeries = elasticsearchIndex.getSeries(id, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">    if (optSeries.isEmpty())</span>
<span class="fc" id="L525">      return ApiResponseBuilder.notFound(&quot;Cannot find a series with id '%s'.&quot;, id);</span>

<span class="fc" id="L527">    MetadataList metadataList = new MetadataList();</span>
<span class="fc" id="L528">    List&lt;SeriesCatalogUIAdapter&gt; catalogUIAdapters = indexService.getSeriesCatalogUIAdapters();</span>
<span class="fc" id="L529">    catalogUIAdapters.remove(indexService.getCommonSeriesCatalogUIAdapter());</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">    for (SeriesCatalogUIAdapter adapter : catalogUIAdapters) {</span>
<span class="nc" id="L531">      final Opt&lt;DublinCoreMetadataCollection&gt; optSeriesMetadata = adapter.getFields(id);</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">      if (optSeriesMetadata.isSome()) {</span>
<span class="nc" id="L533">        metadataList.add(adapter.getFlavor().toString(), adapter.getUITitle(), optSeriesMetadata.get());</span>
      }
<span class="nc" id="L535">    }</span>
<span class="fc" id="L536">    DublinCoreMetadataCollection collection = getSeriesMetadata(optSeries.get());</span>
<span class="fc" id="L537">    ExternalMetadataUtils.changeSubjectToSubjects(collection);</span>
<span class="fc" id="L538">    metadataList.add(indexService.getCommonSeriesCatalogUIAdapter(), collection);</span>
<span class="fc" id="L539">    return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.listToJson(metadataList, false));</span>
  }

  private Response getMetadataByType(String id, String type, ApiVersion requestedVersion) throws SearchIndexException {
<span class="fc" id="L543">    Optional&lt;Series&gt; optSeries = elasticsearchIndex.getSeries(id, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">    if (optSeries.isEmpty())</span>
<span class="nc" id="L545">      return ApiResponseBuilder.notFound(&quot;Cannot find a series with id '%s'.&quot;, id);</span>

    // Try the main catalog first as we load it from the index.
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">    if (typeMatchesSeriesCatalogUIAdapter(type, indexService.getCommonSeriesCatalogUIAdapter())) {</span>
<span class="fc" id="L549">      DublinCoreMetadataCollection collection = getSeriesMetadata(optSeries.get());</span>
<span class="fc" id="L550">      ExternalMetadataUtils.changeSubjectToSubjects(collection);</span>
<span class="fc" id="L551">      return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.collectionToJson(collection, false));</span>
    }

    // Try the other catalogs
<span class="nc" id="L555">    List&lt;SeriesCatalogUIAdapter&gt; catalogUIAdapters = indexService.getSeriesCatalogUIAdapters();</span>
<span class="nc" id="L556">    catalogUIAdapters.remove(indexService.getCommonSeriesCatalogUIAdapter());</span>

<span class="nc bnc" id="L558" title="All 2 branches missed.">    for (SeriesCatalogUIAdapter adapter : catalogUIAdapters) {</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">      if (typeMatchesSeriesCatalogUIAdapter(type, adapter)) {</span>
<span class="nc" id="L560">        final Opt&lt;DublinCoreMetadataCollection&gt; optSeriesMetadata = adapter.getFields(id);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (optSeriesMetadata.isSome()) {</span>
<span class="nc" id="L562">          return ApiResponseBuilder.Json.ok(requestedVersion, MetadataJson.collectionToJson(optSeriesMetadata.get(), true));</span>
        }
      }
<span class="nc" id="L565">    }</span>
<span class="nc" id="L566">    return ApiResponseBuilder.notFound(&quot;Cannot find a catalog with type '%s' for series with id '%s'.&quot;, type, id);</span>
  }

  /**
   * Loads the metadata for the given series
   *
   * @param series
   *          the source {@link Series}
   * @return a {@link DublinCoreMetadataCollection} instance with all the series metadata
   */
  private DublinCoreMetadataCollection getSeriesMetadata(Series series) {
<span class="fc" id="L577">    DublinCoreMetadataCollection metadata = indexService.getCommonSeriesCatalogUIAdapter().getRawFields();</span>

<span class="fc" id="L579">    MetadataField title = metadata.getOutputFields().get(DublinCore.PROPERTY_TITLE.getLocalName());</span>
<span class="fc" id="L580">    metadata.removeField(title);</span>
<span class="fc" id="L581">    MetadataField newTitle = new MetadataField(title);</span>
<span class="fc" id="L582">    newTitle.setValue(series.getTitle());</span>
<span class="fc" id="L583">    metadata.addField(newTitle);</span>

<span class="fc" id="L585">    MetadataField subject = metadata.getOutputFields().get(DublinCore.PROPERTY_SUBJECT.getLocalName());</span>
<span class="fc" id="L586">    metadata.removeField(subject);</span>
<span class="fc" id="L587">    MetadataField newSubject = new MetadataField(subject);</span>
<span class="fc" id="L588">    newSubject.setValue(series.getSubject());</span>
<span class="fc" id="L589">    metadata.addField(newSubject);</span>

<span class="fc" id="L591">    MetadataField description = metadata.getOutputFields().get(DublinCore.PROPERTY_DESCRIPTION.getLocalName());</span>
<span class="fc" id="L592">    metadata.removeField(description);</span>
<span class="fc" id="L593">    MetadataField newDescription = new MetadataField(description);</span>
<span class="fc" id="L594">    newDescription.setValue(series.getDescription());</span>
<span class="fc" id="L595">    metadata.addField(newDescription);</span>

<span class="fc" id="L597">    MetadataField language = metadata.getOutputFields().get(DublinCore.PROPERTY_LANGUAGE.getLocalName());</span>
<span class="fc" id="L598">    metadata.removeField(language);</span>
<span class="fc" id="L599">    MetadataField newLanguage = new MetadataField(language);</span>
<span class="fc" id="L600">    newLanguage.setValue(series.getLanguage());</span>
<span class="fc" id="L601">    metadata.addField(newLanguage);</span>

<span class="fc" id="L603">    MetadataField rightsHolder = metadata.getOutputFields().get(DublinCore.PROPERTY_RIGHTS_HOLDER.getLocalName());</span>
<span class="fc" id="L604">    metadata.removeField(rightsHolder);</span>
<span class="fc" id="L605">    MetadataField newRightsHolder = new MetadataField(rightsHolder);</span>
<span class="fc" id="L606">    newRightsHolder.setValue(series.getRightsHolder());</span>
<span class="fc" id="L607">    metadata.addField(newRightsHolder);</span>

<span class="fc" id="L609">    MetadataField license = metadata.getOutputFields().get(DublinCore.PROPERTY_LICENSE.getLocalName());</span>
<span class="fc" id="L610">    metadata.removeField(license);</span>
<span class="fc" id="L611">    MetadataField newLicense = new MetadataField(license);</span>
<span class="fc" id="L612">    newLicense.setValue(series.getLicense());</span>
<span class="fc" id="L613">    metadata.addField(newLicense);</span>

<span class="fc" id="L615">    MetadataField organizers = metadata.getOutputFields().get(DublinCore.PROPERTY_CREATOR.getLocalName());</span>
<span class="fc" id="L616">    metadata.removeField(organizers);</span>
<span class="fc" id="L617">    MetadataField newOrganizers = new MetadataField(organizers);</span>
<span class="fc" id="L618">    newOrganizers.setValue(StringUtils.join(series.getOrganizers(), &quot;, &quot;));</span>
<span class="fc" id="L619">    metadata.addField(newOrganizers);</span>

<span class="fc" id="L621">    MetadataField contributors = metadata.getOutputFields().get(DublinCore.PROPERTY_CONTRIBUTOR.getLocalName());</span>
<span class="fc" id="L622">    metadata.removeField(contributors);</span>
<span class="fc" id="L623">    MetadataField newContributors = new MetadataField(contributors);</span>
<span class="fc" id="L624">    newContributors.setValue(StringUtils.join(series.getContributors(), &quot;, &quot;));</span>
<span class="fc" id="L625">    metadata.addField(newContributors);</span>

<span class="fc" id="L627">    MetadataField publishers = metadata.getOutputFields().get(DublinCore.PROPERTY_PUBLISHER.getLocalName());</span>
<span class="fc" id="L628">    metadata.removeField(publishers);</span>
<span class="fc" id="L629">    MetadataField newPublishers = new MetadataField(publishers);</span>
<span class="fc" id="L630">    newPublishers.setValue(StringUtils.join(series.getPublishers(), &quot;, &quot;));</span>
<span class="fc" id="L631">    metadata.addField(newPublishers);</span>

    // Admin UI only field
<span class="fc" id="L634">    MetadataField createdBy = new MetadataField(</span>
            &quot;createdBy&quot;,
            null,
            &quot;EVENTS.SERIES.DETAILS.METADATA.CREATED_BY&quot;,
            true,
            false,
            null,
            null,
            MetadataField.Type.TEXT,
            null,
            null,
<span class="fc" id="L645">            CREATED_BY_UI_ORDER,</span>
            null,
            null,
            null,
            null);
<span class="fc" id="L650">    createdBy.setValue(series.getCreator());</span>
<span class="fc" id="L651">    metadata.addField(createdBy);</span>

<span class="fc" id="L653">    MetadataField uid = metadata.getOutputFields().get(DublinCore.PROPERTY_IDENTIFIER.getLocalName());</span>
<span class="fc" id="L654">    metadata.removeField(uid);</span>
<span class="fc" id="L655">    MetadataField newUID = new MetadataField(uid);</span>
<span class="fc" id="L656">    newUID.setValue(series.getIdentifier());</span>
<span class="fc" id="L657">    metadata.addField(newUID);</span>

<span class="fc" id="L659">    ExternalMetadataUtils.removeCollectionList(metadata);</span>

<span class="fc" id="L661">    return metadata;</span>
  }

  /**
   * Checks if a flavor type matches a series catalog's flavor type.
   *
   * @param type
   *          The flavor type to compare against the catalog's flavor
   * @param catalog
   *          The catalog to check if it matches the flavor.
   * @return True if it matches.
   */
  private boolean typeMatchesSeriesCatalogUIAdapter(String type, SeriesCatalogUIAdapter catalog) {
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">    if (StringUtils.trimToNull(type) == null) {</span>
<span class="nc" id="L675">      return false;</span>
    }
<span class="fc" id="L677">    MediaPackageElementFlavor catalogFlavor = MediaPackageElementFlavor.parseFlavor(catalog.getFlavor().toString());</span>
    try {
<span class="fc" id="L679">      MediaPackageElementFlavor flavor = MediaPackageElementFlavor.parseFlavor(type);</span>
<span class="fc" id="L680">      return flavor.equals(catalogFlavor);</span>
<span class="nc" id="L681">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L682">      return false;</span>
    }
  }

  private Opt&lt;MediaPackageElementFlavor&gt; getFlavor(String flavorString) {
    try {
<span class="fc" id="L688">      MediaPackageElementFlavor flavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>
<span class="fc" id="L689">      return Opt.some(flavor);</span>
<span class="nc" id="L690">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L691">      return Opt.none();</span>
    }
  }

  @PUT
  @Path(&quot;{seriesId}/metadata&quot;)
  @RestQuery(name = &quot;updateseriesmetadata&quot;, description = &quot;Update a series' metadata of the given type. For a metadata catalog there is the flavor such as 'dublincore/series' and this is the unique type.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = true, description = &quot;The type of metadata to update&quot;, type = STRING),
                  @RestParameter(name = &quot;metadata&quot;, description = &quot;Series metadata as Form param&quot;, isRequired = true, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The series' metadata have been updated.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The request is invalid or inconsistent.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                          @RestResponse(description = &quot;The specified series does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateSeriesMetadata(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;seriesId&quot;) String id,
          @QueryParam(&quot;type&quot;) String type, @FormParam(&quot;metadata&quot;) String metadataJSON) throws Exception {
<span class="fc bfc" id="L706" title="All 2 branches covered.">    if (StringUtils.trimToNull(metadataJSON) == null) {</span>
<span class="fc" id="L707">      return RestUtil.R.badRequest(&quot;Unable to update metadata for series as the metadata provided is empty.&quot;);</span>
    }
    Map&lt;String, String&gt; updatedFields;
    try {
<span class="fc" id="L711">      updatedFields = RequestUtils.getKeyValueMap(metadataJSON);</span>
<span class="nc" id="L712">    } catch (ParseException e) {</span>
<span class="nc" id="L713">      logger.debug(&quot;Unable to update series '{}' with metadata type '{}' and content '{}'&quot;, id, type, metadataJSON, e);</span>
<span class="nc" id="L714">      return RestUtil.R.badRequest(String.format(&quot;Unable to parse metadata fields as json from '%s' because '%s'&quot;,</span>
<span class="nc" id="L715">              metadataJSON, e.getMessage()));</span>
<span class="nc" id="L716">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L717">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="fc" id="L718">    }</span>

<span class="pc bpc" id="L720" title="1 of 4 branches missed.">    if (updatedFields == null || updatedFields.size() == 0) {</span>
<span class="fc" id="L721">      return RestUtil.R.badRequest(</span>
<span class="fc" id="L722">              String.format(&quot;Unable to parse metadata fields as json from '%s' because there were no fields to update.&quot;,</span>
                      metadataJSON));
    }

<span class="fc" id="L726">    Opt&lt;DublinCoreMetadataCollection&gt; optCollection = Opt.none();</span>
<span class="fc" id="L727">    SeriesCatalogUIAdapter adapter = null;</span>

<span class="fc" id="L729">    Optional&lt;Series&gt; optSeries = elasticsearchIndex.getSeries(id, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">    if (optSeries.isEmpty())</span>
<span class="nc" id="L731">      return ApiResponseBuilder.notFound(&quot;Cannot find a series with id '%s'.&quot;, id);</span>

<span class="fc" id="L733">    MetadataList metadataList = new MetadataList();</span>

    // Try the main catalog first as we load it from the index.
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">    if (typeMatchesSeriesCatalogUIAdapter(type, indexService.getCommonSeriesCatalogUIAdapter())) {</span>
<span class="fc" id="L737">      optCollection = Opt.some(getSeriesMetadata(optSeries.get()));</span>
<span class="fc" id="L738">      adapter = indexService.getCommonSeriesCatalogUIAdapter();</span>
    } else {
<span class="nc" id="L740">      metadataList.add(indexService.getCommonSeriesCatalogUIAdapter(), getSeriesMetadata(optSeries.get()));</span>
    }

    // Try the other catalogs
<span class="fc" id="L744">    List&lt;SeriesCatalogUIAdapter&gt; catalogUIAdapters = indexService.getSeriesCatalogUIAdapters();</span>
<span class="fc" id="L745">    catalogUIAdapters.remove(indexService.getCommonSeriesCatalogUIAdapter());</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">    if (catalogUIAdapters.size() &gt; 0) {</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">      for (SeriesCatalogUIAdapter catalogUIAdapter : catalogUIAdapters) {</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">        if (typeMatchesSeriesCatalogUIAdapter(type, catalogUIAdapter)) {</span>
<span class="nc" id="L749">          optCollection = catalogUIAdapter.getFields(id);</span>
<span class="nc" id="L750">          adapter = catalogUIAdapter;</span>
        } else {
<span class="nc" id="L752">          Opt&lt;DublinCoreMetadataCollection&gt; current = catalogUIAdapter.getFields(id);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">          if (current.isSome()) {</span>
<span class="nc" id="L754">            metadataList.add(catalogUIAdapter, current.get());</span>
          }
        }
<span class="nc" id="L757">      }</span>
    }

<span class="pc bpc" id="L760" title="1 of 2 branches missed.">    if (optCollection.isNone()) {</span>
<span class="nc" id="L761">      return ApiResponseBuilder.notFound(&quot;Cannot find a catalog with type '%s' for series with id '%s'.&quot;, type, id);</span>
    }

<span class="fc" id="L764">    DublinCoreMetadataCollection collection = optCollection.get();</span>

<span class="fc bfc" id="L766" title="All 2 branches covered.">    for (String key : updatedFields.keySet()) {</span>
<span class="fc" id="L767">      MetadataField field = collection.getOutputFields().get(key);</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L769">        return ApiResponseBuilder.notFound(</span>
                &quot;Cannot find a metadata field with id '%s' from event with id '%s' and the metadata type '%s'.&quot;, key,
                id, type);
<span class="pc bpc" id="L772" title="1 of 4 branches missed.">      } else if (field.isRequired() &amp;&amp; StringUtils.isBlank(updatedFields.get(key))) {</span>
<span class="nc" id="L773">        return R.badRequest(String.format(</span>
                &quot;The series metadata field with id '%s' and the metadata type '%s' is required and can not be empty!.&quot;,
                key, type));
      }
<span class="fc" id="L777">      collection.removeField(field);</span>
<span class="fc" id="L778">      collection.addField(MetadataJson.copyWithDifferentJsonValue(field, updatedFields.get(key)));</span>
<span class="fc" id="L779">    }</span>

<span class="fc" id="L781">    metadataList.add(adapter, collection);</span>
<span class="fc" id="L782">    indexService.updateAllSeriesMetadata(id, metadataList, elasticsearchIndex);</span>
<span class="fc" id="L783">    return ApiResponseBuilder.Json.ok(acceptHeader, &quot;&quot;);</span>
  }

  @DELETE
  @Path(&quot;{seriesId}/metadata&quot;)
  @RestQuery(name = &quot;deleteseriesmetadata&quot;, description = &quot;Deletes a series' metadata catalog of the given type. All fields and values of that catalog will be deleted.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;type&quot;, isRequired = true, description = &quot;The type of metadata to delete&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The metadata have been deleted.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                          @RestResponse(description = &quot;The main metadata catalog dublincore/series cannot be deleted as it has mandatory fields.&quot;, responseCode = HttpServletResponse.SC_FORBIDDEN),
                          @RestResponse(description = &quot;The specified series does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteSeriesMetadataByType(@HeaderParam(&quot;Accept&quot;) String acceptHeader,
          @PathParam(&quot;seriesId&quot;) String id, @QueryParam(&quot;type&quot;) String type) throws Exception {
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">    if (StringUtils.trimToNull(type) == null) {</span>
<span class="nc" id="L797">      return RestUtil.R</span>
<span class="nc" id="L798">              .badRequest(String.format(&quot;A type of catalog needs to be specified for series '%s' to delete it.&quot;, id));</span>
    }

<span class="fc" id="L801">    Opt&lt;MediaPackageElementFlavor&gt; flavor = getFlavor(type);</span>

<span class="pc bpc" id="L803" title="1 of 2 branches missed.">    if (flavor.isNone()) {</span>
<span class="nc" id="L804">      return RestUtil.R.badRequest(</span>
<span class="nc" id="L805">              String.format(&quot;Unable to parse flavor '%s' it should look something like dublincore/series.&quot;, type));</span>
    }

<span class="fc bfc" id="L808" title="All 2 branches covered.">    if (typeMatchesSeriesCatalogUIAdapter(type, indexService.getCommonSeriesCatalogUIAdapter())) {</span>
<span class="fc" id="L809">      return Response</span>
<span class="fc" id="L810">              .status(Status.FORBIDDEN).entity(String</span>
<span class="fc" id="L811">                      .format(&quot;Unable to delete mandatory metadata catalog with type '%s' for series '%s'&quot;, type, id))</span>
<span class="fc" id="L812">              .build();</span>
    }

<span class="fc" id="L815">    Optional&lt;Series&gt; optSeries = elasticsearchIndex.getSeries(id, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">    if (optSeries.isEmpty())</span>
<span class="nc" id="L817">      return ApiResponseBuilder.notFound(&quot;Cannot find a series with id '%s'.&quot;, id);</span>

    try {
<span class="fc" id="L820">      indexService.removeCatalogByFlavor(optSeries.get(), MediaPackageElementFlavor.parseFlavor(type));</span>
<span class="nc" id="L821">    } catch (NotFoundException e) {</span>
<span class="nc" id="L822">      return ApiResponseBuilder.notFound(e.getMessage());</span>
<span class="fc" id="L823">    }</span>
<span class="fc" id="L824">    return Response.noContent().build();</span>
  }

  @GET
  @Path(&quot;{seriesId}/acl&quot;)
  @RestQuery(name = &quot;getseriesacl&quot;, description = &quot;Returns a series' access policy.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series id&quot;, isRequired = true, type = STRING) }, responses = {
                  @RestResponse(description = &quot;The series' access policy is returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified series does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getSeriesAcl(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;seriesId&quot;) String id) throws Exception {
<span class="fc" id="L834">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="fc" id="L835">    JSONParser parser = new JSONParser();</span>
<span class="fc" id="L836">    Optional&lt;Series&gt; optSeries = elasticsearchIndex.getSeries(id, securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="pc bpc" id="L837" title="1 of 2 branches missed.">    if (optSeries.isPresent()) {</span>
<span class="fc" id="L838">      Series series = optSeries.get();</span>
      // The ACL is stored as JSON string in the index. Parse it and extract the part we want to have in the API.
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">      if (series.getAccessPolicy() == null) {</span>
<span class="nc" id="L841">        return ApiResponseBuilder.notFound(&quot;Acl for series with id '%s' is not defined.&quot;, id);</span>
      }
<span class="fc" id="L843">      JSONObject acl = (JSONObject) parser.parse(series.getAccessPolicy());</span>

<span class="pc bpc" id="L845" title="1 of 2 branches missed.">      if (!((JSONObject) acl.get(&quot;acl&quot;)).containsKey(&quot;ace&quot;)) {</span>
<span class="nc" id="L846">        return ApiResponseBuilder.notFound(&quot;Cannot find acl for series with id '%s'.&quot;, id);</span>
      } else {
<span class="fc" id="L848">        return ApiResponseBuilder.Json.ok(requestedVersion, ((JSONArray) ((JSONObject) acl.get(&quot;acl&quot;)).get(&quot;ace&quot;)).toJSONString());</span>
      }
    }

<span class="nc" id="L852">    return ApiResponseBuilder.notFound(&quot;Cannot find an series with id '%s'.&quot;, id);</span>
  }

  @GET
  @Path(&quot;{seriesId}/properties&quot;)
  @RestQuery(name = &quot;getseriesproperties&quot;, description = &quot;Returns a series' properties&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series id&quot;, isRequired = true, type = STRING) }, responses = {
                  @RestResponse(description = &quot;The series' properties are returned.&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The specified series does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response getSeriesProperties(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;seriesId&quot;) String id) throws Exception {
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">    if (elasticsearchIndex.getSeries(id, securityService.getOrganization().getId(), securityService.getUser()).isPresent()) {</span>
<span class="fc" id="L863">      final Map&lt;String, String&gt; properties = seriesService.getSeriesProperties(id);</span>

<span class="fc" id="L865">      return ApiResponseBuilder.Json.ok(acceptHeader, obj($(properties.entrySet()).map(new Fn&lt;Entry&lt;String, String&gt;, Field&gt;() {</span>
                @Override
                public Field apply(Entry&lt;String, String&gt; a) {
<span class="fc" id="L868">                  return f(a.getKey(), v(a.getValue(), BLANK));</span>
                }
<span class="fc" id="L870">              }).toList()));</span>
    } else {
<span class="nc" id="L872">      return ApiResponseBuilder.notFound(&quot;Cannot find an series with id '%s'.&quot;, id);</span>
    }
  }

  @DELETE
  @Path(&quot;{seriesId}&quot;)
  @RestQuery(name = &quot;deleteseries&quot;, description = &quot;Deletes a series.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series id&quot;, isRequired = true, type = STRING) }, responses = {
                  @RestResponse(description = &quot;The series has been deleted.&quot;, responseCode = HttpServletResponse.SC_NO_CONTENT),
                  @RestResponse(description = &quot;The specified series does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response deleteSeries(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;seriesId&quot;) String id)
          throws NotFoundException {
    try {
<span class="fc" id="L885">      indexService.removeSeries(id);</span>
<span class="fc" id="L886">      return Response.noContent().build();</span>
<span class="nc" id="L887">    } catch (NotFoundException e) {</span>
<span class="nc" id="L888">      return ApiResponseBuilder.notFound(&quot;Cannot find a series with id '%s'.&quot;, id);</span>
<span class="nc" id="L889">    } catch (Exception e) {</span>
<span class="nc" id="L890">      logger.error(&quot;Unable to delete the series '{}' due to&quot;, id, e);</span>
<span class="nc" id="L891">      return Response.serverError().build();</span>
    }
  }

  @PUT
  @Path(&quot;{seriesId}&quot;)
  @RestQuery(name = &quot;updateallseriesmetadata&quot;, description = &quot;Update all series metadata.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;metadata&quot;, description = &quot;Series metadata as Form param&quot;, isRequired = true, type = STRING) }, responses = {
                          @RestResponse(description = &quot;The series' metadata have been updated.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The request is invalid or inconsistent.&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                          @RestResponse(description = &quot;The specified series does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateSeriesMetadata(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;seriesId&quot;) String seriesID,
          @FormParam(&quot;metadata&quot;) String metadataJSON)
          throws UnauthorizedException, NotFoundException, SearchIndexException {
    try {
<span class="nc" id="L907">      MetadataList metadataList = indexService.updateAllSeriesMetadata(seriesID, metadataJSON, elasticsearchIndex);</span>
<span class="nc" id="L908">      return ApiResponseBuilder.Json.ok(acceptHeader, MetadataJson.listToJson(metadataList, true));</span>
<span class="nc" id="L909">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L910">      logger.debug(&quot;Unable to update series '{}' with metadata '{}'&quot;, seriesID, metadataJSON, e);</span>
<span class="nc" id="L911">      return RestUtil.R.badRequest(e.getMessage());</span>
<span class="nc" id="L912">    } catch (IndexServiceException e) {</span>
<span class="nc" id="L913">      logger.error(&quot;Unable to update series '{}' with metadata '{}'&quot;, seriesID, metadataJSON, e);</span>
<span class="nc" id="L914">      return RestUtil.R.serverError();</span>
    }
  }

  @POST
  @Path(&quot;&quot;)
  @RestQuery(name = &quot;createseries&quot;, description = &quot;Creates a series.&quot;, returnDescription = &quot;&quot;, restParameters = {
          @RestParameter(name = &quot;metadata&quot;, isRequired = true, description = &quot;Series metadata&quot;, type = STRING),
          @RestParameter(name = &quot;acl&quot;, description = &quot;A collection of roles with their possible action&quot;, isRequired = true, type = STRING),
          @RestParameter(name = &quot;theme&quot;, description = &quot;The theme ID to be applied to the series&quot;, isRequired = false, type = STRING) }, responses = {
                  @RestResponse(description = &quot;A new series is created and its identifier is returned in the Location header.&quot;, responseCode = HttpServletResponse.SC_CREATED),
                  @RestResponse(description = &quot;The request is invalid or inconsistent..&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                  @RestResponse(description = &quot;The user doesn't have the rights to create the series.&quot;, responseCode = HttpServletResponse.SC_UNAUTHORIZED) })
  public Response createNewSeries(@HeaderParam(&quot;Accept&quot;) String acceptHeader,
          @FormParam(&quot;metadata&quot;) String metadataParam, @FormParam(&quot;acl&quot;) String aclParam,
          @FormParam(&quot;theme&quot;) String themeIdParam) throws UnauthorizedException, NotFoundException {
<span class="fc bfc" id="L930" title="All 2 branches covered.">    if (isBlank(metadataParam))</span>
<span class="fc" id="L931">      return R.badRequest(&quot;Required parameter 'metadata' is missing or invalid&quot;);</span>

<span class="pc bpc" id="L933" title="1 of 2 branches missed.">    if (isBlank(aclParam))</span>
<span class="nc" id="L934">      return R.badRequest(&quot;Required parameter 'acl' is missing or invalid&quot;);</span>

    MetadataList metadataList;
    try {
<span class="fc" id="L938">      metadataList = deserializeMetadataList(metadataParam);</span>
<span class="nc" id="L939">    } catch (ParseException e) {</span>
<span class="nc" id="L940">      logger.debug(&quot;Unable to parse series metadata '{}'&quot;, metadataParam, e);</span>
<span class="nc" id="L941">      return R.badRequest(String.format(&quot;Unable to parse metadata because '%s'&quot;, e.getMessage()));</span>
<span class="nc" id="L942">    } catch (NotFoundException e) {</span>
      // One of the metadata fields could not be found in the catalogs or one of the catalogs cannot be found.
<span class="nc" id="L944">      return R.badRequest(e.getMessage());</span>
<span class="nc" id="L945">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L946">      logger.debug(&quot;Unable to create series with metadata '{}'&quot;, metadataParam, e);</span>
<span class="nc" id="L947">      return R.badRequest(e.getMessage());</span>
<span class="fc" id="L948">    }</span>
<span class="fc" id="L949">    Map&lt;String, String&gt; options = new TreeMap&lt;&gt;();</span>
<span class="fc" id="L950">    Opt&lt;Long&gt; optThemeId = Opt.none();</span>
<span class="pc bpc" id="L951" title="1 of 2 branches missed.">    if (StringUtils.trimToNull(themeIdParam) != null) {</span>
      try {
<span class="fc" id="L953">        Long themeId = Long.parseLong(themeIdParam);</span>
<span class="fc" id="L954">        optThemeId = Opt.some(themeId);</span>
<span class="nc" id="L955">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L956">        return R.badRequest(String.format(&quot;Unable to parse the theme id '%s' into a number&quot;, themeIdParam));</span>
<span class="fc" id="L957">      }</span>
    }
    AccessControlList acl;
    try {
<span class="fc" id="L961">      acl = AclUtils.deserializeJsonToAcl(aclParam, false);</span>
<span class="nc" id="L962">    } catch (ParseException e) {</span>
<span class="nc" id="L963">      logger.debug(&quot;Unable to parse acl '{}'&quot;, aclParam, e);</span>
<span class="nc" id="L964">      return R.badRequest(String.format(&quot;Unable to parse acl '%s' because '%s'&quot;, aclParam, e.getMessage()));</span>
<span class="nc" id="L965">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L966">      logger.debug(&quot;Unable to create new series with acl '{}'&quot;, aclParam, e);</span>
<span class="nc" id="L967">      return R.badRequest(e.getMessage());</span>
<span class="fc" id="L968">    }</span>

    try {
<span class="fc" id="L971">      String seriesId = indexService.createSeries(metadataList, options, Opt.some(acl), optThemeId);</span>
<span class="fc" id="L972">      return ApiResponseBuilder.Json.created(acceptHeader, URI.create(getSeriesUrl(seriesId)),</span>
<span class="fc" id="L973">                                       obj(f(&quot;identifier&quot;, v(seriesId, BLANK))));</span>
<span class="nc" id="L974">    } catch (IndexServiceException e) {</span>
<span class="nc" id="L975">      logger.error(&quot;Unable to create series with metadata '{}', acl '{}', theme '{}'&quot;,</span>
              metadataParam, aclParam, themeIdParam, e);
<span class="nc" id="L977">      throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Change the simplified fields of key values provided to the external api into a {@link MetadataList}.
   *
   * @param json
   *          The json string that contains an array of metadata field lists for the different catalogs.
   * @return A {@link MetadataList} with the fields populated with the values provided.
   * @throws ParseException
   *           Thrown if unable to parse the json string.
   * @throws NotFoundException
   *           Thrown if unable to find the catalog or field that the json refers to.
   */
  protected MetadataList deserializeMetadataList(String json) throws ParseException, NotFoundException {
<span class="fc" id="L993">    MetadataList metadataList = new MetadataList();</span>
<span class="fc" id="L994">    JSONParser parser = new JSONParser();</span>
<span class="fc" id="L995">    JSONArray jsonCatalogs = (JSONArray) parser.parse(json);</span>
<span class="fc bfc" id="L996" title="All 2 branches covered.">    for (int i = 0; i &lt; jsonCatalogs.size(); i++) {</span>
<span class="fc" id="L997">      JSONObject catalog = (JSONObject) jsonCatalogs.get(i);</span>
<span class="pc bpc" id="L998" title="2 of 4 branches missed.">      if (catalog.get(&quot;flavor&quot;) == null || StringUtils.isBlank(catalog.get(&quot;flavor&quot;).toString())) {</span>
<span class="nc" id="L999">        throw new IllegalArgumentException(</span>
                &quot;Unable to create new series as no flavor was given for one of the metadata collections&quot;);
      }
<span class="fc" id="L1002">      String flavorString = catalog.get(&quot;flavor&quot;).toString();</span>

<span class="fc" id="L1004">      MediaPackageElementFlavor flavor = MediaPackageElementFlavor.parseFlavor(flavorString);</span>

<span class="fc" id="L1006">      DublinCoreMetadataCollection collection = null;</span>
<span class="fc" id="L1007">      SeriesCatalogUIAdapter adapter = null;</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">      for (SeriesCatalogUIAdapter seriesCatalogUIAdapter : indexService.getSeriesCatalogUIAdapters()) {</span>
<span class="fc" id="L1009">        MediaPackageElementFlavor catalogFlavor = MediaPackageElementFlavor</span>
<span class="fc" id="L1010">                .parseFlavor(seriesCatalogUIAdapter.getFlavor().toString());</span>
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">        if (catalogFlavor.equals(flavor)) {</span>
<span class="fc" id="L1012">          adapter = seriesCatalogUIAdapter;</span>
<span class="fc" id="L1013">          collection = seriesCatalogUIAdapter.getRawFields();</span>
        }
<span class="fc" id="L1015">      }</span>

<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">      if (collection == null) {</span>
<span class="nc" id="L1018">        throw new IllegalArgumentException(</span>
<span class="nc" id="L1019">                String.format(&quot;Unable to find an SeriesCatalogUIAdapter with Flavor '%s'&quot;, flavorString));</span>
      }

<span class="fc" id="L1022">      String fieldsJson = catalog.get(&quot;fields&quot;).toString();</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">      if (StringUtils.trimToNull(fieldsJson) != null) {</span>
<span class="fc" id="L1024">        Map&lt;String, String&gt; fields = RequestUtils.getKeyValueMap(fieldsJson);</span>
<span class="fc bfc" id="L1025" title="All 2 branches covered.">        for (String key : fields.keySet()) {</span>
<span class="pc bpc" id="L1026" title="1 of 2 branches missed.">          if (&quot;subjects&quot;.equals(key)) {</span>
<span class="nc" id="L1027">            MetadataField field = collection.getOutputFields().get(&quot;subject&quot;);</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L1029">              throw new NotFoundException(String.format(</span>
                      &quot;Cannot find a metadata field with id '%s' from Catalog with Flavor '%s'.&quot;, key, flavorString));
            }
<span class="nc" id="L1032">            collection.removeField(field);</span>
            try {
<span class="nc" id="L1034">              JSONArray subjects = (JSONArray) parser.parse(fields.get(key));</span>
<span class="nc" id="L1035">              collection.addField(</span>
<span class="nc" id="L1036">                      MetadataJson.copyWithDifferentJsonValue(field, StringUtils.join(subjects.iterator(), &quot;,&quot;)));</span>
<span class="nc" id="L1037">            } catch (ParseException e) {</span>
<span class="nc" id="L1038">              throw new IllegalArgumentException(</span>
<span class="nc" id="L1039">                      String.format(&quot;Unable to parse the 'subjects' metadata array field because: %s&quot;, e.toString()));</span>
<span class="nc" id="L1040">            }</span>
<span class="nc" id="L1041">          } else {</span>
<span class="fc" id="L1042">            MetadataField field = collection.getOutputFields().get(key);</span>
<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L1044">              throw new NotFoundException(String.format(</span>
                      &quot;Cannot find a metadata field with id '%s' from Catalog with Flavor '%s'.&quot;, key, flavorString));
            }
<span class="fc" id="L1047">            collection.removeField(field);</span>
<span class="fc" id="L1048">            collection.addField(MetadataJson.copyWithDifferentJsonValue(field, fields.get(key)));</span>
          }
<span class="fc" id="L1050">        }</span>
      }
<span class="fc" id="L1052">      metadataList.add(adapter, collection);</span>
    }
<span class="fc" id="L1054">    return metadataList;</span>
  }

  @PUT
  @Path(&quot;{seriesId}/acl&quot;)
  @RestQuery(name = &quot;updateseriesacl&quot;, description = &quot;Updates a series' access policy.&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;acl&quot;, isRequired = true, description = &quot;Access policy&quot;, type = STRING),
                  @RestParameter(name = &quot;override&quot;, isRequired = false, description = &quot;If true the series ACL will take precedence over any existing episode ACL&quot;, type = STRING)}, responses = {
                          @RestResponse(description = &quot;The access control list for the specified series is updated.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The specified series does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateSeriesAcl(@HeaderParam(&quot;Accept&quot;) String acceptHeader, @PathParam(&quot;seriesId&quot;) String seriesID,
          @FormParam(&quot;acl&quot;) String aclJson, @DefaultValue(&quot;false&quot;) @FormParam(&quot;override&quot;) boolean override)
          throws NotFoundException, SeriesException, UnauthorizedException {
<span class="pc bpc" id="L1068" title="1 of 2 branches missed.">    if (isBlank(aclJson))</span>
<span class="nc" id="L1069">      return R.badRequest(&quot;Missing form parameter 'acl'&quot;);</span>

<span class="fc" id="L1071">    final ApiVersion requestedVersion = ApiMediaType.parse(acceptHeader).getVersion();</span>
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">    if (requestedVersion.isSmallerThan(VERSION_1_2_0)) {</span>
      // override was added in version 1.2.0 and should be ignored for smaller versions
<span class="fc" id="L1074">      override = false;</span>
    }

<span class="fc" id="L1077">    JSONParser parser = new JSONParser();</span>
    JSONArray acl;
    try {
<span class="fc" id="L1080">      acl = (JSONArray) parser.parse(aclJson);</span>
<span class="nc" id="L1081">    } catch (ParseException e) {</span>
<span class="nc" id="L1082">      logger.debug(&quot;Could not parse ACL ({})&quot;, aclJson, e);</span>
<span class="nc" id="L1083">      return R.badRequest(&quot;Could not parse ACL&quot;);</span>
<span class="fc" id="L1084">    }</span>

<span class="fc" id="L1086">    List&lt;AccessControlEntry&gt; accessControlEntries = $(acl.toArray()).map(new Fn&lt;Object, AccessControlEntry&gt;() {</span>
      @Override
      public AccessControlEntry apply(Object a) {
<span class="fc" id="L1089">        JSONObject ace = (JSONObject) a;</span>
<span class="fc" id="L1090">        return new AccessControlEntry((String) ace.get(&quot;role&quot;), (String) ace.get(&quot;action&quot;), (boolean) ace.get(&quot;allow&quot;));</span>
      }
<span class="fc" id="L1092">    }).toList();</span>

<span class="fc" id="L1094">    seriesService.updateAccessControl(seriesID, new AccessControlList(accessControlEntries), override);</span>
<span class="fc" id="L1095">    return ApiResponseBuilder.Json.ok(acceptHeader, aclJson);</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @PUT
  @Path(&quot;{seriesId}/properties&quot;)
  @RestQuery(name = &quot;updateseriesproperties&quot;, description = &quot;Updates a series' properties&quot;, returnDescription = &quot;&quot;, pathParameters = {
          @RestParameter(name = &quot;seriesId&quot;, description = &quot;The series id&quot;, isRequired = true, type = STRING) }, restParameters = {
                  @RestParameter(name = &quot;properties&quot;, isRequired = true, description = &quot;Series properties&quot;, type = STRING) }, responses = {
                          @RestResponse(description = &quot;Successfully updated the series' properties.&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;The specified series does not exist.&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) })
  public Response updateSeriesProperties(@HeaderParam(&quot;Accept&quot;) String acceptHeader,
          @PathParam(&quot;seriesId&quot;) String seriesID, @FormParam(&quot;properties&quot;) String propertiesJson)
          throws NotFoundException, SeriesException, UnauthorizedException {
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">    if (StringUtils.isBlank(propertiesJson))</span>
<span class="nc" id="L1110">      return R.badRequest(&quot;Missing form parameter 'acl'&quot;);</span>

<span class="fc" id="L1112">    JSONParser parser = new JSONParser();</span>
    JSONObject props;
    try {
<span class="fc" id="L1115">      props = (JSONObject) parser.parse(propertiesJson);</span>
<span class="nc" id="L1116">    } catch (ParseException e) {</span>
<span class="nc" id="L1117">      logger.debug(&quot;Could not parse properties ({})&quot;, propertiesJson, e);</span>
<span class="nc" id="L1118">      return R.badRequest(&quot;Could not parse series properties&quot;);</span>
<span class="fc" id="L1119">    }</span>

<span class="fc bfc" id="L1121" title="All 2 branches covered.">    for (Object prop : props.entrySet()) {</span>
<span class="fc" id="L1122">      Entry&lt;String, Object&gt; field = (Entry&lt;String, Object&gt;) prop;</span>
<span class="fc" id="L1123">      seriesService.updateSeriesProperty(seriesID, field.getKey(), field.getValue().toString());</span>
<span class="fc" id="L1124">    }</span>

<span class="fc" id="L1126">    return ApiResponseBuilder.Json.ok(acceptHeader, propertiesJson);</span>
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;series.json&quot;)
  @RestQuery(
          name = &quot;listSeriesAsJson&quot;,
          description = &quot;Returns the series matching the query parameters&quot;,
          returnDescription = &quot;Returns the series search results as JSON&quot;,
          restParameters = {
                  @RestParameter(
                          name = &quot;q&quot;,
                          isRequired = false,
                          description = &quot;Free text search&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;edit&quot;,
                          isRequired = false,
                          description = &quot;Whether this query should return only series that are editable&quot;,
                          type = BOOLEAN
                  ),
                  @RestParameter(
                          name = &quot;fuzzyMatch&quot;,
                          isRequired = false,
                          description = &quot;Whether a partial match on series id is allowed, default is false&quot;,
                          type = BOOLEAN
                  ),
                  @RestParameter(
                          name = &quot;seriesId&quot;,
                          isRequired = false,
                          description = &quot;The series identifier&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;seriesTitle&quot;,
                          isRequired = false,
                          description = &quot;The series title&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;creator&quot;,
                          isRequired = false,
                          description = &quot;The series creator&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;contributor&quot;,
                          isRequired = false,
                          description = &quot;The series contributor&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;publisher&quot;,
                          isRequired = false,
                          description = &quot;The series publisher&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;rightsholder&quot;,
                          isRequired = false,
                          description = &quot;The series rights holder&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;createdfrom&quot;,
                          isRequired = false,
                          description = &quot;Filter results by created from (yyyy-MM-dd'T'HH:mm:ss'Z')&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;createdto&quot;,
                          isRequired = false,
                          description = &quot;Filter results by created to (yyyy-MM-dd'T'HH:mm:ss'Z')&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;language&quot;,
                          isRequired = false,
                          description = &quot;The series language&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;license&quot;,
                          isRequired = false,
                          description = &quot;The series license&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;subject&quot;,
                          isRequired = false,
                          description = &quot;The series subject&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;description&quot;,
                          isRequired = false,
                          description = &quot;The series description&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;sort&quot;,
                          isRequired = false,
                          description = &quot;The sort order. May include any of the following: TITLE, SUBJECT, &quot;
                                  + &quot;CREATOR, PUBLISHERS, CONTRIBUTORS, DESCRIPTION, CREATED_DATE_TIME, &quot;
                                  + &quot;LANGUAGE, RIGHTS_HOLDER, MANAGED_ACL, LICENCE. &quot;
                                  + &quot;Add '_DESC' to reverse the sort order (e.g. TITLE_DESC).&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;offset&quot;,
                          isRequired = false,
                          description = &quot;The offset&quot;,
                          type = STRING
                  ),
                  @RestParameter(
                          name = &quot;count&quot;,
                          isRequired = false,
                          description = &quot;Results per page (max 100)&quot;,
                          type = STRING
                  )
          },
          responses = {
                  @RestResponse(
                          responseCode = SC_OK,
                          description = &quot;The access control list.&quot;
                  ),
                  @RestResponse(
                          responseCode = SC_UNAUTHORIZED,
                          description = &quot;If the current user is not authorized to perform this action&quot;
                  )
          }
  )
  public Response getSeriesAsJson(
          @QueryParam(&quot;q&quot;) String text,
          @QueryParam(&quot;seriesId&quot;) String seriesId,
          @QueryParam(&quot;edit&quot;) Boolean edit,
          @QueryParam(&quot;fuzzyMatch&quot;) Boolean fuzzyMatch,
          @QueryParam(&quot;seriesTitle&quot;) String seriesTitle,
          @QueryParam(&quot;creator&quot;) String creator,
          @QueryParam(&quot;contributor&quot;) String contributor,
          @QueryParam(&quot;publisher&quot;) String publisher,
          @QueryParam(&quot;rightsholder&quot;) String rightsHolder,
          @QueryParam(&quot;createdfrom&quot;) String createdFrom,
          @QueryParam(&quot;createdto&quot;) String createdTo,
          @QueryParam(&quot;language&quot;) String language,
          @QueryParam(&quot;license&quot;) String license,
          @QueryParam(&quot;subject&quot;) String subject,
          @QueryParam(&quot;description&quot;) String description,
          @QueryParam(&quot;sort&quot;) String sort,
          @QueryParam(&quot;offset&quot;) String offset,
          @QueryParam(&quot;count&quot;) String count
  ) throws UnauthorizedException {
    try {
<span class="nc" id="L1281">      SearchResult&lt;Series&gt; items = getSeries(</span>
              text, seriesId, edit, seriesTitle, creator, contributor, publisher,
              rightsHolder, createdFrom, createdTo, language, license, subject, description, sort,
              offset, count, fuzzyMatch);

<span class="nc" id="L1286">      return queryResultToJson(items, false, ApiVersion.VERSION_1_7_0);</span>

<span class="nc" id="L1288">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1289">      throw e;</span>
<span class="nc" id="L1290">    } catch (Exception e) {</span>
<span class="nc" id="L1291">      logger.warn(&quot;Could not perform search query: {}&quot;, e.getMessage());</span>
    }
<span class="nc" id="L1293">    throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
  }

  private SearchResult&lt;Series&gt; getSeries(
          String text,
          String seriesId,
          Boolean edit,
          String seriesTitle,
          String creator,
          String contributor,
          String publisher,
          String rightsHolder,
          String createdFrom,
          String createdTo,
          String language,
          String license,
          String subject,
          String description,
          String sort,
          String offsetString,
          String countString,
          Boolean fuzzyMatch
  ) throws SeriesException, UnauthorizedException {
<span class="nc" id="L1316">    int offset = 0;</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(offsetString)) {</span>
      try {
<span class="nc" id="L1319">        offset = Integer.parseInt(offsetString);</span>
<span class="nc" id="L1320">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L1321">        logger.warn(&quot;Bad start page parameter&quot;);</span>
<span class="nc" id="L1322">      }</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">      if (offset &lt; 0) {</span>
<span class="nc" id="L1324">        offset = 0;</span>
      }
    }

<span class="nc" id="L1328">    int count = DEFAULT_LIMIT;</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(countString)) {</span>
      try {
<span class="nc" id="L1331">        count = Integer.parseInt(countString);</span>
<span class="nc" id="L1332">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L1333">        logger.warn(&quot;Bad count parameter&quot;);</span>
<span class="nc" id="L1334">      }</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">      if (count &lt; 1) {</span>
<span class="nc" id="L1336">        count = DEFAULT_LIMIT;</span>
      }
    }

<span class="nc" id="L1340">    SeriesSearchQuery q = new SeriesSearchQuery(securityService.getOrganization().getId(), securityService.getUser());</span>
<span class="nc" id="L1341">    q.withLimit(count);</span>
<span class="nc" id="L1342">    q.withOffset(offset);</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">    if (edit != null) {</span>
<span class="nc" id="L1344">      q.withEdit(edit);</span>
    }
<span class="nc bnc" id="L1346" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(text)) {</span>
<span class="nc" id="L1347">      q.withText(fuzzyMatch.booleanValue(), QueryPreprocessor.sanitize(text));</span>
    }
<span class="nc bnc" id="L1349" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(seriesId)) {</span>
<span class="nc" id="L1350">      q.withIdentifier(seriesId);</span>
    }
<span class="nc bnc" id="L1352" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(seriesTitle)) {</span>
<span class="nc" id="L1353">      q.withTitle(seriesTitle);</span>
    }
<span class="nc bnc" id="L1355" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(creator)) {</span>
<span class="nc" id="L1356">      q.withCreator(creator);</span>
    }
<span class="nc bnc" id="L1358" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(contributor)) {</span>
<span class="nc" id="L1359">      q.withContributor(contributor);</span>
    }
<span class="nc bnc" id="L1361" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(language)) {</span>
<span class="nc" id="L1362">      q.withLanguage(language);</span>
    }
<span class="nc bnc" id="L1364" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(license)) {</span>
<span class="nc" id="L1365">      q.withLicense(license);</span>
    }
<span class="nc bnc" id="L1367" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(subject)) {</span>
<span class="nc" id="L1368">      q.withSubject(subject);</span>
    }
<span class="nc bnc" id="L1370" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(publisher)) {</span>
<span class="nc" id="L1371">      q.withPublisher(publisher);</span>
    }
<span class="nc bnc" id="L1373" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(description)) {</span>
<span class="nc" id="L1374">      q.withDescription(description);</span>
    }
<span class="nc bnc" id="L1376" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(rightsHolder)) {</span>
<span class="nc" id="L1377">      q.withRightsHolder(rightsHolder);</span>
    }
    try {
<span class="nc bnc" id="L1380" title="All 2 branches missed.">      if (StringUtils.isNotEmpty(createdFrom)) {</span>
<span class="nc" id="L1381">        SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, Locale.ENGLISH);</span>
<span class="nc" id="L1382">        Date date = formatter.parse(createdFrom);</span>
<span class="nc" id="L1383">        q.withCreatedFrom(date);</span>
      }
<span class="nc bnc" id="L1385" title="All 2 branches missed.">      if (StringUtils.isNotEmpty(createdTo)) {</span>
<span class="nc" id="L1386">        SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, Locale.ENGLISH);</span>
<span class="nc" id="L1387">        Date date = formatter.parse(createdTo);</span>
<span class="nc" id="L1388">        q.withCreatedFrom(date);</span>
      }
<span class="nc" id="L1390">    } catch (java.text.ParseException e1) {</span>
<span class="nc" id="L1391">      logger.warn(&quot;Could not parse date parameter&quot;, e1);</span>
<span class="nc" id="L1392">    }</span>

<span class="nc bnc" id="L1394" title="All 2 branches missed.">    if (StringUtils.isNotBlank(sort)) {</span>
      String enumKey;
      SortCriterion.Order order;
<span class="nc bnc" id="L1397" title="All 2 branches missed.">      if (sort.endsWith(&quot;_DESC&quot;)) {</span>
<span class="nc" id="L1398">        enumKey = sort.substring(0, sort.length() - &quot;_DESC&quot;.length()).toUpperCase();</span>
<span class="nc" id="L1399">        order = SortCriterion.Order.Descending;</span>
      } else {
<span class="nc" id="L1401">        enumKey = sort;</span>
<span class="nc" id="L1402">        order = SortCriterion.Order.Ascending;</span>
      }

      try {
<span class="nc bnc" id="L1406" title="All 12 branches missed.">        switch (enumKey) {</span>
          case SeriesIndexSchema.TITLE:
<span class="nc" id="L1408">            q.sortByTitle(order);</span>
<span class="nc" id="L1409">            break;</span>
          case SeriesIndexSchema.SUBJECT:
<span class="nc" id="L1411">            q.sortBySubject(order);</span>
<span class="nc" id="L1412">            break;</span>
          case SeriesIndexSchema.CREATOR:
<span class="nc" id="L1414">            q.sortByCreator(order);</span>
<span class="nc" id="L1415">            break;</span>
          case SeriesIndexSchema.PUBLISHERS:
<span class="nc" id="L1417">            q.sortByPublishers(order);</span>
<span class="nc" id="L1418">            break;</span>
          case SeriesIndexSchema.CONTRIBUTORS:
<span class="nc" id="L1420">            q.sortByContributors(order);</span>
<span class="nc" id="L1421">            break;</span>
          case SeriesIndexSchema.DESCRIPTION:
<span class="nc" id="L1423">            q.sortByDescription(order);</span>
<span class="nc" id="L1424">            break;</span>
          case SeriesIndexSchema.LANGUAGE:
<span class="nc" id="L1426">            q.sortByLanguage(order);</span>
<span class="nc" id="L1427">            break;</span>
          case SeriesIndexSchema.RIGHTS_HOLDER:
<span class="nc" id="L1429">            q.sortByRightsHolder(order);</span>
<span class="nc" id="L1430">            break;</span>
          case SeriesIndexSchema.LICENSE:
<span class="nc" id="L1432">            q.sortByLicense(order);</span>
<span class="nc" id="L1433">            break;</span>
          case SeriesIndexSchema.CREATED_DATE_TIME:
<span class="nc" id="L1435">            q.sortByCreatedDateTime(order);</span>
<span class="nc" id="L1436">            break;</span>
          case SeriesIndexSchema.MANAGED_ACL:
<span class="nc" id="L1438">            q.sortByManagedAcl(order);</span>
<span class="nc" id="L1439">            break;</span>
          default:
<span class="nc" id="L1441">            logger.info(&quot;Unknown filter criteria {}&quot;, enumKey);</span>
<span class="nc" id="L1442">            throw new IllegalArgumentException(&quot;Unknown filter criteria &quot; + enumKey);</span>
        }
<span class="nc" id="L1444">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1445">        logger.warn(&quot;No sort enum matches '{}'&quot;, enumKey);</span>
<span class="nc" id="L1446">      }</span>
    }

    try {
<span class="nc" id="L1450">      return elasticsearchIndex.getByQuery(q);</span>
<span class="nc" id="L1451">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L1452">      logger.error(&quot;Failed to execute search query: {}&quot;, e.getMessage());</span>
<span class="nc" id="L1453">      throw new SeriesException(e);</span>
    }
  }

  /**
   * Parse two strings in UTC format into Date objects to represent a range of dates.
   *
   * @param createdFrom
   *          The string that represents the start date of the range.
   * @param createdTo
   *          The string that represents the end date of the range.
   * @return A Tuple with the two Dates
   * @throws IllegalArgumentException
   *           Thrown if the input strings are not valid UTC strings
   */
  private Tuple&lt;Date, Date&gt; getFromAndToCreationRange(String createdFrom, String createdTo) {
<span class="nc" id="L1469">    Date createdFromDate = null;</span>
<span class="nc" id="L1470">    Date createdToDate = null;</span>
<span class="nc bnc" id="L1471" title="All 4 branches missed.">    if ((StringUtils.isNotBlank(createdFrom) &amp;&amp; StringUtils.isBlank(createdTo))</span>
<span class="nc bnc" id="L1472" title="All 4 branches missed.">            || (StringUtils.isBlank(createdFrom) &amp;&amp; StringUtils.isNotBlank(createdTo))) {</span>
<span class="nc" id="L1473">      logger.error(&quot;Both createdTo '{}' and createdFrom '{}' have to be specified or neither of them&quot;, createdTo,</span>
              createdFrom);
<span class="nc" id="L1475">      throw new IllegalArgumentException(&quot;Both createdTo '&quot; + createdTo + &quot;' and createdFrom '&quot; + createdFrom</span>
              + &quot;' have to be specified or neither of them&quot;);
    } else {

<span class="nc bnc" id="L1479" title="All 2 branches missed.">      if (StringUtils.isNotBlank(createdFrom)) {</span>
        try {
<span class="nc" id="L1481">          createdFromDate = new Date(DateTimeSupport.fromUTC(createdFrom));</span>
<span class="nc" id="L1482">        } catch (IllegalStateException e) {</span>
<span class="nc" id="L1483">          logger.error(&quot;Unable to parse createdFrom parameter '{}'&quot;, createdFrom, e);</span>
<span class="nc" id="L1484">          throw new IllegalArgumentException(&quot;Unable to parse createdFrom parameter.&quot;);</span>
<span class="nc" id="L1485">        } catch (java.text.ParseException e) {</span>
<span class="nc" id="L1486">          logger.error(&quot;Unable to parse createdFrom parameter '{}'&quot;, createdFrom, e);</span>
<span class="nc" id="L1487">          throw new IllegalArgumentException(&quot;Unable to parse createdFrom parameter.&quot;);</span>
<span class="nc" id="L1488">        }</span>
      }

<span class="nc bnc" id="L1491" title="All 2 branches missed.">      if (StringUtils.isNotBlank(createdTo)) {</span>
        try {
<span class="nc" id="L1493">          createdToDate = new Date(DateTimeSupport.fromUTC(createdTo));</span>
<span class="nc" id="L1494">        } catch (IllegalStateException e) {</span>
<span class="nc" id="L1495">          logger.error(&quot;Unable to parse createdTo parameter '{}'&quot;, createdTo, e);</span>
<span class="nc" id="L1496">          throw new IllegalArgumentException(&quot;Unable to parse createdTo parameter.&quot;);</span>
<span class="nc" id="L1497">        } catch (java.text.ParseException e) {</span>
<span class="nc" id="L1498">          logger.error(&quot;Unable to parse createdTo parameter '{}'&quot;, createdTo, e);</span>
<span class="nc" id="L1499">          throw new IllegalArgumentException(&quot;Unable to parse createdTo parameter.&quot;);</span>
<span class="nc" id="L1500">        }</span>
      }
    }
<span class="nc" id="L1503">    return new Tuple&lt;&gt;(createdFromDate, createdToDate);</span>
  }

  private String getSeriesUrl(String seriesId) {
<span class="fc" id="L1507">    return UrlSupport.concat(endpointBaseUrl, seriesId);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>