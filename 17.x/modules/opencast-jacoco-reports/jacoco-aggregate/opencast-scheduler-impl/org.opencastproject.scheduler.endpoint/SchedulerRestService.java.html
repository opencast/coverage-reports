<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SchedulerRestService.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-scheduler-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.scheduler.endpoint</a> &gt; <span class="el_source">SchedulerRestService.java</span></div><h1>SchedulerRestService.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.scheduler.endpoint;

import static com.entwinemedia.fn.Prelude.chuck;
import static com.entwinemedia.fn.Stream.$;
import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
import static javax.servlet.http.HttpServletResponse.SC_OK;
import static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;
import static org.apache.commons.lang3.exception.ExceptionUtils.getMessage;
import static org.opencastproject.capture.CaptureParameters.AGENT_REGISTRATION_TYPE;
import static org.opencastproject.capture.CaptureParameters.AGENT_REGISTRATION_TYPE_ADHOC;
import static org.opencastproject.metadata.dublincore.DublinCore.PROPERTY_CREATED;
import static org.opencastproject.metadata.dublincore.DublinCore.PROPERTY_SPATIAL;
import static org.opencastproject.metadata.dublincore.DublinCore.PROPERTY_TEMPORAL;
import static org.opencastproject.metadata.dublincore.DublinCore.PROPERTY_TITLE;
import static org.opencastproject.util.Jsons.arr;
import static org.opencastproject.util.Jsons.obj;
import static org.opencastproject.util.Jsons.p;
import static org.opencastproject.util.Jsons.v;
import static org.opencastproject.util.RestUtil.generateErrorResponse;
import static org.opencastproject.util.data.Monadics.mlist;

import org.opencastproject.capture.admin.api.Agent;
import org.opencastproject.capture.admin.api.AgentState;
import org.opencastproject.capture.admin.api.CaptureAgentStateService;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageBuilderFactory;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;
import org.opencastproject.mediapackage.MediaPackageElementFlavor;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.MediaPackageParser;
import org.opencastproject.mediapackage.MediaPackageSupport;
import org.opencastproject.metadata.dublincore.DCMIPeriod;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreUtil;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.metadata.dublincore.EncodingSchemeUtils;
import org.opencastproject.metadata.dublincore.Precision;
import org.opencastproject.rest.RestConstants;
import org.opencastproject.scheduler.api.Recording;
import org.opencastproject.scheduler.api.SchedulerConflictException;
import org.opencastproject.scheduler.api.SchedulerException;
import org.opencastproject.scheduler.api.SchedulerService;
import org.opencastproject.scheduler.api.TechnicalMetadata;
import org.opencastproject.scheduler.impl.CaptureNowProlongingService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.util.DateTimeSupport;
import org.opencastproject.util.Jsons;
import org.opencastproject.util.Jsons.Arr;
import org.opencastproject.util.Jsons.Prop;
import org.opencastproject.util.Jsons.Val;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RestUtil;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.doc.rest.RestParameter;
import org.opencastproject.util.doc.rest.RestParameter.Type;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;
import org.opencastproject.workspace.api.Workspace;

import com.entwinemedia.fn.data.Opt;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializer;

import net.fortuna.ical4j.model.property.RRule;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.net.URI;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.TimeZone;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.DELETE;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.ResponseBuilder;
import javax.ws.rs.core.Response.Status;

/**
 * REST Endpoint for Scheduler Service
 */
@Path(&quot;/recordings&quot;)
@RestService(name = &quot;schedulerservice&quot;, title = &quot;Scheduler Service&quot;, abstractText = &quot;This service creates, edits and retrieves and helps managing scheduled capture events.&quot;, notes = {
        &quot;All paths above are relative to the REST endpoint base (something like http://your.server/files)&quot;,
        &quot;If the service is down or not working it will return a status 503, this means the the underlying service is &quot;
                + &quot;not working and is either restarting or has failed&quot;,
        &quot;A status code 500 means a general failure has occurred which is not recoverable and was not anticipated. In &quot;
                + &quot;other words, there is a bug! You should file an error report with your server logs from the time when the &quot;
                + &quot;error occurred: &lt;a href=\&quot;https://github.com/opencast/opencast/issues\&quot;&gt;Opencast Issue Tracker&lt;/a&gt;&quot; })
@Component(
    immediate = true,
    service = SchedulerRestService.class,
    property = {
        &quot;service.description=Scheduler REST Endpoint&quot;,
        &quot;opencast.service.type=org.opencastproject.scheduler&quot;,
        &quot;opencast.service.path=/recordings&quot;
    }
)
@JaxrsResource
<span class="fc" id="L173">public class SchedulerRestService {</span>

<span class="fc" id="L175">  private static final Logger logger = LoggerFactory.getLogger(SchedulerRestService.class);</span>

  /** Key for the default workflow definition in config.properties */
  private static final String DEFAULT_WORKFLOW_DEFINITION = &quot;org.opencastproject.workflow.default.definition&quot;;

  private SchedulerService service;
  private CaptureAgentStateService agentService;
  private CaptureNowProlongingService prolongingService;
  private Workspace workspace;

<span class="fc" id="L185">  private final Gson gson = new Gson();</span>
<span class="fc" id="L186">  private final Gson gsonTimestamp = new GsonBuilder()</span>
<span class="fc" id="L187">      .registerTypeAdapter(</span>
          Date.class,
<span class="nc" id="L189">          (JsonSerializer&lt;Date&gt;) (date, type, jsonSerializationContext) -&gt; new JsonPrimitive(date.getTime()))</span>
<span class="fc" id="L190">      .create();</span>

  private String defaultWorkflowDefinitionId;

<span class="fc" id="L194">  protected String serverUrl = UrlSupport.DEFAULT_BASE_URL;</span>
<span class="fc" id="L195">  protected String serviceUrl = null;</span>

  /**
   * Method to set the service this REST endpoint uses
   *
   * @param service
   */
  @Reference(
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;unsetService&quot;
  )
  public void setService(SchedulerService service) {
<span class="fc" id="L207">    this.service = service;</span>
<span class="fc" id="L208">  }</span>

  /**
   * Method to unset the service this REST endpoint uses
   *
   * @param service
   */
  public void unsetService(SchedulerService service) {
<span class="nc bnc" id="L216" title="All 2 branches missed.">    if (this.service == service) {</span>
<span class="nc" id="L217">      this.service = null;</span>
    }
<span class="nc" id="L219">  }</span>

  /**
   * Method to set the prolonging service this REST endpoint uses
   *
   * @param prolongingService
   */
  @Reference(
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;unsetProlongingService&quot;
  )
  public void setProlongingService(CaptureNowProlongingService prolongingService) {
<span class="nc" id="L231">    this.prolongingService = prolongingService;</span>
<span class="nc" id="L232">  }</span>

  /**
   * Method to unset the prolonging service this REST endpoint uses
   *
   * @param prolongingService
   */
  public void unsetProlongingService(CaptureNowProlongingService prolongingService) {
<span class="nc bnc" id="L240" title="All 2 branches missed.">    if (this.prolongingService == prolongingService) {</span>
<span class="nc" id="L241">      this.prolongingService = null;</span>
    }
<span class="nc" id="L243">  }</span>

  /**
   * Method to set the capture agent state service this REST endpoint uses
   *
   * @param agentService
   */
  @Reference(
      cardinality = ReferenceCardinality.OPTIONAL,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;unsetCaptureAgentStateService&quot;
  )
  public void setCaptureAgentStateService(CaptureAgentStateService agentService) {
<span class="nc" id="L256">    this.agentService = agentService;</span>
<span class="nc" id="L257">  }</span>

  /**
   * Method to unset the capture agent state service this REST endpoint uses
   *
   * @param agentService
   */
  public void unsetCaptureAgentStateService(CaptureAgentStateService agentService) {
<span class="nc bnc" id="L265" title="All 2 branches missed.">    if (this.agentService == agentService) {</span>
<span class="nc" id="L266">      this.agentService = null;</span>
    }
<span class="nc" id="L268">  }</span>

  /**
   * Method to set the workspace this REST endpoint uses
   *
   * @param workspace
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="nc" id="L277">    this.workspace = workspace;</span>
<span class="nc" id="L278">  }</span>

  /**
   * The method that will be called, if the service will be activated
   *
   * @param cc
   *          The ComponentContext of this service
   */
  @Activate
  public void activate(ComponentContext cc) {
    // Get the configured server URL
<span class="nc bnc" id="L289" title="All 2 branches missed.">    if (cc != null) {</span>
<span class="nc" id="L290">      String ccServerUrl = cc.getBundleContext().getProperty(OpencastConstants.SERVER_URL_PROPERTY);</span>
<span class="nc" id="L291">      logger.debug(&quot;configured server url is {}&quot;, ccServerUrl);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">      if (ccServerUrl == null) {</span>
<span class="nc" id="L293">        serverUrl = UrlSupport.DEFAULT_BASE_URL;</span>
      } else {
<span class="nc" id="L295">        serverUrl = ccServerUrl;</span>
      }
<span class="nc" id="L297">      serviceUrl = (String) cc.getProperties().get(RestConstants.SERVICE_PATH_PROPERTY);</span>
<span class="nc" id="L298">      defaultWorkflowDefinitionId = StringUtils</span>
<span class="nc" id="L299">              .trimToNull(cc.getBundleContext().getProperty(DEFAULT_WORKFLOW_DEFINITION));</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">      if (defaultWorkflowDefinitionId == null)</span>
<span class="nc" id="L301">        defaultWorkflowDefinitionId = &quot;schedule-and-upload&quot;;</span>
    }
<span class="nc" id="L303">  }</span>

  /**
   * Gets a XML with the media package for the specified event.
   *
   * @param eventId
   *          The unique ID of the event.
   * @return media package XML for the event
   */
  @GET
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;{id:.+}/mediapackage.xml&quot;)
  @RestQuery(name = &quot;getmediapackagexml&quot;, description = &quot;Retrieves media package for specified event&quot;, returnDescription = &quot;media package in XML&quot;, pathParameters = {
          @RestParameter(name = &quot;id&quot;, isRequired = true, description = &quot;ID of event for which media package will be retrieved&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;DublinCore of event is in the body of response&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;Event with specified ID does not exist&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to remove the event. Maybe you need to authenticate.&quot;) })
  public Response getMediaPackageXml(@PathParam(&quot;id&quot;) String eventId) throws UnauthorizedException {
    try {
<span class="nc" id="L322">      MediaPackage result = service.getMediaPackage(eventId);</span>
<span class="nc" id="L323">      return Response.ok(MediaPackageParser.getAsXml(result)).build();</span>
<span class="nc" id="L324">    } catch (NotFoundException e) {</span>
<span class="nc" id="L325">      logger.info(&quot;Event with id '{}' does not exist.&quot;, eventId);</span>
<span class="nc" id="L326">      return Response.status(Status.NOT_FOUND).build();</span>
<span class="nc" id="L327">    } catch (SchedulerException e) {</span>
<span class="nc" id="L328">      logger.error(&quot;Unable to retrieve event with id '{}': {}&quot;, eventId, getMessage(e));</span>
<span class="nc" id="L329">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Gets a XML with the Dublin Core metadata for the specified event.
   *
   * @param eventId
   *          The unique ID of the event.
   * @return Dublin Core XML for the event
   */
  @GET
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;{id:.+}/dublincore.xml&quot;)
  @RestQuery(name = &quot;recordingsasxml&quot;, description = &quot;Retrieves DublinCore for specified event&quot;, returnDescription = &quot;DublinCore in XML&quot;, pathParameters = {
          @RestParameter(name = &quot;id&quot;, isRequired = true, description = &quot;ID of event for which DublinCore will be retrieved&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;DublinCore of event is in the body of response&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;Event with specified ID does not exist&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to remove the event. Maybe you need to authenticate.&quot;) })
  public Response getDublinCoreMetadataXml(@PathParam(&quot;id&quot;) String eventId) throws UnauthorizedException {
    try {
<span class="nc" id="L350">      DublinCoreCatalog result = service.getDublinCore(eventId);</span>
<span class="nc" id="L351">      return Response.ok(result.toXmlString()).build();</span>
<span class="nc" id="L352">    } catch (NotFoundException e) {</span>
<span class="nc" id="L353">      logger.info(&quot;Event with id '{}' does not exist.&quot;, eventId);</span>
<span class="nc" id="L354">      return Response.status(Status.NOT_FOUND).build();</span>
<span class="nc" id="L355">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L356">      throw e;</span>
<span class="nc" id="L357">    } catch (Exception e) {</span>
<span class="nc" id="L358">      logger.error(&quot;Unable to retrieve event with id '{}': {}&quot;, eventId, getMessage(e));</span>
<span class="nc" id="L359">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Gets a Dublin Core metadata for the specified event as JSON.
   *
   * @param eventId
   *          The unique ID of the event.
   * @return Dublin Core JSON for the event
   */
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;{id:.+}/dublincore.json&quot;)
  @RestQuery(name = &quot;recordingsasjson&quot;, description = &quot;Retrieves DublinCore for specified event&quot;, returnDescription = &quot;DublinCore in JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;id&quot;, isRequired = true, description = &quot;ID of event for which DublinCore will be retrieved&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;DublinCore of event is in the body of response&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;Event with specified ID does not exist&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to remove the event. Maybe you need to authenticate.&quot;) })
  public Response getDublinCoreMetadataJSON(@PathParam(&quot;id&quot;) String eventId) throws UnauthorizedException {
    try {
<span class="nc" id="L380">      DublinCoreCatalog result = service.getDublinCore(eventId);</span>
<span class="nc" id="L381">      return Response.ok(result.toJson()).build();</span>
<span class="nc" id="L382">    } catch (NotFoundException e) {</span>
<span class="nc" id="L383">      logger.info(&quot;Event with id '{}' does not exist.&quot;, eventId);</span>
<span class="nc" id="L384">      return Response.status(Status.NOT_FOUND).build();</span>
<span class="nc" id="L385">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L386">      throw e;</span>
<span class="nc" id="L387">    } catch (Exception e) {</span>
<span class="nc" id="L388">      logger.error(&quot;Unable to retrieve event with id '{}': {}&quot;, eventId, getMessage(e));</span>
<span class="nc" id="L389">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Gets a XML with the media package for the specified event.
   *
   * @param eventId
   *          The unique ID of the event.
   * @return media package XML for the event
   */
  @GET
  @Produces(MediaType.TEXT_XML)
  @Path(&quot;{id:.+}/technical.json&quot;)
  @RestQuery(name = &quot;gettechnicalmetadatajson&quot;, description = &quot;Retrieves the technical metadata for specified event&quot;, returnDescription = &quot;technical metadata as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;id&quot;, isRequired = true, description = &quot;ID of event for which the technical metadata will be retrieved&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;technical metadata of event is in the body of response&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;Event with specified ID does not exist&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to remove the event. Maybe you need to authenticate.&quot;) })
  public Response getTechnicalMetadataJSON(@PathParam(&quot;id&quot;) String eventId) throws UnauthorizedException {
    try {
<span class="nc" id="L410">      TechnicalMetadata metadata = service.getTechnicalMetadata(eventId);</span>

<span class="nc" id="L412">      Val state = v(&quot;&quot;);</span>
<span class="nc" id="L413">      Val lastHeard = v(&quot;&quot;);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">      if (metadata.getRecording().isSome()) {</span>
<span class="nc" id="L415">        state = v(metadata.getRecording().get().getState());</span>
<span class="nc" id="L416">        lastHeard = v(DateTimeSupport.toUTC(metadata.getRecording().get().getLastCheckinTime()));</span>
      }

<span class="nc" id="L419">      Arr presenters = arr(mlist(metadata.getPresenters()).map(Jsons.stringVal));</span>
<span class="nc" id="L420">      List&lt;Prop&gt; wfProperties = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">      for (Entry&lt;String, String&gt; entry : metadata.getWorkflowProperties().entrySet()) {</span>
<span class="nc" id="L422">        wfProperties.add(p(entry.getKey(), entry.getValue()));</span>
<span class="nc" id="L423">      }</span>
<span class="nc" id="L424">      List&lt;Prop&gt; agentConfig = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">      for (Entry&lt;String, String&gt; entry : metadata.getCaptureAgentConfiguration().entrySet()) {</span>
<span class="nc" id="L426">        agentConfig.add(p(entry.getKey(), entry.getValue()));</span>
<span class="nc" id="L427">      }</span>
<span class="nc" id="L428">      return RestUtil.R.ok(obj(p(&quot;id&quot;, metadata.getEventId()), p(&quot;location&quot;, metadata.getAgentId()),</span>
<span class="nc" id="L429">              p(&quot;start&quot;, DateTimeSupport.toUTC(metadata.getStartDate().getTime())),</span>
<span class="nc" id="L430">              p(&quot;end&quot;, DateTimeSupport.toUTC(metadata.getEndDate().getTime())),</span>
<span class="nc" id="L431">              p(&quot;presenters&quot;, presenters), p(&quot;wfProperties&quot;, obj(wfProperties.toArray(new Prop[wfProperties.size()]))),</span>
<span class="nc" id="L432">              p(&quot;agentConfig&quot;, obj(agentConfig.toArray(new Prop[agentConfig.size()]))), p(&quot;state&quot;, state),</span>
<span class="nc" id="L433">              p(&quot;lastHeardFrom&quot;, lastHeard)));</span>
<span class="nc" id="L434">    } catch (NotFoundException e) {</span>
<span class="nc" id="L435">      logger.info(&quot;Event with id '{}' does not exist.&quot;, eventId);</span>
<span class="nc" id="L436">      return Response.status(Status.NOT_FOUND).build();</span>
<span class="nc" id="L437">    } catch (SchedulerException e) {</span>
<span class="nc" id="L438">      logger.error(&quot;Unable to retrieve event with id '{}': {}&quot;, eventId, getMessage(e));</span>
<span class="nc" id="L439">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Gets the workflow configuration for the specified event.
   *
   * @param eventId
   *          The unique ID of the event.
   * @return the workflow configuration
   */
  @GET
  @Produces(MediaType.TEXT_PLAIN)
  @Path(&quot;{id:.+}/workflow.properties&quot;)
  @RestQuery(name = &quot;recordingsagentproperties&quot;, description = &quot;Retrieves workflow configuration for specified event&quot;, returnDescription = &quot;workflow configuration in the form of key, value pairs&quot;, pathParameters = {
          @RestParameter(name = &quot;id&quot;, isRequired = true, description = &quot;ID of event for which workflow configuration will be retrieved&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;workflow configuration of event is in the body of response&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;Event with specified ID does not exist&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to remove the event. Maybe you need to authenticate.&quot;) })
  public Response getWorkflowConfiguration(@PathParam(&quot;id&quot;) String eventId) throws UnauthorizedException {
    try {
<span class="nc" id="L460">      Map&lt;String, String&gt; result = service.getWorkflowConfig(eventId);</span>
<span class="nc" id="L461">      String serializedProperties = serializeProperties(result);</span>
<span class="nc" id="L462">      return Response.ok(serializedProperties).build();</span>
<span class="nc" id="L463">    } catch (NotFoundException e) {</span>
<span class="nc" id="L464">      logger.info(&quot;Event with id '{}' does not exist.&quot;, eventId);</span>
<span class="nc" id="L465">      return Response.status(Status.NOT_FOUND).build();</span>
<span class="nc" id="L466">    } catch (SchedulerException e) {</span>
<span class="nc" id="L467">      logger.error(&quot;Unable to retrieve workflow configuration for event with id '{}': {}&quot;, eventId, getMessage(e));</span>
<span class="nc" id="L468">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Gets java Properties file with technical metadata for the specified event.
   *
   * @param eventId
   *          The unique ID of the event.
   * @return Java Properties File with the metadata for the event
   */
  @GET
  @Produces(MediaType.TEXT_PLAIN)
  @Path(&quot;{id:.+}/agent.properties&quot;)
  @RestQuery(name = &quot;recordingsagentproperties&quot;, description = &quot;Retrieves Capture Agent properties for specified event&quot;, returnDescription = &quot;Capture Agent properties in the form of key, value pairs&quot;, pathParameters = {
          @RestParameter(name = &quot;id&quot;, isRequired = true, description = &quot;ID of event for which agent properties will be retrieved&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;Capture Agent properties of event is in the body of response&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;Event with specified ID does not exist&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to remove the event. Maybe you need to authenticate.&quot;) })
  public Response getCaptureAgentMetadata(@PathParam(&quot;id&quot;) String eventId) throws UnauthorizedException {
    try {
<span class="nc" id="L489">      Map&lt;String, String&gt; result = service.getCaptureAgentConfiguration(eventId);</span>
<span class="nc" id="L490">      String serializedProperties = serializeProperties(result);</span>
<span class="nc" id="L491">      return Response.ok(serializedProperties).build();</span>
<span class="nc" id="L492">    } catch (NotFoundException e) {</span>
<span class="nc" id="L493">      logger.info(&quot;Event with id '{}' does not exist.&quot;, eventId);</span>
<span class="nc" id="L494">      return Response.status(Status.NOT_FOUND).build();</span>
<span class="nc" id="L495">    } catch (SchedulerException e) {</span>
<span class="nc" id="L496">      logger.error(&quot;Unable to retrieve event with id '{}': {}&quot;, eventId, getMessage(e));</span>
<span class="nc" id="L497">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   *
   * Removes the specified event. Returns true if the event was found and could be removed.
   *
   * @param eventId
   *          The unique ID of the event.
   * @return true if the event was found and could be deleted.
   */
  @DELETE
  @Path(&quot;{id:.+}&quot;)
  @Produces(MediaType.TEXT_PLAIN)
  @RestQuery(name = &quot;deleterecordings&quot;, description = &quot;Removes scheduled event with specified ID.&quot;, returnDescription = &quot;OK if event were successfully removed or NOT FOUND if event with specified ID does not exist&quot;, pathParameters = {
          @RestParameter(name = &quot;id&quot;, isRequired = true, description = &quot;Event ID&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;Event was successfully removed&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;Event with specified ID does not exist&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to remove the event. Maybe you need to authenticate.&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_CONFLICT, description = &quot;Event with specified ID is locked by a transaction, unable to delete event.&quot;) })
  public Response deleteEvent(@PathParam(&quot;id&quot;) String eventId) throws UnauthorizedException {
    try {
<span class="nc" id="L520">      service.removeEvent(eventId);</span>
<span class="nc" id="L521">      return Response.status(Response.Status.OK).build();</span>
<span class="nc" id="L522">    } catch (NotFoundException e) {</span>
<span class="nc" id="L523">      logger.info(&quot;Event with id '{}' does not exist.&quot;, eventId);</span>
<span class="nc" id="L524">      return Response.status(Status.NOT_FOUND).build();</span>
<span class="nc" id="L525">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L526">      throw e;</span>
<span class="nc" id="L527">    } catch (Exception e) {</span>
<span class="nc" id="L528">      logger.error(&quot;Unable to delete event with id '{}': {}&quot;, eventId, getMessage(e));</span>
<span class="nc" id="L529">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   * Gets the iCalendar with all (even old) events for the specified filter.
   *
   * @param captureAgentId
   *          The ID that specifies the capture agent.
   * @param seriesId
   *          The ID that specifies series.
   *
   * @return an iCalendar
   */
  @GET
  @Produces(&quot;text/calendar&quot;)
  // NOTE: charset not supported by current jaxrs impl (is ignored), set explicitly in response
  @Path(&quot;calendars&quot;)
  @RestQuery(name = &quot;getcalendar&quot;, description = &quot;Returns iCalendar for specified set of events&quot;, returnDescription = &quot;ICalendar for events&quot;, restParameters = {
          @RestParameter(name = &quot;agentid&quot;, description = &quot;Filter events by capture agent&quot;, isRequired = false, type = Type.STRING),
          @RestParameter(name = &quot;seriesid&quot;, description = &quot;Filter events by series&quot;, isRequired = false, type = Type.STRING),
          @RestParameter(name = &quot;cutoff&quot;, description = &quot;A cutoff date in UNIX milliseconds to limit the number of events returned in the calendar.&quot;, isRequired = false, type = Type.INTEGER) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_MODIFIED, description = &quot;Events were not modified since last request&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;Events were modified, new calendar is in the body&quot;) })
  public Response getCalendar(@QueryParam(&quot;agentid&quot;) String captureAgentId, @QueryParam(&quot;seriesid&quot;) String seriesId,
          @QueryParam(&quot;cutoff&quot;) Long cutoff, @Context HttpServletRequest request) {
<span class="fc" id="L555">    Date endDate = null;</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">    if (cutoff != null) {</span>
      try {
<span class="nc" id="L558">        endDate = new Date(cutoff);</span>
<span class="nc" id="L559">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L560">        return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L561">      }</span>
    }

    try {
<span class="fc" id="L565">      String lastModified = null;</span>
      // If the etag matches the if-not-modified header,return a 304
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(captureAgentId)) {</span>
<span class="fc" id="L568">        lastModified = service.getScheduleLastModified(captureAgentId);</span>
<span class="fc" id="L569">        String ifNoneMatch = request.getHeader(HttpHeaders.IF_NONE_MATCH);</span>
<span class="fc bfc" id="L570" title="All 4 branches covered.">        if (StringUtils.isNotBlank(ifNoneMatch) &amp;&amp; ifNoneMatch.equals(lastModified)) {</span>
<span class="fc" id="L571">          return Response.notModified(lastModified).expires(null).build();</span>
        }
      }

<span class="fc" id="L575">      String result = service.getCalendar(Opt.nul(StringUtils.trimToNull(captureAgentId)),</span>
<span class="fc" id="L576">              Opt.nul(StringUtils.trimToNull(seriesId)), Opt.nul(endDate));</span>

<span class="fc" id="L578">      ResponseBuilder response = Response.ok(result).header(HttpHeaders.CONTENT_TYPE, &quot;text/calendar; charset=UTF-8&quot;);</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(lastModified))</span>
<span class="fc" id="L580">        response.header(HttpHeaders.ETAG, lastModified);</span>
<span class="fc" id="L581">      return response.build();</span>
<span class="nc" id="L582">    } catch (Exception e) {</span>
<span class="nc" id="L583">      logger.error(&quot;Unable to get calendar for capture agent '{}':&quot;, captureAgentId, e);</span>
<span class="nc" id="L584">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @GET
  @Produces(&quot;application/json&quot;)
  @Path(&quot;calendar.json&quot;)
  @RestQuery(
    name = &quot;getCalendarJSON&quot;,
    description = &quot;Returns a calendar in JSON format for specified events.&quot;,
    returnDescription = &quot;Calendar for events in JSON format&quot;,
    restParameters = {
      @RestParameter(name = &quot;agentid&quot;, description = &quot;Filter events by capture agent&quot;, isRequired = false, type = Type.STRING),
      @RestParameter(name = &quot;cutoff&quot;, description = &quot;A cutoff date in UNIX milliseconds to limit the number of events returned in the calendar.&quot;, isRequired = false, type = Type.INTEGER),
      @RestParameter(name = &quot;timestamp&quot;, description = &quot;Return dates as UNIX timestamp in milliseconds instead of a date string.&quot;, isRequired = false, type = Type.BOOLEAN)
    }, responses = {
      @RestResponse(responseCode = HttpServletResponse.SC_NOT_MODIFIED, description = &quot;Events were not modified since last request&quot;),
      @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;Events were modified, new calendar is in the body&quot;)
    })
  public Response getCalendarJson(
          @QueryParam(&quot;agentid&quot;) String captureAgentId,
          @QueryParam(&quot;cutoff&quot;) Long cutoff,
          @QueryParam(&quot;timestamp&quot;) Boolean timestamp,
          @Context HttpServletRequest request) {
    try {
<span class="nc" id="L609">      var endDate = Optional.ofNullable(cutoff)</span>
<span class="nc" id="L610">              .map(Date::new)</span>
<span class="nc" id="L611">              .map(Opt::some)</span>
<span class="nc" id="L612">              .orElse(Opt.none());</span>
<span class="nc" id="L613">      var agent = Optional.ofNullable(captureAgentId)</span>
<span class="nc" id="L614">              .map(String::trim)</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">              .filter(id -&gt; !id.isEmpty())</span>
<span class="nc" id="L616">              .map(Opt::some)</span>
<span class="nc" id="L617">              .orElse(Opt.none());</span>
<span class="nc bnc" id="L618" title="All 4 branches missed.">      timestamp = !Objects.isNull(timestamp) &amp;&amp; timestamp;</span>

<span class="nc" id="L620">      String lastModified = null;</span>
      // If the `etag` matches the if-not-modified header,return a 304
<span class="nc bnc" id="L622" title="All 2 branches missed.">      if (agent.isSome()) {</span>
<span class="nc" id="L623">        lastModified = service.getScheduleLastModified(agent.get());</span>
<span class="nc" id="L624">        String ifNoneMatch = request.getHeader(HttpHeaders.IF_NONE_MATCH);</span>
<span class="nc bnc" id="L625" title="All 4 branches missed.">        if (StringUtils.isNotBlank(ifNoneMatch) &amp;&amp; ifNoneMatch.equals(lastModified)) {</span>
<span class="nc" id="L626">          return Response.notModified(lastModified).expires(null).build();</span>
        }
      }

<span class="nc" id="L630">      var result = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">      for (var event: service.search(agent, Opt.none(), Opt.none(), Opt.some(new Date()), endDate)) {</span>
<span class="nc" id="L632">        var id = event.getIdentifier().toString();</span>
<span class="nc" id="L633">        result.add(Map.of(</span>
<span class="nc" id="L634">                &quot;data&quot;, service.getTechnicalMetadata(id),</span>
<span class="nc" id="L635">                &quot;episode-dublincore&quot;, service.getDublinCore(id).toXmlString()</span>
                ));
<span class="nc" id="L637">      }</span>

<span class="nc bnc" id="L639" title="All 2 branches missed.">      final ResponseBuilder response = Response.ok((timestamp ? gsonTimestamp : gson).toJson(result));</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">      if (StringUtils.isNotBlank(lastModified)) {</span>
<span class="nc" id="L641">        response.header(HttpHeaders.ETAG, lastModified);</span>
      }
<span class="nc" id="L643">      return response.build();</span>
<span class="nc" id="L644">    } catch (Exception e) {</span>
<span class="nc" id="L645">      throw new WebApplicationException(</span>
<span class="nc" id="L646">              String.format(&quot;Unable to get calendar for capture agent %s&quot;, captureAgentId),</span>
              e, Response.Status.INTERNAL_SERVER_ERROR);
    }
  }


  @GET
  @Produces(MediaType.TEXT_PLAIN)
  @Path(&quot;{id}/lastmodified&quot;)
  @RestQuery(name = &quot;agentlastmodified&quot;, description = &quot;Retrieves the last modified hash for specified agent&quot;, returnDescription = &quot;The last modified hash&quot;, pathParameters = {
          @RestParameter(name = &quot;id&quot;, isRequired = true, description = &quot;ID of capture agent for which the last modified hash will be retrieved&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;The last modified hash of agent is in the body of response&quot;) })
  public Response getLastModified(@PathParam(&quot;id&quot;) String agentId) {
    try {
<span class="nc" id="L660">      String lastModified = service.getScheduleLastModified(agentId);</span>
<span class="nc" id="L661">      return Response.ok(lastModified).build();</span>
<span class="nc" id="L662">    } catch (Exception e) {</span>
<span class="nc" id="L663">      logger.error(&quot;Unable to retrieve agent last modified hash of agent id '{}': {}&quot;, agentId, getMessage(e));</span>
<span class="nc" id="L664">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @POST
  @Path(&quot;/removeOldScheduledRecordings&quot;)
  @RestQuery(name = &quot;removeOldScheduledRecordings&quot;, description = &quot;This will find and remove any scheduled events before the buffer time to keep performance in the scheduler optimum.&quot;, returnDescription = &quot;No return value&quot;, responses = {
          @RestResponse(responseCode = SC_OK, description = &quot;Removed old scheduled recordings.&quot;),
          @RestResponse(responseCode = SC_BAD_REQUEST, description = &quot;Unable to parse buffer.&quot;),
          @RestResponse(responseCode = SC_UNAUTHORIZED, description = &quot;You do not have permission to remove old schedulings. Maybe you need to authenticate.&quot;) }, restParameters = {
                  @RestParameter(name = &quot;buffer&quot;, type = RestParameter.Type.INTEGER, defaultValue = &quot;604800&quot;, isRequired = true, description = &quot;The amount of seconds before now that a capture has to have stopped capturing. It must be 0 or greater.&quot;) })
  public Response removeOldScheduledRecordings(@FormParam(&quot;buffer&quot;) long buffer) throws UnauthorizedException {
<span class="nc bnc" id="L676" title="All 2 branches missed.">    if (buffer &lt; 0) {</span>
<span class="nc" id="L677">      return Response.status(SC_BAD_REQUEST).build();</span>
    }

    try {
<span class="nc" id="L681">      service.removeScheduledRecordingsBeforeBuffer(buffer);</span>
<span class="nc" id="L682">    } catch (SchedulerException e) {</span>
<span class="nc" id="L683">      logger.error(&quot;Error while trying to remove old scheduled recordings&quot;, e);</span>
<span class="nc" id="L684">      throw new WebApplicationException(e);</span>
<span class="nc" id="L685">    }</span>
<span class="nc" id="L686">    return Response.ok().build();</span>
  }


  /**
   * Creates new event based on parameters. All times and dates are in milliseconds.
   */
  @POST
  @Path(&quot;/&quot;)
  @RestQuery(name = &quot;newrecording&quot;, description = &quot;Creates new event with specified parameters&quot;,
          returnDescription = &quot;If an event was successfully created&quot;,
          restParameters = {
          @RestParameter(name = &quot;start&quot;, isRequired = true, type = Type.INTEGER, description = &quot;The start date of the event in milliseconds from 1970-01-01T00:00:00Z&quot;),
          @RestParameter(name = &quot;end&quot;, isRequired = true, type = Type.INTEGER, description = &quot;The end date of the event in milliseconds from 1970-01-01T00:00:00Z&quot;),
          @RestParameter(name = &quot;agent&quot;, isRequired = true, type = Type.STRING, description = &quot;The agent of the event&quot;),
          @RestParameter(name = &quot;users&quot;, isRequired = false, type = Type.STRING, description = &quot;Comma separated list of user ids (speakers/lecturers) for the event&quot;),
          @RestParameter(name = &quot;mediaPackage&quot;, isRequired = true, type = Type.TEXT, description = &quot;The media package of the event&quot;),
          @RestParameter(name = &quot;wfproperties&quot;, isRequired = false, type = Type.TEXT, description = &quot;Workflow &quot;
                  + &quot;configuration keys for the event. Each key will be prefixed by 'org.opencastproject.workflow&quot;
                  + &quot;.config.' and added to the capture agent parameters.&quot;),
          @RestParameter(name = &quot;agentparameters&quot;, isRequired = false, type = Type.TEXT, description = &quot;The capture agent properties for the event&quot;),
          @RestParameter(name = &quot;source&quot;, isRequired = false, type = Type.STRING, description = &quot;The scheduling source of the event&quot;),
          }, responses = {
          @RestResponse(responseCode = HttpServletResponse.SC_CREATED, description = &quot;Event is successfully created&quot;),
          @RestResponse(responseCode = HttpServletResponse.SC_CONFLICT, description = &quot;Unable to create event, conflicting events found (ConflicsFound)&quot;),
          @RestResponse(responseCode = HttpServletResponse.SC_CONFLICT, description = &quot;Unable to create event, event locked by a transaction  (TransactionLock)&quot;),
          @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to create the event. Maybe you need to authenticate.&quot;),
          @RestResponse(responseCode = HttpServletResponse.SC_BAD_REQUEST, description = &quot;Missing or invalid information for this request&quot;) })
  public Response addEvent(@FormParam(&quot;start&quot;) long startTime, @FormParam(&quot;end&quot;) long endTime,
          @FormParam(&quot;agent&quot;) String agentId, @FormParam(&quot;users&quot;) String users,
          @FormParam(&quot;mediaPackage&quot;) String mediaPackageXml, @FormParam(&quot;wfproperties&quot;) String workflowProperties,
          @FormParam(&quot;agentparameters&quot;) String agentParameters,
          @FormParam(&quot;source&quot;) String schedulingSource)
                  throws UnauthorizedException {
<span class="nc bnc" id="L720" title="All 4 branches missed.">    if (endTime &lt;= startTime || startTime &lt; 0) {</span>
<span class="nc" id="L721">      logger.debug(&quot;Cannot add event without proper start and end time&quot;);</span>
<span class="nc" id="L722">      return RestUtil.R.badRequest(&quot;Cannot add event without proper start and end time&quot;);</span>
    }

<span class="nc bnc" id="L725" title="All 2 branches missed.">    if (StringUtils.isBlank(agentId)) {</span>
<span class="nc" id="L726">      logger.debug(&quot;Cannot add event without agent identifier&quot;);</span>
<span class="nc" id="L727">      return RestUtil.R.badRequest(&quot;Cannot add event without agent identifier&quot;);</span>
    }

<span class="nc bnc" id="L730" title="All 2 branches missed.">    if (StringUtils.isBlank(mediaPackageXml)) {</span>
<span class="nc" id="L731">      logger.debug(&quot;Cannot add event without media package&quot;);</span>
<span class="nc" id="L732">      return RestUtil.R.badRequest(&quot;Cannot add event without media package&quot;);</span>
    }

    MediaPackage mediaPackage;
    try {
<span class="nc" id="L737">      mediaPackage = MediaPackageParser.getFromXml(mediaPackageXml);</span>
<span class="nc" id="L738">    } catch (MediaPackageException e) {</span>
<span class="nc" id="L739">      logger.debug(&quot;Could not parse media package&quot;, e);</span>
<span class="nc" id="L740">      return RestUtil.R.badRequest(&quot;Could not parse media package&quot;);</span>
<span class="nc" id="L741">    }</span>

<span class="nc" id="L743">    String eventId = mediaPackage.getIdentifier().toString();</span>

<span class="nc" id="L745">    Map&lt;String, String&gt; caProperties = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">    if (StringUtils.isNotBlank(agentParameters)) {</span>
      try {
<span class="nc" id="L748">        Properties prop = parseProperties(agentParameters);</span>
<span class="nc" id="L749">        caProperties.putAll((Map) prop);</span>
<span class="nc" id="L750">      } catch (Exception e) {</span>
<span class="nc" id="L751">        logger.info(&quot;Could not parse capture agent properties: {}&quot;, agentParameters);</span>
<span class="nc" id="L752">        return RestUtil.R.badRequest(&quot;Could not parse capture agent properties&quot;);</span>
<span class="nc" id="L753">      }</span>
    }

<span class="nc" id="L756">    Map&lt;String, String&gt; wfProperties = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">    if (StringUtils.isNotBlank(workflowProperties)) {</span>
      try {
<span class="nc" id="L759">        Properties prop = parseProperties(workflowProperties);</span>
<span class="nc" id="L760">        wfProperties.putAll((Map) prop);</span>
<span class="nc" id="L761">      } catch (IOException e) {</span>
<span class="nc" id="L762">        logger.info(&quot;Could not parse workflow configuration properties: {}&quot;, workflowProperties);</span>
<span class="nc" id="L763">        return RestUtil.R.badRequest(&quot;Could not parse workflow configuration properties&quot;);</span>
<span class="nc" id="L764">      }</span>
    }
<span class="nc" id="L766">    Set&lt;String&gt; userIds = new HashSet&lt;&gt;();</span>
<span class="nc" id="L767">    String[] ids = StringUtils.split(users, &quot;,&quot;);</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">    if (ids != null)</span>
<span class="nc" id="L769">      userIds.addAll(Arrays.asList(ids));</span>

<span class="nc" id="L771">    DateTime startDate = new DateTime(startTime).toDateTime(DateTimeZone.UTC);</span>
<span class="nc" id="L772">    DateTime endDate = new DateTime(endTime).toDateTime(DateTimeZone.UTC);</span>

    try {
<span class="nc" id="L775">      service.addEvent(startDate.toDate(), endDate.toDate(), agentId, userIds, mediaPackage, wfProperties, caProperties,</span>
<span class="nc" id="L776">              Opt.nul(schedulingSource));</span>
<span class="nc" id="L777">      return Response.status(Status.CREATED)</span>
<span class="nc" id="L778">              .header(&quot;Location&quot;, serverUrl + serviceUrl + '/' + eventId + &quot;/mediapackage.xml&quot;).build();</span>
<span class="nc" id="L779">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L780">      throw e;</span>
<span class="nc" id="L781">    } catch (SchedulerConflictException e) {</span>
<span class="nc" id="L782">      return Response.status(Status.CONFLICT).entity(generateErrorResponse(e)).type(MediaType.APPLICATION_JSON).build();</span>
<span class="nc" id="L783">    } catch (Exception e) {</span>
<span class="nc" id="L784">      logger.error(&quot;Unable to create new event with id '{}'&quot;, eventId, e);</span>
<span class="nc" id="L785">      return Response.serverError().build();</span>
    }
  }

  /**
   * Creates new event based on parameters. All times and dates are in milliseconds.
   */
  @POST
  @Path(&quot;/multiple&quot;)
  @RestQuery(name = &quot;newrecordings&quot;, description = &quot;Creates new event with specified parameters&quot;,
          returnDescription = &quot;If an event was successfully created&quot;,
          restParameters = {
                  @RestParameter(name = &quot;rrule&quot;, isRequired = true, type = Type.STRING, description = &quot;The recurrence rule for the events&quot;),
                  @RestParameter(name = &quot;start&quot;, isRequired = true, type = Type.INTEGER, description = &quot;The start date of the event in milliseconds from 1970-01-01T00:00:00Z&quot;),
                  @RestParameter(name = &quot;end&quot;, isRequired = true, type = Type.INTEGER, description = &quot;The end date of the event in milliseconds from 1970-01-01T00:00:00Z&quot;),
                  @RestParameter(name = &quot;duration&quot;, isRequired = true, type = Type.INTEGER, description = &quot;The duration of the events in milliseconds&quot;),
                  @RestParameter(name = &quot;tz&quot;, isRequired = true, type = Type.INTEGER, description = &quot;The timezone of the events&quot;),
                  @RestParameter(name = &quot;agent&quot;, isRequired = true, type = Type.STRING, description = &quot;The agent of the event&quot;),
                  @RestParameter(name = &quot;users&quot;, isRequired = false, type = Type.STRING, description = &quot;Comma separated list of user ids (speakers/lecturers) for the event&quot;),
                  @RestParameter(name = &quot;templateMp&quot;, isRequired = true, type = Type.TEXT, description = &quot;The template mediapackage for the events&quot;),
                  @RestParameter(name = &quot;wfproperties&quot;, isRequired = false, type = Type.TEXT, description = &quot;Workflow &quot;
                          + &quot;configuration keys for the event. Each key will be prefixed by 'org.opencastproject.workflow&quot;
                          + &quot;.config.' and added to the capture agent parameters.&quot;),
                  @RestParameter(name = &quot;agentparameters&quot;, isRequired = false, type = Type.TEXT, description = &quot;The capture agent properties for the event&quot;),
                  @RestParameter(name = &quot;source&quot;, isRequired = false, type = Type.STRING, description = &quot;The scheduling source of the event&quot;),
          }, responses = {
          @RestResponse(responseCode = HttpServletResponse.SC_CREATED, description = &quot;Event is successfully created&quot;),
          @RestResponse(responseCode = HttpServletResponse.SC_CONFLICT, description = &quot;Unable to create event, conflicting events found (ConflicsFound)&quot;),
          @RestResponse(responseCode = HttpServletResponse.SC_CONFLICT, description = &quot;Unable to create event, event locked by a transaction  (TransactionLock)&quot;),
          @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to create the event. Maybe you need to authenticate.&quot;),
          @RestResponse(responseCode = HttpServletResponse.SC_BAD_REQUEST, description = &quot;Missing or invalid information for this request&quot;) })
  public Response addMultipleEvents(@FormParam(&quot;rrule&quot;) String rruleString, @FormParam(&quot;start&quot;) long startTime,
          @FormParam(&quot;end&quot;) long endTime, @FormParam(&quot;duration&quot;) long duration, @FormParam(&quot;tz&quot;) String tzString,
          @FormParam(&quot;agent&quot;) String agentId, @FormParam(&quot;users&quot;) String users,
          @FormParam(&quot;templateMp&quot;) MediaPackage templateMp, @FormParam(&quot;wfproperties&quot;) String workflowProperties,
          @FormParam(&quot;agentparameters&quot;) String agentParameters,
          @FormParam(&quot;source&quot;) String schedulingSource)
          throws UnauthorizedException {
<span class="nc bnc" id="L823" title="All 4 branches missed.">    if (endTime &lt;= startTime || startTime &lt; 0) {</span>
<span class="nc" id="L824">      logger.debug(&quot;Cannot add event without proper start and end time&quot;);</span>
<span class="nc" id="L825">      return RestUtil.R.badRequest(&quot;Cannot add event without proper start and end time&quot;);</span>
    }

    RRule rrule;
    try {
<span class="nc" id="L830">      rrule = new RRule(rruleString);</span>
<span class="nc" id="L831">    } catch (ParseException e) {</span>
<span class="nc" id="L832">      logger.debug(&quot;Could not parse recurrence rule&quot;);</span>
<span class="nc" id="L833">      return RestUtil.R.badRequest(&quot;Could not parse recurrence rule&quot;);</span>
<span class="nc" id="L834">    }</span>

<span class="nc bnc" id="L836" title="All 2 branches missed.">    if (duration &lt; 1) {</span>
<span class="nc" id="L837">      logger.debug(&quot;Cannot schedule events with durations less than 1&quot;);</span>
<span class="nc" id="L838">      return RestUtil.R.badRequest(&quot;Cannot schedule events with durations less than 1&quot;);</span>
    }

<span class="nc bnc" id="L841" title="All 2 branches missed.">    if (StringUtils.isBlank(tzString)) {</span>
<span class="nc" id="L842">      logger.debug(&quot;Cannot schedule events with blank timezone&quot;);</span>
<span class="nc" id="L843">      return RestUtil.R.badRequest(&quot;Cannot schedule events with blank timezone&quot;);</span>
    }
<span class="nc" id="L845">    TimeZone tz = TimeZone.getTimeZone(tzString);</span>

<span class="nc bnc" id="L847" title="All 2 branches missed.">    if (StringUtils.isBlank(agentId)) {</span>
<span class="nc" id="L848">      logger.debug(&quot;Cannot add event without agent identifier&quot;);</span>
<span class="nc" id="L849">      return RestUtil.R.badRequest(&quot;Cannot add event without agent identifier&quot;);</span>
    }

<span class="nc" id="L852">    Map&lt;String, String&gt; caProperties = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">    if (StringUtils.isNotBlank(agentParameters)) {</span>
      try {
<span class="nc" id="L855">        Properties prop = parseProperties(agentParameters);</span>
<span class="nc" id="L856">        caProperties.putAll((Map) prop);</span>
<span class="nc" id="L857">      } catch (Exception e) {</span>
<span class="nc" id="L858">        logger.info(&quot;Could not parse capture agent properties: {}&quot;, agentParameters);</span>
<span class="nc" id="L859">        return RestUtil.R.badRequest(&quot;Could not parse capture agent properties&quot;);</span>
<span class="nc" id="L860">      }</span>
    }

<span class="nc" id="L863">    Map&lt;String, String&gt; wfProperties = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">    if (StringUtils.isNotBlank(workflowProperties)) {</span>
      try {
<span class="nc" id="L866">        Properties prop = parseProperties(workflowProperties);</span>
<span class="nc" id="L867">        wfProperties.putAll((Map) prop);</span>
<span class="nc" id="L868">      } catch (IOException e) {</span>
<span class="nc" id="L869">        logger.info(&quot;Could not parse workflow configuration properties: {}&quot;, workflowProperties);</span>
<span class="nc" id="L870">        return RestUtil.R.badRequest(&quot;Could not parse workflow configuration properties&quot;);</span>
<span class="nc" id="L871">      }</span>
    }
<span class="nc" id="L873">    Set&lt;String&gt; userIds = new HashSet&lt;&gt;();</span>
<span class="nc" id="L874">    String[] ids = StringUtils.split(users, &quot;,&quot;);</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">    if (ids != null)</span>
<span class="nc" id="L876">      userIds.addAll(Arrays.asList(ids));</span>

    // ical4j expects start and end dates to be in TimeZone to be schedule to (not UTC)
<span class="nc" id="L879">    DateTime startDate = new DateTime(startTime).toDateTime(DateTimeZone.forTimeZone(tz));</span>
<span class="nc" id="L880">    DateTime endDate = new DateTime(endTime).toDateTime(DateTimeZone.forTimeZone(tz));</span>

    try {
<span class="nc" id="L883">      service.addMultipleEvents(rrule, startDate.toDate(), endDate.toDate(), duration, tz, agentId, userIds, templateMp, wfProperties, caProperties,</span>
<span class="nc" id="L884">              Opt.nul(schedulingSource));</span>
<span class="nc" id="L885">      return Response.status(Status.CREATED).build();</span>
<span class="nc" id="L886">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L887">      throw e;</span>
<span class="nc" id="L888">    } catch (SchedulerConflictException e) {</span>
<span class="nc" id="L889">      return Response.status(Status.CONFLICT).entity(generateErrorResponse(e)).type(MediaType.APPLICATION_JSON).build();</span>
<span class="nc" id="L890">    } catch (Exception e) {</span>
<span class="nc" id="L891">      logger.error(&quot;Unable to create new events&quot;, e);</span>
<span class="nc" id="L892">      return Response.serverError().build();</span>
    }
  }

  @PUT
  @Path(&quot;{id}&quot;)
  @RestQuery(name = &quot;updaterecordings&quot;, description = &quot;Updates specified event&quot;, returnDescription = &quot;Status OK is returned if event was successfully updated, NOT FOUND if specified event does not exist or BAD REQUEST if data is missing or invalid&quot;, pathParameters = {
          @RestParameter(name = &quot;id&quot;, description = &quot;ID of event to be updated&quot;, isRequired = true, type = Type.STRING) }, restParameters = {
                  @RestParameter(name = &quot;start&quot;, isRequired = false, description = &quot;Updated start date for event&quot;, type = Type.INTEGER),
                  @RestParameter(name = &quot;end&quot;, isRequired = false, description = &quot;Updated end date for event&quot;, type = Type.INTEGER),
                  @RestParameter(name = &quot;agent&quot;, isRequired = false, description = &quot;Updated agent for event&quot;, type = Type.STRING),
                  @RestParameter(name = &quot;users&quot;, isRequired = false, type = Type.STRING, description = &quot;Updated comma separated list of user ids (speakers/lecturers) for the event&quot;),
                  @RestParameter(name = &quot;mediaPackage&quot;, isRequired = false, description = &quot;Updated media package for event&quot;, type = Type.TEXT),
                  @RestParameter(name = &quot;wfproperties&quot;, isRequired = false, description = &quot;Workflow configuration properties&quot;, type = Type.TEXT),
                  @RestParameter(name = &quot;agentparameters&quot;, isRequired = false, description = &quot;Updated Capture Agent properties&quot;, type = Type.TEXT)
                  }, responses = {
                          @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;Event was successfully updated&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;Event with specified ID does not exist&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_CONFLICT, description = &quot;Unable to update event, conflicting events found (ConflicsFound)&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_CONFLICT, description = &quot;Unable to update event, event locked by a transaction (TransactionLock)&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_FORBIDDEN, description = &quot;Event with specified ID cannot be updated&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to update the event. Maybe you need to authenticate.&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_BAD_REQUEST, description = &quot;Data is missing or invalid&quot;) })
  public Response updateEvent(@PathParam(&quot;id&quot;) String eventID, @FormParam(&quot;start&quot;) Long startTime,
          @FormParam(&quot;end&quot;) Long endTime, @FormParam(&quot;agent&quot;) String agentId, @FormParam(&quot;users&quot;) String users,
          @FormParam(&quot;mediaPackage&quot;) String mediaPackageXml, @FormParam(&quot;wfproperties&quot;) String workflowProperties,
          @FormParam(&quot;agentparameters&quot;) String agentParameters) throws UnauthorizedException {
<span class="nc bnc" id="L919" title="All 2 branches missed.">    if (startTime != null) {</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">      if (startTime &lt; 0) {</span>
<span class="nc" id="L921">        logger.debug(&quot;Cannot add event with negative start time ({} &lt; 0)&quot;, startTime);</span>
<span class="nc" id="L922">        return RestUtil.R.badRequest(&quot;Cannot add event with negative start time&quot;);</span>
      }
<span class="nc bnc" id="L924" title="All 4 branches missed.">      if (endTime != null &amp;&amp; endTime &lt;= startTime) {</span>
<span class="nc" id="L925">        logger.debug(&quot;Cannot add event without proper end time ({} &lt;= {})&quot;, startTime, endTime);</span>
<span class="nc" id="L926">        return RestUtil.R.badRequest(&quot;Cannot add event without proper end time&quot;);</span>
      }
    }

<span class="nc" id="L930">    MediaPackage mediaPackage = null;</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">    if (StringUtils.isNotBlank(mediaPackageXml)) {</span>
      try {
<span class="nc" id="L933">        mediaPackage = MediaPackageParser.getFromXml(mediaPackageXml);</span>
<span class="nc" id="L934">      } catch (Exception e) {</span>
<span class="nc" id="L935">        logger.debug(&quot;Could not parse media packagey&quot;, e);</span>
<span class="nc" id="L936">        return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L937">      }</span>
    }

<span class="nc" id="L940">    Map&lt;String, String&gt; caProperties = null;</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">    if (StringUtils.isNotBlank(agentParameters)) {</span>
      try {
<span class="nc" id="L943">        Properties prop = parseProperties(agentParameters);</span>
<span class="nc" id="L944">        caProperties = new HashMap&lt;&gt;();</span>
<span class="nc" id="L945">        caProperties.putAll((Map) prop);</span>
<span class="nc" id="L946">      } catch (Exception e) {</span>
<span class="nc" id="L947">        logger.debug(&quot;Could not parse capture agent properties: {}&quot;, agentParameters, e);</span>
<span class="nc" id="L948">        return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L949">      }</span>
    }

<span class="nc" id="L952">    Map&lt;String, String&gt; wfProperties = null;</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">    if (StringUtils.isNotBlank(workflowProperties)) {</span>
      try {
<span class="nc" id="L955">        Properties prop = parseProperties(workflowProperties);</span>
<span class="nc" id="L956">        wfProperties = new HashMap&lt;&gt;();</span>
<span class="nc" id="L957">        wfProperties.putAll((Map) prop);</span>
<span class="nc" id="L958">      } catch (IOException e) {</span>
<span class="nc" id="L959">        logger.debug(&quot;Could not parse workflow configuration properties: {}&quot;, workflowProperties, e);</span>
<span class="nc" id="L960">        return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L961">      }</span>
    }

<span class="nc" id="L964">    Set&lt;String&gt; userIds = null;</span>
<span class="nc" id="L965">    String[] ids = StringUtils.split(StringUtils.trimToNull(users), &quot;,&quot;);</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">    if (ids != null) {</span>
<span class="nc" id="L967">      userIds = new HashSet&lt;&gt;(Arrays.asList(ids));</span>
    }

<span class="nc" id="L970">    Date startDate = null;</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">    if (startTime != null) {</span>
<span class="nc" id="L972">      startDate = new DateTime(startTime).toDateTime(DateTimeZone.UTC).toDate();</span>
    }

<span class="nc" id="L975">    Date endDate = null;</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">    if (endTime != null) {</span>
<span class="nc" id="L977">      endDate = new DateTime(endTime).toDateTime(DateTimeZone.UTC).toDate();</span>
    }

    try {
<span class="nc" id="L981">      service.updateEvent(eventID, Opt.nul(startDate), Opt.nul(endDate), Opt.nul(StringUtils.trimToNull(agentId)),</span>
<span class="nc" id="L982">              Opt.nul(userIds), Opt.nul(mediaPackage), Opt.nul(wfProperties), Opt.nul(caProperties));</span>
<span class="nc" id="L983">      return Response.ok().build();</span>
<span class="nc" id="L984">    } catch (SchedulerConflictException e) {</span>
<span class="nc" id="L985">      return Response.status(Status.CONFLICT).entity(generateErrorResponse(e)).type(MediaType.APPLICATION_JSON).build();</span>
<span class="nc" id="L986">    } catch (SchedulerException e) {</span>
<span class="nc" id="L987">      logger.warn(&quot;Error updating event with id '{}'&quot;, eventID, e);</span>
<span class="nc" id="L988">      return Response.status(Status.FORBIDDEN).build();</span>
<span class="nc" id="L989">    } catch (NotFoundException e) {</span>
<span class="nc" id="L990">      logger.info(&quot;Event with id '{}' does not exist.&quot;, eventID);</span>
<span class="nc" id="L991">      return Response.status(Status.NOT_FOUND).build();</span>
<span class="nc" id="L992">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L993">      throw e;</span>
<span class="nc" id="L994">    } catch (Exception e) {</span>
<span class="nc" id="L995">      logger.error(&quot;Unable to update event with id '{}'&quot;, eventID, e);</span>
<span class="nc" id="L996">      return Response.serverError().build();</span>
    }
  }

  @GET
  @Path(&quot;currentRecording/{agent}&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;currentrecording&quot;, description = &quot;Get the current capture event as XML&quot;, returnDescription = &quot;The current capture event as XML&quot;, pathParameters = {
      @RestParameter(name = &quot;agent&quot;, isRequired = true, type = Type.STRING, description = &quot;The agent identifier&quot;) }, responses = {
      @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;current event is in the body of response&quot;),
      @RestResponse(responseCode = HttpServletResponse.SC_NO_CONTENT, description = &quot;There is no current recording&quot;) })
  public Response currentRecording(@PathParam(&quot;agent&quot;) String agentId) throws UnauthorizedException {
    try {
<span class="nc" id="L1009">      Opt&lt;MediaPackage&gt; current = service.getCurrentRecording(agentId);</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">      if (current.isNone()) {</span>
<span class="nc" id="L1011">        return Response.noContent().build();</span>
      } else {
<span class="nc" id="L1013">        return Response.ok(MediaPackageParser.getAsXml(current.get())).build();</span>
      }
<span class="nc" id="L1015">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1016">      throw e;</span>
<span class="nc" id="L1017">    } catch (Exception e) {</span>
<span class="nc" id="L1018">      logger.error(&quot;Unable to get the current recording for agent '{}'&quot;, agentId, e);</span>
<span class="nc" id="L1019">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @GET
  @Path(&quot;upcomingRecording/{agent}&quot;)
  @Produces(MediaType.TEXT_XML)
  @RestQuery(name = &quot;upcomingrecording&quot;, description = &quot;Get the upcoming capture event as XML&quot;, returnDescription = &quot;The upcoming capture event as XML&quot;, pathParameters = {
      @RestParameter(name = &quot;agent&quot;, isRequired = true, type = Type.STRING, description = &quot;The agent identifier&quot;) }, responses = {
      @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;upcoming event is in the body of response&quot;),
      @RestResponse(responseCode = HttpServletResponse.SC_NO_CONTENT, description = &quot;There is no upcoming recording&quot;) })
  public Response upcomingRecording(@PathParam(&quot;agent&quot;) String agentId) throws UnauthorizedException {
    try {
<span class="nc" id="L1032">      Opt&lt;MediaPackage&gt; upcoming = service.getUpcomingRecording(agentId);</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">      if (upcoming.isNone()) {</span>
<span class="nc" id="L1034">        return Response.noContent().build();</span>
      } else {
<span class="nc" id="L1036">        return Response.ok(MediaPackageParser.getAsXml(upcoming.get())).build();</span>
      }
<span class="nc" id="L1038">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1039">      throw e;</span>
<span class="nc" id="L1040">    } catch (Exception e) {</span>
<span class="nc" id="L1041">      logger.error(&quot;Unable to get the upcoming recording for agent '{}'&quot;, agentId, e);</span>
<span class="nc" id="L1042">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @GET
  @Path(&quot;eventCount&quot;)
  @Produces(MediaType.TEXT_PLAIN)
  @RestQuery(name = &quot;eventcount&quot;, description = &quot;Get the number of scheduled events&quot;, returnDescription = &quot;The number of scheduled events&quot;, responses = {
      @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;The event count&quot;) })
  public Response eventCount() throws UnauthorizedException {
    try {
<span class="nc" id="L1053">      return Response.ok(&quot;&quot; + service.getEventCount()).build();</span>
<span class="nc" id="L1054">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1055">      throw e;</span>
<span class="nc" id="L1056">    } catch (Exception e) {</span>
<span class="nc" id="L1057">      logger.error(&quot;Unable to get the event count&quot;, e);</span>
<span class="nc" id="L1058">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @GET
  @Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
  @Path(&quot;recordings.{type:xml|json}&quot;)
  @RestQuery(name = &quot;recordingsaslist&quot;, description = &quot;Searches recordings and returns result as XML or JSON&quot;, returnDescription = &quot;XML or JSON formated results&quot;,
       pathParameters = {
          @RestParameter(name = &quot;type&quot;, isRequired = true, description = &quot;The media type of the response [xml|json]&quot;, type = Type.STRING) },
       restParameters = {
          @RestParameter(name = &quot;agent&quot;, description = &quot;Search by device&quot;, isRequired = false, type = Type.STRING),
          @RestParameter(name = &quot;startsfrom&quot;, description = &quot;Search by when does event start&quot;, isRequired = false, type = Type.INTEGER),
          @RestParameter(name = &quot;startsto&quot;, description = &quot;Search by when does event start&quot;, isRequired = false, type = Type.INTEGER),
          @RestParameter(name = &quot;endsfrom&quot;, description = &quot;Search by when does event finish&quot;, isRequired = false, type = Type.INTEGER),
          @RestParameter(name = &quot;endsto&quot;, description = &quot;Search by when does event finish&quot;, isRequired = false, type = Type.INTEGER) },
       responses = {
          @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;Search completed, results returned in body&quot;) })
  public Response getEventsAsList(@PathParam(&quot;type&quot;) final String type, @QueryParam(&quot;agent&quot;) String device,
          @QueryParam(&quot;startsfrom&quot;) Long startsFromTime,
          @QueryParam(&quot;startsto&quot;) Long startsToTime, @QueryParam(&quot;endsfrom&quot;) Long endsFromTime,
          @QueryParam(&quot;endsto&quot;) Long endsToTime) throws UnauthorizedException {
<span class="nc" id="L1080">    Date startsfrom = null;</span>
<span class="nc" id="L1081">    Date startsTo = null;</span>
<span class="nc" id="L1082">    Date endsFrom = null;</span>
<span class="nc" id="L1083">    Date endsTo = null;</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">    if (startsFromTime != null)</span>
<span class="nc" id="L1085">      startsfrom = new DateTime(startsFromTime).toDateTime(DateTimeZone.UTC).toDate();</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">    if (startsToTime != null)</span>
<span class="nc" id="L1087">      startsTo = new DateTime(startsToTime).toDateTime(DateTimeZone.UTC).toDate();</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">    if (endsFromTime != null)</span>
<span class="nc" id="L1089">      endsFrom = new DateTime(endsFromTime).toDateTime(DateTimeZone.UTC).toDate();</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">    if (endsToTime != null)</span>
<span class="nc" id="L1091">      endsTo = new DateTime(endsToTime).toDateTime(DateTimeZone.UTC).toDate();</span>

    try {
<span class="nc" id="L1094">      List&lt;MediaPackage&gt; events = service.search(Opt.nul(StringUtils.trimToNull(device)), Opt.nul(startsfrom),</span>
<span class="nc" id="L1095">              Opt.nul(startsTo), Opt.nul(endsFrom), Opt.nul(endsTo));</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">      if (&quot;json&quot;.equalsIgnoreCase(type)) {</span>
<span class="nc" id="L1097">        return Response.ok(getEventListAsJsonString(events)).build();</span>
      } else {
<span class="nc" id="L1099">        return Response.ok(MediaPackageParser.getArrayAsXml(events)).build();</span>
      }
<span class="nc" id="L1101">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1102">      throw e;</span>
<span class="nc" id="L1103">    } catch (Exception e) {</span>
<span class="nc" id="L1104">      logger.error(&quot;Unable to perform search: {}&quot;, getMessage(e));</span>
<span class="nc" id="L1105">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;conflicts.json&quot;)
  @RestQuery(name = &quot;conflictingrecordingsasjson&quot;, description = &quot;Searches for conflicting recordings based on parameters&quot;, returnDescription = &quot;Returns NO CONTENT if no recordings are in conflict within specified period or list of conflicting recordings in JSON&quot;, restParameters = {
          @RestParameter(name = &quot;agent&quot;, description = &quot;Device identifier for which conflicts will be searched&quot;, isRequired = true, type = Type.STRING),
          @RestParameter(name = &quot;start&quot;, description = &quot;Start time of conflicting period, in milliseconds&quot;, isRequired = true, type = Type.INTEGER),
          @RestParameter(name = &quot;end&quot;, description = &quot;End time of conflicting period, in milliseconds&quot;, isRequired = true, type = Type.INTEGER),
          @RestParameter(name = &quot;rrule&quot;, description = &quot;Rule for recurrent conflicting, specified as: \&quot;FREQ=WEEKLY;BYDAY=day(s);BYHOUR=hour;BYMINUTE=minute\&quot;. FREQ is required. BYDAY may include one or more (separated by commas) of the following: SU,MO,TU,WE,TH,FR,SA.&quot;, isRequired = false, type = Type.STRING),
          @RestParameter(name = &quot;duration&quot;, description = &quot;If recurrence rule is specified duration of each conflicting period, in milliseconds&quot;, isRequired = false, type = Type.INTEGER),
          @RestParameter(name = &quot;timezone&quot;, description = &quot;The timezone of the capture device&quot;, isRequired = false, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_NO_CONTENT, description = &quot;No conflicting events found&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;Found conflicting events, returned in body of response&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_BAD_REQUEST, description = &quot;Missing or invalid parameters&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;Not authorized to make this request&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR, description = &quot;A detailed stack track of the internal issue.&quot;)})
  public Response getConflictingEventsJson(@QueryParam(&quot;agent&quot;) String device, @QueryParam(&quot;rrule&quot;) String rrule,
          @QueryParam(&quot;start&quot;) Long startDate, @QueryParam(&quot;end&quot;) Long endDate, @QueryParam(&quot;duration&quot;) Long duration,
          @QueryParam(&quot;timezone&quot;) String timezone) throws UnauthorizedException {
    try {
<span class="nc" id="L1127">      List&lt;MediaPackage&gt; events = getConflictingEvents(device, rrule, startDate, endDate, duration, timezone);</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">      if (!events.isEmpty()) {</span>
<span class="nc" id="L1129">        String eventsJsonString = getEventListAsJsonString(events);</span>
<span class="nc" id="L1130">        return Response.ok(eventsJsonString).build();</span>
      } else {
<span class="nc" id="L1132">        return Response.noContent().build();</span>
      }
<span class="nc" id="L1134">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1135">      return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L1136">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1137">      throw e;</span>
<span class="nc" id="L1138">    } catch (Exception e) {</span>
<span class="nc" id="L1139">      logger.error(&quot;Unable to find conflicting events for {}, {}, {}, {}, {}:&quot;,</span>
              device, rrule, startDate, endDate, duration, e);
<span class="nc" id="L1141">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @GET
  @Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
  @Path(&quot;conflicts.{type:xml|json}&quot;)
  @RestQuery(name = &quot;conflictingrecordings&quot;, description = &quot;Searches for conflicting recordings based on parameters and returns result as XML or JSON&quot;, returnDescription = &quot;Returns NO CONTENT if no recordings are in conflict within specified period or list of conflicting recordings in XML or JSON&quot;,
       pathParameters = {
           @RestParameter(name = &quot;type&quot;, isRequired = true, description = &quot;The media type of the response [xml|json]&quot;, type = Type.STRING) },
       restParameters = {
           @RestParameter(name = &quot;agent&quot;, description = &quot;Device identifier for which conflicts will be searched&quot;, isRequired = true, type = Type.STRING),
           @RestParameter(name = &quot;start&quot;, description = &quot;Start time of conflicting period, in milliseconds&quot;, isRequired = true, type = Type.INTEGER),
           @RestParameter(name = &quot;end&quot;, description = &quot;End time of conflicting period, in milliseconds&quot;, isRequired = true, type = Type.INTEGER),
           @RestParameter(name = &quot;rrule&quot;, description = &quot;Rule for recurrent conflicting, specified as: \&quot;FREQ=WEEKLY;BYDAY=day(s);BYHOUR=hour;BYMINUTE=minute\&quot;. FREQ is required. BYDAY may include one or more (separated by commas) of the following: SU,MO,TU,WE,TH,FR,SA.&quot;, isRequired = false, type = Type.STRING),
           @RestParameter(name = &quot;duration&quot;, description = &quot;If recurrence rule is specified duration of each conflicting period, in milliseconds&quot;, isRequired = false, type = Type.INTEGER),
           @RestParameter(name = &quot;timezone&quot;, description = &quot;The timezone of the capture device&quot;, isRequired = false, type = Type.STRING) }, responses = {
           @RestResponse(responseCode = HttpServletResponse.SC_NO_CONTENT, description = &quot;No conflicting events found&quot;),
           @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;Found conflicting events, returned in body of response&quot;),
           @RestResponse(responseCode = HttpServletResponse.SC_BAD_REQUEST, description = &quot;Missing or invalid parameters&quot;),
           @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;Not authorized to make this request&quot;),
           @RestResponse(responseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR, description = &quot;A detailed stack track of the internal issue.&quot;)})
  public Response getConflicts(@PathParam(&quot;type&quot;) final String type, @QueryParam(&quot;agent&quot;) String device, @QueryParam(&quot;rrule&quot;) String rrule,
          @QueryParam(&quot;start&quot;) Long startDate, @QueryParam(&quot;end&quot;) Long endDate, @QueryParam(&quot;duration&quot;) Long duration,
          @QueryParam(&quot;timezone&quot;) String timezone) throws UnauthorizedException {
    // Pass dates in the TZ to be schedule to (not UTC)
    // If no timezone passed, use the local timezone of the system
<span class="nc bnc" id="L1168" title="All 2 branches missed.">    if (StringUtils.isBlank(timezone)) {</span>
<span class="nc" id="L1169">      timezone = DateTimeZone.getDefault().toString();</span>
    }

    try {
<span class="nc" id="L1173">      List&lt;MediaPackage&gt; events = getConflictingEvents(device, rrule, startDate, endDate, duration, timezone);</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">      if (!events.isEmpty()) {</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">        if (&quot;json&quot;.equalsIgnoreCase(type)) {</span>
<span class="nc" id="L1176">          return Response.ok(getEventListAsJsonString(events)).build();</span>
        } else {
<span class="nc" id="L1178">          return Response.ok(MediaPackageParser.getArrayAsXml(events)).build();</span>
        }
      } else {
<span class="nc" id="L1181">        return Response.noContent().build();</span>
      }
<span class="nc" id="L1183">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1184">      return Response.status(Status.BAD_REQUEST).build();</span>
<span class="nc" id="L1185">    } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1186">      throw e;</span>
<span class="nc" id="L1187">    } catch (Exception e) {</span>
<span class="nc" id="L1188">      logger.error(&quot;Unable to find conflicting events for {}, {}, {}, {}, {}&quot;,</span>
              device, rrule, startDate, endDate, duration, e);
<span class="nc" id="L1190">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @PUT
  @Path(&quot;{id}/recordingStatus&quot;)
  @RestQuery(name = &quot;updateRecordingState&quot;, description = &quot;Set the status of a given recording, registering it if it is new&quot;, pathParameters = {
          @RestParameter(description = &quot;The ID of a given recording&quot;, isRequired = true, name = &quot;id&quot;, type = Type.STRING) }, restParameters = {
                  @RestParameter(description = &quot;The state of the recording. Must be one of the following: unknown, capturing, capture_finished, capture_error, manifest, manifest_error, manifest_finished, compressing, compressing_error, uploading, upload_finished, upload_error.&quot;, isRequired = true, name = &quot;state&quot;, type = Type.STRING) }, responses = {
                          @RestResponse(description = &quot;{id} set to {state}&quot;, responseCode = HttpServletResponse.SC_OK),
                          @RestResponse(description = &quot;{id} or state {state} is empty or the {state} is not known&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                          @RestResponse(description = &quot;Recording with {id} could not be found&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) }, returnDescription = &quot;&quot;)
  public Response updateRecordingState(@PathParam(&quot;id&quot;) String id, @FormParam(&quot;state&quot;) String state)
          throws NotFoundException {
<span class="nc bnc" id="L1204" title="All 4 branches missed.">    if (StringUtils.isEmpty(id) || StringUtils.isEmpty(state))</span>
<span class="nc" id="L1205">      return Response.serverError().status(Response.Status.BAD_REQUEST).build();</span>

    try {
<span class="nc bnc" id="L1208" title="All 2 branches missed.">      if (service.updateRecordingState(id, state)) {</span>
<span class="nc" id="L1209">        return Response.ok(id + &quot; set to &quot; + state).build();</span>
      } else {
<span class="nc" id="L1211">        return Response.status(Response.Status.BAD_REQUEST).build();</span>
      }
<span class="nc" id="L1213">    } catch (SchedulerException e) {</span>
<span class="nc" id="L1214">      logger.debug(&quot;Unable to set recording state of {}:&quot;, id, e);</span>
<span class="nc" id="L1215">      return Response.serverError().build();</span>
    }
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;{id}/recordingStatus&quot;)
  @RestQuery(name = &quot;getRecordingState&quot;, description = &quot;Return the state of a given recording&quot;, pathParameters = {
          @RestParameter(description = &quot;The ID of a given recording&quot;, isRequired = true, name = &quot;id&quot;, type = Type.STRING) }, restParameters = {}, responses = {
                  @RestResponse(description = &quot;Returns the state of the recording with the correct id&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;The recording with the specified ID does not exist&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) }, returnDescription = &quot;&quot;)
  public Response getRecordingState(@PathParam(&quot;id&quot;) String id) throws NotFoundException {
    try {
<span class="nc" id="L1228">      Recording rec = service.getRecordingState(id);</span>
<span class="nc" id="L1229">      return RestUtil.R</span>
<span class="nc" id="L1230">              .ok(obj(p(&quot;id&quot;, rec.getID()), p(&quot;state&quot;, rec.getState()), p(&quot;lastHeardFrom&quot;, rec.getLastCheckinTime())));</span>
<span class="nc" id="L1231">    } catch (SchedulerException e) {</span>
<span class="nc" id="L1232">      logger.debug(&quot;Unable to get recording state of {}:&quot;, id, e);</span>
<span class="nc" id="L1233">      return Response.serverError().build();</span>
    }
  }

  @DELETE
  @Path(&quot;{id}/recordingStatus&quot;)
  @RestQuery(name = &quot;removeRecording&quot;, description = &quot;Remove record of a given recording&quot;, pathParameters = {
          @RestParameter(description = &quot;The ID of a given recording&quot;, isRequired = true, name = &quot;id&quot;, type = Type.STRING) }, restParameters = {}, responses = {
                  @RestResponse(description = &quot;{id} removed&quot;, responseCode = HttpServletResponse.SC_OK),
                  @RestResponse(description = &quot;{id} is empty&quot;, responseCode = HttpServletResponse.SC_BAD_REQUEST),
                  @RestResponse(description = &quot;Recording with {id} could not be found&quot;, responseCode = HttpServletResponse.SC_NOT_FOUND) }, returnDescription = &quot;&quot;)
  public Response removeRecording(@PathParam(&quot;id&quot;) String id) throws NotFoundException {
<span class="nc bnc" id="L1245" title="All 2 branches missed.">    if (StringUtils.isEmpty(id))</span>
<span class="nc" id="L1246">      return Response.serverError().status(Response.Status.BAD_REQUEST).build();</span>

    try {
<span class="nc" id="L1249">      service.removeRecording(id);</span>
<span class="nc" id="L1250">      return Response.ok(id + &quot; removed&quot;).build();</span>
<span class="nc" id="L1251">    } catch (SchedulerException e) {</span>
<span class="nc" id="L1252">      logger.debug(&quot;Unable to remove recording with id '{}':&quot;, id, e);</span>
<span class="nc" id="L1253">      return Response.serverError().build();</span>
    }
  }

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;recordingStatus&quot;)
  @RestQuery(name = &quot;getAllRecordings&quot;, description = &quot;Return all registered recordings and their state&quot;, pathParameters = {}, restParameters = {}, responses = {
          @RestResponse(description = &quot;Returns all known recordings.&quot;, responseCode = HttpServletResponse.SC_OK) }, returnDescription = &quot;&quot;)
  public Response getAllRecordings() {
    try {
<span class="nc" id="L1264">      List&lt;Val&gt; update = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">      for (Entry&lt;String, Recording&gt; e : service.getKnownRecordings().entrySet()) {</span>
<span class="nc" id="L1266">        update.add(obj(p(&quot;id&quot;, e.getValue().getID()), p(&quot;state&quot;, e.getValue().getState()),</span>
<span class="nc" id="L1267">                p(&quot;lastHeardFrom&quot;, e.getValue().getLastCheckinTime())));</span>
<span class="nc" id="L1268">      }</span>
<span class="nc" id="L1269">      return RestUtil.R.ok(arr(update).toJson());</span>
<span class="nc" id="L1270">    } catch (SchedulerException e) {</span>
<span class="nc" id="L1271">      logger.debug(&quot;Unable to get all recordings:&quot;, e);</span>
<span class="nc" id="L1272">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  /**
   *
   *
   *
   * Prolonging service
   *
   *
   *
   *
   */

  @GET
  @Path(&quot;capture/{agent}&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;currentcapture&quot;, description = &quot;Get the current capture event catalog as JSON&quot;, returnDescription = &quot;The current capture event catalog as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;agent&quot;, isRequired = true, type = Type.STRING, description = &quot;The agent identifier&quot;) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;DublinCore of current capture event is in the body of response&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;There is no ongoing recording&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE, description = &quot;The agent is not ready to communicate&quot;) })
  public Response currentCapture(@PathParam(&quot;agent&quot;) String agentId) throws NotFoundException {
<span class="nc bnc" id="L1296" title="All 4 branches missed.">    if (service == null || agentService == null)</span>
<span class="nc" id="L1297">      return Response.serverError().status(Response.Status.SERVICE_UNAVAILABLE)</span>
<span class="nc" id="L1298">              .entity(&quot;Scheduler service is unavailable, please wait...&quot;).build();</span>

    try {
<span class="nc" id="L1301">      Opt&lt;MediaPackage&gt; current = service.getCurrentRecording(agentId);</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">      if (current.isNone()) {</span>
<span class="nc" id="L1303">        logger.info(&quot;No recording to stop found for agent '{}'!&quot;, agentId);</span>
<span class="nc" id="L1304">        throw new NotFoundException(&quot;No recording to stop found for agent: &quot; + agentId);</span>
      } else {
<span class="nc" id="L1306">        DublinCoreCatalog catalog = DublinCoreUtil.loadEpisodeDublinCore(workspace, current.get()).get();</span>
<span class="nc" id="L1307">        return Response.ok(catalog.toJson()).build();</span>
      }
<span class="nc" id="L1309">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1310">      throw e;</span>
<span class="nc" id="L1311">    } catch (Exception e) {</span>
<span class="nc" id="L1312">      logger.error(&quot;Unable to get the immediate recording for agent '{}'&quot;, agentId, e);</span>
<span class="nc" id="L1313">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @GET
  @Path(&quot;capture/{agent}/upcoming&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(name = &quot;upcomingcapture&quot;, description = &quot;Get the upcoming capture event catalog as JSON&quot;, returnDescription = &quot;The upcoming capture event catalog as JSON&quot;, pathParameters = {
          @RestParameter(name = &quot;agent&quot;, isRequired = true, type = Type.STRING, description = &quot;The agent identifier&quot;) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;DublinCore of the upcomfing capture event is in the body of response&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;There is no upcoming recording&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE, description = &quot;The agent is not ready to communicate&quot;) })
  public Response upcomingCapture(@PathParam(&quot;agent&quot;) String agentId) throws NotFoundException {
<span class="nc bnc" id="L1326" title="All 4 branches missed.">    if (service == null || agentService == null)</span>
<span class="nc" id="L1327">      return Response.serverError().status(Response.Status.SERVICE_UNAVAILABLE)</span>
<span class="nc" id="L1328">              .entity(&quot;Scheduler service is unavailable, please wait...&quot;).build();</span>

    try {
<span class="nc" id="L1331">      Opt&lt;MediaPackage&gt; upcoming = service.getUpcomingRecording(agentId);</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">      if (upcoming.isNone()) {</span>
<span class="nc" id="L1333">        logger.info(&quot;No recording to stop found for agent '{}'!&quot;, agentId);</span>
<span class="nc" id="L1334">        throw new NotFoundException(&quot;No recording to stop found for agent: &quot; + agentId);</span>
      } else {
<span class="nc" id="L1336">        DublinCoreCatalog catalog = DublinCoreUtil.loadEpisodeDublinCore(workspace, upcoming.get()).get();</span>
<span class="nc" id="L1337">        return Response.ok(catalog.toJson()).build();</span>
      }
<span class="nc" id="L1339">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1340">      throw e;</span>
<span class="nc" id="L1341">    } catch (Exception e) {</span>
<span class="nc" id="L1342">      logger.error(&quot;Unable to get the immediate recording for agent '{}'&quot;, agentId, e);</span>
<span class="nc" id="L1343">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  @POST
  @Path(&quot;capture/{agent}&quot;)
  @RestQuery(name = &quot;startcapture&quot;, description = &quot;Create an immediate event&quot;, returnDescription = &quot;If events were successfully generated, status CREATED is returned&quot;, pathParameters = {
          @RestParameter(name = &quot;agent&quot;, isRequired = true, type = Type.STRING, description = &quot;The agent identifier&quot;) }, restParameters = {
                  @RestParameter(name = &quot;workflowDefinitionId&quot;, isRequired = false, type = Type.STRING, description = &quot;The workflow definition id to use&quot;) }, responses = {
                          @RestResponse(responseCode = HttpServletResponse.SC_CREATED, description = &quot;Recording started&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;There is no such agent&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_CONFLICT, description = &quot;The agent is already recording&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to start this immediate capture. Maybe you need to authenticate.&quot;),
                          @RestResponse(responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE, description = &quot;The agent is not ready to communicate&quot;) })
  public Response startCapture(@PathParam(&quot;agent&quot;) String agentId, @FormParam(&quot;workflowDefinitionId&quot;) String wfId)
          throws NotFoundException, UnauthorizedException {
<span class="nc bnc" id="L1359" title="All 6 branches missed.">    if (service == null || agentService == null || prolongingService == null)</span>
<span class="nc" id="L1360">      return Response.serverError().status(Response.Status.SERVICE_UNAVAILABLE)</span>
<span class="nc" id="L1361">              .entity(&quot;Scheduler service is unavailable, please wait...&quot;).build();</span>

    // Lookup the agent. If it doesn't exist, add a temporary registration
<span class="nc" id="L1364">    boolean adHocRegistration = false;</span>
    try {
<span class="nc" id="L1366">      agentService.getAgent(agentId);</span>
<span class="nc" id="L1367">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1368">      Properties adHocProperties = new Properties();</span>
<span class="nc" id="L1369">      adHocProperties.put(AGENT_REGISTRATION_TYPE, AGENT_REGISTRATION_TYPE_ADHOC);</span>
<span class="nc" id="L1370">      agentService.setAgentConfiguration(agentId, adHocProperties);</span>
<span class="nc" id="L1371">      agentService.setAgentState(agentId, AgentState.CAPTURING);</span>
<span class="nc" id="L1372">      adHocRegistration = true;</span>
<span class="nc" id="L1373">      logger.info(&quot;Temporarily registered agent '{}' for ad-hoc recording&quot;, agentId);</span>
<span class="nc" id="L1374">    }</span>

    try {
<span class="nc" id="L1377">      Date now = new Date();</span>
<span class="nc" id="L1378">      Date temporaryEndDate = DateTime.now().plus(prolongingService.getInitialTime()).toDate();</span>
      try {
<span class="nc" id="L1380">        List&lt;MediaPackage&gt; events = service.findConflictingEvents(agentId, now, temporaryEndDate);</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">        if (!events.isEmpty()) {</span>
<span class="nc" id="L1382">          logger.info(&quot;An already existing event is in a conflict with the the one to be created on the agent {}!&quot;,</span>
                  agentId);
<span class="nc" id="L1384">          return Response.status(Status.CONFLICT).build();</span>
        }
<span class="nc" id="L1386">      } catch (SchedulerException e) {</span>
<span class="nc" id="L1387">        logger.error(&quot;Unable to create immediate event on agent {}&quot;, agentId, e);</span>
<span class="nc" id="L1388">        throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L1389">      }</span>

<span class="nc" id="L1391">      String workflowId = defaultWorkflowDefinitionId;</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">      if (StringUtils.isNotBlank(wfId))</span>
<span class="nc" id="L1393">        workflowId = wfId;</span>

<span class="nc" id="L1395">      Map&lt;String, String&gt; caProperties = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1396">      caProperties.put(&quot;org.opencastproject.workflow.definition&quot;, workflowId);</span>
<span class="nc" id="L1397">      caProperties.put(&quot;event.location&quot;, agentId);</span>
<span class="nc" id="L1398">      caProperties.put(&quot;event.title&quot;, &quot;Capture now event&quot;);</span>
      // caProperties.put(&quot;org.opencastproject.workflow.config.captionHold&quot;, &quot;false&quot;);
      // caProperties.put(&quot;org.opencastproject.workflow.config.archiveOp&quot;, &quot;true&quot;);
      // caProperties.put(&quot;org.opencastproject.workflow.config.trimHold&quot;, &quot;false&quot;);

      // TODO default metadata? configurable?
      // A temporal with start and end period is needed! As well PROPERTY_SPATIAL is needed
<span class="nc" id="L1405">      DublinCoreCatalog eventCatalog = DublinCores.mkOpencastEpisode().getCatalog();</span>
<span class="nc" id="L1406">      eventCatalog.set(PROPERTY_TITLE, &quot;Capture now event&quot;);</span>
<span class="nc" id="L1407">      eventCatalog.set(PROPERTY_TEMPORAL,</span>
<span class="nc" id="L1408">              EncodingSchemeUtils.encodePeriod(new DCMIPeriod(now, temporaryEndDate), Precision.Second));</span>
<span class="nc" id="L1409">      eventCatalog.set(PROPERTY_SPATIAL, agentId);</span>
<span class="nc" id="L1410">      eventCatalog.set(PROPERTY_CREATED, EncodingSchemeUtils.encodeDate(new Date(), Precision.Minute));</span>
      // eventCatalog.set(PROPERTY_CREATOR, &quot;demo&quot;);
      // eventCatalog.set(PROPERTY_SUBJECT, &quot;demo&quot;);
      // eventCatalog.set(PROPERTY_LANGUAGE, &quot;demo&quot;);
      // eventCatalog.set(PROPERTY_CONTRIBUTOR, &quot;demo&quot;);
      // eventCatalog.set(PROPERTY_DESCRIPTION, &quot;demo&quot;);

      // TODO workflow properties
<span class="nc" id="L1418">      Map&lt;String, String&gt; wfProperties = new HashMap&lt;&gt;();</span>

<span class="nc" id="L1420">      MediaPackage mediaPackage = null;</span>
      try {
<span class="nc" id="L1422">        mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder().createNew();</span>
<span class="nc" id="L1423">        mediaPackage = addCatalog(workspace, IOUtils.toInputStream(eventCatalog.toXmlString(), &quot;UTF-8&quot;),</span>
                &quot;dublincore.xml&quot;, MediaPackageElements.EPISODE, mediaPackage);

<span class="nc" id="L1426">        prolongingService.schedule(agentId);</span>
<span class="nc" id="L1427">        service.addEvent(now, temporaryEndDate, agentId, Collections.&lt;String&gt; emptySet(), mediaPackage, wfProperties,</span>
<span class="nc" id="L1428">                caProperties, Opt.&lt;String&gt; none());</span>
<span class="nc" id="L1429">        return Response.status(Status.CREATED)</span>
<span class="nc" id="L1430">                .header(&quot;Location&quot;, serverUrl + serviceUrl + '/' + mediaPackage.getIdentifier().toString() + &quot;.xml&quot;)</span>
<span class="nc" id="L1431">                .build();</span>
<span class="nc" id="L1432">      } catch (Exception e) {</span>
<span class="nc" id="L1433">        prolongingService.stop(agentId);</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">        if (e instanceof UnauthorizedException)</span>
<span class="nc" id="L1435">          throw (UnauthorizedException) e;</span>
<span class="nc" id="L1436">        logger.error(&quot;Unable to create immediate event on agent {}&quot;, agentId, e);</span>
<span class="nc" id="L1437">        throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
      } finally {
<span class="nc bnc" id="L1439" title="All 2 branches missed.">        if (mediaPackage != null) {</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">          for (MediaPackageElement elem : $(mediaPackage.getElements())</span>
<span class="nc" id="L1441">                  .bind(MediaPackageSupport.Filters.byFlavor(MediaPackageElements.EPISODE).toFn())) {</span>
            try {
<span class="nc" id="L1443">              workspace.delete(elem.getURI());</span>
<span class="nc" id="L1444">            } catch (NotFoundException e) {</span>
<span class="nc" id="L1445">              logger.warn(&quot;Unable to find (and hence, delete), this mediapackage '{}' element '{}'&quot;,</span>
<span class="nc" id="L1446">                      mediaPackage.getIdentifier(), elem.getIdentifier());</span>
<span class="nc" id="L1447">            } catch (IOException e) {</span>
<span class="nc" id="L1448">              chuck(e);</span>
<span class="nc" id="L1449">            }</span>
<span class="nc" id="L1450">          }</span>
        }
      }
<span class="nc" id="L1453">    } catch (Throwable t) {</span>
<span class="nc" id="L1454">      throw t;</span>
    } finally {
<span class="nc bnc" id="L1456" title="All 2 branches missed.">      if (adHocRegistration) {</span>
<span class="nc" id="L1457">        agentService.removeAgent(agentId);</span>
<span class="nc" id="L1458">        logger.info(&quot;Removed temporary registration for agent '{}'&quot;, agentId);</span>
      }
    }
  }

  @DELETE
  @Path(&quot;capture/{agent}&quot;)
  @Produces(MediaType.TEXT_PLAIN)
  @RestQuery(name = &quot;stopcapture&quot;, description = &quot;Stops an immediate capture.&quot;, returnDescription = &quot;OK if event were successfully stopped&quot;, pathParameters = {
          @RestParameter(name = &quot;agent&quot;, isRequired = true, description = &quot;The agent identifier&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;Recording stopped&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_MODIFIED, description = &quot;The recording was already stopped&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;There is no such agent&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to stop this immediate capture. Maybe you need to authenticate.&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE, description = &quot;The agent is not ready to communicate&quot;) })
  public Response stopCapture(@PathParam(&quot;agent&quot;) String agentId) throws NotFoundException, UnauthorizedException {
<span class="nc bnc" id="L1474" title="All 6 branches missed.">    if (service == null || agentService == null || prolongingService == null)</span>
<span class="nc" id="L1475">      return Response.serverError().status(Response.Status.SERVICE_UNAVAILABLE)</span>
<span class="nc" id="L1476">              .entity(&quot;Scheduler service is unavailable, please wait...&quot;).build();</span>

<span class="nc" id="L1478">    boolean isAdHoc = false;</span>
    try {
<span class="nc" id="L1480">      Agent agent = agentService.getAgent(agentId);</span>
<span class="nc" id="L1481">      String registrationType = (String) agent.getConfiguration().get(AGENT_REGISTRATION_TYPE);</span>
<span class="nc" id="L1482">      isAdHoc = AGENT_REGISTRATION_TYPE_ADHOC.equals(registrationType);</span>
<span class="nc" id="L1483">    } catch (NotFoundException e) {</span>
<span class="nc" id="L1484">      logger.debug(&quot;Temporarily registered agent '{}' for ad-hoc recording already removed&quot;, agentId);</span>
<span class="nc" id="L1485">    }</span>

    try {
      String eventId;
      MediaPackage mp;
      DublinCoreCatalog eventCatalog;
      try {
<span class="nc" id="L1492">        Opt&lt;MediaPackage&gt; current = service.getCurrentRecording(agentId);</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">        if (current.isNone()) {</span>
<span class="nc" id="L1494">          logger.info(&quot;No recording to stop found for agent '{}'!&quot;, agentId);</span>
<span class="nc" id="L1495">          return Response.notModified().build();</span>
        } else {
<span class="nc" id="L1497">          mp = current.get();</span>
<span class="nc" id="L1498">          eventCatalog = DublinCoreUtil.loadEpisodeDublinCore(workspace, mp).get();</span>
<span class="nc" id="L1499">          eventId = mp.getIdentifier().toString();</span>
        }
<span class="nc" id="L1501">      } catch (Exception e) {</span>
<span class="nc" id="L1502">        logger.error(&quot;Unable to get the immediate recording for agent '{}'&quot;, agentId, e);</span>
<span class="nc" id="L1503">        throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L1504">      }</span>

      try {
<span class="nc" id="L1507">        DCMIPeriod period = EncodingSchemeUtils</span>
<span class="nc" id="L1508">                .decodeMandatoryPeriod(eventCatalog.getFirst(DublinCore.PROPERTY_TEMPORAL));</span>
<span class="nc" id="L1509">        eventCatalog.set(PROPERTY_TEMPORAL,</span>
<span class="nc" id="L1510">                EncodingSchemeUtils.encodePeriod(new DCMIPeriod(period.getStart(), new Date()), Precision.Second));</span>

<span class="nc" id="L1512">        mp = addCatalog(workspace, IOUtils.toInputStream(eventCatalog.toXmlString(), &quot;UTF-8&quot;), &quot;dublincore.xml&quot;,</span>
                MediaPackageElements.EPISODE, mp);

<span class="nc" id="L1515">        service.updateEvent(eventId, Opt.&lt;Date&gt; none(), Opt.&lt;Date&gt; none(), Opt.&lt;String&gt; none(),</span>
<span class="nc" id="L1516">                Opt.&lt;Set&lt;String&gt;&gt; none(), Opt.some(mp), Opt.&lt;Map&lt;String, String&gt;&gt; none(),</span>
<span class="nc" id="L1517">                Opt.&lt;Map&lt;String, String&gt;&gt; none());</span>
<span class="nc" id="L1518">        prolongingService.stop(agentId);</span>
<span class="nc" id="L1519">        return Response.ok().build();</span>
<span class="nc" id="L1520">      } catch (UnauthorizedException e) {</span>
<span class="nc" id="L1521">        throw e;</span>
<span class="nc" id="L1522">      } catch (Exception e) {</span>
<span class="nc" id="L1523">        logger.error(&quot;Unable to update the temporal of event '{}'&quot;, eventId, e);</span>
<span class="nc" id="L1524">        throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
      }
<span class="nc" id="L1526">    } catch (Throwable t) {</span>
<span class="nc" id="L1527">      throw t;</span>
    } finally {
<span class="nc bnc" id="L1529" title="All 2 branches missed.">      if (isAdHoc) {</span>
<span class="nc" id="L1530">        agentService.removeAgent(agentId);</span>
<span class="nc" id="L1531">        logger.info(&quot;Removed temporary agent registration '{}'&quot;, agentId);</span>
      }
    }
  }

  @PUT
  @Path(&quot;capture/{agent}/prolong&quot;)
  @Produces(MediaType.TEXT_PLAIN)
  @RestQuery(name = &quot;prolongcapture&quot;, description = &quot;Prolong an immediate capture.&quot;, returnDescription = &quot;OK if event were successfully prolonged&quot;, pathParameters = {
          @RestParameter(name = &quot;agent&quot;, isRequired = true, description = &quot;The agent identifier&quot;, type = Type.STRING) }, responses = {
                  @RestResponse(responseCode = HttpServletResponse.SC_OK, description = &quot;Recording prolonged&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_NOT_FOUND, description = &quot;No recording found for prolonging&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_UNAUTHORIZED, description = &quot;You do not have permission to prolong this immediate capture. Maybe you need to authenticate.&quot;),
                  @RestResponse(responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE, description = &quot;The agent is not ready to communicate&quot;) })
  public Response prolongCapture(@PathParam(&quot;agent&quot;) String agentId) throws NotFoundException, UnauthorizedException {
<span class="nc bnc" id="L1546" title="All 6 branches missed.">    if (service == null || agentService == null || prolongingService == null)</span>
<span class="nc" id="L1547">      return Response.serverError().status(Response.Status.SERVICE_UNAVAILABLE)</span>
<span class="nc" id="L1548">              .entity(&quot;Scheduler service is unavailable, please wait...&quot;).build();</span>
    try {
<span class="nc" id="L1550">      MediaPackage event = prolongingService.getCurrentRecording(agentId);</span>
<span class="nc" id="L1551">      DublinCoreCatalog dc = DublinCoreUtil.loadEpisodeDublinCore(workspace, event).get();</span>
<span class="nc" id="L1552">      prolongingService.prolongEvent(event, dc, agentId);</span>
<span class="nc" id="L1553">      return Response.ok().build();</span>
<span class="nc" id="L1554">    } catch (NotFoundException | UnauthorizedException e) {</span>
<span class="nc" id="L1555">      throw e;</span>
<span class="nc" id="L1556">    } catch (Exception e) {</span>
<span class="nc" id="L1557">      logger.error(&quot;Unable to prolong the immediate recording for agent '{}'&quot;, agentId, e);</span>
<span class="nc" id="L1558">      throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);</span>
    }
  }

  private List&lt;MediaPackage&gt; getConflictingEvents(String device, String rrule,
          Long startDate, Long endDate, Long duration, String timezone)
                  throws IllegalArgumentException, UnauthorizedException, SchedulerException {

<span class="nc" id="L1566">    List&lt;MediaPackage&gt; events = null;</span>

<span class="nc bnc" id="L1568" title="All 6 branches missed.">    if (StringUtils.isBlank(device) || startDate == null || endDate == null) {</span>
<span class="nc" id="L1569">      logger.info(&quot;Either agent, start date or end date were not specified&quot;);</span>
<span class="nc" id="L1570">      throw new IllegalArgumentException();</span>
    }

<span class="nc" id="L1573">    RRule rule = null;</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">    if (StringUtils.isNotBlank(rrule)) {</span>
<span class="nc bnc" id="L1575" title="All 4 branches missed.">      if (duration == null || StringUtils.isBlank(timezone)) {</span>
<span class="nc" id="L1576">        logger.info(&quot;Either duration or timezone were not specified&quot;);</span>
<span class="nc" id="L1577">        throw new IllegalArgumentException();</span>
      }

      try {
<span class="nc" id="L1581">        rule = new RRule(rrule);</span>
<span class="nc" id="L1582">        rule.validate();</span>
<span class="nc" id="L1583">      } catch (Exception e) {</span>
<span class="nc" id="L1584">        logger.info(&quot;Unable to parse rrule {}: {}&quot;, rrule, getMessage(e));</span>
<span class="nc" id="L1585">        throw new IllegalArgumentException();</span>
<span class="nc" id="L1586">      }</span>

<span class="nc bnc" id="L1588" title="All 2 branches missed.">      if (!Arrays.asList(TimeZone.getAvailableIDs()).contains(timezone)) {</span>
<span class="nc" id="L1589">        logger.info(&quot;Unable to parse timezone: {}&quot;, timezone);</span>
<span class="nc" id="L1590">        throw new IllegalArgumentException();</span>
      }
    }

<span class="nc" id="L1594">    Date start = new DateTime(startDate).toDateTime(DateTimeZone.UTC).toDate();</span>

<span class="nc" id="L1596">    Date end = new DateTime(endDate).toDateTime(DateTimeZone.UTC).toDate();</span>

<span class="nc bnc" id="L1598" title="All 2 branches missed.">    if (StringUtils.isNotBlank(rrule)) {</span>
<span class="nc" id="L1599">      events = service.findConflictingEvents(device, rule, start, end, duration, TimeZone.getTimeZone(timezone));</span>
    } else {
<span class="nc" id="L1601">      events = service.findConflictingEvents(device, start, end);</span>
    }
<span class="nc" id="L1603">    return events;</span>
  }

  private MediaPackage addCatalog(Workspace workspace, InputStream in, String fileName,
          MediaPackageElementFlavor flavor, MediaPackage mediaPackage) throws IOException {
<span class="nc" id="L1608">    Catalog[] catalogs = mediaPackage.getCatalogs(flavor);</span>
<span class="nc" id="L1609">    Catalog c = null;</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">    if (catalogs.length == 1)</span>
<span class="nc" id="L1611">      c = catalogs[0];</span>

    // If catalog found, create a new one
<span class="nc bnc" id="L1614" title="All 2 branches missed.">    if (c == null) {</span>
<span class="nc" id="L1615">      c = (Catalog) MediaPackageElementBuilderFactory.newInstance().newElementBuilder()</span>
<span class="nc" id="L1616">              .newElement(MediaPackageElement.Type.Catalog, flavor);</span>
<span class="nc" id="L1617">      c.setIdentifier(UUID.randomUUID().toString());</span>
<span class="nc" id="L1618">      logger.info(&quot;Adding catalog with flavor {} to mediapackage {}&quot;, flavor, mediaPackage);</span>
<span class="nc" id="L1619">      mediaPackage.add(c);</span>
    }

    // Update comments catalog
    try {
<span class="nc" id="L1624">      URI catalogUrl = workspace.put(mediaPackage.getIdentifier().toString(), c.getIdentifier(), fileName, in);</span>
<span class="nc" id="L1625">      c.setURI(catalogUrl);</span>
      // setting the URI to a new source so the checksum will most like be invalid
<span class="nc" id="L1627">      c.setChecksum(null);</span>
    } finally {
<span class="nc" id="L1629">      IOUtils.closeQuietly(in);</span>
    }
<span class="nc" id="L1631">    return mediaPackage;</span>
  }

  private String serializeProperties(Map&lt;String, String&gt; properties) {
<span class="nc" id="L1635">    StringBuilder wfPropertiesString = new StringBuilder();</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">    for (Map.Entry&lt;String, String&gt; entry : properties.entrySet())</span>
<span class="nc" id="L1637">      wfPropertiesString.append(entry.getKey() + &quot;=&quot; + entry.getValue() + &quot;\n&quot;);</span>
<span class="nc" id="L1638">    return wfPropertiesString.toString();</span>
  }

  /**
   * Parses Properties represented as String.
   *
   * @param serializedProperties
   *          properties to be parsed.
   * @return parsed properties
   * @throws IOException
   *           if parsing fails
   */
  private Properties parseProperties(String serializedProperties) throws IOException {
<span class="nc" id="L1651">    Properties caProperties = new Properties();</span>
<span class="nc" id="L1652">    logger.debug(&quot;properties: {}&quot;, serializedProperties);</span>
<span class="nc" id="L1653">    caProperties.load(new StringReader(serializedProperties));</span>
<span class="nc" id="L1654">    return caProperties;</span>
  }

  /**
   * Serializes mediapackage schedule metadata into JSON array string.
   *
   * @return serialized array as json array string
   * @throws SchedulerException
   *           if parsing list into JSON format fails
   */
  public String getEventListAsJsonString(List&lt;MediaPackage&gt; mpList) throws SchedulerException {
<span class="nc" id="L1665">    JSONParser parser = new JSONParser();</span>
<span class="nc" id="L1666">    JSONObject jsonObj = new JSONObject();</span>
<span class="nc" id="L1667">    JSONArray jsonArray = new JSONArray();</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">    for (MediaPackage mp: mpList) {</span>
      JSONObject mpJson;
      try {
<span class="nc" id="L1671">        mpJson = (JSONObject) parser.parse(MediaPackageParser.getAsJSON(mp));</span>
<span class="nc" id="L1672">        mpJson = (JSONObject) mpJson.get(&quot;mediapackage&quot;);</span>
<span class="nc" id="L1673">        jsonArray.add(mpJson);</span>
<span class="nc" id="L1674">      } catch (org.json.simple.parser.ParseException e) {</span>
<span class="nc" id="L1675">        logger.warn(&quot;Unexpected JSON parse exception for getAsJSON on mp {}&quot;, mp.getIdentifier().toString(), e);</span>
<span class="nc" id="L1676">        throw new SchedulerException(e);</span>
<span class="nc" id="L1677">      }</span>
<span class="nc" id="L1678">    }</span>
<span class="nc" id="L1679">    jsonObj.put(&quot;totalCount&quot;, String.valueOf(mpList.size()));</span>
<span class="nc" id="L1680">    jsonObj.put(&quot;events&quot;, jsonArray);</span>
<span class="nc" id="L1681">    return jsonObj.toJSONString();</span>
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>