<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractElasticsearchQueryBuilder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-elasticsearch-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.elasticsearch.impl</a> &gt; <span class="el_source">AbstractElasticsearchQueryBuilder.java</span></div><h1>AbstractElasticsearchQueryBuilder.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.elasticsearch.impl;

import static org.opencastproject.elasticsearch.impl.IndexSchema.TEXT;
import static org.opencastproject.elasticsearch.impl.IndexSchema.TEXT_FUZZY;

import org.opencastproject.elasticsearch.api.SearchQuery;
import org.opencastproject.util.DateTimeSupport;

import org.apache.commons.lang3.StringUtils;
import org.apache.lucene.search.Query;
import org.elasticsearch.common.io.stream.StreamOutput;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.MatchAllQueryBuilder;
import org.elasticsearch.index.query.MoreLikeThisQueryBuilder;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.index.query.QueryRewriteContext;
import org.elasticsearch.index.query.QueryShardContext;
import org.elasticsearch.index.query.QueryStringQueryBuilder;
import org.elasticsearch.index.query.RangeQueryBuilder;
import org.elasticsearch.index.query.TermsQueryBuilder;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Opencast implementation of the elastic search query builder.
 */
public abstract class AbstractElasticsearchQueryBuilder&lt;T extends SearchQuery&gt; implements QueryBuilder {

  /** Term queries on fields */
<span class="nc" id="L62">  private Map&lt;String, Set&lt;Object&gt;&gt; searchTerms = null;</span>

  /** Fields that need to match all values */
<span class="nc" id="L65">  protected List&lt;ValueGroup&gt; groups = null;</span>

  /** Fields that query a date range */
<span class="nc" id="L68">  private Set&lt;DateRange&gt; dateRanges = null;</span>

  /** Filter expression */
<span class="nc" id="L71">  protected String filter = null;</span>

  /** Text query */
<span class="nc" id="L74">  protected String text = null;</span>

  /** Fuzzy text query */
<span class="nc" id="L77">  protected String fuzzyText = null;</span>

  /** The original search query */
  private T query;

  /** The boolean query */
<span class="nc" id="L83">  private QueryBuilder queryBuilder = null;</span>

  /**
   * Creates a new elastic search query based on the raw query.
   *
   * @param query
   *          the search query
   */
<span class="nc" id="L91">  public AbstractElasticsearchQueryBuilder(T query) {</span>
<span class="nc" id="L92">    this.query = query;</span>
<span class="nc" id="L93">    buildQuery(query);</span>
<span class="nc" id="L94">    createQuery();</span>
<span class="nc" id="L95">  }</span>

  /**
   * Returns the original search query.
   *
   * @return the search query
   */
  public T getQuery() {
<span class="nc" id="L103">    return query;</span>
  }

  public abstract void buildQuery(T query);

  /**
   * Create the actual query. We start with a query that matches everything, then move to the boolean conditions,
   * finally add filter queries.
   */
  private void createQuery() {

<span class="nc" id="L114">    queryBuilder = new MatchAllQueryBuilder();</span>

    // The boolean query builder
<span class="nc" id="L117">    BoolQueryBuilder booleanQuery = new BoolQueryBuilder();</span>

    // Terms
<span class="nc bnc" id="L120" title="All 2 branches missed.">    if (searchTerms != null) {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">      for (Map.Entry&lt;String, Set&lt;Object&gt;&gt; entry : searchTerms.entrySet()) {</span>
<span class="nc" id="L122">        booleanQuery.must(new TermsQueryBuilder(entry.getKey(), entry.getValue().toArray(new Object[0])));</span>
<span class="nc" id="L123">      }</span>
<span class="nc" id="L124">      this.queryBuilder = booleanQuery;</span>
    }

    // Date ranges
<span class="nc bnc" id="L128" title="All 2 branches missed.">    if (dateRanges != null) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      for (DateRange dr : dateRanges) {</span>
<span class="nc" id="L130">        booleanQuery.must(dr.getQueryBuilder());</span>
<span class="nc" id="L131">      }</span>
<span class="nc" id="L132">      this.queryBuilder = booleanQuery;</span>
    }

    // Text
<span class="nc bnc" id="L136" title="All 2 branches missed.">    if (text != null) {</span>
<span class="nc" id="L137">      QueryStringQueryBuilder queryBuilder = QueryBuilders.queryStringQuery(text).field(TEXT);</span>
<span class="nc" id="L138">      booleanQuery.must(queryBuilder);</span>
<span class="nc" id="L139">      this.queryBuilder = booleanQuery;</span>
    }

    // Fuzzy text
<span class="nc bnc" id="L143" title="All 2 branches missed.">    if (fuzzyText != null) {</span>
<span class="nc" id="L144">      MoreLikeThisQueryBuilder moreLikeThisQueryBuilder = QueryBuilders.moreLikeThisQuery(</span>
              new String[] {TEXT_FUZZY},
              new String[] {fuzzyText},
              null);
<span class="nc" id="L148">      booleanQuery.must(moreLikeThisQueryBuilder);</span>
<span class="nc" id="L149">      this.queryBuilder = booleanQuery;</span>
    }

<span class="nc" id="L152">    List&lt;QueryBuilder&gt; filters = new ArrayList&lt;&gt;();</span>

    // Add filtering for AND terms
<span class="nc bnc" id="L155" title="All 2 branches missed.">    if (groups != null) {</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">      for (ValueGroup group : groups) {</span>
<span class="nc" id="L157">        filters.addAll(group.getFilterBuilders());</span>
<span class="nc" id="L158">      }</span>
    }

    // Filter expressions
<span class="nc bnc" id="L162" title="All 2 branches missed.">    if (filter != null) {</span>
<span class="nc" id="L163">      filters.add(QueryBuilders.termQuery(IndexSchema.TEXT, filter));</span>
    }

    // Apply the filters
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (!filters.isEmpty()) {</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">      for (QueryBuilder filter : filters) {</span>
<span class="nc" id="L169">        booleanQuery.filter(filter);</span>
<span class="nc" id="L170">      }</span>
<span class="nc" id="L171">      this.queryBuilder = booleanQuery;</span>
    }

<span class="nc" id="L174">  }</span>

  /**
   * Stores &lt;code&gt;fieldValue&lt;/code&gt; as a search term on the &lt;code&gt;fieldName&lt;/code&gt; field.
   *
   * @param fieldName
   *          the field name
   * @param fieldValues
   *          the field value
   */
  protected void and(String fieldName, Object... fieldValues) {

    // Make sure the data structures are set up accordingly
<span class="nc bnc" id="L187" title="All 2 branches missed.">    if (searchTerms == null) {</span>
<span class="nc" id="L188">      searchTerms = new HashMap&lt;&gt;();</span>
    }

    // Fix the field name, just in case
<span class="nc" id="L192">    fieldName = StringUtils.trim(fieldName);</span>

    // insert value
<span class="nc" id="L195">    searchTerms.computeIfAbsent(fieldName, k -&gt; new HashSet&lt;&gt;())</span>
<span class="nc" id="L196">            .addAll(Arrays.asList(fieldValues));</span>
<span class="nc" id="L197">  }</span>

  /**
   * Stores &lt;code&gt;fieldValue&lt;/code&gt; as a search term on the &lt;code&gt;fieldName&lt;/code&gt; field.
   *
   * @param fieldName
   *          the field name
   * @param startDate
   *          the start date
   * @param endDate
   *          the end date
   */
  protected void and(String fieldName, Date startDate, Date endDate) {

    // Fix the field name, just in case
<span class="nc" id="L212">    fieldName = StringUtils.trim(fieldName);</span>

    // Make sure the data structures are set up accordingly
<span class="nc bnc" id="L215" title="All 2 branches missed.">    if (dateRanges == null) {</span>
<span class="nc" id="L216">      dateRanges = new HashSet&lt;&gt;();</span>
    }

    // Add the term
<span class="nc" id="L220">    dateRanges.add(new DateRange(fieldName, startDate, endDate));</span>
<span class="nc" id="L221">  }</span>

  @Override
  public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
<span class="nc" id="L225">    return queryBuilder.toXContent(builder, params);</span>
  }

  @Override
  public Query toQuery(QueryShardContext context) throws IOException {
<span class="nc" id="L230">    return queryBuilder.toQuery(context);</span>
  }

  @Override
  public QueryBuilder queryName(String queryName) {
<span class="nc" id="L235">    return queryBuilder.queryName(queryName);</span>
  }

  @Override
  public String queryName() {
<span class="nc" id="L240">    return queryBuilder.queryName();</span>
  }

  @Override
  public float boost() {
<span class="nc" id="L245">    return queryBuilder.boost();</span>
  }

  @Override
  public QueryBuilder boost(float boost) {
<span class="nc" id="L250">    return queryBuilder.boost(boost);</span>
  }

  @Override
  public String getName() {
<span class="nc" id="L255">    return queryBuilder.getName();</span>
  }

  @Override
  public String getWriteableName() {
<span class="nc" id="L260">    return queryBuilder.getWriteableName();</span>
  }

  @Override
  public void writeTo(StreamOutput out) throws IOException {
<span class="nc" id="L265">    queryBuilder.writeTo(out);</span>
<span class="nc" id="L266">  }</span>

  @Override
  public QueryBuilder rewrite(QueryRewriteContext queryShardContext) throws IOException {
<span class="nc" id="L270">    return queryBuilder.rewrite(queryShardContext);</span>
  }

  @Override
  public boolean isFragment() {
<span class="nc" id="L275">    return queryBuilder.isFragment();</span>
  }

  /**
   * Utility class to hold date range specifications and turn them into elastic search queries.
   */
  public static final class DateRange {

    /** The field name */
    private String field;

    /** The start date */
    private Date startDate;

    /** The end date */
    private Date endDate;

    /**
     * Creates a new date range specification with the given field name, start and end dates. &lt;code&gt;null&lt;/code&gt; may be
     * passed in for start or end dates that should remain unspecified.
     *
     * @param field
     *          the field name
     * @param start
     *          the start date
     * @param end
     *          the end date
     */
<span class="nc" id="L303">    DateRange(String field, Date start, Date end) {</span>
<span class="nc" id="L304">      this.field = field;</span>
<span class="nc" id="L305">      this.startDate = start;</span>
<span class="nc" id="L306">      this.endDate = end;</span>
<span class="nc" id="L307">    }</span>

    /**
     * Returns the range query that is represented by this date range.
     *
     * @return the range query builder
     */
    QueryBuilder getQueryBuilder() {
<span class="nc" id="L315">      RangeQueryBuilder rqb = new RangeQueryBuilder(field);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">      if (startDate != null) {</span>
<span class="nc" id="L317">        rqb.from(DateTimeSupport.toUTC(startDate.getTime()));</span>
      }
<span class="nc bnc" id="L319" title="All 2 branches missed.">      if (endDate != null) {</span>
<span class="nc" id="L320">        rqb.to(DateTimeSupport.toUTC(endDate.getTime()));</span>
      }
<span class="nc" id="L322">      return rqb;</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">      return obj instanceof DateRange</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">              &amp;&amp; ((DateRange) obj).field.equals(field);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L333">      return field.hashCode();</span>
    }

  }

  /**
   * Stores a group of values which will later be added to the query using AND.
   */
  public static final class ValueGroup {

    /** The field name */
    private String field;

    /** The values to store */
    private Object[] values;

    /**
     * Creates a new value group for the given field and values.
     *
     * @param field
     *          the field name
     * @param values
     *          the values
     */
<span class="nc" id="L357">    public ValueGroup(String field, Object... values) {</span>
<span class="nc" id="L358">      this.field = field;</span>
<span class="nc" id="L359">      this.values = values;</span>
<span class="nc" id="L360">    }</span>

    /**
     * Returns the filter that will make sure only documents are returned that match all of the values at once.
     *
     * @return the filter builder
     */
    List&lt;QueryBuilder&gt; getFilterBuilders() {
<span class="nc" id="L368">      return Arrays.stream(values)</span>
<span class="nc" id="L369">              .map((v) -&gt; QueryBuilders.termQuery(field, v.toString()))</span>
<span class="nc" id="L370">              .collect(Collectors.toList());</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L375" title="All 2 branches missed.">      return obj instanceof ValueGroup</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">              &amp;&amp; ((ValueGroup) obj).field.equals(field);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L381">      return field.hashCode();</span>
    }

  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>