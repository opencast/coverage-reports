<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractElasticsearchIndex.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-elasticsearch-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.elasticsearch.impl</a> &gt; <span class="el_source">AbstractElasticsearchIndex.java</span></div><h1>AbstractElasticsearchIndex.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */


package org.opencastproject.elasticsearch.impl;

import static org.opencastproject.util.data.functions.Misc.chuck;

import org.opencastproject.elasticsearch.api.SearchIndex;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.api.SearchMetadata;
import org.opencastproject.elasticsearch.api.SearchQuery;
import org.opencastproject.elasticsearch.api.SearchResult;
import org.opencastproject.elasticsearch.api.SearchResultItem;
import org.opencastproject.util.requests.SortCriterion;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.http.ConnectionClosedException;
import org.apache.http.HttpHost;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.ElasticsearchStatusException;
import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;
import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;
import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;
import org.elasticsearch.action.bulk.BulkRequest;
import org.elasticsearch.action.bulk.BulkResponse;
import org.elasticsearch.action.delete.DeleteRequest;
import org.elasticsearch.action.delete.DeleteResponse;
import org.elasticsearch.action.get.GetRequest;
import org.elasticsearch.action.get.GetResponse;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.search.SearchType;
import org.elasticsearch.action.support.WriteRequest;
import org.elasticsearch.action.support.master.AcknowledgedResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestClientBuilder;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.client.indices.CreateIndexRequest;
import org.elasticsearch.client.indices.CreateIndexResponse;
import org.elasticsearch.cluster.health.ClusterHealthStatus;
import org.elasticsearch.common.document.DocumentField;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.rest.RestStatus;
import org.elasticsearch.script.Script;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;
import org.elasticsearch.search.aggregations.AggregationBuilder;
import org.elasticsearch.search.aggregations.AggregationBuilders;
import org.elasticsearch.search.aggregations.bucket.terms.Terms;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.search.sort.ScriptSortBuilder;
import org.elasticsearch.search.sort.SortBuilders;
import org.elasticsearch.search.sort.SortOrder;
import org.osgi.framework.BundleContext;
import org.osgi.service.component.ComponentException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.net.ConnectException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Function;

/**
 * A search index implementation based on ElasticSearch.
 */
<span class="fc" id="L103">public abstract class AbstractElasticsearchIndex implements SearchIndex {</span>

  /** Logging facility */
<span class="fc" id="L106">  private static final Logger logger = LoggerFactory.getLogger(AbstractElasticsearchIndex.class);</span>

  /** The Elasticsearch maximum results window size */
  private static final int ELASTICSEARCH_INDEX_MAX_RESULT_WINDOW = Integer.MAX_VALUE;

  /** The Elasticsearch term aggregation size */
  private static final int ELASTICSEARCH_TERM_AGGREGATION_SIZE = 10000;

  /** Configuration key defining the hostname of an external Elasticsearch server */
  public static final String ELASTICSEARCH_SERVER_HOSTNAME_KEY = &quot;org.opencastproject.elasticsearch.server.hostname&quot;;

  /** Configuration key defining the scheme (http/https) of an external Elasticsearch server */
  public static final String ELASTICSEARCH_SERVER_SCHEME_KEY = &quot;org.opencastproject.elasticsearch.server.scheme&quot;;

  /** Configuration key defining the port of an external Elasticsearch server */
  public static final String ELASTICSEARCH_SERVER_PORT_KEY = &quot;org.opencastproject.elasticsearch.server.port&quot;;

  /** Configuration key defining the username of an external Elasticsearch server */
  public static final String ELASTICSEARCH_USERNAME_KEY = &quot;org.opencastproject.elasticsearch.username&quot;;

  /** Configuration key defining the password of an external Elasticsearch server */
  public static final String ELASTICSEARCH_PASSWORD_KEY = &quot;org.opencastproject.elasticsearch.password&quot;;

  /** Default port of an external Elasticsearch server */
  private static final int ELASTICSEARCH_SERVER_PORT_DEFAULT = 9200;

  /** Default hostname of an external Elasticsearch server */
  private static final String ELASTICSEARCH_SERVER_HOSTNAME_DEFAULT = &quot;localhost&quot;;

  /** Default scheme of an external Elasticsearch server */
  private static final String ELASTICSEARCH_SERVER_SCHEME_DEFAULT = &quot;http&quot;;

  /** Identifier of the root entry */
  private static final String ROOT_ID = &quot;root&quot;;

  /** The index identifier */
<span class="fc" id="L142">  private String indexIdentifier = null;</span>
  private static final String INDEX_IDENTIFIER_PROPERTY = &quot;index.identifier&quot;;
  private static final String DEFAULT_INDEX_IDENTIFIER = &quot;opencast&quot;;

  /** The index name */
<span class="fc" id="L147">  private String indexName = null;</span>
  private static final String INDEX_NAME_PROPERTY = &quot;index.name&quot;;
  private static final String DEFAULT_INDEX_NAME = &quot;Elasticsearch&quot;;

  /** The high level client */
<span class="fc" id="L152">  private RestHighLevelClient client = null;</span>

  /** The version number */
<span class="fc" id="L155">  private int indexVersion = -1;</span>

  /** The path to the index settings */
  protected String indexSettingsPath;

  /** Hostname of an external Elasticsearch server to connect to. */
<span class="fc" id="L161">  private String externalServerHostname = ELASTICSEARCH_SERVER_HOSTNAME_DEFAULT;</span>

  /** Scheme of an external Elasticsearch server to connect to. */
<span class="fc" id="L164">  private String externalServerScheme = ELASTICSEARCH_SERVER_SCHEME_DEFAULT;</span>

  /** Port of an external Elasticsearch server to connect to */
<span class="fc" id="L167">  private int externalServerPort = ELASTICSEARCH_SERVER_PORT_DEFAULT;</span>

  /** Username of an external Elasticsearch server to connect to. */
  private String username;

  /** Password of an external Elasticsearch server to connect to. */
  private String password;

  /** Defines how long to wait between retries, when the connection to OpenSearch failed on startup */
  private int retryDelayOnStartup;
  private static final String RETRY_DELAY_ON_STARTUP = &quot;retry.delay.on.startup&quot;;
  private static final int DEFAULT_RETRY_DELAY_ON_STARTUP = 10000;

  /**
   * Returns an array of document types for the index. For every one of these, the corresponding document type
   * definition will be loaded.
   *
   * @return the document types
   */
  public abstract String[] getDocumentTypes();

  /**
   * OSGi callback to activate this component instance.
   *
   * @param properties
   *          The configuration
   * @param bundleContext
   *          the bundle context
   * @throws ComponentException
   *           if the search index cannot be initialized
   */
  public void activate(Map&lt;String, Object&gt; properties, BundleContext bundleContext) throws ComponentException {
<span class="nc" id="L199">    indexIdentifier = StringUtils.defaultIfBlank((String) properties</span>
<span class="nc" id="L200">            .get(INDEX_IDENTIFIER_PROPERTY), DEFAULT_INDEX_IDENTIFIER);</span>
<span class="nc" id="L201">    logger.info(&quot;Index identifier set to {}.&quot;, indexIdentifier);</span>

<span class="nc" id="L203">    indexSettingsPath = StringUtils.trimToNull(bundleContext.getProperty(&quot;karaf.etc&quot;));</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">    if (indexSettingsPath == null) {</span>
<span class="nc" id="L205">      throw new ComponentException(&quot;Could not determine Karaf configuration path&quot;);</span>
    }
<span class="nc" id="L207">    externalServerHostname = StringUtils</span>
<span class="nc" id="L208">            .defaultIfBlank(bundleContext.getProperty(ELASTICSEARCH_SERVER_HOSTNAME_KEY),</span>
                    ELASTICSEARCH_SERVER_HOSTNAME_DEFAULT);
<span class="nc" id="L210">    externalServerScheme = StringUtils</span>
<span class="nc" id="L211">            .defaultIfBlank(bundleContext.getProperty(ELASTICSEARCH_SERVER_SCHEME_KEY),</span>
                    ELASTICSEARCH_SERVER_SCHEME_DEFAULT);
<span class="nc" id="L213">    externalServerPort = Integer.parseInt(StringUtils</span>
<span class="nc" id="L214">            .defaultIfBlank(bundleContext.getProperty(ELASTICSEARCH_SERVER_PORT_KEY),</span>
                    ELASTICSEARCH_SERVER_PORT_DEFAULT + &quot;&quot;));
<span class="nc" id="L216">    username = StringUtils.trimToNull(bundleContext.getProperty(ELASTICSEARCH_USERNAME_KEY));</span>
<span class="nc" id="L217">    password = StringUtils.trimToNull(bundleContext.getProperty(ELASTICSEARCH_PASSWORD_KEY));</span>
<span class="nc" id="L218">  }</span>

  /**
   * OSGi callback for configuration changes.
   *
   * @param properties
   *          The configuration
   */
  public void modified(Map&lt;String, Object&gt; properties) {
<span class="nc" id="L227">    indexName = StringUtils.defaultIfBlank((String) properties.get(INDEX_NAME_PROPERTY),</span>
            DEFAULT_INDEX_NAME);
<span class="nc" id="L229">    logger.info(&quot;Index name set to {}.&quot;, indexName);</span>

<span class="nc" id="L231">    retryDelayOnStartup = NumberUtils.toInt((String) properties.get(RETRY_DELAY_ON_STARTUP),</span>
        DEFAULT_RETRY_DELAY_ON_STARTUP);
<span class="nc bnc" id="L233" title="All 2 branches missed.">    if (retryDelayOnStartup &lt;= 0) {</span>
<span class="nc" id="L234">      throw new IllegalArgumentException(RETRY_DELAY_ON_STARTUP</span>
          + &quot; was wrongly configured. Value has to be greater than 0.&quot;);
    }
<span class="nc" id="L237">    logger.info(&quot;Retry delay on startup set to {} ms.&quot;, retryDelayOnStartup);</span>
<span class="nc" id="L238">  }</span>

  @Override
  public int getIndexVersion() {
<span class="nc" id="L242">    return indexVersion;</span>
  }

  @Override
  public void clear() throws IOException {
    try {
<span class="nc" id="L248">      final DeleteIndexRequest request = new DeleteIndexRequest(</span>
<span class="nc" id="L249">              Arrays.stream(getDocumentTypes()).map(this::getSubIndexIdentifier).toArray(String[]::new));</span>
<span class="nc" id="L250">      final AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">      if (!delete.isAcknowledged()) {</span>
<span class="nc" id="L252">        logger.error(&quot;Index '{}' could not be deleted&quot;, getIndexName());</span>
      }
<span class="nc" id="L254">      createIndex();</span>
<span class="nc" id="L255">    } catch (ElasticsearchException exception) {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (exception.status() == RestStatus.NOT_FOUND) {</span>
<span class="nc" id="L257">        logger.error(&quot;Cannot clear non-existing index '{}'&quot;, exception.getIndex().getName());</span>
      }
<span class="nc" id="L259">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L260">      logger.error(&quot;Unable to re-create the index after a clear&quot;, e);</span>
<span class="nc" id="L261">    }</span>
<span class="nc" id="L262">  }</span>

  /**
   * Posts the input document to the search index.
   *
   * @param maxRetryAttempts
   *          How often to retry update in case of ElasticsearchStatusException
   * @param retryWaitingPeriod
   *          How long to wait (in ms) between retries
   * @param document
   *          The Elasticsearch document
   * @return the query response
   *
   * @throws IOException
   *         If updating the index fails
   * @throws InterruptedException
   *         If waiting during retry is interrupted
   */
  protected IndexResponse update(int maxRetryAttempts, int retryWaitingPeriod, ElasticsearchDocument document)
          throws IOException, InterruptedException {

<span class="nc" id="L283">    final IndexRequest indexRequest = new IndexRequest(getSubIndexIdentifier(document.getType())).id(document.getUID())</span>
<span class="nc" id="L284">            .source(document).setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);</span>

<span class="nc" id="L286">    IndexResponse indexResponse = null;</span>
<span class="nc" id="L287">    int retryAttempts = 0;</span>
    do {
      try {
<span class="nc" id="L290">        indexResponse = client.index(indexRequest, RequestOptions.DEFAULT);</span>
<span class="nc" id="L291">      } catch (ElasticsearchStatusException e) {</span>
<span class="nc" id="L292">        retryAttempts++;</span>

<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (retryAttempts &lt;= maxRetryAttempts) {</span>
<span class="nc" id="L295">          logger.warn(&quot;Could not update documents in index {}, retrying in {} ms.&quot;, getIndexName(),</span>
<span class="nc" id="L296">                  retryWaitingPeriod, e);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">          if (retryWaitingPeriod &gt; 0) {</span>
<span class="nc" id="L298">            Thread.sleep(retryWaitingPeriod);</span>
          }
        } else {
<span class="nc" id="L301">          logger.error(&quot;Could not update documents in index {}, not retrying.&quot;, getIndexName(),</span>
                  e);
<span class="nc" id="L303">          throw e;</span>
        }
<span class="nc" id="L305">      }</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">    } while (indexResponse == null);</span>

<span class="nc" id="L308">    return indexResponse;</span>
  }

  /**
   * Posts the input documents to the search index.
   *
   * @param maxRetryAttempts
   *          How often to retry update in case of ElasticsearchStatusException
   * @param retryWaitingPeriod
   *          How long to wait (in ms) between retries
   * @param documents
   *          The Elasticsearch documents
   * @return the query response
   *
   * @throws IOException
   *         If updating the index fails
   * @throws InterruptedException
   *         If waiting during retry is interrupted
   */
  protected BulkResponse bulkUpdate(int maxRetryAttempts, int retryWaitingPeriod,
      List&lt;ElasticsearchDocument&gt; documents)
          throws IOException, InterruptedException {
<span class="nc" id="L330">    BulkRequest bulkRequest = new BulkRequest().setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">    for (ElasticsearchDocument document: documents) {</span>
<span class="nc" id="L333">      bulkRequest.add(new IndexRequest(getSubIndexIdentifier(document.getType())).id(document.getUID())</span>
<span class="nc" id="L334">          .source(document));</span>
<span class="nc" id="L335">    }</span>

<span class="nc" id="L337">    BulkResponse bulkResponse = null;</span>
<span class="nc" id="L338">    int retryAttempts = 0;</span>
    do {
      try {
<span class="nc" id="L341">        bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span>
<span class="nc" id="L342">      } catch (ElasticsearchStatusException e) {</span>
<span class="nc" id="L343">        retryAttempts++;</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (retryAttempts &lt;= maxRetryAttempts) {</span>
<span class="nc" id="L346">          logger.warn(&quot;Could not update documents in index {} because of {}, retrying in {} ms.&quot;, getIndexName(),</span>
<span class="nc" id="L347">                  e.getMessage(), retryWaitingPeriod);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">          if (retryWaitingPeriod &gt; 0) {</span>
<span class="nc" id="L349">            Thread.sleep(retryWaitingPeriod);</span>
          }
        } else {
<span class="nc" id="L352">          logger.error(&quot;Could not update documents in index {}, not retrying.&quot;, getIndexName(),</span>
                  e);
<span class="nc" id="L354">          throw e;</span>
        }
<span class="nc" id="L356">      }</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">    } while (bulkResponse == null);</span>

<span class="nc" id="L359">    return bulkResponse;</span>
  }

  /**
   * Delete document from index.
   *
   * @param type
   *         The type of document we want to delete
   * @param id
   *         The identifier of the document
   * @return
   *         The delete response
   *
   * @throws IOException
   *         If deleting from the index fails
   * @throws InterruptedException
   *         If waiting during retry is interrupted
   */
  protected DeleteResponse delete(String type, String id, int maxRetryAttempts, int retryWaitingPeriod)
          throws IOException, InterruptedException {
<span class="nc" id="L379">    final DeleteRequest deleteRequest = new DeleteRequest(getSubIndexIdentifier(type), id).setRefreshPolicy(</span>
            WriteRequest.RefreshPolicy.IMMEDIATE);
<span class="nc" id="L381">    DeleteResponse deleteResponse = null;</span>
<span class="nc" id="L382">    int retryAttempts = 0;</span>
    do {
      try {
<span class="nc" id="L385">        deleteResponse = getClient().delete(deleteRequest, RequestOptions.DEFAULT);</span>
<span class="nc" id="L386">      } catch (ElasticsearchStatusException e) {</span>
<span class="nc" id="L387">        retryAttempts++;</span>

<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (retryAttempts &lt;= maxRetryAttempts) {</span>
<span class="nc" id="L390">          logger.warn(&quot;Could not remove documents from index {} because of {}, retrying in {} ms.&quot;, getIndexName(),</span>
<span class="nc" id="L391">                  e.getMessage(), retryWaitingPeriod);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">          if (retryWaitingPeriod &gt; 0) {</span>
<span class="nc" id="L393">            Thread.sleep(retryWaitingPeriod);</span>
          }
        } else {
<span class="nc" id="L396">          logger.error(&quot;Could not remove documents from index {}, not retrying.&quot;, getIndexName(),</span>
                  e);
<span class="nc" id="L398">          throw e;</span>
        }
<span class="nc" id="L400">      }</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">    } while (deleteResponse == null);</span>

<span class="nc" id="L403">    return deleteResponse;</span>
  }

  /**
   * Initializes an Elasticsearch node for the given index.
   *
   * @param version
   *          the index version
   * @throws SearchIndexException
   *           if the index configuration cannot be loaded
   * @throws IOException
   *           if loading of settings fails
   * @throws IllegalArgumentException
   *           if the index identifier is blank.
   */
  protected void init(int version)
          throws IOException, IllegalArgumentException, SearchIndexException {
<span class="nc" id="L420">    this.indexVersion = version;</span>

<span class="nc bnc" id="L422" title="All 2 branches missed.">    if (client == null) {</span>
<span class="nc" id="L423">      final RestClientBuilder builder = RestClient</span>
<span class="nc" id="L424">          .builder(new HttpHost(externalServerHostname, externalServerPort, externalServerScheme));</span>

<span class="nc bnc" id="L426" title="All 4 branches missed.">      if (username != null &amp;&amp; password != null) {</span>
<span class="nc" id="L427">        final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();</span>
<span class="nc" id="L428">        credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(username, password));</span>
<span class="nc" id="L429">        builder.setHttpClientConfigCallback(</span>
<span class="nc" id="L430">            httpClientBuilder -&gt; httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider));</span>
      }

<span class="nc" id="L433">      client = new RestHighLevelClient(builder);</span>
    }

    // Test if opensearch is reachable and continuously retry if it is not
<span class="nc" id="L437">    waitUntilOpensearchIsAvailable();</span>

    // Create the index
<span class="nc" id="L440">    createIndex();</span>
<span class="nc" id="L441">  }</span>

  /**
   * Continuously tries to connect to OpenSearch until it is reachable.
   *
   * @throws RuntimeException if an unexpected exception occurs
   */
  private void waitUntilOpensearchIsAvailable() {
<span class="nc" id="L449">    String openSearchUrl = getOpensearchURL();</span>
<span class="nc" id="L450">    logger.info(&quot;Testing connection to OpenSearch at {}&quot;, openSearchUrl);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">    while (!isOpensearchReachable()) {</span>
<span class="nc" id="L452">      logger.warn(&quot;Could not reach OpenSearch at {}. Trying again after {} ms...&quot;, openSearchUrl, retryDelayOnStartup);</span>
      try {
<span class="nc" id="L454">        Thread.sleep(retryDelayOnStartup);</span>
<span class="nc" id="L455">      } catch (InterruptedException e) {</span>
<span class="nc" id="L456">        throw new RuntimeException(&quot;Could not reach OpenSearch at &quot; + openSearchUrl, e);</span>
<span class="nc" id="L457">      }</span>
    }
<span class="nc" id="L459">    logger.info(&quot;Connection to OpenSearch at {} tested successfully&quot;, openSearchUrl);</span>
<span class="nc" id="L460">  }</span>

  /**
   * Checks if OpenSearch is reachable.
   *
   * @return true if OpenSearch is reachable, false otherwise
   *
   * @throws ElasticsearchException if an ElasticsearchException occurs, e.g. if the server returns a 4xx or 5xx error
   *
   * @throws RuntimeException if an unexpected exception occurs
   */
  private boolean isOpensearchReachable() {
    try {
      // test connection
<span class="nc" id="L474">      ClusterHealthRequest request = new ClusterHealthRequest();</span>
<span class="nc" id="L475">      request.waitForYellowStatus();</span>
<span class="nc" id="L476">      ClusterHealthResponse resp = client.cluster().health(request, RequestOptions.DEFAULT);</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">      if (resp.getStatus().equals(ClusterHealthStatus.GREEN)) {</span>
<span class="nc" id="L478">        logger.debug(&quot;Connected to OpenSearch, cluster health is {}&quot;, resp.getStatus());</span>
<span class="nc" id="L479">        return true;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">      } else if (resp.getStatus().equals(ClusterHealthStatus.YELLOW)) {</span>
<span class="nc" id="L481">        logger.warn(&quot;Connected to OpenSearch, cluster health is {}&quot;, resp.getStatus());</span>
<span class="nc" id="L482">        return true;</span>
      }
<span class="nc" id="L484">      logger.debug(&quot;Connected to OpenSearch, but cluster health is {}&quot;, resp.getStatus());</span>
<span class="nc" id="L485">      return false;</span>
<span class="nc" id="L486">    } catch (ConnectException | ConnectionClosedException connectException) {</span>
      // Get thrown when we are unable to connect. Normally this should only happen when
      // opensearch is not running or is just starting up, therefore only log the error on debug level
<span class="nc" id="L489">      logger.debug(&quot;Unable to connect to OpenSearch&quot;, connectException);</span>
<span class="nc" id="L490">      return false;</span>
<span class="nc" id="L491">    } catch (IOException ioException) {</span>
      // Could be thrown when a docker container with opensearch is just starting up,
      // so we check further if the cause is a socket exception
<span class="nc bnc" id="L494" title="All 2 branches missed.">      if (ioException.getCause() instanceof java.net.SocketException) {</span>
        // it seems like a container is starting up, we continue the loop
<span class="nc" id="L496">        logger.debug(&quot;Unable to connect to OpenSearch&quot;, ioException);</span>
<span class="nc" id="L497">        return false;</span>
      }
      // something different triggered an ioexception, so we fail
<span class="nc" id="L500">      throw new RuntimeException(&quot;Couldn't connect to opensearch due to IOExceptionError&quot;, ioException);</span>
<span class="nc" id="L501">    } catch (ElasticsearchException elasticsearchException) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">      if (elasticsearchException.status().getStatus() &gt;= 500) {</span>
<span class="nc" id="L503">        logger.debug(&quot;OpenSearch health request ended with HTTP status code {}. Is OpenSearch service running?&quot;,</span>
<span class="nc" id="L504">            elasticsearchException.status().getStatus());</span>
<span class="nc" id="L505">        return false;</span>
      }
      // An ElasticsearchException is usually thrown in case where the server returns a 4xx or 5xx error code.
      // So for example for an HTTP 401 Unauthorized: In this case we want the startup to fail, so
      // we get an error and have the chance to change the configuration
<span class="nc" id="L510">      logger.error(&quot;Error while testing OpenSearch connection&quot;, elasticsearchException);</span>
<span class="nc" id="L511">      throw elasticsearchException;</span>
<span class="nc" id="L512">    } catch (Exception e) {</span>
      // When another exception occurs, we throw a runtime exception, so the startup of Opencast will fail
<span class="nc" id="L514">      throw new RuntimeException(&quot;Unable to connect to OpenSearch, unexpected exception&quot;, e);</span>
    }
  }

  /**
   * Closes the client.
   *
   * @throws IOException
   *           if stopping the Elasticsearch node fails
   */
  protected void close() throws IOException {
<span class="nc bnc" id="L525" title="All 2 branches missed.">    if (client != null) {</span>
<span class="nc" id="L526">      client.close();</span>
    }
<span class="nc" id="L528">  }</span>

  /**
   * Prepares index to store data for the types (or mappings) as returned by {@link #getDocumentTypes()}.
   *
   *
   * @throws SearchIndexException
   *           if index and type creation fails
   * @throws IOException
   *           if loading of the type definitions fails
   */
  private void createIndex() throws SearchIndexException, IOException {
<span class="nc bnc" id="L540" title="All 2 branches missed.">    if (StringUtils.isBlank(this.indexIdentifier)) {</span>
<span class="nc" id="L541">      throw new IllegalArgumentException(&quot;Search index identifier must be set&quot;);</span>
    }

<span class="nc bnc" id="L544" title="All 2 branches missed.">    for (String type : getDocumentTypes()) {</span>
<span class="nc" id="L545">      createSubIndex(type, getSubIndexIdentifier(type));</span>
    }
<span class="nc" id="L547">  }</span>

  private void createSubIndex(String type, String idxName) throws SearchIndexException, IOException {
    try {
<span class="nc" id="L551">      logger.debug(&quot;Trying to create index for '{}'&quot;, idxName);</span>
<span class="nc" id="L552">      final CreateIndexRequest request = new CreateIndexRequest(idxName)</span>
<span class="nc" id="L553">              .settings(loadResources(&quot;indexSettings.json&quot;), XContentType.JSON)</span>
<span class="nc" id="L554">              .mapping(loadResources(type + &quot;-mapping.json&quot;), XContentType.JSON);</span>

<span class="nc" id="L556">      final CreateIndexResponse siteIdxResponse = client.indices().create(request, RequestOptions.DEFAULT);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">      if (!siteIdxResponse.isAcknowledged()) {</span>
<span class="nc" id="L558">        throw new SearchIndexException(&quot;Unable to create index for '&quot; + idxName + &quot;'&quot;);</span>
      }
<span class="nc" id="L560">    } catch (ElasticsearchStatusException e) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">      if (e.getDetailedMessage().contains(&quot;already_exists_exception&quot;)) {</span>
<span class="nc" id="L562">        logger.info(&quot;Detected existing index '{}'&quot;, idxName);</span>
      } else {
<span class="nc" id="L564">        throw e;</span>
      }
<span class="nc" id="L566">    }</span>

    // See if the index version exists and check if it matches. The request will
    // fail if there is no version index
<span class="nc" id="L570">    boolean versionIndexExists = false;</span>
<span class="nc" id="L571">    final GetRequest getRequest = new GetRequest(idxName, ROOT_ID);</span>
    try {
<span class="nc" id="L573">      final GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);</span>
<span class="nc bnc" id="L574" title="All 4 branches missed.">      if (getResponse.isExists() &amp;&amp; getResponse.getField(IndexSchema.VERSION) != null) {</span>
<span class="nc" id="L575">        final int actualIndexVersion = Integer.parseInt(getResponse.getField(IndexSchema.VERSION).getValue()</span>
<span class="nc" id="L576">                .toString());</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (indexVersion != actualIndexVersion) {</span>
<span class="nc" id="L578">          throw new SearchIndexException(</span>
                  &quot;Search index is at version &quot; + actualIndexVersion + &quot;, but codebase expects &quot; + indexVersion);
        }
<span class="nc" id="L581">        versionIndexExists = true;</span>
<span class="nc" id="L582">        logger.debug(&quot;Search index version is {}&quot;, indexVersion);</span>
      }
<span class="nc" id="L584">    } catch (ElasticsearchException e) {</span>
<span class="nc" id="L585">      logger.debug(&quot;Version index has not been created&quot;);</span>
<span class="nc" id="L586">    }</span>

    // The index does not exist, let's create it
<span class="nc bnc" id="L589" title="All 2 branches missed.">    if (!versionIndexExists) {</span>
<span class="nc" id="L590">      logger.debug(&quot;Creating version index for site '{}'&quot;, idxName);</span>
<span class="nc" id="L591">      final IndexRequest indexRequest = new IndexRequest(idxName).id(ROOT_ID)</span>
<span class="nc" id="L592">              .source(Collections.singletonMap(IndexSchema.VERSION, indexVersion + &quot;&quot;));</span>
<span class="nc" id="L593">      logger.debug(&quot;Index version of site '{}' is {}&quot;, idxName, indexVersion);</span>
<span class="nc" id="L594">      client.index(indexRequest, RequestOptions.DEFAULT);</span>
    }
<span class="nc" id="L596">  }</span>

  /**
   * Load resources from active index class resources if they exist or fall back to these classes resources as default.
   *
   * @return the string containing the resource
   * @throws IOException
   *           if reading the resources fails
   */
  private String loadResources(final String filename) throws IOException {
<span class="nc" id="L606">    final String resourcePath = &quot;/elasticsearch/&quot; + filename;</span>
    // Try loading from the index implementation first.
    // This allows index implementations to override the defaults
<span class="nc bnc" id="L609" title="All 2 branches missed.">    for (Class cls : Arrays.asList(this.getClass(), AbstractElasticsearchIndex.class)) {</span>
<span class="nc" id="L610">      try (InputStream is = cls.getResourceAsStream(resourcePath)) {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">        if (is != null) {</span>
<span class="nc" id="L612">          final String settings = IOUtils.toString(is, StandardCharsets.UTF_8);</span>
<span class="nc" id="L613">          logger.debug(&quot;Reading elasticsearch configuration resources from {}:\n{}&quot;, cls, settings);</span>
<span class="nc" id="L614">          return settings;</span>
        }
<span class="nc bnc" id="L616" title="All 2 branches missed.">      }</span>
<span class="nc" id="L617">    }</span>
<span class="nc" id="L618">    return null;</span>
  }

  /**
   * Creates a request for a search query based on the properties known by the search query.
   * &lt;p&gt;
   * Once this query builder has been created, support for ordering needs to be configured as needed.
   *
   * @param query
   *          the search query
   * @return the request builder
   */
  protected SearchRequest getSearchRequest(SearchQuery query, QueryBuilder queryBuilder) {

<span class="nc" id="L632">    final SearchSourceBuilder searchSource = new SearchSourceBuilder()</span>
<span class="nc" id="L633">        .query(queryBuilder)</span>
<span class="nc" id="L634">        .trackTotalHits(true);</span>

    // Create the actual search query
<span class="nc" id="L637">    logger.debug(&quot;Searching for {}&quot;, searchSource);</span>

    // Make sure all fields are being returned
<span class="nc bnc" id="L640" title="All 2 branches missed.">    if (query.getFields().length &gt; 0) {</span>
<span class="nc" id="L641">      searchSource.storedFields(Arrays.asList(query.getFields()));</span>
    } else {
<span class="nc" id="L643">      searchSource.storedFields(Collections.singletonList(&quot;*&quot;));</span>
    }

    // Pagination
<span class="nc bnc" id="L647" title="All 2 branches missed.">    if (query.getOffset() &gt;= 0) {</span>
<span class="nc" id="L648">      searchSource.from(query.getOffset());</span>
    }

<span class="nc" id="L651">    int limit = ELASTICSEARCH_INDEX_MAX_RESULT_WINDOW;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">    if (query.getLimit() &gt; 0) {</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">      if (query.getOffset() &gt; 0</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">              &amp;&amp; (long) query.getOffset() + (long) query.getLimit() &gt; ELASTICSEARCH_INDEX_MAX_RESULT_WINDOW) {</span>
<span class="nc" id="L655">        limit = ELASTICSEARCH_INDEX_MAX_RESULT_WINDOW - query.getOffset();</span>
      } else {
<span class="nc" id="L657">        limit = query.getLimit();</span>
      }
    }
<span class="nc" id="L660">    searchSource.size(limit);</span>

    // Sort orders
<span class="nc" id="L663">    final Map&lt;String, SortCriterion.Order&gt; sortCriteria = query.getSortOrders();</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">    for (Entry&lt;String, SortCriterion.Order&gt; sortCriterion : sortCriteria.entrySet()) {</span>
<span class="nc" id="L665">      ScriptSortBuilder sortBuilder = null;</span>
<span class="nc" id="L666">      logger.debug(&quot;Event sort criteria: {}&quot;, sortCriterion.getKey());</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">      if (&quot;publication&quot;.equals(sortCriterion.getKey())) {</span>
<span class="nc" id="L668">        sortBuilder = SortBuilders.scriptSort(</span>
            new Script(&quot;params._source.publication.length&quot;),
            ScriptSortBuilder.ScriptSortType.NUMBER);
      }
<span class="nc bnc" id="L672" title="All 3 branches missed.">      switch (sortCriterion.getValue()) {</span>
        case Ascending:
<span class="nc bnc" id="L674" title="All 2 branches missed.">          if (sortBuilder != null) {</span>
<span class="nc" id="L675">            sortBuilder.order(SortOrder.ASC);</span>
<span class="nc" id="L676">            searchSource.sort(sortBuilder);</span>
          } else {
<span class="nc" id="L678">            searchSource.sort(sortCriterion.getKey(), SortOrder.ASC);</span>
          }
<span class="nc" id="L680">          break;</span>
        case Descending:
<span class="nc bnc" id="L682" title="All 2 branches missed.">          if (sortBuilder != null) {</span>
<span class="nc" id="L683">            sortBuilder.order(SortOrder.DESC);</span>
<span class="nc" id="L684">            searchSource.sort(sortBuilder);</span>
          } else {
<span class="nc" id="L686">            searchSource.sort(sortCriterion.getKey(), SortOrder.DESC);</span>
          }
<span class="nc" id="L688">          break;</span>
        default:
          break;
      }
<span class="nc" id="L692">    }</span>
<span class="nc" id="L693">    return new SearchRequest(Arrays.stream(query.getTypes()).map(this::getSubIndexIdentifier).toArray(String[]::new))</span>
<span class="nc" id="L694">            .searchType(SearchType.QUERY_THEN_FETCH).preference(&quot;_local&quot;).source(searchSource);</span>
  }

  /**
   * Returns the name of this index.
   *
   * @return the index name
   */
  public String getIndexName() {
<span class="nc" id="L703">    return indexName;</span>
  }

  /*
   * This method is a workaround to avoid accessing org.apache.lucene.search.TotalHits outside this bundle.
   * Doing so would cause OSGi dependency problems. It seems to be a bug anyway that ES exposes this
   * class.
   */
  protected long getTotalHits(SearchHits hits) {
<span class="nc" id="L712">    return hits.getTotalHits().value;</span>
  }

  /**
   * Returns the name of the sub index for the given type.
   *
   * @param type
   *          The type to get the sub index for.
   * @return the index name
   */
  protected String getSubIndexIdentifier(String type) {
<span class="nc" id="L723">    return this.indexIdentifier + &quot;_&quot; + type;</span>
  }

  public RestHighLevelClient getClient() {
<span class="nc" id="L727">    return client;</span>
  }

  /**
   * Execute a query on the index.
   *
   * @param query
   *          The query to use to find the results
   * @param request
   *          The builder to use to create the query.
   * @param toSearchResult
   *          The function to convert the results to a {@link SearchResult}
   * @param maxRetryAttempts
   *          How often to retry query in case of ElasticsearchStatusException
   * @param retryWaitingPeriod
   *          How long to wait (in ms) between retries
   * @return A {@link SearchResult} containing the relevant objects.
   *
   * @throws IOException
   *         If querying the index fails
   * @throws InterruptedException
   *         If waiting during retry is interrupted
   */
  protected &lt;T&gt; SearchResult&lt;T&gt; executeQuery(SearchQuery query, SearchRequest request,
          Function&lt;SearchMetadataCollection, T&gt; toSearchResult, int maxRetryAttempts, int retryWaitingPeriod)
          throws IOException, InterruptedException {
    // Execute the query and try to get hold of a query response
<span class="nc" id="L754">    SearchResponse searchResponse = null;</span>
<span class="nc" id="L755">    int retryAttempts = 0;</span>
    do {
      try {
<span class="nc" id="L758">        searchResponse = getClient().search(request, RequestOptions.DEFAULT);</span>
<span class="nc" id="L759">      } catch (ElasticsearchStatusException e) {</span>
<span class="nc" id="L760">        retryAttempts++;</span>

<span class="nc bnc" id="L762" title="All 2 branches missed.">        if (retryAttempts &lt;= maxRetryAttempts) {</span>
<span class="nc" id="L763">          logger.warn(&quot;Could not query documents from index {} because of {}, retrying in {} ms.&quot;, getIndexName(),</span>
<span class="nc" id="L764">                  e.getMessage(), retryWaitingPeriod);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">          if (retryWaitingPeriod &gt; 0) {</span>
<span class="nc" id="L766">            Thread.sleep(retryWaitingPeriod);</span>
          }
        } else {
<span class="nc" id="L769">          logger.error(&quot;Could not query documents from index {}, not retrying.&quot;, getIndexName(),</span>
                  e);
<span class="nc" id="L771">          throw e;</span>
        }
<span class="nc" id="L773">      }</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">    } while (searchResponse == null);</span>

    // Create and configure the query result
<span class="nc" id="L777">    long hits = getTotalHits(searchResponse.getHits());</span>
<span class="nc" id="L778">    long size = searchResponse.getHits().getHits().length;</span>
<span class="nc" id="L779">    SearchResultImpl&lt;T&gt; result = new SearchResultImpl&lt;&gt;(query, hits, size);</span>
<span class="nc" id="L780">    result.setSearchTime(searchResponse.getTook().millis());</span>

    // Walk through response and create new items with title, creator, etc:
<span class="nc bnc" id="L783" title="All 2 branches missed.">    for (SearchHit doc : searchResponse.getHits()) {</span>

      // Wrap the search resulting metadata
<span class="nc" id="L786">      SearchMetadataCollection metadata = new SearchMetadataCollection(doc.getType());</span>
<span class="nc" id="L787">      metadata.setIdentifier(doc.getId());</span>

<span class="nc bnc" id="L789" title="All 2 branches missed.">      for (DocumentField field : doc.getFields().values()) {</span>
<span class="nc" id="L790">        String name = field.getName();</span>
<span class="nc" id="L791">        SearchMetadata&lt;Object&gt; m = new SearchMetadataImpl&lt;&gt;(name);</span>
        // TODO: Add values with more care (localized, correct type etc.)

        // Add the field values
<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (field.getValues().size() &gt; 1) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">          for (Object v : field.getValues()) {</span>
<span class="nc" id="L797">            m.addValue(v);</span>
<span class="nc" id="L798">          }</span>
        } else {
<span class="nc" id="L800">          m.addValue(field.getValue());</span>
        }

        // Add the metadata
<span class="nc" id="L804">        metadata.add(m);</span>
<span class="nc" id="L805">      }</span>

      // Get the score for this item
<span class="nc" id="L808">      float score = doc.getScore();</span>

      // Have the serializer in charge create a type-specific search result
      // item
      try {
<span class="nc" id="L813">        T document = toSearchResult.apply(metadata);</span>
<span class="nc" id="L814">        SearchResultItem&lt;T&gt; item = new SearchResultItemImpl&lt;&gt;(score, document);</span>
<span class="nc" id="L815">        result.addResultItem(item);</span>
<span class="nc" id="L816">      } catch (Throwable t) {</span>
<span class="nc" id="L817">        logger.warn(&quot;Error during search result serialization: '{}'. Skipping this search result.&quot;, t.getMessage());</span>
<span class="nc" id="L818">        size--;</span>
<span class="nc" id="L819">      }</span>
<span class="nc" id="L820">    }</span>

    // Set the number of resulting documents
<span class="nc" id="L823">    result.setDocumentCount(size);</span>

<span class="nc" id="L825">    return result;</span>
  }

  /**
   * Construct the URL to the OpenSearch service.
   *
   * @return the OpenSearch URL
   */
  private String getOpensearchURL() {
<span class="nc" id="L834">    return this.externalServerScheme + &quot;://&quot; + this.externalServerHostname + &quot;:&quot; + this.externalServerPort;</span>
  }

  /**
   * Returns all the known terms for a field (aka facets).
   *
   * @param field
   *          the field name
   * @param type
   *          the document type
   * @return the list of terms
   */
  public List&lt;String&gt; getTermsForField(String field, String type) {
<span class="nc" id="L847">    final String facetName = &quot;terms&quot;;</span>
    // Add size to aggregation to return all values (the default is the top ten terms with the most documents).
    // We set it to 10,000, which should be enough (the maximum is 'search.max_buckets', which defaults to 65,536).
<span class="nc" id="L850">    final AggregationBuilder aggBuilder = AggregationBuilders.terms(facetName).field(field)</span>
<span class="nc" id="L851">            .size(ELASTICSEARCH_TERM_AGGREGATION_SIZE);</span>
<span class="nc" id="L852">    final SearchSourceBuilder searchSource = new SearchSourceBuilder().aggregation(aggBuilder);</span>
<span class="nc" id="L853">    final SearchRequest searchRequest = new SearchRequest(this.getSubIndexIdentifier(type)).source(searchSource);</span>
    try {
<span class="nc" id="L855">      final SearchResponse response = getClient().search(searchRequest, RequestOptions.DEFAULT);</span>

<span class="nc" id="L857">      final List&lt;String&gt; terms = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L858">      final Terms aggs = response.getAggregations().get(facetName);</span>

<span class="nc bnc" id="L860" title="All 2 branches missed.">      for (Terms.Bucket bucket : aggs.getBuckets()) {</span>
<span class="nc" id="L861">        terms.add(bucket.getKey().toString());</span>
<span class="nc" id="L862">      }</span>

<span class="nc" id="L864">      return terms;</span>
<span class="nc" id="L865">    } catch (IOException e) {</span>
<span class="nc" id="L866">      return chuck(e);</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>