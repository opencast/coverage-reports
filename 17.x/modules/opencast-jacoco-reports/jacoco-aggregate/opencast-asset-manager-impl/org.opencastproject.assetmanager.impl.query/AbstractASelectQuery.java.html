<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractASelectQuery.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-asset-manager-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.assetmanager.impl.query</a> &gt; <span class="el_source">AbstractASelectQuery.java</span></div><h1>AbstractASelectQuery.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.assetmanager.impl.query;

import static com.entwinemedia.fn.Stream.$;

import org.opencastproject.assetmanager.api.Property;
import org.opencastproject.assetmanager.api.Snapshot;
import org.opencastproject.assetmanager.api.query.ARecord;
import org.opencastproject.assetmanager.api.query.AResult;
import org.opencastproject.assetmanager.api.query.ASelectQuery;
import org.opencastproject.assetmanager.api.query.Order;
import org.opencastproject.assetmanager.api.query.Predicate;
import org.opencastproject.assetmanager.impl.AssetManagerImpl;
import org.opencastproject.assetmanager.impl.RuntimeTypes;
import org.opencastproject.assetmanager.impl.persistence.EntityPaths;
import org.opencastproject.assetmanager.impl.persistence.PropertyDto;
import org.opencastproject.assetmanager.impl.persistence.QPropertyDto;
import org.opencastproject.assetmanager.impl.persistence.SnapshotDto;
import org.opencastproject.util.RequireUtil;
import org.opencastproject.util.data.Function;

import com.entwinemedia.fn.Fn;
import com.entwinemedia.fn.Fn2;
import com.entwinemedia.fn.Stream;
import com.entwinemedia.fn.data.Opt;
import com.entwinemedia.fn.data.SetB;
import com.entwinemedia.fn.fns.Booleans;
import com.mysema.query.Tuple;
import com.mysema.query.jpa.impl.JPAQuery;
import com.mysema.query.jpa.impl.JPAQueryFactory;
import com.mysema.query.types.EntityPath;
import com.mysema.query.types.Expression;
import com.mysema.query.types.OrderSpecifier;
import com.mysema.query.types.expr.BooleanExpression;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

public abstract class AbstractASelectQuery implements ASelectQuery, SelectQueryContributor, EntityPaths {
<span class="fc" id="L68">  protected static final Logger logger = LoggerFactory.getLogger(AbstractASelectQuery.class);</span>

<span class="fc" id="L70">  private final AbstractASelectQuery self = this;</span>
  private final AssetManagerImpl am;

<span class="fc" id="L73">  public AbstractASelectQuery(AssetManagerImpl am) {</span>
<span class="fc" id="L74">    this.am = am;</span>
<span class="fc" id="L75">  }</span>

  @Override public ASelectQuery where(final Predicate predicate) {
<span class="fc" id="L78">    return new AbstractASelectQuery(am) {</span>
      @Override public SelectQueryContribution contributeSelect(JPAQueryFactory f) {
<span class="fc" id="L80">        final SelectQueryContribution predicateContrib = RuntimeTypes.convert(predicate).contributeSelect(f);</span>
<span class="fc" id="L81">        return self.contributeSelect(f)</span>
<span class="fc" id="L82">                .addFrom(predicateContrib.from)</span>
<span class="fc" id="L83">                .addJoin(predicateContrib.join)</span>
<span class="fc" id="L84">                .andWhere(predicateContrib.where);</span>
      }

      @Override public String toString() {
<span class="nc" id="L88">        return &quot;where &quot; + predicate;</span>
      }
    };
  }

  @Override public ASelectQuery page(final int offset, final int size) {
<span class="fc" id="L94">    return new AbstractASelectQuery(am) {</span>
      @Override public SelectQueryContribution contributeSelect(JPAQueryFactory f) {
<span class="fc" id="L96">        return self.contributeSelect(f).offset(offset).limit(size);</span>
      }
    };
  }

  @Override public ASelectQuery orderBy(final Order order) {
<span class="fc" id="L102">    return new AbstractASelectQuery(am) {</span>
      @Override public SelectQueryContribution contributeSelect(JPAQueryFactory f) {
<span class="fc" id="L104">        final SelectQueryContribution orderContrib = RuntimeTypes.convert(order).contributeSelect(f);</span>
<span class="fc" id="L105">        return self.contributeSelect(f).addOrder(orderContrib.order).andWhere(orderContrib.where);</span>
      }
    };
  }

  @Override public AResult run() {
<span class="fc" id="L111">    return am.getDatabase().run(new Function&lt;JPAQueryFactory, AResult&gt;() {</span>
      @Override public AResult apply(JPAQueryFactory f) {
<span class="fc" id="L113">        return run(f);</span>
      }
    });
  }

  private AResult run(JPAQueryFactory f) {
    // run query and map the result to records
<span class="fc" id="L120">    final long startTime = System.nanoTime();</span>
    // resolve AST
<span class="fc" id="L122">    final SelectQueryContribution r = contributeSelect(f);</span>
<span class="fc" id="L123">    final boolean toFetchProperties = r.fetch.exists(Booleans.&lt;Expression&lt;?&gt;&gt;eq(QPropertyDto.propertyDto));</span>
    // # create Querydsl query
<span class="fc" id="L125">    final JPAQuery q = f.query();</span>
    // # from
    {
      // Make sure that the snapshotDto is always contained in the from clause because the media package ID and
      //   the ID are always selected.
      // Use a mutable hash set to be able to use the removeAll operation.
<span class="fc" id="L131">      final Set&lt;EntityPath&lt;?&gt;&gt; from = Stream.&lt;EntityPath&lt;?&gt;&gt;mk(Q_SNAPSHOT)</span>
<span class="fc" id="L132">              .append(r.from) // all collected from clauses</span>
<span class="fc" id="L133">              .append(r.join.map(Join.getFrom)) // all from clauses from the joins</span>
<span class="fc" id="L134">              .toSet(SetB.MH);</span>
      // Now remove everything that will be joined. Adding them in both the from and a join
      //   clause is not allowed.
<span class="fc" id="L137">      from.removeAll(r.join.map(Join.getJoin).toSet());</span>
<span class="fc" id="L138">      q.from(JpaFns.toEntityPathArray(from));</span>
    }
    // # join
<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (!r.join.isEmpty()) {</span>
      // Group joins by entity and combine all &quot;on&quot; clauses with &quot;or&quot; expressions.
      // This way there is only one join clause per distinct entity which eliminates the need to alias entities
      //   like this `new QPropertyDto(&quot;alias&quot;)`.
      // Entity aliasing produces many issues which seem to cause a huge rewrite of the query building mechanism
      //   so it should be prevented at all costs.
<span class="fc" id="L147">      final Map&lt;EntityPath&lt;?&gt;, BooleanExpression&gt; joins = r.join.foldl(</span>
          new HashMap&lt;EntityPath&lt;?&gt;, BooleanExpression&gt;(),
<span class="fc" id="L149">          new Fn2&lt;Map&lt;EntityPath&lt;?&gt;, BooleanExpression&gt;, Join, Map&lt;EntityPath&lt;?&gt;, BooleanExpression&gt;&gt;() {</span>
            @Override
            public Map&lt;EntityPath&lt;?&gt;, BooleanExpression&gt; apply(Map&lt;EntityPath&lt;?&gt;, BooleanExpression&gt; sum, Join join) {
              // get the on expression saved with the join, may be null
<span class="fc" id="L153">              final BooleanExpression existing = sum.get(join.join);</span>
              final BooleanExpression combined;
              // combine the existing and the current expression
<span class="fc bfc" id="L156" title="All 2 branches covered.">              if (existing == null) {</span>
<span class="fc" id="L157">                combined = join.on;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">              } else if (existing.equals(join.on)) {</span>
                // if both expressions are equal there is no need to combine them
<span class="fc" id="L160">                combined = existing;</span>
              } else {
                // if different combine with logical &quot;or&quot;
<span class="fc" id="L163">                combined = existing.or(join.on);</span>
              }
<span class="fc" id="L165">              sum.put(join.join, combined);</span>
<span class="fc" id="L166">              return sum;</span>
            }
          });
<span class="fc bfc" id="L169" title="All 2 branches covered.">      for (final Map.Entry&lt;EntityPath&lt;?&gt;, BooleanExpression&gt; j : joins.entrySet()) {</span>
<span class="fc" id="L170">        q.leftJoin(j.getKey()).on(j.getValue());</span>
<span class="fc" id="L171">      }</span>
    }
    // # where
<span class="fc" id="L174">    q.where(r.where.orNull());</span>
    // # paging
<span class="fc bfc" id="L176" title="All 2 branches covered.">    for (Integer a : r.offset) {</span>
<span class="fc" id="L177">      q.offset(a);</span>
<span class="fc" id="L178">    }</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">    for (Integer a : r.limit) {</span>
<span class="fc" id="L180">      q.limit(a);</span>
<span class="fc" id="L181">    }</span>
    // # order
<span class="fc bfc" id="L183" title="All 2 branches covered.">    for (OrderSpecifier&lt;?&gt; a : r.order) {</span>
<span class="fc" id="L184">      q.orderBy(a);</span>
<span class="fc" id="L185">    }</span>
    // # distinct
<span class="fc bfc" id="L187" title="All 2 branches covered.">    if (!toFetchProperties) {</span>
      // if no properties shall be fetched the result set can be distinct
<span class="fc" id="L189">      q.distinct();</span>
    }
    // # fetch
    // create parameters for fetch clause, i.e. Querydsl's list() method
    final List&lt;Expression&lt;?&gt;&gt; fetch;
    {
      // check if the media package ID needs to be selected separately
<span class="fc bfc" id="L196" title="All 2 branches covered.">      if (r.fetch.exists(MandatoryFetch.exists)) {</span>
<span class="fc" id="L197">        fetch = r.fetch.toList();</span>
      } else {
<span class="fc" id="L199">        fetch = r.fetch.append(MandatoryFetch.fetch).toList();</span>
      }
    }
    // Run the query and transform the result into records
    final LinkedHashSet&lt;ARecordImpl&gt; records;
    {
      // run query
<span class="fc" id="L206">      am.getDatabase().logQuery(q);</span>
<span class="fc" id="L207">      final List&lt;Tuple&gt; result = q.list(JpaFns.toExpressionArray(fetch));</span>
<span class="fc" id="L208">      logger.debug(&quot;Pure query ms &quot; + (System.nanoTime() - startTime) / 1000000);</span>
      // map result based on the fact whether properties have been fetched or not
<span class="fc bfc" id="L210" title="All 2 branches covered.">      if (!toFetchProperties) {</span>
        // No properties have been fetched -&gt; each result row (tuple) is a distinct record (snapshot).
<span class="fc" id="L212">        records = result.stream()</span>
<span class="fc" id="L213">            .map(tuple -&gt; toARecord(tuple, r))</span>
<span class="fc" id="L214">            .map(record -&gt; {</span>
<span class="fc" id="L215">              Optional&lt;Snapshot&gt; snapshotOpt = record.getSnapshot();</span>
<span class="fc" id="L216">              Snapshot snapshot = null;</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">              if (snapshotOpt.isPresent()) {</span>
                // make sure the delivered media package has valid URIs
<span class="fc" id="L219">                snapshot = am.getHttpAssetProvider().prepareForDelivery(snapshotOpt.get());</span>
              }
<span class="fc" id="L221">              return new ARecordImpl(</span>
<span class="fc" id="L222">                  record.getSnapshotId(),</span>
<span class="fc" id="L223">                  record.getMediaPackageId(),</span>
<span class="fc" id="L224">                  record.getProperties(),</span>
                  snapshot);
<span class="fc" id="L226">            }).collect(Collectors.toCollection(LinkedHashSet::new));</span>
      } else {
<span class="fc" id="L228">        logger.trace(&quot;Fetched properties&quot;);</span>
        // Properties have been fetched -&gt; there may be multiple rows (tuples)
        // per snapshot because of the join with the property table. Extract
        // records and properties and link them together.

        // group properties after their media package ID and make sure that no duplicate properties occur
<span class="fc" id="L234">        final Map&lt;String, Set&lt;Property&gt;&gt; propertiesPerMp = $(result).bind(toProperty).foldl(</span>
            new HashMap&lt;String, Set&lt;Property&gt;&gt;(),
<span class="fc" id="L236">            new Fn2&lt;Map&lt;String, Set&lt;Property&gt;&gt;, Property, Map&lt;String, Set&lt;Property&gt;&gt;&gt;() {</span>
              @Override
              public Map&lt;String, Set&lt;Property&gt;&gt; apply(Map&lt;String, Set&lt;Property&gt;&gt; sum, Property p) {
<span class="fc" id="L239">                final String mpId = p.getId().getMediaPackageId();</span>
<span class="fc" id="L240">                final Set&lt;Property&gt; props = sum.get(mpId);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                if (props != null) {</span>
<span class="fc" id="L242">                  props.add(p);</span>
                } else {
<span class="fc" id="L244">                  sum.put(mpId, SetB.MH.mk(p));</span>
                }
<span class="fc" id="L246">                return sum;</span>
              }
            });
        // group records after their media package ID
<span class="fc" id="L250">        final Map&lt;String, List&lt;ARecordImpl&gt;&gt; distinctRecords = result.stream()</span>
<span class="fc" id="L251">            .map(tuple -&gt; toARecord(tuple, r))</span>
<span class="fc" id="L252">            .collect(Collectors.groupingBy(record -&gt; record.getMediaPackageId()));</span>
<span class="fc" id="L253">        records = distinctRecords.values().stream()</span>
<span class="fc" id="L254">            .flatMap(List::stream)</span>
<span class="fc" id="L255">            .map(record -&gt; {</span>
<span class="fc" id="L256">              final Set&lt;Property&gt; properties = propertiesPerMp.get(record.getMediaPackageId());</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">              final List&lt;Property&gt; p = properties != null</span>
<span class="fc" id="L258">                  ? properties.stream().collect(Collectors.toList()) : new ArrayList&lt;&gt;();</span>
<span class="fc" id="L259">              Snapshot snapshot = null;</span>
<span class="fc" id="L260">              Optional&lt;Snapshot&gt; snapshotOpt = record.getSnapshot();</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">              if (snapshotOpt.isPresent()) {</span>
                // make sure the delivered media package has valid URIs
<span class="fc" id="L263">                snapshot = am.getHttpAssetProvider().prepareForDelivery(snapshotOpt.get());</span>
              }
<span class="fc" id="L265">              return new ARecordImpl(record.getSnapshotId(), record.getMediaPackageId(), p, snapshot);</span>
            })
<span class="fc" id="L267">            .collect(Collectors.toCollection(LinkedHashSet::new));</span>
      }
    }
<span class="fc" id="L270">    final long searchTime = (System.nanoTime() - startTime) / 1000000;</span>
<span class="fc" id="L271">    logger.debug(&quot;Complete query ms &quot; + searchTime);</span>
<span class="fc" id="L272">    LinkedHashSet&lt;ARecord&gt; narrowRecords = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">    for (ARecordImpl recordImpl : records) {</span>
<span class="fc" id="L274">      narrowRecords.add(recordImpl);</span>
<span class="fc" id="L275">    }</span>
<span class="fc" id="L276">    return new AResultImpl(</span>
        narrowRecords,
<span class="fc" id="L278">        narrowRecords.size(),</span>
<span class="fc" id="L279">        r.offset.getOr(0),</span>
<span class="fc" id="L280">        r.limit.getOr(-1),</span>
        searchTime
    );
  }

  /**
   * Transform a Querydsl result {@link Tuple} into an {@link ARecord}.
   * To do the transformation I need to know what targets have been selected.
   */
  private Fn&lt;Tuple, ARecordImpl&gt; toARecord(final SelectQueryContribution c) {
<span class="nc" id="L290">    return new Fn&lt;Tuple, ARecordImpl&gt;() {</span>
      @Override public ARecordImpl apply(Tuple tuple) {
        final String mediaPackageId;
<span class="nc" id="L293">        SnapshotDto snapshotDto = null;</span>
        final long id;
        // Only fetch the snapshot if it is in the fetch list.
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (c.fetch.exists(Booleans.&lt;Expression&lt;?&gt;&gt;eq(Q_SNAPSHOT))) {</span>
<span class="nc" id="L297">          snapshotDto = RequireUtil.notNull(tuple.get(Q_SNAPSHOT), &quot;[BUG] snapshot table data&quot;);</span>
<span class="nc" id="L298">          id = snapshotDto.getId();</span>
<span class="nc" id="L299">          mediaPackageId = snapshotDto.getMediaPackageId();</span>
        } else {
          // The media package ID and the snapshot's database ID must always be fetched.
<span class="nc" id="L302">          id = RequireUtil.notNull(tuple.get(Q_SNAPSHOT.id), &quot;[BUG] snapshot table id&quot;);</span>
<span class="nc" id="L303">          mediaPackageId = RequireUtil.notNull(</span>
<span class="nc" id="L304">              tuple.get(Q_SNAPSHOT.mediaPackageId),</span>
              &quot;[BUG] snapshot table media package id&quot;
          );
        }
<span class="nc" id="L308">        return new ARecordImpl(id, mediaPackageId, new ArrayList&lt;&gt;(), snapshotDto);</span>
      }
    };
  }

  private ARecordImpl toARecord(Tuple tuple, final SelectQueryContribution c) {
    final String mediaPackageId;
<span class="fc" id="L315">    SnapshotDto snapshotDto = null;</span>
    final long id;
    // Only fetch the snapshot if it is in the fetch list.
<span class="fc bfc" id="L318" title="All 2 branches covered.">    if (c.fetch.exists(Booleans.&lt;Expression&lt;?&gt;&gt;eq(Q_SNAPSHOT))) {</span>
<span class="fc" id="L319">      snapshotDto = RequireUtil.notNull(tuple.get(Q_SNAPSHOT), &quot;[BUG] snapshot table data&quot;);</span>
<span class="fc" id="L320">      id = snapshotDto.getId();</span>
<span class="fc" id="L321">      mediaPackageId = snapshotDto.getMediaPackageId();</span>
    } else {
      // The media package ID and the snapshot's database ID must always be fetched.
<span class="fc" id="L324">      id = RequireUtil.notNull(tuple.get(Q_SNAPSHOT.id), &quot;[BUG] snapshot table id&quot;);</span>
<span class="fc" id="L325">      mediaPackageId = RequireUtil.notNull(</span>
<span class="fc" id="L326">          tuple.get(Q_SNAPSHOT.mediaPackageId),</span>
          &quot;[BUG] snapshot table media package id&quot;
      );
    }
<span class="fc" id="L330">    return new ARecordImpl(id, mediaPackageId, new ArrayList&lt;&gt;(), snapshotDto);</span>
  }

<span class="fc" id="L333">  private static Fn&lt;Tuple, Opt&lt;Property&gt;&gt; toProperty = new Fn&lt;Tuple, Opt&lt;Property&gt;&gt;() {</span>
    @Override public Opt&lt;Property&gt; apply(Tuple tuple) {
<span class="fc" id="L335">      final PropertyDto dto = tuple.get(Q_PROPERTY);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">      return dto != null ? Opt.some(dto.toProperty()) : Opt.&lt;Property&gt;none();</span>
    }
  };

  /**
   * Specification of fields whose fetch is mandatory.
   */
  private static final class MandatoryFetch {
<span class="fc" id="L344">    static final Fn&lt;Expression&lt;?&gt;, Boolean&gt; exists =</span>
<span class="fc" id="L345">            Booleans.&lt;Expression&lt;?&gt;&gt;eq(Q_SNAPSHOT)</span>
<span class="fc" id="L346">                    .or(Booleans.&lt;Expression&lt;?&gt;&gt;eq(Q_SNAPSHOT.mediaPackageId))</span>
<span class="fc" id="L347">                    .or(Booleans.&lt;Expression&lt;?&gt;&gt;eq(Q_SNAPSHOT.id));</span>

<span class="fc" id="L349">    static final Stream&lt;Expression&lt;?&gt;&gt; fetch = Stream.&lt;Expression&lt;?&gt;&gt;mk(Q_SNAPSHOT.mediaPackageId, Q_SNAPSHOT.id);</span>
  }

  private static &lt;A&gt; Stream&lt;A&gt; vary(Stream&lt;? extends A&gt; a) {
<span class="nc" id="L353">    return (Stream&lt;A&gt;) a;</span>
  }

  private static &lt;A&gt; int sizeOf(Stream&lt;A&gt; stream) {
<span class="nc" id="L357">    int count = 0;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">    for (A ignore : stream) {</span>
<span class="nc" id="L359">      count++;</span>
<span class="nc" id="L360">    }</span>
<span class="nc" id="L361">    return count;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>