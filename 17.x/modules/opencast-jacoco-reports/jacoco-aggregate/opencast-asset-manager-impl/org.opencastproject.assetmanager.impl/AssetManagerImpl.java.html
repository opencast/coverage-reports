<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AssetManagerImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-asset-manager-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.assetmanager.impl</a> &gt; <span class="el_source">AssetManagerImpl.java</span></div><h1>AssetManagerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.assetmanager.impl;

import static com.entwinemedia.fn.Prelude.chuck;
import static com.entwinemedia.fn.Stream.$;
import static java.lang.String.format;
import static org.opencastproject.assetmanager.api.fn.Enrichments.enrich;
import static org.opencastproject.mediapackage.MediaPackageSupport.Filters.hasNoChecksum;
import static org.opencastproject.mediapackage.MediaPackageSupport.Filters.isNotPublication;
import static org.opencastproject.mediapackage.MediaPackageSupport.getFileName;
import static org.opencastproject.mediapackage.MediaPackageSupport.getMediaPackageElementId;
import static org.opencastproject.security.api.SecurityConstants.EPISODE_ROLE_ID_PREFIX;
import static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;
import static org.opencastproject.security.api.SecurityConstants.GLOBAL_CAPTURE_AGENT_ROLE;
import static org.opencastproject.security.util.SecurityUtil.getEpisodeRoleId;

import org.opencastproject.assetmanager.api.Asset;
import org.opencastproject.assetmanager.api.AssetId;
import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.AssetManagerException;
import org.opencastproject.assetmanager.api.Availability;
import org.opencastproject.assetmanager.api.Property;
import org.opencastproject.assetmanager.api.PropertyId;
import org.opencastproject.assetmanager.api.Snapshot;
import org.opencastproject.assetmanager.api.Value;
import org.opencastproject.assetmanager.api.Version;
import org.opencastproject.assetmanager.api.fn.Enrichments;
import org.opencastproject.assetmanager.api.query.ADeleteQuery;
import org.opencastproject.assetmanager.api.query.AQueryBuilder;
import org.opencastproject.assetmanager.api.query.ARecord;
import org.opencastproject.assetmanager.api.query.AResult;
import org.opencastproject.assetmanager.api.query.ASelectQuery;
import org.opencastproject.assetmanager.api.query.Predicate;
import org.opencastproject.assetmanager.api.query.RichAResult;
import org.opencastproject.assetmanager.api.query.Target;
import org.opencastproject.assetmanager.api.storage.AssetStore;
import org.opencastproject.assetmanager.api.storage.DeletionSelector;
import org.opencastproject.assetmanager.api.storage.RemoteAssetStore;
import org.opencastproject.assetmanager.api.storage.Source;
import org.opencastproject.assetmanager.api.storage.StoragePath;
import org.opencastproject.assetmanager.impl.persistence.Database;
import org.opencastproject.assetmanager.impl.persistence.SnapshotDto;
import org.opencastproject.assetmanager.impl.query.AQueryBuilderImpl;
import org.opencastproject.assetmanager.impl.query.AbstractADeleteQuery;
import org.opencastproject.authorization.xacml.manager.api.AclServiceFactory;
import org.opencastproject.authorization.xacml.manager.api.ManagedAcl;
import org.opencastproject.authorization.xacml.manager.util.AccessInformationUtil;
import org.opencastproject.db.DBSessionFactory;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.objects.event.EventIndexUtils;
import org.opencastproject.elasticsearch.index.rebuild.AbstractIndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildException;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildService;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildService.DataType;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.MediaPackageParser;
import org.opencastproject.mediapackage.MediaPackageSupport;
import org.opencastproject.message.broker.api.assetmanager.AssetManagerItem;
import org.opencastproject.message.broker.api.update.AssetManagerUpdateHandler;
import org.opencastproject.metadata.dublincore.DublinCores;
import org.opencastproject.metadata.dublincore.EventCatalogUIAdapter;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.security.api.DefaultOrganization;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.Role;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UnauthorizedException;
import org.opencastproject.security.api.User;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.util.Checksum;
import org.opencastproject.util.ChecksumType;
import org.opencastproject.util.MimeTypes;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RequireUtil;
import org.opencastproject.util.data.functions.Functions;
import org.opencastproject.workspace.api.Workspace;

import com.entwinemedia.fn.Fn;
import com.entwinemedia.fn.Fx;
import com.entwinemedia.fn.P1;
import com.entwinemedia.fn.P1Lazy;
import com.entwinemedia.fn.Pred;
import com.entwinemedia.fn.Prelude;
import com.entwinemedia.fn.fns.Booleans;
import com.google.common.collect.Sets;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Function;
import java.util.stream.Collectors;

import javax.persistence.EntityManagerFactory;

/**
 * The Asset Manager implementation.
 */
@Component(
    property = {
        &quot;service.description=Opencast Asset Manager&quot;
    },
    immediate = true,
    service = { AssetManager.class, IndexProducer.class }
)
<span class="fc" id="L163">public class AssetManagerImpl extends AbstractIndexProducer implements AssetManager,</span>
    AbstractADeleteQuery.DeleteEpisodeHandler {

<span class="fc" id="L166">  private static final Logger logger = LoggerFactory.getLogger(AssetManagerImpl.class);</span>

  private static final int PAGE_SIZE = 1000;

<span class="fc" id="L170">  enum AdminRole {</span>
<span class="fc" id="L171">    GLOBAL, ORGANIZATION, NONE</span>
  }

  public static final String WRITE_ACTION = &quot;write&quot;;
  public static final String READ_ACTION = &quot;read&quot;;
  public static final String SECURITY_NAMESPACE = &quot;org.opencastproject.assetmanager.security&quot;;

  private static final String MANIFEST_DEFAULT_NAME = &quot;manifest&quot;;

  private static final String CONFIG_EPISODE_ID_ROLE = &quot;org.opencastproject.episode.id.role.access&quot;;
<span class="fc" id="L181">  private static boolean episodeIdRole = false;</span>

<span class="fc" id="L183">  private CopyOnWriteArrayList&lt;AssetManagerUpdateHandler&gt; handlers = new CopyOnWriteArrayList&lt;&gt;();</span>

  private SecurityService securityService;
  private AuthorizationService authorizationService;
  private OrganizationDirectoryService orgDir;
  private Workspace workspace;
  private AssetStore assetStore;
  private HttpAssetProvider httpAssetProvider;
  private String systemUserName;
  private Database db;
  private DBSessionFactory dbSessionFactory;
  private EntityManagerFactory emf;
  private AclServiceFactory aclServiceFactory;
  private ElasticsearchIndex index;
<span class="fc" id="L197">  private Map&lt;String, List&lt;EventCatalogUIAdapter&gt;&gt; extendedEventCatalogUIAdapters = new HashMap&lt;&gt;();</span>

  // Settings for role filter
  private boolean includeAPIRoles;
  private boolean includeCARoles;
  private boolean includeUIRoles;


<span class="fc" id="L205">  public static final Set&lt;MediaPackageElement.Type&gt; MOVABLE_TYPES = Sets.newHashSet(</span>
          MediaPackageElement.Type.Attachment,
          MediaPackageElement.Type.Catalog,
          MediaPackageElement.Type.Track
  );

<span class="fc" id="L211">  private final HashMap&lt;String, RemoteAssetStore&gt; remoteStores = new LinkedHashMap&lt;&gt;();</span>

  /**
   * OSGi callback.
   */
  @Activate
  public synchronized void activate(ComponentContext cc) {
<span class="nc" id="L218">    logger.info(&quot;Activating AssetManager.&quot;);</span>
<span class="nc" id="L219">    db = new Database(dbSessionFactory.createSession(emf));</span>
<span class="nc" id="L220">    systemUserName = SecurityUtil.getSystemUserName(cc);</span>

<span class="nc" id="L222">    includeAPIRoles = BooleanUtils.toBoolean(Objects.toString(cc.getProperties().get(&quot;includeAPIRoles&quot;), null));</span>
<span class="nc" id="L223">    includeCARoles = BooleanUtils.toBoolean(Objects.toString(cc.getProperties().get(&quot;includeCARoles&quot;), null));</span>
<span class="nc" id="L224">    includeUIRoles = BooleanUtils.toBoolean(Objects.toString(cc.getProperties().get(&quot;includeUIRoles&quot;), null));</span>

<span class="nc" id="L226">    episodeIdRole = BooleanUtils.toBoolean(Objects.toString(</span>
<span class="nc" id="L227">        cc.getBundleContext().getProperty(CONFIG_EPISODE_ID_ROLE), &quot;false&quot;));</span>
<span class="nc" id="L228">    logger.debug(&quot;Usage of episode ID roles is set to {}&quot;, episodeIdRole);</span>
<span class="nc" id="L229">  }</span>

  /**
   * OSGi dependencies
   */

  @Reference(target = &quot;(osgi.unit.name=org.opencastproject.assetmanager.impl)&quot;)
  public void setEntityManagerFactory(EntityManagerFactory emf) {
<span class="nc" id="L237">    this.emf = emf;</span>
<span class="nc" id="L238">  }</span>

  @Reference
  public void setDBSessionFactory(DBSessionFactory dbSessionFactory) {
<span class="nc" id="L242">    this.dbSessionFactory = dbSessionFactory;</span>
<span class="nc" id="L243">  }</span>

  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L247">    this.securityService = securityService;</span>
<span class="fc" id="L248">  }</span>

  @Reference
  public void setAuthorizationService(AuthorizationService authorizationService) {
<span class="fc" id="L252">    this.authorizationService = authorizationService;</span>
<span class="fc" id="L253">  }</span>

  @Reference
  public void setOrgDir(OrganizationDirectoryService orgDir) {
<span class="nc" id="L257">    this.orgDir = orgDir;</span>
<span class="nc" id="L258">  }</span>

  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="fc" id="L262">    this.workspace = workspace;</span>
<span class="fc" id="L263">  }</span>

  @Reference
  public void setAssetStore(AssetStore assetStore) {
<span class="fc" id="L267">    this.assetStore = assetStore;</span>
<span class="fc" id="L268">  }</span>

  @Reference(
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeEventHandler&quot;
  )
  public void addEventHandler(AssetManagerUpdateHandler handler) {
<span class="fc" id="L276">    this.handlers.add(handler);</span>
<span class="fc" id="L277">  }</span>

  public void removeEventHandler(AssetManagerUpdateHandler handler) {
<span class="nc" id="L280">    this.handlers.remove(handler);</span>
<span class="nc" id="L281">  }</span>

  @Reference(
      cardinality = ReferenceCardinality.MULTIPLE,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;removeRemoteAssetStore&quot;
  )
  public synchronized void addRemoteAssetStore(RemoteAssetStore assetStore) {
<span class="fc" id="L289">    remoteStores.put(assetStore.getStoreType(), assetStore);</span>
<span class="fc" id="L290">  }</span>

  public void removeRemoteAssetStore(RemoteAssetStore store) {
<span class="nc" id="L293">    remoteStores.remove(store.getStoreType());</span>
<span class="nc" id="L294">  }</span>

  @Reference
  public void setHttpAssetProvider(HttpAssetProvider httpAssetProvider) {
<span class="fc" id="L298">    this.httpAssetProvider = httpAssetProvider;</span>
<span class="fc" id="L299">  }</span>

  @Reference
  public void setAclServiceFactory(AclServiceFactory aclServiceFactory) {
<span class="nc" id="L303">    this.aclServiceFactory = aclServiceFactory;</span>
<span class="nc" id="L304">  }</span>

  @Reference
  public void setIndex(ElasticsearchIndex index) {
<span class="fc" id="L308">    this.index = index;</span>
<span class="fc" id="L309">  }</span>

  @Reference(cardinality = ReferenceCardinality.MULTIPLE, policy = ReferencePolicy.DYNAMIC,
          target = &quot;(common-metadata=false)&quot;)
  public synchronized void addCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="nc" id="L314">    List&lt;EventCatalogUIAdapter&gt; list = extendedEventCatalogUIAdapters.computeIfAbsent(</span>
<span class="nc" id="L315">            catalogUIAdapter.getOrganization(), k -&gt; new ArrayList());</span>
<span class="nc" id="L316">    list.add(catalogUIAdapter);</span>
<span class="nc" id="L317">  }</span>

  public synchronized void removeCatalogUIAdapter(EventCatalogUIAdapter catalogUIAdapter) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">    if (extendedEventCatalogUIAdapters.containsKey(catalogUIAdapter.getOrganization())) {</span>
<span class="nc" id="L321">      extendedEventCatalogUIAdapters.get(catalogUIAdapter.getOrganization()).remove(catalogUIAdapter);</span>
    }
<span class="nc" id="L323">  }</span>

  /**
   * AssetManager implementation
   */

  @Override
  public Optional&lt;MediaPackage&gt; getMediaPackage(String mediaPackageId) {
<span class="nc" id="L331">    final AQueryBuilder q = createQuery();</span>
<span class="nc" id="L332">    final AResult r = q.select(q.snapshot()).where(q.mediaPackageId(mediaPackageId).and(q.version().isLatest()))</span>
<span class="nc" id="L333">            .run();</span>

<span class="nc bnc" id="L335" title="All 2 branches missed.">    if (r.getSize() == 0) {</span>
<span class="nc" id="L336">      return Optional.empty();</span>
    }
<span class="nc" id="L338">    return Optional.of(r.getRecords().stream().findFirst().get().getSnapshot().get().getMediaPackage());</span>
  }

  @Override
  public Optional&lt;Asset&gt; getAsset(Version version, String mpId, String mpElementId) {
<span class="fc bfc" id="L343" title="All 2 branches covered.">    if (isAuthorized(mpId, READ_ACTION)) {</span>
      // try to fetch the asset
<span class="fc" id="L345">      var asset = getDatabase().getAsset(RuntimeTypes.convert(version), mpId, mpElementId);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">      if (asset.isPresent()) {</span>
<span class="fc" id="L347">        var storageId = getSnapshotStorageLocation(version, mpId);</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">        if (storageId.isPresent()) {</span>
<span class="fc" id="L349">          var store = getAssetStore(storageId.get());</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">          if (store.isPresent()) {</span>
<span class="fc" id="L351">            var assetStream = store.get().get(StoragePath.mk(</span>
<span class="fc" id="L352">                asset.get().getOrganizationId(),</span>
                mpId,
                version,
                mpElementId
            ));
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">            if (assetStream.isPresent()) {</span>

<span class="fc" id="L359">              Checksum checksum = null;</span>
              try {
<span class="fc" id="L361">                checksum = Checksum.fromString(asset.get().getAssetDto().getChecksum());</span>
<span class="nc" id="L362">              } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L363">                logger.warn(&quot;Invalid checksum for asset {} of media package {}&quot;, mpElementId, mpId, e);</span>
<span class="fc" id="L364">              }</span>

<span class="fc" id="L366">              final Asset a = new AssetImpl(</span>
<span class="fc" id="L367">                      AssetId.mk(version, mpId, mpElementId),</span>
<span class="fc" id="L368">                      assetStream.get(),</span>
<span class="fc" id="L369">                      asset.get().getAssetDto().getMimeType(),</span>
<span class="fc" id="L370">                      asset.get().getAssetDto().getSize(),</span>
<span class="fc" id="L371">                      asset.get().getStorageId(),</span>
<span class="fc" id="L372">                      asset.get().getAvailability(),</span>
                      checksum);
<span class="fc" id="L374">              return Optional.of(a);</span>
            }
          }
        }
      }
<span class="fc" id="L379">      return Optional.empty();</span>
    }
<span class="pc" id="L381">    return chuck(new UnauthorizedException(</span>
<span class="fc" id="L382">            format(&quot;Not allowed to read assets of snapshot %s, version=%s&quot;, mpId, version)</span>
    ));
  }

  @Override
  public Optional&lt;AssetStore&gt; getAssetStore(String storeId) {
<span class="fc bfc" id="L388" title="All 2 branches covered.">    if (assetStore.getStoreType().equals(storeId)) {</span>
<span class="fc" id="L389">      return Optional.of(assetStore);</span>
    } else {
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">      if (remoteStores.containsKey(storeId)) {</span>
<span class="fc" id="L392">        return Optional.of(remoteStores.get(storeId));</span>
      } else {
<span class="nc" id="L394">        return Optional.empty();</span>
      }
    }
  }

  @Override
  public AssetStore getLocalAssetStore() {
<span class="fc" id="L401">    return assetStore;</span>
  }

  @Override
  public List&lt;AssetStore&gt; getRemoteAssetStores() {
<span class="fc" id="L406">    return new ArrayList&lt;&gt;(remoteStores.values());</span>
  }

  /** Snapshots */

  @Override
  public boolean snapshotExists(final String mediaPackageId) {
<span class="fc" id="L413">    return getDatabase().snapshotExists(mediaPackageId);</span>
  }

  @Override
  public boolean snapshotExists(final String mediaPackageId, final String organization) {
<span class="fc" id="L418">    return getDatabase().snapshotExists(mediaPackageId, organization);</span>
  }

  @Override
  public Snapshot takeSnapshot(MediaPackage mp) {
<span class="nc" id="L423">    return takeSnapshot(null, mp);</span>
  }

  @Override
  public Snapshot takeSnapshot(String owner, MediaPackage mp) {

<span class="fc" id="L429">    final String mediaPackageId = mp.getIdentifier().toString();</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">    final boolean firstSnapshot = !snapshotExists(mediaPackageId);</span>

    // Allow this if:
    //  - no previous snapshot exists
    //  - the user has write access to the previous snapshot
<span class="fc bfc" id="L435" title="All 2 branches covered.">    if (firstSnapshot) {</span>
      // if it's the first snapshot, ensure that old, leftover properties are removed
<span class="fc" id="L437">      deleteProperties(mediaPackageId);</span>
    }
<span class="pc bpc" id="L439" title="1 of 4 branches missed.">    if (firstSnapshot || isAuthorized(mediaPackageId, WRITE_ACTION)) {</span>
      final Snapshot snapshot;
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">      if (owner == null) {</span>
<span class="nc" id="L442">        snapshot = takeSnapshotInternal(mp);</span>
      } else {
<span class="fc" id="L444">        snapshot = takeSnapshotInternal(owner, mp);</span>
      }

<span class="fc" id="L447">      final AccessControlList acl = authorizationService.getActiveAcl(mp).getA();</span>
      // store acl as properties
      // Drop old ACL rules
<span class="fc" id="L450">      deleteProperties(mediaPackageId, SECURITY_NAMESPACE);</span>
      // Set new ACL rules
<span class="fc bfc" id="L452" title="All 2 branches covered.">      for (final AccessControlEntry ace : acl.getEntries()) {</span>
<span class="fc" id="L453">        getDatabase().saveProperty(Property.mk(PropertyId.mk(mediaPackageId, SECURITY_NAMESPACE,</span>
<span class="fc" id="L454">                mkPropertyName(ace.getRole(), ace.getAction())), Value.mk(ace.isAllow())));</span>
<span class="fc" id="L455">      }</span>

<span class="fc" id="L457">      updateEventInIndex(snapshot);</span>

<span class="fc" id="L459">      logger.info(&quot;Trigger update handlers for snapshot {}, version {}&quot;,</span>
<span class="fc" id="L460">          snapshot.getMediaPackage().getIdentifier(), snapshot.getVersion());</span>
<span class="fc" id="L461">      fireEventHandlers(mkTakeSnapshotMessage(snapshot));</span>

<span class="fc" id="L463">      return snapshot;</span>
    }
<span class="nc" id="L465">    return chuck(new UnauthorizedException(&quot;Not allowed to take snapshot of media package &quot; + mediaPackageId));</span>
  }

  private Snapshot takeSnapshotInternal(MediaPackage mediaPackage) {
<span class="nc" id="L469">    final String mediaPackageId = mediaPackage.getIdentifier().toString();</span>
<span class="nc" id="L470">    AQueryBuilder queryBuilder = createQuery();</span>
<span class="nc" id="L471">    AResult result = queryBuilder.select(queryBuilder.snapshot())</span>
<span class="nc" id="L472">            .where(queryBuilder.mediaPackageId(mediaPackageId).and(queryBuilder.version().isLatest())).run();</span>
<span class="nc" id="L473">    Optional&lt;ARecord&gt; record = result.getRecords().stream().findFirst();</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">    if (record.isPresent()) {</span>
<span class="nc" id="L475">      Optional&lt;Snapshot&gt; snapshot = Optional.of(record.get().getSnapshot().get());</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">      if (snapshot.isPresent()) {</span>
<span class="nc" id="L477">        return takeSnapshotInternal(snapshot.get().getOwner(), mediaPackage);</span>
      }
    }
<span class="nc" id="L480">    return takeSnapshotInternal(DEFAULT_OWNER, mediaPackage);</span>
  }

  private Snapshot takeSnapshotInternal(final String owner, final MediaPackage mp) {
<span class="fc" id="L484">    return handleException(new P1Lazy&lt;Snapshot&gt;() {</span>
      @Override public Snapshot get1() {
        try {
<span class="fc" id="L487">          final Snapshot archived = addInternal(owner, MediaPackageSupport.copy(mp)).toSnapshot();</span>
<span class="fc" id="L488">          return getHttpAssetProvider().prepareForDelivery(archived);</span>
<span class="nc" id="L489">        } catch (Exception e) {</span>
<span class="nc" id="L490">          return Prelude.chuck(e);</span>
        }
      }
    });
  }

  /**
   * Create a {@link AssetManagerItem.TakeSnapshot} message.
   * &lt;p&gt;
   * Do not call outside of a security context.
   */
  private AssetManagerItem.TakeSnapshot mkTakeSnapshotMessage(Snapshot snapshot) {
<span class="fc" id="L502">    final MediaPackage mp = snapshot.getMediaPackage();</span>

    long version;
    try {
<span class="fc" id="L506">      version = Long.parseLong(snapshot.getVersion().toString());</span>
<span class="nc" id="L507">    } catch (NumberFormatException e) {</span>
      // The index requires a version to be a long value.
      // Since the asset manager default implementation uses long values that should be not a problem.
      // However, a decent exception message is helpful if a different implementation of the asset manager
      // is used.
<span class="nc" id="L512">      throw new RuntimeException(&quot;The current implementation of the index requires versions being of type 'long'.&quot;);</span>
<span class="fc" id="L513">    }</span>

<span class="fc" id="L515">    return AssetManagerItem.add(workspace, mp, authorizationService.getActiveAcl(mp).getA(),</span>
<span class="fc" id="L516">            version, snapshot.getArchivalDate());</span>
  }

  @Override
  public void triggerIndexUpdate(String mediaPackageId) throws NotFoundException, UnauthorizedException {

<span class="nc bnc" id="L522" title="All 2 branches missed.">    if (!securityService.getUser().hasRole(&quot;ROLE_ADMIN&quot;)) {</span>
<span class="nc" id="L523">      throw new UnauthorizedException(&quot;Only global administrators may trigger manual event updates.&quot;);</span>
    }
<span class="nc" id="L525">    final AQueryBuilder q = createQuery();</span>
<span class="nc" id="L526">    final AResult r = q.select(q.snapshot()).where(q.mediaPackageId(mediaPackageId).and(q.version().isLatest())).run();</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">    if (r.getSize() == 0) {</span>
<span class="nc" id="L529">      throw new NotFoundException(&quot;No event with ID `&quot; + mediaPackageId + &quot;`&quot;);</span>
    }

    // Update event index with latest snapshot
<span class="nc" id="L533">    var snapshot = r.getRecords().stream().findFirst().get().getSnapshot().get();</span>
<span class="nc" id="L534">    updateEventInIndex(snapshot);</span>
<span class="nc" id="L535">  }</span>

  /**
   * Update the event in the Elasticsearch index.
   *
   * @param snapshot
   *         The newest snapshot of the event to update
   */
  private void updateEventInIndex(Snapshot snapshot) {
<span class="fc" id="L544">    final MediaPackage mp = snapshot.getMediaPackage();</span>
<span class="fc" id="L545">    String eventId = mp.getIdentifier().toString();</span>
<span class="fc" id="L546">    final String organization = securityService.getOrganization().getId();</span>
<span class="fc" id="L547">    final User user = securityService.getUser();</span>
<span class="fc" id="L548">    logger.debug(&quot;Updating event {} in the {} index.&quot;, eventId, index.getIndexName());</span>

<span class="fc" id="L550">    Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; updateFunction = (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
<span class="nc" id="L551">      Event event = eventOpt.orElse(new Event(eventId, organization));</span>

<span class="nc" id="L553">      AccessControlList acl = authorizationService.getActiveAcl(mp).getA();</span>
<span class="nc" id="L554">      List&lt;ManagedAcl&gt; acls = aclServiceFactory.serviceFor(securityService.getOrganization()).getAcls();</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">      for (final ManagedAcl managedAcl : AccessInformationUtil.matchAcls(acls, acl)) {</span>
<span class="nc" id="L556">        event.setManagedAcl(managedAcl.getName());</span>
<span class="nc" id="L557">      }</span>
<span class="nc" id="L558">      event.setAccessPolicy(AccessControlParser.toJsonSilent(acl));</span>
<span class="nc" id="L559">      event.setArchiveVersion(Long.parseLong(snapshot.getVersion().toString()));</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">      if (StringUtils.isBlank(event.getCreator())) {</span>
<span class="nc" id="L561">        event.setCreator(securityService.getUser().getName());</span>
      }
<span class="nc" id="L563">      EventIndexUtils.updateEvent(event, mp);</span>

      // common metadata
<span class="nc bnc" id="L566" title="All 2 branches missed.">      for (Catalog catalog: mp.getCatalogs(MediaPackageElements.EPISODE)) {</span>
<span class="nc" id="L567">        try (InputStream in = workspace.read(catalog.getURI())) {</span>
<span class="nc" id="L568">          EventIndexUtils.updateEvent(event, DublinCores.read(in));</span>
<span class="nc" id="L569">        } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L570">          throw new IllegalStateException(String.format(&quot;Unable to load common dublin core catalog for event '%s'&quot;,</span>
<span class="nc" id="L571">                  mp.getIdentifier()), e);</span>
<span class="nc" id="L572">        }</span>
      }

      // extended metadata
<span class="nc" id="L576">      event.resetExtendedMetadata();  // getting rid of old data</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">      for (EventCatalogUIAdapter extendedCatalogUIAdapter : extendedEventCatalogUIAdapters.getOrDefault(organization,</span>
<span class="nc" id="L578">              Collections.emptyList())) {</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">        for (Catalog catalog: mp.getCatalogs(extendedCatalogUIAdapter.getFlavor())) {</span>
<span class="nc" id="L580">          try (InputStream in = workspace.read(catalog.getURI())) {</span>
<span class="nc" id="L581">            EventIndexUtils.updateEventExtendedMetadata(event, DublinCores.read(in),</span>
<span class="nc" id="L582">                    extendedCatalogUIAdapter.getFlavor());</span>
<span class="nc" id="L583">          } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L584">            throw new IllegalStateException(String.format(&quot;Unable to load extended dublin core catalog '%s' for event &quot;</span>
<span class="nc" id="L585">                            + &quot;'%s'&quot;, catalog.getFlavor(), mp.getIdentifier()), e);</span>
<span class="nc" id="L586">          }</span>
        }
<span class="nc" id="L588">      }</span>

      // Update series name if not already done
      try {
<span class="nc" id="L592">        EventIndexUtils.updateSeriesName(event, organization, user, index);</span>
<span class="nc" id="L593">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L594">        logger.error(&quot;Error updating the series name of the event {} in the {} index.&quot;, eventId, index.getIndexName(),</span>
                e);
<span class="nc" id="L596">      }</span>
<span class="nc" id="L597">      return Optional.of(event);</span>
    };

    // Persist the scheduling event
    try {
<span class="fc" id="L602">      index.addOrUpdateEvent(eventId, updateFunction, organization, user);</span>
<span class="fc" id="L603">      logger.debug(&quot;Event {} updated in the {} index.&quot;, eventId, index.getIndexName());</span>
<span class="nc" id="L604">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L605">      logger.error(&quot;Error updating the event {} in the {} index.&quot;, eventId, index.getIndexName(), e);</span>
<span class="fc" id="L606">    }</span>
<span class="fc" id="L607">  }</span>

  /**
   * Remove the event from the Elasticsearch index
   *
   * @param eventId
   *         The id of the event to remove
   */
  private void removeArchivedVersionFromIndex(String eventId) {
<span class="fc" id="L616">    final String orgId = securityService.getOrganization().getId();</span>
<span class="fc" id="L617">    final User user = securityService.getUser();</span>
<span class="fc" id="L618">    logger.debug(&quot;Received AssetManager delete episode message {}&quot;, eventId);</span>

<span class="fc" id="L620">    Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; updateFunction = (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">      if (eventOpt.isEmpty()) {</span>
<span class="nc" id="L622">        logger.warn(&quot;Event {} not found for deletion&quot;, eventId);</span>
<span class="nc" id="L623">        return Optional.empty();</span>
      }
<span class="nc" id="L625">      Event event = eventOpt.get();</span>
<span class="nc" id="L626">      event.setArchiveVersion(null);</span>
<span class="nc" id="L627">      return Optional.of(event);</span>
    };

    try {
<span class="fc" id="L631">      index.addOrUpdateEvent(eventId, updateFunction, orgId, user);</span>
<span class="fc" id="L632">      logger.debug(&quot;Event {} removed from the {} index&quot;, eventId, index.getIndexName());</span>
<span class="nc" id="L633">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L634">      logger.error(&quot;Error deleting the event {} from the {} index.&quot;, eventId, index.getIndexName(), e);</span>
<span class="fc" id="L635">    }</span>
<span class="fc" id="L636">  }</span>

  @Override
  public RichAResult getSnapshotsById(final String mpId) {
<span class="nc" id="L640">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>
<span class="nc" id="L641">    AQueryBuilder q = createQuery();</span>
<span class="nc" id="L642">    ASelectQuery query = baseQuery(q, mpId);</span>
<span class="nc" id="L643">    return Enrichments.enrich(query.run());</span>
  }

  @Override
  public RichAResult getSnapshotsByIdOrderedByVersion(String mpId, boolean asc) {
<span class="fc" id="L648">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L649">    AQueryBuilder q = createQuery();</span>
<span class="fc" id="L650">    ASelectQuery query = baseQuery(q, mpId);</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">    if (asc) {</span>
<span class="fc" id="L652">      query = query.orderBy(q.version().asc());</span>
    } else {
<span class="nc" id="L654">      query = query.orderBy(q.version().desc());</span>
    }
<span class="fc" id="L656">    return Enrichments.enrich(query.run());</span>
  }

  @Override
  public RichAResult getSnapshotsByIdAndVersion(final String mpId, final Version version) {
<span class="fc" id="L661">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L662">    RequireUtil.notNull(version, &quot;version&quot;);</span>
<span class="fc" id="L663">    AQueryBuilder q = createQuery();</span>
<span class="fc" id="L664">    ASelectQuery query = baseQuery(q, version, mpId);</span>
<span class="fc" id="L665">    return Enrichments.enrich(query.run());</span>
  }

  @Override
  public RichAResult getSnapshotsByDate(final Date start, final Date end) {
<span class="nc" id="L670">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="nc" id="L671">    RequireUtil.notNull(end, &quot;end&quot;);</span>
<span class="nc" id="L672">    AQueryBuilder q = createQuery();</span>
<span class="nc" id="L673">    ASelectQuery query = baseQuery(q).where(q.archived().ge(start)).where(q.archived().le(end));</span>
<span class="nc" id="L674">    return Enrichments.enrich(query.run());</span>
  }

  @Override
  public RichAResult getSnapshotsByDateOrderedById(Date start, Date end) {
<span class="fc" id="L679">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="fc" id="L680">    RequireUtil.notNull(end, &quot;end&quot;);</span>
<span class="fc" id="L681">    AQueryBuilder q = createQuery();</span>
<span class="fc" id="L682">    ASelectQuery query = baseQuery(q).where(q.archived().ge(start)).where(q.archived().le(end));</span>
<span class="fc" id="L683">    return Enrichments.enrich(query.orderBy(q.mediapackageId().asc()).run());</span>
  }

  @Override
  public RichAResult getSnapshotsByIdAndDate(final String mpId, final Date start, final Date end) {
<span class="nc" id="L688">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>
<span class="nc" id="L689">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="nc" id="L690">    RequireUtil.notNull(end, &quot;end&quot;);</span>
<span class="nc" id="L691">    AQueryBuilder q = createQuery();</span>
<span class="nc" id="L692">    ASelectQuery query = baseQuery(q, mpId).where(q.archived().ge(start)).where(q.archived().le(end));</span>
<span class="nc" id="L693">    return Enrichments.enrich(query.run());</span>
  }

  @Override
  public RichAResult getSnapshotsByIdAndDateOrderedByVersion(String mpId, Date start, Date end, boolean asc) {
<span class="fc" id="L698">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L699">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="fc" id="L700">    RequireUtil.notNull(end, &quot;end&quot;);</span>
<span class="fc" id="L701">    AQueryBuilder q = createQuery();</span>
<span class="fc" id="L702">    ASelectQuery query = baseQuery(q, mpId).where(q.archived().ge(start)).where(q.archived().le(end));</span>
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">    if (asc) {</span>
<span class="fc" id="L704">      query = query.orderBy(q.version().asc());</span>
    } else {
<span class="nc" id="L706">      query = query.orderBy(q.version().desc());</span>
    }
<span class="fc" id="L708">    return Enrichments.enrich(query.run());</span>
  }

  @Override
  public void moveSnapshotsById(final String mpId, final String targetStore) throws NotFoundException {
<span class="nc" id="L713">    RichAResult results = getSnapshotsById(mpId);</span>

<span class="nc bnc" id="L715" title="All 2 branches missed.">    if (results.getRecords().isEmpty()) {</span>
<span class="nc" id="L716">      throw new NotFoundException(&quot;Mediapackage &quot; + mpId + &quot; not found!&quot;);</span>
    }

<span class="nc" id="L719">    processOperations(results, targetStore);</span>
<span class="nc" id="L720">  }</span>

  @Override
  public void moveSnapshotsByIdAndVersion(final String mpId, final Version version, final String targetStore)
          throws NotFoundException {
<span class="nc" id="L725">    RichAResult results = getSnapshotsByIdAndVersion(mpId, version);</span>

<span class="nc bnc" id="L727" title="All 2 branches missed.">    if (results.getRecords().isEmpty()) {</span>
<span class="nc" id="L728">      throw new NotFoundException(&quot;Mediapackage &quot; + mpId + &quot;@&quot; + version.toString() + &quot; not found!&quot;);</span>
    }

<span class="nc" id="L731">    processOperations(results, targetStore);</span>
<span class="nc" id="L732">  }</span>

  @Override
  public void moveSnapshotsByDate(final Date start, final Date end, final String targetStore)
          throws NotFoundException {
    // We don't use #getSnapshotsByDate() as this includes also all snapshots already in targetStore. On large installs
    // this could lead to memory overflow.
<span class="nc" id="L739">    AQueryBuilder q = createQuery();</span>
<span class="nc" id="L740">    ASelectQuery query = baseQuery(q)</span>
<span class="nc" id="L741">        .where(q.storage(targetStore).not())</span>
<span class="nc" id="L742">        .where(q.archived().ge(start))</span>
<span class="nc" id="L743">        .where(q.archived().le(end));</span>
<span class="nc" id="L744">    RichAResult results = Enrichments.enrich(query.run());</span>

<span class="nc bnc" id="L746" title="All 2 branches missed.">    if (results.getRecords().isEmpty()) {</span>
<span class="nc" id="L747">      throw new NotFoundException(&quot;No media packages found between &quot; + start + &quot; and &quot; + end);</span>
    }

<span class="nc" id="L750">    processOperations(results, targetStore);</span>
<span class="nc" id="L751">  }</span>

  @Override
  public void moveSnapshotsByIdAndDate(final String mpId, final Date start, final Date end, final String targetStore)
          throws NotFoundException {
<span class="nc" id="L756">    RichAResult results = getSnapshotsByIdAndDate(mpId, start, end);</span>

<span class="nc bnc" id="L758" title="All 2 branches missed.">    if (results.getRecords().isEmpty()) {</span>
<span class="nc" id="L759">      throw new NotFoundException(&quot;No media package with id &quot; + mpId + &quot; found between &quot; + start + &quot; and &quot; + end);</span>
    }

<span class="nc" id="L762">    processOperations(results, targetStore);</span>
<span class="nc" id="L763">  }</span>

  @Override
  public void moveSnapshotToStore(final Version version, final String mpId, final String storeId)
          throws NotFoundException {

    //Find the snapshot
<span class="fc" id="L770">    AQueryBuilder q = createQuery();</span>
<span class="fc" id="L771">    RichAResult results = Enrichments.enrich(baseQuery(q, version, mpId).run());</span>

<span class="fc bfc" id="L773" title="All 2 branches covered.">    if (results.getRecords().isEmpty()) {</span>
<span class="fc" id="L774">      throw new NotFoundException(&quot;Mediapackage &quot; + mpId + &quot;@&quot; + version.toString() + &quot; not found!&quot;);</span>
    }
<span class="fc" id="L776">    processOperations(results, storeId);</span>
<span class="fc" id="L777">  }</span>

  //Do the actual moving
  private void processOperations(final RichAResult results, final String targetStoreId) {
<span class="fc" id="L781">    results.getRecords().forEach(record -&gt; {</span>
<span class="fc" id="L782">      Snapshot s = record.getSnapshot().get();</span>
<span class="fc" id="L783">      Optional&lt;String&gt; currentStoreId = getSnapshotStorageLocation(s);</span>

<span class="pc bpc" id="L785" title="1 of 2 branches missed.">      if (currentStoreId.isEmpty()) {</span>
<span class="nc" id="L786">        logger.warn(&quot;IsNone store ID&quot;);</span>
<span class="nc" id="L787">        return;</span>
      }

      //If this snapshot is already stored in the desired store
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">      if (currentStoreId.get().equals(targetStoreId)) {</span>
        //return, since we don't need to move anything
<span class="nc" id="L793">        return;</span>
      }

      AssetStore currentStore;
      AssetStore targetStore;

<span class="fc" id="L799">      Optional&lt;AssetStore&gt; optCurrentStore = getAssetStore(currentStoreId.get());</span>
<span class="fc" id="L800">      Optional&lt;AssetStore&gt; optTargetStore = getAssetStore(targetStoreId);</span>

<span class="pc bpc" id="L802" title="1 of 2 branches missed.">      if (!optCurrentStore.isEmpty()) {</span>
<span class="fc" id="L803">        currentStore = optCurrentStore.get();</span>
      } else {
<span class="nc" id="L805">        logger.error(&quot;Unknown current store: &quot; + currentStoreId.get());</span>
<span class="nc" id="L806">        return;</span>
      }
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">      if (!optTargetStore.isEmpty()) {</span>
<span class="fc" id="L809">        targetStore = optTargetStore.get();</span>
      } else {
<span class="nc" id="L811">        logger.error(&quot;Unknown target store: &quot; + targetStoreId);</span>
<span class="nc" id="L812">        return;</span>
      }

      //If the content is already local, or is moving from a remote to the local
      // Returns true if the store id is equal to the local asset store's id
<span class="fc" id="L817">      String localAssetStoreType = getLocalAssetStore().getStoreType();</span>
<span class="pc bpc" id="L818" title="3 of 4 branches missed.">      if (localAssetStoreType.equals(currentStoreId.get()) || localAssetStoreType.equals(targetStoreId)) {</span>
<span class="fc" id="L819">        logger.debug(&quot;Moving {} from {} to {}&quot;, s, currentStoreId, targetStoreId);</span>

        try {
<span class="fc" id="L822">          copyAssetsToStore(s, targetStore);</span>
<span class="fc" id="L823">          copyManifest(s, targetStore);</span>
<span class="nc" id="L824">        } catch (Exception e) {</span>
<span class="nc" id="L825">          Functions.chuck(e);</span>
<span class="fc" id="L826">        }</span>
<span class="fc" id="L827">        getDatabase().setStorageLocation(s, targetStoreId);</span>
<span class="fc" id="L828">        currentStore.delete(DeletionSelector.delete(s.getOrganizationId(),</span>
<span class="fc" id="L829">                s.getMediaPackage().getIdentifier().toString(), s.getVersion()</span>
        ));
      } else {
        //Else, the content is *not* local and is going to a *different* remote
<span class="nc" id="L833">        String intermediateStore = getLocalAssetStore().getStoreType();</span>
<span class="nc" id="L834">        logger.debug(&quot;Moving {} from {} to {}, then to {}&quot;,</span>
                s, currentStoreId, intermediateStore, targetStoreId);
<span class="nc" id="L836">        Version version = s.getVersion();</span>
<span class="nc" id="L837">        String mpId = s.getMediaPackage().getIdentifier().toString();</span>
        try {
<span class="nc" id="L839">          moveSnapshotToStore(version, mpId, intermediateStore);</span>
<span class="nc" id="L840">          moveSnapshotToStore(version, mpId, targetStoreId);</span>
<span class="nc" id="L841">        } catch (NotFoundException e) {</span>
<span class="nc" id="L842">          Functions.chuck(e);</span>
<span class="nc" id="L843">        }</span>
      }
<span class="fc" id="L845">    });</span>
<span class="fc" id="L846">  }</span>

  // Return the asset store ID that is currently storing the snapshot
  public Optional&lt;String&gt; getSnapshotStorageLocation(final Version version, final String mpId) {
<span class="fc" id="L850">    RichAResult result = getSnapshotsByIdAndVersion(mpId, version);</span>

<span class="pc bpc" id="L852" title="1 of 2 branches missed.">    for (Snapshot snapshot : result.getSnapshots()) {</span>
<span class="fc" id="L853">      return Optional.of(snapshot.getStorageId());</span>
    }

<span class="nc" id="L856">    logger.error(&quot;Mediapackage &quot; + mpId + &quot;@&quot; + version + &quot; not found!&quot;);</span>
<span class="nc" id="L857">    return Optional.empty();</span>
  }

  public Optional&lt;String&gt; getSnapshotStorageLocation(final Snapshot snap) {
<span class="fc" id="L861">    return getSnapshotStorageLocation(snap.getVersion(), snap.getMediaPackage().getIdentifier().toString());</span>
  }

  /** Properties */

  @Override
  public boolean setProperty(Property property) {
<span class="fc" id="L868">    final String mpId = property.getId().getMediaPackageId();</span>
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">    if (isAuthorized(mpId, WRITE_ACTION)) {</span>
<span class="fc" id="L870">      return getDatabase().saveProperty(property);</span>
    }
<span class="nc" id="L872">    return chuck(new UnauthorizedException(&quot;Not allowed to set property on episode &quot; + mpId));</span>
  }

  @Override
  public List&lt;Property&gt; selectProperties(final String mediaPackageId, String namespace) {
<span class="nc bnc" id="L877" title="All 2 branches missed.">    if (isAuthorized(mediaPackageId, READ_ACTION)) {</span>
<span class="nc" id="L878">      return getDatabase().selectProperties(mediaPackageId, namespace);</span>
    }
<span class="nc" id="L880">    return chuck(new UnauthorizedException(format(&quot;Not allowed to read properties of event %s&quot;, mediaPackageId)));</span>
  }

  @Override
  public int deleteProperties(final String mediaPackageId) {
<span class="fc" id="L885">    return getDatabase().deleteProperties(mediaPackageId);</span>
  }

  @Override
  public int deleteProperties(final String mediaPackageId, final String namespace) {
<span class="fc" id="L890">    return getDatabase().deleteProperties(mediaPackageId, namespace);</span>
  }

  /** Misc. */

  @Override
  public AQueryBuilder createQuery() {
<span class="fc" id="L897">    return new AQueryBuilderDecorator(createQueryWithoutSecurityCheck()) {</span>
      @Override public ASelectQuery select(Target... target) {
<span class="fc bfc" id="L899" title="All 3 branches covered.">        switch (isAdmin()) {</span>
          case GLOBAL:
<span class="fc" id="L901">            return super.select(target);</span>
          case ORGANIZATION:
<span class="fc" id="L903">            return super.select(target).where(restrictToUsersOrganization());</span>
          default:
<span class="fc" id="L905">            return super.select(target).where(mkAuthPredicate(READ_ACTION));</span>
        }
      }

      @Override public ADeleteQuery delete(String owner, Target target) {
<span class="fc bfc" id="L910" title="All 3 branches covered.">        switch (isAdmin()) {</span>
          case GLOBAL:
<span class="fc" id="L912">            return super.delete(owner, target);</span>
          case ORGANIZATION:
<span class="fc" id="L914">            return super.delete(owner, target).where(restrictToUsersOrganization());</span>
          default:
<span class="fc" id="L916">            return super.delete(owner, target).where(mkAuthPredicate(WRITE_ACTION));</span>
        }
      }
    };
  }

  private AQueryBuilder createQueryWithoutSecurityCheck() {
<span class="fc" id="L923">    return new AQueryBuilderDecorator(new AQueryBuilderImpl(this)) {</span>
      @Override
      public ADeleteQuery delete(String owner, Target target) {
<span class="fc" id="L926">        return new ADeleteQueryWithMessaging(super.delete(owner, target));</span>
      }
    };
  }

  @Override
  public Optional&lt;Version&gt; toVersion(String version) {
    try {
<span class="fc" id="L934">      return Optional.of(VersionImpl.mk(Long.parseLong(version)));</span>
<span class="nc" id="L935">    } catch (NumberFormatException e) {</span>
<span class="nc" id="L936">      return Optional.empty();</span>
    }
  }

  @Override
  public long countEvents(final String organization) {
<span class="nc" id="L942">    return getDatabase().countEvents(organization);</span>
  }

  @Override
  public void handleDeletedEpisode(String mpId) {
<span class="fc" id="L947">    logger.info(&quot;Firing event handlers for deleting event {}&quot;, mpId);</span>
<span class="fc" id="L948">    fireEventHandlers(AssetManagerItem.deleteEpisode(mpId, new Date()));</span>

<span class="fc" id="L950">    removeArchivedVersionFromIndex(mpId);</span>
<span class="fc" id="L951">  }</span>

  /**
   * AbstractIndexProducer Implementation
   */

  @Override
  public IndexRebuildService.Service getService() {
<span class="nc" id="L959">    return IndexRebuildService.Service.AssetManager;</span>
  }

  @Override
  public DataType[] getSupportedDataTypes() {
<span class="nc" id="L964">    return new DataType[]{ DataType.ALL, DataType.ACL };</span>
  }

  @Override
  public void repopulate(DataType dataType) throws IndexRebuildException {
<span class="nc" id="L969">    final Organization originalOrg = securityService.getOrganization();</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">    final User originalUser = (originalOrg != null ? securityService.getUser() : null);</span>
    try {
<span class="nc" id="L972">      final Organization defaultOrg = new DefaultOrganization();</span>
<span class="nc" id="L973">      final User defaultSystemUser = SecurityUtil.createSystemUser(systemUserName, defaultOrg);</span>
<span class="nc" id="L974">      securityService.setOrganization(defaultOrg);</span>
<span class="nc" id="L975">      securityService.setUser(defaultSystemUser);</span>

<span class="nc" id="L977">      int offset = 0;</span>
<span class="nc" id="L978">      int total = (int) countEvents(null);</span>
<span class="nc" id="L979">      final AQueryBuilder q = createQuery();</span>
      RichAResult r;
<span class="nc" id="L981">      int current = 0;</span>
<span class="nc" id="L982">      logIndexRebuildBegin(logger, total, &quot;snapshot(s)&quot;);</span>
<span class="nc" id="L983">      var updatedEventRange = new ArrayList&lt;Event&gt;();</span>
      do {
<span class="nc" id="L985">        r = enrich(q.select(q.snapshot()).where(q.version().isLatest()).orderBy(q.mediapackageId().desc())</span>
<span class="nc" id="L986">            .page(offset, PAGE_SIZE).run());</span>
<span class="nc" id="L987">        offset += PAGE_SIZE;</span>
<span class="nc" id="L988">        int n = 20;</span>

<span class="nc" id="L990">        final Map&lt;String, List&lt;Snapshot&gt;&gt; byOrg = r.getSnapshots().stream()</span>
<span class="nc" id="L991">            .collect(Collectors.groupingBy(Snapshot::getOrganizationId));</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">        for (String orgId : byOrg.keySet()) {</span>
          final Organization snapshotOrg;
          try {
<span class="nc" id="L995">            snapshotOrg = orgDir.getOrganization(orgId);</span>
<span class="nc" id="L996">            User snapshotSystemUser = SecurityUtil.createSystemUser(systemUserName, snapshotOrg);</span>
<span class="nc" id="L997">            securityService.setOrganization(snapshotOrg);</span>
<span class="nc" id="L998">            securityService.setUser(snapshotSystemUser);</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">            for (Snapshot snapshot : byOrg.get(orgId)) {</span>
              try {
<span class="nc" id="L1001">                current++;</span>

<span class="nc" id="L1003">                var updatedEventData = index.getEvent(snapshot.getMediaPackage().getIdentifier().toString(), orgId,</span>
                    snapshotSystemUser);
<span class="nc bnc" id="L1005" title="All 2 branches missed.">                if (dataType == DataType.ALL) {</span>
                  // Reindex everything (default)
<span class="nc" id="L1007">                  updatedEventData = getEventUpdateFunction(snapshot, orgId, snapshotSystemUser)</span>
<span class="nc" id="L1008">                      .apply(updatedEventData);</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                } else if (dataType == DataType.ACL) {</span>
                  // Only reindex ACLs
<span class="nc" id="L1011">                  updatedEventData = getEventUpdateFunctionOnlyAcl(snapshot, orgId, snapshotSystemUser)</span>
<span class="nc" id="L1012">                      .apply(updatedEventData);</span>
                } else {
<span class="nc" id="L1014">                  throw new IndexRebuildException(dataType + &quot; is not a supported data type. &quot;</span>
<span class="nc" id="L1015">                      + &quot;Accepted values are &quot; + Arrays.toString(getSupportedDataTypes()) + &quot;.&quot;);</span>
                }
<span class="nc" id="L1017">                updatedEventRange.add(updatedEventData.get());</span>

<span class="nc bnc" id="L1019" title="All 4 branches missed.">                if (updatedEventRange.size() &gt;= n || current &gt;= total) {</span>
<span class="nc" id="L1020">                  index.bulkEventUpdate(updatedEventRange);</span>
<span class="nc" id="L1021">                  logIndexRebuildProgress(logger, total, current, n);</span>
<span class="nc" id="L1022">                  updatedEventRange.clear();</span>
                }
<span class="nc" id="L1024">              } catch (Throwable t) {</span>
<span class="nc" id="L1025">                logSkippingElement(logger, &quot;event&quot;, snapshot.getMediaPackage().getIdentifier().toString(),</span>
                    snapshotOrg, t);
<span class="nc" id="L1027">              }</span>
<span class="nc" id="L1028">            }</span>
<span class="nc" id="L1029">          } catch (Throwable t) {</span>
<span class="nc" id="L1030">            logIndexRebuildError(logger, t, originalOrg);</span>
<span class="nc" id="L1031">            throw new IndexRebuildException(getService(), originalOrg, t);</span>
          } finally {
<span class="nc" id="L1033">            securityService.setOrganization(defaultOrg);</span>
<span class="nc" id="L1034">            securityService.setUser(defaultSystemUser);</span>
          }
<span class="nc" id="L1036">        }</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">      } while (offset &lt; total);</span>
    } finally {
<span class="nc" id="L1039">      securityService.setOrganization(originalOrg);</span>
<span class="nc" id="L1040">      securityService.setUser(originalUser);</span>
    }
<span class="nc" id="L1042">  }</span>

  /**
   * Used for testing
   */
  public void setAvailability(Version version, String mpId, Availability availability) {
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">    if (isAuthorized(mpId, WRITE_ACTION)) {</span>
<span class="fc" id="L1049">      getDatabase().setAvailability(RuntimeTypes.convert(version), mpId, availability);</span>
    } else {
<span class="nc" id="L1051">      chuck(new UnauthorizedException(&quot;Not allowed to set availability of episode &quot; + mpId));</span>
    }
<span class="fc" id="L1053">  }</span>

  public void setDatabase(Database database) {
<span class="fc" id="L1056">    this.db = database;</span>
<span class="fc" id="L1057">  }</span>

  public Database getDatabase() {
<span class="fc" id="L1060">    return db;</span>
  }

  public HttpAssetProvider getHttpAssetProvider() {
<span class="fc" id="L1064">    return httpAssetProvider;</span>
  }

  /*
   * Security handling
   */

  /**
   * Create an authorization predicate to be used with {@link #isAuthorized(String, String)},
   * restricting access to the user's organization and the given action.
   *
   * @param action
   *     the action to restrict access to
   */
  private Predicate mkAuthPredicate(final String action) {
<span class="fc" id="L1079">    final AQueryBuilder q = createQueryWithoutSecurityCheck();</span>
<span class="fc" id="L1080">    return securityService.getUser().getRoles().stream()</span>
<span class="fc" id="L1081">            .filter(roleFilter)</span>
<span class="fc" id="L1082">            .map((role) -&gt; {</span>
<span class="pc bpc" id="L1083" title="3 of 4 branches missed.">              if (episodeIdRole &amp;&amp; role.getName().startsWith(EPISODE_ROLE_ID_PREFIX)) {</span>
<span class="nc" id="L1084">                return q.mediapackageId().eq(StringUtils.substringBetween(</span>
<span class="nc" id="L1085">                    role.getName(), EPISODE_ROLE_ID_PREFIX + &quot;_&quot;, &quot;_&quot;));</span>
              } else {
<span class="fc" id="L1087">                return q.property(Value.BOOLEAN, SECURITY_NAMESPACE, mkPropertyName(role.getName(), action)).eq(true);</span>
              }
            })
<span class="fc" id="L1090">            .reduce(Predicate::or)</span>
<span class="pc" id="L1091">            .orElseGet(() -&gt; q.always().not())</span>
<span class="fc" id="L1092">            .and(restrictToUsersOrganization());</span>
  }

  /** Create a predicate that restricts access to the user's organization. */
  private Predicate restrictToUsersOrganization() {
<span class="fc" id="L1097">    return createQueryWithoutSecurityCheck().organizationId().eq(securityService.getUser().getOrganization().getId());</span>
  }

  /** Check authorization based on the given predicate. */
  private boolean isAuthorized(final String mediaPackageId, final String action) {
<span class="pc bpc" id="L1102" title="1 of 3 branches missed.">    switch (isAdmin()) {</span>
      case GLOBAL:
        // grant general access
<span class="fc" id="L1105">        logger.debug(&quot;Access granted since user is global admin&quot;);</span>
<span class="fc" id="L1106">        return true;</span>
      case ORGANIZATION:
        // ensure that the requested assets belong to this organization
<span class="nc" id="L1109">        logger.debug(&quot;User is organization admin. Checking organization. Checking organization ID of asset.&quot;);</span>
<span class="nc" id="L1110">        return snapshotExists(mediaPackageId, securityService.getOrganization().getId());</span>
      default:
        // check organization
<span class="fc" id="L1113">        logger.debug(&quot;Non admin user. Checking organization.&quot;);</span>
<span class="fc" id="L1114">        final String org = securityService.getOrganization().getId();</span>
<span class="pc bpc" id="L1115" title="1 of 2 branches missed.">        if (!snapshotExists(mediaPackageId, org)) {</span>
<span class="nc" id="L1116">          return false;</span>
        }
        // check episode role id
<span class="fc" id="L1119">        User user = securityService.getUser();</span>
<span class="pc bpc" id="L1120" title="3 of 4 branches missed.">        if (episodeIdRole &amp;&amp; user.hasRole(getEpisodeRoleId(mediaPackageId, action))) {</span>
<span class="nc" id="L1121">          return true;</span>
        }
        // check acl rules
<span class="fc" id="L1124">        logger.debug(&quot;Non admin user. Checking ACL rules.&quot;);</span>
<span class="fc" id="L1125">        final List&lt;String&gt; roles = user.getRoles().parallelStream()</span>
<span class="fc" id="L1126">                .filter(roleFilter)</span>
<span class="fc" id="L1127">                .map((role) -&gt; mkPropertyName(role.getName(), action))</span>
<span class="fc" id="L1128">                .collect(Collectors.toList());</span>
<span class="fc" id="L1129">        return getDatabase().selectProperties(mediaPackageId, SECURITY_NAMESPACE).parallelStream()</span>
<span class="fc" id="L1130">                .map(p -&gt; p.getId().getName())</span>
<span class="fc" id="L1131">                .filter(p -&gt; p.endsWith(action))</span>
<span class="fc" id="L1132">                .anyMatch(p -&gt; roles.stream().anyMatch(r -&gt; r.equals(p)));</span>
    }
  }

  private AdminRole isAdmin() {
<span class="fc" id="L1137">    final User user = securityService.getUser();</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">    if (user.hasRole(GLOBAL_ADMIN_ROLE)) {</span>
<span class="fc" id="L1139">      return AdminRole.GLOBAL;</span>
<span class="fc bfc" id="L1140" title="All 2 branches covered.">    } else if (user.hasRole(securityService.getOrganization().getAdminRole())</span>
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">            || user.hasRole(GLOBAL_CAPTURE_AGENT_ROLE)) {</span>
      // In this context, we treat capture agents the same way as organization admins, allowing them access so that
      // they can ingest new media without requiring them to be explicitly specified in the ACLs.
<span class="fc" id="L1144">      return AdminRole.ORGANIZATION;</span>
    } else {
<span class="fc" id="L1146">      return AdminRole.NONE;</span>
    }
  }

  private String mkPropertyName(String role, String action) {
<span class="fc" id="L1151">    return role + &quot; | &quot; + action;</span>
  }

  /**
   * Configurable filter for roles
   */
<span class="fc" id="L1157">  private final java.util.function.Predicate&lt;Role&gt; roleFilter = (role) -&gt; {</span>
<span class="fc" id="L1158">    final String name = role.getName();</span>
<span class="pc bpc" id="L1159" title="3 of 6 branches missed.">    return (includeAPIRoles || !name.startsWith(&quot;ROLE_API_&quot;))</span>
<span class="pc bpc" id="L1160" title="2 of 4 branches missed.">            &amp;&amp; (includeCARoles  || !name.startsWith(&quot;ROLE_CAPTURE_AGENT_&quot;))</span>
<span class="pc bpc" id="L1161" title="1 of 2 branches missed.">            &amp;&amp; (includeUIRoles  || !name.startsWith(&quot;ROLE_UI_&quot;));</span>
  };

  /*
   * Utility
   */

  /**
   * Return a basic query which returns the snapshot and its current storage location
   *
   * @param q
   *   The query builder object to configure
   * @return
   *   The {@link ASelectQuery} configured with as described above
   */
  private ASelectQuery baseQuery(final AQueryBuilder q) {
<span class="fc" id="L1177">    RequireUtil.notNull(q, &quot;q&quot;);</span>
<span class="fc" id="L1178">    return q.select(q.snapshot());</span>
  }

  /**
   * Return a mediapackage filtered query which returns the snapshot and its current storage location
   *
   * @param q
   *   The query builder object to configure
   * @param mpId
   *   The mediapackage ID to filter results for
   * @return
   *   The {@link ASelectQuery} configured with as described above
   */
  private ASelectQuery baseQuery(final AQueryBuilder q, final String mpId) {
<span class="fc" id="L1192">    RequireUtil.notNull(q, &quot;q&quot;);</span>
<span class="fc" id="L1193">    ASelectQuery query = baseQuery(q);</span>
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">    if (StringUtils.isNotEmpty(mpId)) {</span>
<span class="fc" id="L1195">      return query.where(q.mediaPackageId(mpId));</span>
    } else {
<span class="nc" id="L1197">      return query;</span>
    }
  }

  /**
   * Return a mediapackage and version filtered query which returns the snapshot and its current storage location
   *
   * @param q
   *   The query builder object to configure
   * @param version
   *   The version to filter results for
   * @param mpId
   *   The mediapackage ID to filter results for
   * @return
   *   The {@link ASelectQuery} configured with as described above
   */
  private ASelectQuery baseQuery(final AQueryBuilder q, final Version version, final String mpId) {
<span class="fc" id="L1214">    RequireUtil.notNull(q, &quot;q&quot;);</span>
<span class="fc" id="L1215">    RequireUtil.requireNotBlank(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L1216">    ASelectQuery query = baseQuery(q, mpId);</span>
<span class="pc bpc" id="L1217" title="1 of 2 branches missed.">    if (null != version) {</span>
<span class="fc" id="L1218">      return query.where(q.version().eq(version));</span>
    } else {
<span class="nc" id="L1220">      return query;</span>
    }
  }

  /** Move the assets for a snapshot to the target store */
  private void copyAssetsToStore(Snapshot snap, AssetStore store) {
<span class="fc" id="L1226">    final String mpId = snap.getMediaPackage().getIdentifier().toString();</span>
<span class="fc" id="L1227">    final String orgId = snap.getOrganizationId();</span>
<span class="fc" id="L1228">    final Version version = snap.getVersion();</span>
<span class="fc" id="L1229">    final String prettyMpId = mpId + &quot;@v&quot; + version;</span>
<span class="fc" id="L1230">    logger.debug(&quot;Moving assets for snapshot {} to store {}&quot;, prettyMpId, store.getStoreType());</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">    for (final MediaPackageElement e : snap.getMediaPackage().getElements()) {</span>
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">      if (!MOVABLE_TYPES.contains(e.getElementType())) {</span>
<span class="nc" id="L1233">        logger.debug(&quot;Skipping {} because type is {}&quot;, e.getIdentifier(), e.getElementType());</span>
<span class="nc" id="L1234">        continue;</span>
      }
<span class="fc" id="L1236">      logger.debug(&quot;Moving {} to store {}&quot;, e.getIdentifier(), store.getStoreType());</span>
<span class="fc" id="L1237">      final StoragePath storagePath = StoragePath.mk(orgId, mpId, version, e.getIdentifier());</span>
<span class="pc bpc" id="L1238" title="1 of 2 branches missed.">      if (store.contains(storagePath)) {</span>
<span class="nc" id="L1239">        logger.debug(&quot;Element {} (version {}) is already in store {} so skipping it&quot;, e.getIdentifier(),</span>
<span class="nc" id="L1240">                version, store.getStoreType());</span>
<span class="nc" id="L1241">        continue;</span>
      }

      // find asset in versions &amp; stores
<span class="fc" id="L1245">      final Optional&lt;StoragePath&gt; existingAssetOpt =</span>
<span class="fc" id="L1246">          getDatabase()</span>
<span class="fc" id="L1247">          .findAssetByChecksumAndStoreAndOrg(e.getChecksum().toString(), store.getStoreType(), orgId)</span>
<span class="fc" id="L1248">          .map(dto -&gt; StoragePath.mk(</span>
<span class="fc" id="L1249">              dto.getOrganizationId(),</span>
<span class="fc" id="L1250">              dto.getMediaPackageId(),</span>
<span class="fc" id="L1251">              dto.getVersion(),</span>
<span class="fc" id="L1252">              dto.getAssetDto().getMediaPackageElementId()</span>
          ));

<span class="fc bfc" id="L1255" title="All 2 branches covered.">      if (existingAssetOpt.isPresent()) {</span>
<span class="fc" id="L1256">        final StoragePath existingAsset = existingAssetOpt.get();</span>
<span class="fc" id="L1257">        logger.debug(&quot;Content of asset {} with checksum {} already exists in {}&quot;,</span>
<span class="fc" id="L1258">                existingAsset.getMediaPackageElementId(), e.getChecksum(), store.getStoreType());</span>
<span class="pc bpc" id="L1259" title="1 of 2 branches missed.">        if (!store.copy(existingAsset, storagePath)) {</span>
<span class="nc" id="L1260">          throw new AssetManagerException(format(</span>
                  &quot;An asset with checksum %s has already been archived but trying to copy or link asset %s to it &quot;
                          + &quot;failed&quot;,
<span class="nc" id="L1263">                  e.getChecksum(),</span>
                  existingAsset
          ));
        }
<span class="fc" id="L1267">      } else {</span>
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">        final Optional&lt;Long&gt; size = e.getSize() &gt; 0 ? Optional.of(e.getSize()) : Optional.empty();</span>
<span class="fc" id="L1269">        store.put(storagePath, Source.mk(e.getURI(), size, Optional.ofNullable(e.getMimeType())));</span>
      }
<span class="fc" id="L1271">      getDatabase().setAssetStorageLocation(VersionImpl.mk(version), mpId, e.getIdentifier(), store.getStoreType());</span>
    }
<span class="fc" id="L1273">  }</span>

  private void copyManifest(Snapshot snap, AssetStore targetStore) throws IOException, NotFoundException {
<span class="fc" id="L1276">    final String mpId = snap.getMediaPackage().getIdentifier().toString();</span>
<span class="fc" id="L1277">    final String orgId = snap.getOrganizationId();</span>
<span class="fc" id="L1278">    final Version version = snap.getVersion();</span>

<span class="fc" id="L1280">    AssetStore currentStore = getAssetStore(snap.getStorageId()).get();</span>
<span class="fc" id="L1281">    Optional&lt;String&gt; manifestOpt = findManifestBaseName(snap, MANIFEST_DEFAULT_NAME, currentStore);</span>
<span class="pc bpc" id="L1282" title="1 of 2 branches missed.">    if (manifestOpt.isEmpty()) {</span>
<span class="nc" id="L1283">      return; // Nothing to do, already moved to long-term storage</span>
    }

    // Copy the manifest file
<span class="fc" id="L1287">    String manifestBaseName = manifestOpt.get();</span>
<span class="fc" id="L1288">    StoragePath pathToManifest = new StoragePath(orgId, mpId, version, manifestBaseName);</span>

    // Already copied?
<span class="pc bpc" id="L1291" title="1 of 2 branches missed.">    if (!targetStore.contains(pathToManifest)) {</span>
      Optional&lt;InputStream&gt; inputStreamOpt;
<span class="fc" id="L1293">      InputStream inputStream = null;</span>
<span class="fc" id="L1294">      String manifestFileName = null;</span>
      try {
<span class="fc" id="L1296">        inputStreamOpt = currentStore.get(pathToManifest);</span>
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">        if (inputStreamOpt.isEmpty()) { // This should never happen because it has been tested before</span>
<span class="nc" id="L1298">          throw new NotFoundException(</span>
<span class="nc" id="L1299">                  String.format(&quot;Unexpected error. Manifest %s not found in current asset store&quot;, manifestBaseName));</span>
        }

<span class="fc" id="L1302">        inputStream = inputStreamOpt.get();</span>
<span class="fc" id="L1303">        manifestFileName = UUID.randomUUID() + &quot;.xml&quot;;</span>
<span class="fc" id="L1304">        URI manifestTmpUri = workspace.putInCollection(&quot;archive&quot;, manifestFileName, inputStream);</span>
<span class="fc" id="L1305">        targetStore.put(pathToManifest, Source.mk(manifestTmpUri, Optional.empty(), Optional.of(MimeTypes.XML)));</span>
      } finally {
<span class="fc" id="L1307">        IOUtils.closeQuietly(inputStream);</span>
        try {
          // Make sure to clean up the temporary file
<span class="fc" id="L1310">          workspace.deleteFromCollection(&quot;archive&quot;, manifestFileName);</span>
<span class="nc" id="L1311">        } catch (NotFoundException e) {</span>
          // This is OK, we are deleting it anyway
<span class="nc" id="L1313">        } catch (IOException e) {</span>
          // This usually happens when the collection directory cannot be deleted
          // because another process is running at the same time and wrote a file there
          // after it was tested but before it was actually deleted. We will consider this ok.
          // Does the error message mention the manifest file name?
<span class="nc bnc" id="L1318" title="All 2 branches missed.">          if (e.getMessage().contains(manifestFileName)) {</span>
<span class="nc" id="L1319">            logger.warn(&quot;The manifest file {} didn't get deleted from the archive collection&quot;,</span>
                    manifestBaseName, e);
          }
          // Else the error is related to the file-archive collection, which is fine
<span class="pc" id="L1323">        }</span>
      }
    }
<span class="fc" id="L1326">  }</span>

  Optional&lt;String&gt; findManifestBaseName(Snapshot snap, String manifestName, AssetStore store) {
<span class="fc" id="L1329">    StoragePath path = new StoragePath(snap.getOrganizationId(), snap.getMediaPackage().getIdentifier().toString(),</span>
<span class="fc" id="L1330">            snap.getVersion(), manifestName);</span>
    // If manifest_.xml, etc not found, return previous name (copied from the EpsiodeServiceImpl logic)
<span class="fc bfc" id="L1332" title="All 2 branches covered.">    if (!store.contains(path)) {</span>
      // If first call, manifest is not found, which probably means it has already been moved
<span class="pc bpc" id="L1334" title="1 of 2 branches missed.">      if (MANIFEST_DEFAULT_NAME.equals(manifestName)) {</span>
<span class="nc" id="L1335">        return Optional.empty(); // No manifest found in current store</span>
      } else {
<span class="fc" id="L1337">        return Optional.of(manifestName.substring(0, manifestName.length() - 1));</span>
      }
    }
    // This is the same logic as when building the manifest name: manifest, manifest_, manifest__, etc
<span class="fc" id="L1341">    return findManifestBaseName(snap, manifestName + &quot;_&quot;, store);</span>
  }

  /* -------------------------------------------------------------------------------------------------------------- */

  /**
   * Make sure each of the elements has a checksum.
   */
  void calcChecksumsForMediaPackageElements(PartialMediaPackage pmp) {
<span class="fc" id="L1350">    final Fx&lt;MediaPackageElement&gt; addChecksum = new Fx&lt;MediaPackageElement&gt;() {</span>
      @Override public void apply(MediaPackageElement mpe) {
<span class="fc" id="L1352">        File file = null;</span>
        try {
<span class="fc" id="L1354">          logger.trace(&quot;Calculate checksum for {}&quot;, mpe.getURI());</span>
<span class="fc" id="L1355">          file = workspace.get(mpe.getURI(), true);</span>
<span class="fc" id="L1356">          mpe.setChecksum(Checksum.create(ChecksumType.DEFAULT_TYPE, file));</span>
<span class="nc" id="L1357">        } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L1358">          throw new AssetManagerException(format(</span>
                  &quot;Cannot calculate checksum for media package element %s&quot;,
<span class="nc" id="L1360">                  mpe.getURI()</span>
          ), e);
        } finally {
<span class="pc bpc" id="L1363" title="1 of 2 branches missed.">          if (file != null) {</span>
<span class="fc" id="L1364">            FileUtils.deleteQuietly(file);</span>
          }
        }
<span class="fc" id="L1367">      }</span>
    };
<span class="fc" id="L1369">    pmp.getElements().filter(hasNoChecksum.toFn()).each(addChecksum).run();</span>
<span class="fc" id="L1370">  }</span>

  /** Mutates mp and its elements, so make sure to work on a copy. */
  private SnapshotDto addInternal(String owner, final MediaPackage mp) throws Exception {
<span class="fc" id="L1374">    final Date now = new Date();</span>
    // claim a new version for the media package
<span class="fc" id="L1376">    final String mpId = mp.getIdentifier().toString();</span>
<span class="fc" id="L1377">    final VersionImpl version = getDatabase().claimVersion(mpId);</span>
<span class="fc" id="L1378">    logger.info(&quot;Creating new version {} of media package {}&quot;, version, mp);</span>
<span class="fc" id="L1379">    final PartialMediaPackage pmp = assetsOnly(mp);</span>
    // make sure they have a checksum
<span class="fc" id="L1381">    calcChecksumsForMediaPackageElements(pmp);</span>
    // download and archive elements
<span class="fc" id="L1383">    storeAssets(pmp, version);</span>
    // store mediapackage in db
    final SnapshotDto snapshotDto;
    try {
      // rewrite URIs for archival
<span class="fc" id="L1388">      Fn&lt;MediaPackageElement, URI&gt; uriCreator = new Fn&lt;MediaPackageElement, URI&gt;() {</span>
        @Override
        public URI apply(MediaPackageElement mpe) {
          try {
<span class="fc" id="L1392">            String fileName = getFileName(mpe).getOr(&quot;unknown&quot;);</span>
<span class="fc" id="L1393">            return new URI(</span>
                    &quot;urn&quot;,
<span class="fc" id="L1395">                    &quot;matterhorn:&quot; + mpId + &quot;:&quot; + version + &quot;:&quot; + mpe.getIdentifier() + &quot;:&quot; + fileName,</span>
                    null
            );
<span class="nc" id="L1398">          } catch (URISyntaxException e) {</span>
<span class="nc" id="L1399">            throw new AssetManagerException(e);</span>
          }
        }
      };

<span class="fc bfc" id="L1404" title="All 2 branches covered.">      for (MediaPackageElement mpe : pmp.getElements()) {</span>
<span class="fc" id="L1405">        mpe.setURI(uriCreator.apply(mpe));</span>
<span class="fc" id="L1406">      }</span>

<span class="fc" id="L1408">      String currentOrgId = securityService.getOrganization().getId();</span>
<span class="fc" id="L1409">      snapshotDto = getDatabase().saveSnapshot(</span>
              currentOrgId, pmp, now, version,
<span class="fc" id="L1411">              Availability.ONLINE, getLocalAssetStore().getStoreType(), owner</span>
      );
<span class="nc" id="L1413">    } catch (AssetManagerException e) {</span>
<span class="nc" id="L1414">      logger.error(&quot;Could not take snapshot {}&quot;, mpId, e);</span>
<span class="nc" id="L1415">      throw new AssetManagerException(e);</span>
<span class="fc" id="L1416">    }</span>
    // save manifest to element store
    // this is done at the end after the media package element ids have been rewritten to neutral URNs
<span class="fc" id="L1419">    storeManifest(pmp, version);</span>
<span class="fc" id="L1420">    return snapshotDto;</span>
  }

  /**
   * Store all elements of &lt;code&gt;pmp&lt;/code&gt; under the given version.
   */
  private void storeAssets(final PartialMediaPackage pmp, final Version version) {
<span class="fc" id="L1427">    final String mpId = pmp.getMediaPackage().getIdentifier().toString();</span>
<span class="fc" id="L1428">    final String orgId = securityService.getOrganization().getId();</span>
<span class="fc bfc" id="L1429" title="All 2 branches covered.">    for (final MediaPackageElement e : pmp.getElements()) {</span>
<span class="fc" id="L1430">      logger.debug(&quot;Archiving {} {} {}&quot;, e.getFlavor(), e.getMimeType(), e.getURI());</span>
<span class="fc" id="L1431">      final StoragePath storagePath = StoragePath.mk(orgId, mpId, version, e.getIdentifier());</span>
      // find asset in versions
<span class="fc" id="L1433">      final Optional&lt;StoragePath&gt; existingAssetOpt = getDatabase()</span>
<span class="fc" id="L1434">          .findAssetByChecksumAndStoreAndOrg(e.getChecksum().toString(), getLocalAssetStore().getStoreType(), orgId)</span>
<span class="fc" id="L1435">          .map(dto -&gt; StoragePath.mk(</span>
<span class="fc" id="L1436">                  dto.getOrganizationId(),</span>
<span class="fc" id="L1437">                  dto.getMediaPackageId(),</span>
<span class="fc" id="L1438">                  dto.getVersion(),</span>
<span class="fc" id="L1439">                  dto.getAssetDto().getMediaPackageElementId()));</span>

<span class="fc bfc" id="L1441" title="All 2 branches covered.">      if (existingAssetOpt.isPresent()) {</span>
<span class="fc" id="L1442">        final StoragePath existingAsset = existingAssetOpt.get();</span>
<span class="fc" id="L1443">        logger.debug(&quot;Content of asset {} with checksum {} has been archived before&quot;,</span>
<span class="fc" id="L1444">                existingAsset.getMediaPackageElementId(), e.getChecksum());</span>
<span class="pc bpc" id="L1445" title="1 of 2 branches missed.">        if (!getLocalAssetStore().copy(existingAsset, storagePath)) {</span>
<span class="nc" id="L1446">          throw new AssetManagerException(format(</span>
                  &quot;An asset with checksum %s has already been archived but trying to copy or link asset %s to it &quot;
                          + &quot;failed&quot;,
<span class="nc" id="L1449">                  e.getChecksum(),</span>
                  existingAsset
          ));
        }
<span class="fc" id="L1453">      } else {</span>
<span class="pc bpc" id="L1454" title="1 of 2 branches missed.">        final Optional&lt;Long&gt; size = e.getSize() &gt; 0 ? Optional.of(e.getSize()) : Optional.empty();</span>
<span class="fc" id="L1455">        getLocalAssetStore().put(storagePath, Source.mk(e.getURI(), size, Optional.ofNullable(e.getMimeType())));</span>
      }
<span class="fc" id="L1457">    }</span>
<span class="fc" id="L1458">  }</span>

  private void storeManifest(final PartialMediaPackage pmp, final Version version) throws Exception {
<span class="fc" id="L1461">    final String mpId = pmp.getMediaPackage().getIdentifier().toString();</span>
<span class="fc" id="L1462">    final String orgId = securityService.getOrganization().getId();</span>
    // store the manifest.xml
    // TODO make use of checksums
<span class="fc" id="L1465">    logger.debug(&quot;Archiving manifest of media package {} version {}&quot;, mpId, version);</span>
    // temporarily save the manifest XML into the workspace to
    // Fix file not found exception when several snapshots are taken at the same time
<span class="fc" id="L1468">    final String manifestFileName = format(&quot;manifest_%s_%s.xml&quot;, pmp.getMediaPackage().getIdentifier(), version);</span>
<span class="fc" id="L1469">    final URI manifestTmpUri = workspace.putInCollection(</span>
            &quot;archive&quot;,
            manifestFileName,
<span class="fc" id="L1472">            IOUtils.toInputStream(MediaPackageParser.getAsXml(pmp.getMediaPackage()), &quot;UTF-8&quot;));</span>
    try {
<span class="fc" id="L1474">      getLocalAssetStore().put(</span>
<span class="fc" id="L1475">              StoragePath.mk(orgId, mpId, version, manifestAssetId(pmp, &quot;manifest&quot;)),</span>
<span class="fc" id="L1476">              Source.mk(manifestTmpUri, Optional.empty(), Optional.of(MimeTypes.XML)));</span>
    } finally {
      // make sure to clean up the temporary file
<span class="fc" id="L1479">      workspace.deleteFromCollection(&quot;archive&quot;, manifestFileName);</span>
    }
<span class="fc" id="L1481">  }</span>

  /**
   * Create a unique id for the manifest xml. This is to avoid an id collision
   * in the rare case that the media package contains an XML element with the id
   * used for the manifest. A UUID could also be used but this is far less
   * readable.
   *
   * @param seedId
   *          the id to start with
   */
  private String manifestAssetId(PartialMediaPackage pmp, String seedId) {
<span class="pc bpc" id="L1493" title="1 of 2 branches missed.">    if ($(pmp.getElements()).map(getMediaPackageElementId.toFn()).exists(Booleans.eq(seedId))) {</span>
<span class="nc" id="L1494">      return manifestAssetId(pmp, seedId + &quot;_&quot;);</span>
    } else {
<span class="fc" id="L1496">      return seedId;</span>
    }
  }

  /* --------------------------------------------------------------------------------------------------------------- */

  /**
   * Unify exception handling by wrapping any occurring exception in an
   * {@link AssetManagerException}.
   */
  static &lt;A&gt; A handleException(final P1&lt;A&gt; p) throws AssetManagerException {
    try {
<span class="fc" id="L1508">      return p.get1();</span>
<span class="nc" id="L1509">    } catch (Exception e) {</span>
<span class="nc" id="L1510">      logger.error(&quot;An error occurred&quot;, e);</span>
<span class="nc" id="L1511">      throw unwrapExceptionUntil(AssetManagerException.class, e).orElse(new AssetManagerException(e));</span>
    }
  }

  /**
   * Walk up the stacktrace to find a cause of type &lt;code&gt;type&lt;/code&gt;. Return none if no such
   * type can be found.
   */
  static &lt;A extends Throwable&gt; Optional&lt;A&gt; unwrapExceptionUntil(Class&lt;A&gt; type, Throwable e) {
<span class="pc bpc" id="L1520" title="1 of 2 branches missed.">    if (e == null) {</span>
<span class="nc" id="L1521">      return Optional.empty();</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">    } else if (type.isAssignableFrom(e.getClass())) {</span>
<span class="fc" id="L1523">      return Optional.of((A) e);</span>
    } else {
<span class="fc" id="L1525">      return unwrapExceptionUntil(type, e.getCause());</span>
    }
  }

  /**
   * Return a partial media package filtering assets. Assets are elements the archive is going to manager, i.e. all
   * non-publication elements.
   */
  static PartialMediaPackage assetsOnly(MediaPackage mp) {
<span class="fc" id="L1534">    final Pred&lt;MediaPackageElement&gt; isAsset = Pred.mk(isNotPublication.toFn());</span>
<span class="fc" id="L1535">    return PartialMediaPackage.mk(mp, isAsset);</span>
  }

  /**
   * Extract the file name from a media package elements URN.
   *
   * @return the file name or none if it could not be determined
   */
  public static Optional&lt;String&gt; getFileNameFromUrn(MediaPackageElement mpe) {
<span class="fc" id="L1544">    Fn&lt;URI, String&gt; toString = new Fn&lt;URI, String&gt;() {</span>
      @Override
      public String apply(URI uri) {
<span class="nc" id="L1547">        return uri.toString();</span>
      }
    };

<span class="fc" id="L1551">    Optional&lt;URI&gt; uri = Optional.ofNullable(mpe.getURI());</span>
<span class="fc bfc" id="L1552" title="All 4 branches covered.">    if (uri.isPresent() &amp;&amp; &quot;urn&quot;.equals(uri.get().getScheme())) {</span>
<span class="fc" id="L1553">      String[] tmp = uri.get().toString().split(&quot;:&quot;);</span>
<span class="pc bpc" id="L1554" title="1 of 2 branches missed.">      if (tmp.length &lt; 1) {</span>
<span class="nc" id="L1555">        return Optional.empty();</span>
      }
<span class="fc" id="L1557">      return Optional.of(tmp[tmp.length - 1]);</span>
    }
<span class="fc" id="L1559">    return Optional.empty();</span>
  }

  /**
   * Rewrite URIs of all asset elements of a snapshot's media package.
   * This method does not mutate anything.
   */
  public static Snapshot rewriteUris(Snapshot snapshot, Fn&lt;MediaPackageElement, URI&gt; uriCreator) {
<span class="fc" id="L1567">    final MediaPackage mpCopy = MediaPackageSupport.copy(snapshot.getMediaPackage());</span>
<span class="fc bfc" id="L1568" title="All 2 branches covered.">    for (final MediaPackageElement mpe : assetsOnly(mpCopy).getElements()) {</span>
<span class="fc" id="L1569">      mpe.setURI(uriCreator.apply(mpe));</span>
<span class="fc" id="L1570">    }</span>
<span class="fc" id="L1571">    return new SnapshotImpl(</span>
<span class="fc" id="L1572">            snapshot.getVersion(),</span>
<span class="fc" id="L1573">            snapshot.getOrganizationId(),</span>
<span class="fc" id="L1574">            snapshot.getArchivalDate(),</span>
<span class="fc" id="L1575">            snapshot.getAvailability(),</span>
<span class="fc" id="L1576">            snapshot.getStorageId(),</span>
<span class="fc" id="L1577">            snapshot.getOwner(),</span>
            mpCopy);
  }

  public void fireEventHandlers(AssetManagerItem item) {
<span class="pc bpc" id="L1582" title="1 of 2 branches missed.">    while (handlers.size() != 2) {</span>
<span class="nc" id="L1583">      logger.warn(&quot;Expecting 2 handlers, but {} are registered.  Waiting 10s then retrying...&quot;, handlers.size());</span>
      try {
<span class="nc" id="L1585">        Thread.sleep(10000L);</span>
<span class="nc" id="L1586">      } catch (InterruptedException e) { /* swallow this, nothing to do */ }</span>
    }
<span class="fc bfc" id="L1588" title="All 2 branches covered.">    for (AssetManagerUpdateHandler handler : handlers) {</span>
<span class="fc" id="L1589">      handler.execute(item);</span>
<span class="fc" id="L1590">    }</span>
<span class="fc" id="L1591">  }</span>

  /**
   * Call {@link
   * org.opencastproject.assetmanager.impl.query.AbstractADeleteQuery#run(AbstractADeleteQuery.DeleteEpisodeHandler)}
   * with a delete handler. Also make sure to propagate the behaviour to subsequent instances.
   */
  private final class ADeleteQueryWithMessaging extends ADeleteQueryDecorator {
<span class="fc" id="L1599">    ADeleteQueryWithMessaging(ADeleteQuery delegate) {</span>
<span class="fc" id="L1600">      super(delegate);</span>
<span class="fc" id="L1601">    }</span>

    @Override
    public long run() {
<span class="fc" id="L1605">      return RuntimeTypes.convert(delegate).run(AssetManagerImpl.this);</span>
    }

    @Override
    protected ADeleteQueryDecorator mkDecorator(ADeleteQuery delegate) {
<span class="fc" id="L1610">      return new ADeleteQueryWithMessaging(delegate);</span>
    }
  }

  /**
   * Get the function to update a commented event in the Elasticsearch index.
   *
   * @return the function to do the update
   */
  private Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; getEventUpdateFunction(Snapshot snapshot,
          String orgId, User user) {
<span class="nc" id="L1621">    return (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
<span class="nc" id="L1622">      MediaPackage mp = snapshot.getMediaPackage();</span>
<span class="nc" id="L1623">      String eventId = mp.getIdentifier().toString();</span>
<span class="nc" id="L1624">      Event event = eventOpt.orElse(new Event(eventId, orgId));</span>

<span class="nc" id="L1626">      event = updateAclInEvent(event, mp, eventId);</span>

<span class="nc" id="L1628">      event.setArchiveVersion(Long.parseLong(snapshot.getVersion().toString()));</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">      if (StringUtils.isBlank(event.getCreator())) {</span>
<span class="nc" id="L1630">        event.setCreator(securityService.getUser().getName());</span>
      }
<span class="nc" id="L1632">      EventIndexUtils.updateEvent(event, mp);</span>

<span class="nc bnc" id="L1634" title="All 2 branches missed.">      for (Catalog catalog: mp.getCatalogs(MediaPackageElements.EPISODE)) {</span>
<span class="nc" id="L1635">        try (InputStream in = workspace.read(catalog.getURI())) {</span>
<span class="nc" id="L1636">          EventIndexUtils.updateEvent(event, DublinCores.read(in));</span>
<span class="nc" id="L1637">        } catch (IOException | NotFoundException e) {</span>
<span class="nc" id="L1638">          throw new IllegalStateException(String.format(&quot;Unable to load dublin core catalog for event '%s'&quot;,</span>
<span class="nc" id="L1639">                  mp.getIdentifier()), e);</span>
<span class="nc" id="L1640">        }</span>
      }

      // Update series name if not already done
      try {
<span class="nc" id="L1645">        EventIndexUtils.updateSeriesName(event, orgId, user, index);</span>
<span class="nc" id="L1646">      } catch (SearchIndexException e) {</span>
<span class="nc" id="L1647">        logger.error(&quot;Error updating the series name of the event {} in the {} index.&quot;, eventId, index.getIndexName(),</span>
                e);
<span class="nc" id="L1649">      }</span>
<span class="nc" id="L1650">      return Optional.of(event);</span>
    };
  }

  private Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; getEventUpdateFunctionOnlyAcl(Snapshot snapshot,
      String orgId, User user) {
<span class="nc" id="L1656">    return (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
<span class="nc" id="L1657">      MediaPackage mp = snapshot.getMediaPackage();</span>
<span class="nc" id="L1658">      String eventId = mp.getIdentifier().toString();</span>
<span class="nc" id="L1659">      Event event = eventOpt.orElse(new Event(eventId, orgId));</span>

<span class="nc" id="L1661">      event = updateAclInEvent(event, mp, eventId);</span>

<span class="nc" id="L1663">      return Optional.of(event);</span>
    };
  }

  private Event updateAclInEvent(Event event, MediaPackage mp, String eventId) {
<span class="nc" id="L1668">    AccessControlList acl = authorizationService.getActiveAcl(mp).getA();</span>
<span class="nc" id="L1669">    List&lt;ManagedAcl&gt; acls = aclServiceFactory.serviceFor(securityService.getOrganization()).getAcls();</span>

<span class="nc bnc" id="L1671" title="All 2 branches missed.">    for (final ManagedAcl managedAcl : AccessInformationUtil.matchAcls(acls, acl)) {</span>
<span class="nc" id="L1672">      event.setManagedAcl(managedAcl.getName());</span>
<span class="nc" id="L1673">    }</span>
<span class="nc" id="L1674">    event.setAccessPolicy(AccessControlParser.toJsonSilent(acl));</span>

<span class="nc" id="L1676">    return event;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>