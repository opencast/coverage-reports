<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AssetManagerJobProducer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-asset-manager-impl</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.assetmanager.impl</a> &gt; <span class="el_source">AssetManagerJobProducer.java</span></div><h1>AssetManagerJobProducer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.assetmanager.impl;

import org.opencastproject.assetmanager.api.AssetManager;
import org.opencastproject.assetmanager.api.AssetManagerException;
import org.opencastproject.assetmanager.api.Snapshot;
import org.opencastproject.assetmanager.api.Version;
import org.opencastproject.assetmanager.api.query.ARecord;
import org.opencastproject.assetmanager.api.query.RichAResult;
import org.opencastproject.assetmanager.api.storage.AssetStore;
import org.opencastproject.assetmanager.api.storage.RemoteAssetStore;
import org.opencastproject.job.api.AbstractJobProducer;
import org.opencastproject.job.api.Job;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.RequireUtil;

import com.google.gson.Gson;

import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Consumer;

@Component(
    immediate = true,
    service = AssetManagerJobProducer.class,
    property = {
        &quot;service.description=Opencast Asset Manager Job Producer&quot;
    }
)
public class AssetManagerJobProducer extends AbstractJobProducer {

  /** The logging facility */
<span class="fc" id="L68">  private static final Logger logger = LoggerFactory.getLogger(AssetManagerJobProducer.class);</span>

  public static final String JOB_TYPE = &quot;org.opencastproject.assetmanager&quot;;
<span class="fc" id="L71">  public static final Float JOB_LOAD = 0.1f;</span>
<span class="fc" id="L72">  public static final Float NONTERMINAL_JOB_LOAD = 0.1f;</span>

<span class="fc" id="L74">  public enum Operation {</span>
<span class="fc" id="L75">    MoveById, MoveByIdAndVersion, MoveByIdAndDate, MoveByDate, MoveRecords</span>
  }

  private static final String OK = &quot;OK&quot;;

<span class="fc" id="L80">  private AssetManager tsam = null;</span>
<span class="fc" id="L81">  private ServiceRegistry serviceRegistry = null;</span>
<span class="fc" id="L82">  private SecurityService securityService = null;</span>
<span class="fc" id="L83">  private UserDirectoryService userDirectoryService = null;</span>
<span class="fc" id="L84">  private OrganizationDirectoryService organizationDirectoryService = null;</span>

  public AssetManagerJobProducer() {
<span class="fc" id="L87">    super(JOB_TYPE);</span>
<span class="fc" id="L88">  }</span>

  /**
   * OSGi callback on component activation.
   *
   * @param cc
   *          the component context
   */
  @Override
  @Activate
  public void activate(ComponentContext cc) {
<span class="nc" id="L99">    logger.info(&quot;Activating assetmanager job service&quot;);</span>
<span class="nc" id="L100">    super.activate(cc);</span>
<span class="nc" id="L101">  }</span>

  public boolean datastoreExists(String storeId) {
<span class="nc" id="L104">    Optional&lt;AssetStore&gt; store = tsam.getAssetStore(storeId);</span>
<span class="nc" id="L105">    return store.isPresent();</span>
  }

  /** Utility class to collect RecordInformation for moving larger 
   * groups of mediapackages in combined jobs.
   */
<span class="fc" id="L111">  private class MoveRecordInfo {</span>
<span class="fc" id="L112">    private final Gson gson = new Gson();</span>
<span class="fc" id="L113">    private int success = 0;</span>
<span class="fc" id="L114">    private int failed = 0;</span>
<span class="fc" id="L115">    private String currentMpId = &quot;&quot;;</span>
    public void addSuccess() {
<span class="fc" id="L117">      success++;</span>
<span class="fc" id="L118">    };</span>
    public void addFailed() {
<span class="nc" id="L120">      failed ++;</span>
<span class="nc" id="L121">    }</span>

    public boolean isNewMpId(String mpId) {
<span class="fc bfc" id="L124" title="All 2 branches covered.">      if (currentMpId.equals(mpId)) {</span>
<span class="fc" id="L125">        return false;</span>
      }
<span class="fc" id="L127">      currentMpId = mpId;</span>
<span class="fc" id="L128">      return true;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L133">      Map&lt;String,Integer&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">      if (success &gt; 0) {</span>
<span class="fc" id="L135">        result.put(&quot;OK&quot;, success);</span>
      }
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">      if (failed &gt; 0) {</span>
<span class="nc" id="L138">        result.put(&quot;FAIL&quot;, failed);</span>
      }
<span class="fc" id="L140">      return gson.toJson(result);</span>
    }
  };

  @Override
  protected String process(Job job) throws ServiceRegistryException {
<span class="fc" id="L146">    Operation op = null;</span>
<span class="fc" id="L147">    String operation = job.getOperation();</span>
<span class="fc" id="L148">    List&lt;String&gt; arguments = job.getArguments();</span>
    String id;
<span class="fc" id="L150">    String targetStore = arguments.get(0);</span>
    VersionImpl version;
    Date start;
    Date end;
    try {
<span class="fc" id="L155">      op = Operation.valueOf(operation);</span>
<span class="pc bpc" id="L156" title="4 of 5 branches missed.">      switch (op) {</span>
        case MoveById:
<span class="nc" id="L158">          id = arguments.get(1);</span>
<span class="nc" id="L159">          return internalMoveById(id, targetStore);</span>
        case MoveByIdAndVersion:
<span class="fc" id="L161">          id = arguments.get(1);</span>
<span class="fc" id="L162">          version = VersionImpl.mk(Long.parseLong(arguments.get(2)));</span>
<span class="fc" id="L163">          return internalMoveByIdAndVersion(version, id, targetStore);</span>
        case MoveByDate:
<span class="nc" id="L165">          start = new Date(Long.parseLong(arguments.get(1)));</span>
<span class="nc" id="L166">          end = new Date(Long.parseLong(arguments.get(2)));</span>
<span class="nc" id="L167">          return internalMoveByDate(start, end, targetStore);</span>
        case MoveByIdAndDate:
<span class="nc" id="L169">          id = arguments.get(1);</span>
<span class="nc" id="L170">          start = new Date(Long.parseLong(arguments.get(2)));</span>
<span class="nc" id="L171">          end = new Date(Long.parseLong(arguments.get(3)));</span>
<span class="nc" id="L172">          return internalMoveByIdAndDate(id, start, end, targetStore);</span>
        default:
<span class="nc" id="L174">          throw new IllegalArgumentException(&quot;Unknown operation '&quot; + operation + &quot;'&quot;);</span>
      }
<span class="nc" id="L176">    } catch (NotFoundException e) {</span>
<span class="nc" id="L177">      throw new ServiceRegistryException(&quot;Error running job&quot;, e);</span>
<span class="nc" id="L178">    } catch (Exception e) {</span>
<span class="nc" id="L179">      throw new ServiceRegistryException(&quot;Error handling operation '&quot; + op + &quot;'&quot;, e);</span>
    }
  }

  /**
   * Spawns a job to move a single snapshot from its current storage to a new target storage location
   *
   * @param version
   *  The {@link Version} to move
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   */
  public Job moveByIdAndVersion(final Version version, final String mpId, final String targetStorage) {
<span class="fc" id="L195">    RequireUtil.notNull(version, &quot;version&quot;);</span>
<span class="fc" id="L196">    RequireUtil.notEmpty(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L197">    RequireUtil.notEmpty(targetStorage, &quot;targetStorage&quot;);</span>
<span class="fc" id="L198">    List&lt;String&gt; args = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L199">    args.add(targetStorage);</span>
<span class="fc" id="L200">    args.add(mpId);</span>
<span class="fc" id="L201">    args.add(version.toString());</span>

    try {
<span class="fc" id="L204">      return serviceRegistry.createJob(JOB_TYPE, Operation.MoveByIdAndVersion.toString(), args, null, true, JOB_LOAD);</span>
<span class="nc" id="L205">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L206">      throw new AssetManagerException(&quot;Unable to create a job&quot;, e);</span>
    }
  }

  /**
   * Triggers the move operation inside the {@link AssetManager}
   *
   * @param version
   *  The {@link Version} to move
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The string &quot;OK&quot;
   * @throws NotFoundException
   */
  protected String internalMoveByIdAndVersion(
      final Version version,
      final String mpId,
      final String targetStorage
  ) throws NotFoundException {
<span class="fc" id="L228">    tsam.moveSnapshotToStore(version, mpId, targetStorage);</span>
<span class="fc" id="L229">    return OK;</span>
  }

  /**
   * Spawns a job to move a all snapshots of a mediapackage from their current storage to a new target storage location
   *
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The {@link Job}
   */
  public Job moveById(final String mpId, final String targetStorage) {
<span class="fc" id="L243">    RequireUtil.notEmpty(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L244">    RequireUtil.notEmpty(targetStorage, &quot;targetStorage&quot;);</span>
<span class="fc" id="L245">    List&lt;String&gt; args = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L246">    args.add(targetStorage);</span>
<span class="fc" id="L247">    args.add(mpId);</span>

    try {
<span class="fc" id="L250">      return serviceRegistry.createJob(JOB_TYPE, Operation.MoveById.toString(), args, null, true, NONTERMINAL_JOB_LOAD);</span>
<span class="nc" id="L251">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L252">      throw new AssetManagerException(&quot;Unable to create a job&quot;, e);</span>
    }
  }

  /**
   * Moves all the appropriate snapshots to their new home
   *
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The String containing the number of successful and failed moves
   *  [0 OK ][0 FAILED ]
   */
  protected String internalMoveById(final String mpId, final String targetStorage) {
<span class="fc" id="L268">    RichAResult results = tsam.getSnapshotsByIdOrderedByVersion(mpId, true);</span>
<span class="fc" id="L269">    MoveRecordInfo result = moveSnapshots(results, targetStorage);</span>
<span class="fc" id="L270">    return result.toString();</span>
  }


  /**
   * Spawns a job to move a all snapshots taken between two points from their
   * current storage to a new target storage location
   *
   * @param start
   *  The start {@link Date}
   * @param end
   *  The end {@link Date}
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The {@link Job}
   */
  public Job moveByDate(final Date start, final Date end, final String targetStorage) {
<span class="fc" id="L288">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="fc" id="L289">    RequireUtil.notNull(end, &quot;end&quot;);</span>
<span class="fc" id="L290">    RequireUtil.notNull(targetStorage, &quot;targetStorage&quot;);</span>
<span class="fc" id="L291">    List&lt;String&gt; args = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L292">    args.add(targetStorage);</span>
<span class="fc" id="L293">    args.add(Long.toString(start.getTime()));</span>
<span class="fc" id="L294">    args.add(Long.toString(end.getTime()));</span>

    try {
<span class="fc" id="L297">      return serviceRegistry.createJob(</span>
<span class="fc" id="L298">          JOB_TYPE, Operation.MoveByDate.toString(), args, null, true, NONTERMINAL_JOB_LOAD);</span>
<span class="nc" id="L299">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L300">      throw new AssetManagerException(&quot;Unable to create a job&quot;, e);</span>
    }
  }

  /**
   * Spawns subjobs on a per-snapshot level to move the appropriate snapshots to their new home
   * Moves all the appropriate snapshots to their new home
   *
   * @param start
   *  The start {@link Date}
   * @param end
   *  The end {@link Date}
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The number of subjobs spawned
   */
  protected String internalMoveByDate(final Date start, final Date end, final String targetStorage) {
<span class="fc" id="L318">    RichAResult results = tsam.getSnapshotsByDateOrderedById(start, end);</span>
<span class="fc" id="L319">    List&lt;Job&gt; subjobs = spawnSubjobs(results, start, end, targetStorage);</span>
<span class="fc" id="L320">    return Integer.toString(subjobs.size());</span>
  }

  /**
   * Spawns a job to move a all snapshots of a given mediapackage taken between
   * two points from their current storage to a new target storage location
   *
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param start
   *  The start {@link Date}
   * @param end
   *  The end {@link Date}
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The {@link Job}
   */
  public Job moveByIdAndDate(final String mpId, final Date start, final Date end, final String targetStorage) {
<span class="fc" id="L339">    RequireUtil.notNull(mpId, &quot;mpId&quot;);</span>
<span class="fc" id="L340">    RequireUtil.notNull(start, &quot;start&quot;);</span>
<span class="fc" id="L341">    RequireUtil.notNull(end, &quot;end&quot;);</span>
<span class="fc" id="L342">    RequireUtil.notNull(targetStorage, &quot;targetStorage&quot;);</span>
<span class="fc" id="L343">    List&lt;String&gt; args = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L344">    args.add(targetStorage);</span>
<span class="fc" id="L345">    args.add(mpId);</span>
<span class="fc" id="L346">    args.add(Long.toString(start.getTime()));</span>
<span class="fc" id="L347">    args.add(Long.toString(end.getTime()));</span>

    try {
<span class="fc" id="L350">      return serviceRegistry.createJob(</span>
<span class="fc" id="L351">          JOB_TYPE, Operation.MoveByIdAndDate.toString(), args, null, true, NONTERMINAL_JOB_LOAD);</span>
<span class="nc" id="L352">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L353">      throw new AssetManagerException(&quot;Unable to create a job&quot;, e);</span>
    }
  }

  /**
   * Moves all the appropriate snapshots to their new home
   *
   * @param mpId
   *  The mediapackage ID of the snapshot to move
   * @param start
   *  The start {@link Date}
   * @param end
   *  The end {@link Date}
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The JSON String containing the number of successful and failed moves
   *  {&quot;OK&quot;: 0,&quot;FAIL&quot;: 0}
   */
  protected String internalMoveByIdAndDate(
      final String mpId,
      final Date start,
      final Date end,
      final String targetStorage
  ) {
<span class="fc" id="L378">    RichAResult results = tsam.getSnapshotsByIdAndDateOrderedByVersion(mpId, start, end, true);</span>
<span class="fc" id="L379">    MoveRecordInfo result = moveSnapshots(results, targetStorage);</span>
<span class="fc" id="L380">    return result.toString();</span>
  }

  /**
   * Spawns the subjobs based on the stream of records
   *
   * @param records
   *  The stream of records containing the snapshots to move to the new target storage
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The set of subjobs
   */

  private List&lt;Job&gt; spawnSubjobs(
      final RichAResult records,
      final Date start,
      final Date end,
      final String targetStorage
  ) {
<span class="fc" id="L400">    List&lt;Job&gt; jobs = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L401">    MoveRecordInfo recordInfo = new MoveRecordInfo();</span>
<span class="fc" id="L402">    records.forEach(new Consumer&lt;ARecord&gt;() {</span>
      @Override
      public void accept(ARecord record) {
<span class="fc" id="L405">        Snapshot snap = record.getSnapshot().get();</span>
<span class="fc" id="L406">        String mediaPackageId = snap.getMediaPackage().getIdentifier().toString();</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (recordInfo.isNewMpId(mediaPackageId)) {</span>
<span class="fc" id="L408">          jobs.add(moveByIdAndDate(mediaPackageId,start,end,targetStorage));</span>
        }
<span class="fc" id="L410">      }</span>
    });
<span class="fc" id="L412">    return jobs;</span>
  }

  /**
   * Moves all snapshot based on the stream of records from its current storage to a new target storage location
   *
   * @param records
   *  The stream of records containing the snapshots to move to the new target storage
   * @param targetStorage
   *  The {@link RemoteAssetStore} ID where the snapshot should be moved
   * @return
   *  The {@link MoveRecordInfo}
   */
  private MoveRecordInfo moveSnapshots(final RichAResult records, final String targetStorage) {
<span class="fc" id="L426">    final MoveRecordInfo result = new MoveRecordInfo();</span>
<span class="fc" id="L427">    records.forEach(new Consumer&lt;ARecord&gt;() {</span>
      @Override
      public void accept(ARecord record) {
<span class="fc" id="L430">        Snapshot snap = record.getSnapshot().get();</span>
          try {
<span class="fc" id="L432">            logger.debug(&quot;moving Mediapackage {} Version {} from {} to {}&quot;,</span>
<span class="fc" id="L433">                snap.getMediaPackage().getIdentifier().toString(),</span>
<span class="fc" id="L434">                snap.getVersion().toString(),</span>
<span class="fc" id="L435">                snap.getStorageId(),</span>
                targetStorage
            );
<span class="fc" id="L438">            internalMoveByIdAndVersion(snap.getVersion(),</span>
<span class="fc" id="L439">                snap.getMediaPackage().getIdentifier().toString(),</span>
                targetStorage
            );
<span class="fc" id="L442">            result.addSuccess();</span>
<span class="nc" id="L443">          } catch (NotFoundException e) {</span>
<span class="nc" id="L444">            result.addFailed();</span>
<span class="nc" id="L445">            logger.warn(e.getMessage());</span>
<span class="fc" id="L446">          }</span>
<span class="fc" id="L447">      }</span>
    });
<span class="fc" id="L449">    return result;</span>
  }

  @Reference
  protected void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L454">    this.serviceRegistry = serviceRegistry;</span>
<span class="fc" id="L455">  }</span>

  @Override
  protected ServiceRegistry getServiceRegistry() {
<span class="nc" id="L459">    return this.serviceRegistry;</span>
  }

  @Reference
  protected void setAssetManager(AssetManager assetManager) {
<span class="fc" id="L464">    this.tsam = assetManager;</span>
<span class="fc" id="L465">  }</span>

  @Reference
  protected void setSecurityService(SecurityService securityService) {
<span class="fc" id="L469">    this.securityService = securityService;</span>
<span class="fc" id="L470">  }</span>

  @Override
  protected SecurityService getSecurityService() {
<span class="nc" id="L474">    return this.securityService;</span>
  }

  @Reference
  protected void setUserDirectoryService(UserDirectoryService uds) {
<span class="fc" id="L479">    this.userDirectoryService = uds;</span>
<span class="fc" id="L480">  }</span>

  @Override
  protected UserDirectoryService getUserDirectoryService() {
<span class="nc" id="L484">    return this.userDirectoryService;</span>
  }

  @Reference
  protected void setOrganizationDirectoryService(OrganizationDirectoryService os) {
<span class="fc" id="L489">    this.organizationDirectoryService = os;</span>
<span class="fc" id="L490">  }</span>

  @Override
  protected OrganizationDirectoryService getOrganizationDirectoryService() {
<span class="nc" id="L494">    return this.organizationDirectoryService;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>