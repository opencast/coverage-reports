<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Item.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-tobira</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.tobira.impl</a> &gt; <span class="el_source">Item.java</span></div><h1>Item.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.tobira.impl;

import static org.opencastproject.metadata.dublincore.DublinCore.PROPERTY_CREATED;
import static org.opencastproject.metadata.dublincore.DublinCore.PROPERTY_DESCRIPTION;
import static org.opencastproject.metadata.dublincore.DublinCore.PROPERTY_TITLE;

import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.TrackSupport;
import org.opencastproject.mediapackage.VideoStream;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreUtil;
import org.opencastproject.metadata.dublincore.EncodingSchemeUtils;
import org.opencastproject.metadata.mpeg7.MediaTimePointImpl;
import org.opencastproject.playlists.Playlist;
import org.opencastproject.search.api.SearchResult;
import org.opencastproject.security.api.AccessControlEntry;
import org.opencastproject.security.api.AccessControlList;
import org.opencastproject.security.api.AccessControlParser;
import org.opencastproject.security.api.AclScope;
import org.opencastproject.security.api.AuthorizationService;
import org.opencastproject.series.api.Series;
import org.opencastproject.util.Jsons;
import org.opencastproject.util.MimeType;
import org.opencastproject.workspace.api.Workspace;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;


/**
 * A item of the harvesting API, basically as a JSON object. Can be &quot;event&quot;, &quot;series&quot;,
 * &quot;event-deleted&quot; or &quot;series-deleted&quot;. Also contains the modified date, used for sorting.
 */
class Item {
<span class="nc" id="L71">  private static final Logger logger = LoggerFactory.getLogger(Item.class);</span>

  private Date modifiedDate;
  private Jsons.Val obj;

  /** Converts a event into the corresponding JSON representation */
<span class="nc" id="L77">  Item(SearchResult event, AuthorizationService authorizationService, Workspace workspace) {</span>
<span class="nc" id="L78">    this.modifiedDate = event.getModifiedDate();</span>

<span class="nc bnc" id="L80" title="All 2 branches missed.">    if (event.getDeletionDate() != null) {</span>
<span class="nc" id="L81">      this.obj = Jsons.obj(</span>
<span class="nc" id="L82">          Jsons.p(&quot;kind&quot;, &quot;event-deleted&quot;),</span>
<span class="nc" id="L83">          Jsons.p(&quot;id&quot;, event.getId()),</span>
<span class="nc" id="L84">          Jsons.p(&quot;updated&quot;, event.getModifiedDate().getTime())</span>
      );
    } else {
<span class="nc" id="L87">      final var mp = event.getMediaPackage();</span>
<span class="nc" id="L88">      final var dccs = getDccsFromMp(mp, workspace);</span>

      // Figure out whether this is a live event
<span class="nc" id="L91">      final var isLive = Arrays.stream(mp.getTracks()).anyMatch(track -&gt; track.isLive());</span>

      // Obtain creators. We first try to obtain it from the DCCs. We collect
      // into `LinkedHashSet` to deduplicate entries.
<span class="nc" id="L95">      final var creators = dccs.stream()</span>
<span class="nc" id="L96">              .flatMap(dcc -&gt; dcc.get(DublinCore.PROPERTY_CREATOR).stream())</span>
<span class="nc" id="L97">              .filter(Objects::nonNull)</span>
<span class="nc" id="L98">              .map(creator -&gt; Jsons.v(creator.getValue()))</span>
<span class="nc" id="L99">              .collect(Collectors.toCollection(LinkedHashSet::new));</span>

      // Get start and end time
<span class="nc" id="L102">      final var period = dccs.stream()</span>
<span class="nc" id="L103">              .map(dcc -&gt; dcc.getFirst(DublinCore.PROPERTY_TEMPORAL))</span>
<span class="nc" id="L104">              .filter(Objects::nonNull)</span>
<span class="nc" id="L105">              .findFirst()</span>
<span class="nc" id="L106">              .flatMap(str -&gt; {</span>
                try {
<span class="nc" id="L108">                  return Optional.of(EncodingSchemeUtils.decodeMandatoryPeriod(str));</span>
<span class="nc" id="L109">                } catch (Exception e) {</span>
<span class="nc" id="L110">                  return Optional.empty();</span>
                }
              });

      // Get title. We require a title and will consult all three sources for it, in decreasing
      // order of trust in that source.
<span class="nc" id="L116">      var title = dccs.stream()</span>
<span class="nc" id="L117">              .map(dcc -&gt; dcc.getFirst(DublinCore.PROPERTY_TITLE))</span>
<span class="nc" id="L118">              .filter(Objects::nonNull)</span>
<span class="nc" id="L119">              .findFirst()</span>
<span class="nc" id="L120">              .orElse(mp.getTitle());</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">      if (title == null) {</span>
        // If there is no title to be found, we throw an exception to skip this event.
<span class="nc" id="L123">        throw new RuntimeException(&quot;Event has no title&quot;);</span>
      }

<span class="nc" id="L126">      final var captions = findCaptions(mp);</span>

      // Get the generated slide text.
<span class="nc" id="L129">      final var slideText = Arrays.stream(mp.getElements())</span>
<span class="nc" id="L130">          .filter(mpe -&gt; mpe.getFlavor().eq(&quot;mpeg-7/text&quot;))</span>
<span class="nc" id="L131">          .map(element -&gt; element.getURI())</span>
<span class="nc" id="L132">          .findFirst();</span>

      // Obtain duration from tracks, as that's usually more accurate (stores information from
      // inspect operations). Fall back to `getDcExtent`.
<span class="nc" id="L136">      final var duration = Arrays.stream(mp.getTracks())</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">          .filter(track -&gt; track.hasVideo() || track.hasAudio())</span>
<span class="nc" id="L138">          .map(Track::getDuration)</span>
<span class="nc bnc" id="L139" title="All 4 branches missed.">          .filter(d -&gt; d != null &amp;&amp; d &gt; 0)</span>
<span class="nc" id="L140">          .mapToLong(Long::longValue)</span>
          // Not entirely clear how to combine different track durations. Taking the max is not
          // worse than any other thing that I can think of. And usually all durations are basically
          // the same.
<span class="nc" id="L144">          .max()</span>
          //NB: This is an else case, so we ignore the item(s) in the stream
<span class="nc" id="L146">          .orElseGet(() -&gt; {</span>
<span class="nc" id="L147">            String dcExtent = event.getDublinCore().getFirst(DublinCore.PROPERTY_EXTENT);</span>
<span class="nc" id="L148">            return Math.max(0L, EncodingSchemeUtils.decodeMandatoryDuration(dcExtent));</span>
          });

<span class="nc" id="L151">      this.obj = Jsons.obj(</span>
<span class="nc" id="L152">          Jsons.p(&quot;kind&quot;, &quot;event&quot;),</span>
<span class="nc" id="L153">          Jsons.p(&quot;id&quot;, event.getId()),</span>
<span class="nc" id="L154">          Jsons.p(&quot;title&quot;, title),</span>
<span class="nc" id="L155">          Jsons.p(&quot;partOf&quot;, event.getDublinCore().getFirst(DublinCore.PROPERTY_IS_PART_OF)),</span>
<span class="nc" id="L156">          Jsons.p(&quot;description&quot;, event.getDublinCore().getFirst(PROPERTY_DESCRIPTION)),</span>
<span class="nc" id="L157">          Jsons.p(&quot;created&quot;, event.getCreatedDate().toEpochMilli()),</span>
<span class="nc" id="L158">          Jsons.p(&quot;startTime&quot;, period.map(p -&gt; p.getStart().getTime()).orElse(null)),</span>
<span class="nc" id="L159">          Jsons.p(&quot;endTime&quot;, period.map(p -&gt; p.getEnd().getTime()).orElse(null)),</span>
<span class="nc" id="L160">          Jsons.p(&quot;creators&quot;, Jsons.arr(new ArrayList&lt;&gt;(creators))),</span>
<span class="nc" id="L161">          Jsons.p(&quot;duration&quot;, duration),</span>
<span class="nc" id="L162">          Jsons.p(&quot;thumbnail&quot;, findThumbnail(mp)),</span>
<span class="nc" id="L163">          Jsons.p(&quot;timelinePreview&quot;, findTimelinePreview(mp)),</span>
<span class="nc" id="L164">          Jsons.p(&quot;tracks&quot;, Jsons.arr(assembleTracks(event, mp))),</span>
<span class="nc" id="L165">          Jsons.p(&quot;acl&quot;, assembleAcl(authorizationService.getAcl(mp, AclScope.Merged).getA().getEntries())),</span>
<span class="nc" id="L166">          Jsons.p(&quot;isLive&quot;, isLive),</span>
<span class="nc" id="L167">          Jsons.p(&quot;metadata&quot;, dccToMetadata(dccs, Set.of(new String[] {</span>
              &quot;created&quot;, &quot;creator&quot;, &quot;title&quot;, &quot;extent&quot;, &quot;isPartOf&quot;, &quot;description&quot;, &quot;identifier&quot;,
          }))),
<span class="nc" id="L170">          Jsons.p(&quot;captions&quot;, Jsons.arr(captions)),</span>
<span class="nc" id="L171">          Jsons.p(&quot;slideText&quot;, slideText.map(t -&gt; t.toString()).orElse(null)),</span>
<span class="nc" id="L172">          Jsons.p(&quot;segments&quot;, Jsons.arr(findSegments(mp))),</span>
<span class="nc" id="L173">          Jsons.p(&quot;updated&quot;, event.getModifiedDate().getTime())</span>
      );
    }
<span class="nc" id="L176">  }</span>

  private static List&lt;DublinCoreCatalog&gt; getDccsFromMp(MediaPackage mp, Workspace workspace) {
<span class="nc" id="L179">    return Arrays.stream(mp.getElements())</span>
<span class="nc" id="L180">            .filter(mpe -&gt; {</span>
<span class="nc" id="L181">              final var flavor = mpe.getFlavor();</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">              if (flavor == null) {</span>
<span class="nc" id="L183">                return false;</span>
              }
<span class="nc" id="L185">              final var isForEpisode = Objects.equals(flavor.getSubtype(), &quot;episode&quot;);</span>
<span class="nc" id="L186">              final var isCatalog = Objects.equals(mpe.getElementType(), MediaPackageElement.Type.Catalog);</span>
<span class="nc" id="L187">              final var isXml = Objects.equals(mpe.getMimeType(), MimeType.mimeType(&quot;text&quot;, &quot;xml&quot;));</span>
<span class="nc bnc" id="L188" title="All 6 branches missed.">              return isCatalog &amp;&amp; isForEpisode &amp;&amp; isXml;</span>
            })
<span class="nc" id="L190">            .map(mpe -&gt; DublinCoreUtil.loadDublinCore(workspace, mpe))</span>
<span class="nc" id="L191">            .collect(Collectors.toCollection(ArrayList::new));</span>
  }

  /**
   * Assembles the object containing all additional metadata.
   *
   * The second argument is a list of dcterms metadata fields that is already included elsewhere in
   * the response. They will be ignored here.
   */
  private static Jsons.Obj dccToMetadata(List&lt;DublinCoreCatalog&gt; dccs, Set&lt;String&gt; ignoredDcFields) {
<span class="nc" id="L201">    final var namespaces = new HashMap&lt;String, ArrayList&lt;Jsons.Prop&gt;&gt;();</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">    for (final var dcc : (Iterable&lt;DublinCoreCatalog&gt;) dccs::iterator) {</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">      for (final var e : dcc.getValues().entrySet()) {</span>
<span class="nc" id="L205">        final var key = e.getKey();</span>

        // We special case dcterms here to get a smaller, easier to read JSON. In most cases, this
        // will be the only namespace.
<span class="nc bnc" id="L209" title="All 2 branches missed.">        final var ns = key.getNamespaceURI().equals(&quot;http://purl.org/dc/terms/&quot;)</span>
<span class="nc" id="L210">            ? &quot;dcterms&quot;</span>
<span class="nc" id="L211">            : key.getNamespaceURI();</span>

        // We skip fields that we already include elsewhere.
<span class="nc bnc" id="L214" title="All 4 branches missed.">        if (ns.equals(&quot;dcterms&quot;) &amp;&amp; ignoredDcFields.contains(key.getLocalName())) {</span>
<span class="nc" id="L215">          continue;</span>
        }

<span class="nc" id="L218">        final var fields = namespaces.computeIfAbsent(ns, k -&gt; new ArrayList&lt;&gt;());</span>
<span class="nc" id="L219">        final var values = e.getValue().stream()</span>
<span class="nc" id="L220">            .map(v -&gt; Jsons.v(v.getValue()))</span>
<span class="nc" id="L221">            .collect(Collectors.toCollection(ArrayList::new));</span>
<span class="nc" id="L222">        final var field = Jsons.p(e.getKey().getLocalName(), Jsons.arr(values));</span>
<span class="nc" id="L223">        fields.add(field);</span>
<span class="nc" id="L224">      }</span>
<span class="nc" id="L225">    }</span>

<span class="nc" id="L227">    final var fields = namespaces.entrySet().stream()</span>
<span class="nc" id="L228">        .map(e -&gt; {</span>
<span class="nc" id="L229">          final var obj = Jsons.obj(e.getValue().toArray(new Jsons.Prop[0]));</span>
<span class="nc" id="L230">          return Jsons.p(e.getKey(), obj);</span>
        })
<span class="nc" id="L232">        .toArray(Jsons.Prop[]::new);</span>

<span class="nc" id="L234">    return Jsons.obj(fields);</span>
  }

  private static Jsons.Obj assembleAcl(List&lt;AccessControlEntry&gt; acl) {
    // We just transform the ACL into a map with one field per action, and the
    // value being a list of roles, e.g.
    // `{ &quot;read&quot;: [&quot;ROLE_USER&quot;, &quot;ROLE_FOO&quot;], &quot;write&quot;: [...] }`
<span class="nc" id="L241">    final var actionToRoles = new HashMap&lt;String, ArrayList&lt;Jsons.Val&gt;&gt;();</span>
<span class="nc" id="L242">    acl.stream().filter(AccessControlEntry::isAllow).forEach(entry -&gt; {</span>
<span class="nc" id="L243">      final var action = entry.getAction();</span>
<span class="nc" id="L244">      actionToRoles.putIfAbsent(action, new ArrayList&lt;&gt;());</span>
<span class="nc" id="L245">      actionToRoles.get(action).add(Jsons.v(entry.getRole()));</span>
<span class="nc" id="L246">    });</span>

<span class="nc" id="L248">    final var props = actionToRoles.entrySet().stream()</span>
<span class="nc" id="L249">        .map(e -&gt; Jsons.p(e.getKey(), Jsons.arr(e.getValue())))</span>
<span class="nc" id="L250">        .toArray(Jsons.Prop[]::new);</span>

<span class="nc" id="L252">    return Jsons.obj(props);</span>
  }

  private static List&lt;Jsons.Val&gt; assembleTracks(SearchResult event, MediaPackage mp) {
<span class="nc" id="L256">    return Arrays.stream(mp.getTracks())</span>
<span class="nc bnc" id="L257" title="All 4 branches missed.">        .filter(track -&gt; track.hasAudio() || track.hasVideo())</span>
<span class="nc" id="L258">        .map(track -&gt; {</span>
<span class="nc" id="L259">          var videoStreams = TrackSupport.byType(track.getStreams(), VideoStream.class);</span>
<span class="nc" id="L260">          var resolution = Jsons.NULL;</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">          if (videoStreams.length &gt; 0) {</span>
<span class="nc" id="L262">            final var stream = videoStreams[0];</span>
<span class="nc" id="L263">            resolution = Jsons.arr(Jsons.v(stream.getFrameWidth()), Jsons.v(stream.getFrameHeight()));</span>

<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (videoStreams.length &gt; 1) {</span>
<span class="nc" id="L266">              logger.warn(</span>
                  &quot;Track of event {} has more than one video stream; we will ignore all but the first&quot;,
<span class="nc" id="L268">                  event.getId()</span>
              );
            }
          }

<span class="nc" id="L273">          return Jsons.obj(</span>
<span class="nc" id="L274">              Jsons.p(&quot;uri&quot;, track.getURI().toString()),</span>
<span class="nc" id="L275">              Jsons.p(&quot;mimetype&quot;, track.getMimeType().toString()),</span>
<span class="nc" id="L276">              Jsons.p(&quot;flavor&quot;, track.getFlavor().toString()),</span>
<span class="nc" id="L277">              Jsons.p(&quot;resolution&quot;, resolution),</span>
<span class="nc" id="L278">              Jsons.p(&quot;isMaster&quot;, track.isMaster())</span>
          );
        })
<span class="nc" id="L281">        .collect(Collectors.toCollection(ArrayList::new));</span>
  }

  private static List&lt;Jsons.Val&gt; findCaptions(MediaPackage mp) {
<span class="nc" id="L285">    return Arrays.stream(mp.getElements())</span>
<span class="nc" id="L286">        .filter(element -&gt; {</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">          final var isVTT = element.getFlavor().toString().startsWith(&quot;captions/vtt&quot;)</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                || element.getMimeType().eq(&quot;text&quot;, &quot;vtt&quot;);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">          final var isCorrectType = element.getElementType() == MediaPackageElement.Type.Attachment</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                || element.getElementType() == MediaPackageElement.Type.Track;</span>

<span class="nc bnc" id="L292" title="All 4 branches missed.">          return isVTT &amp;&amp; isCorrectType;</span>
        })
<span class="nc" id="L294">        .map(track -&gt; {</span>
<span class="nc" id="L295">          final var tags = track.getTags();</span>
<span class="nc" id="L296">          final Function&lt;String, Optional&lt;String&gt;&gt; findTag = (String prefix) -&gt; Arrays.stream(tags)</span>
<span class="nc" id="L297">                .map(tag -&gt; tag.split(&quot;:&quot;, 2))</span>
<span class="nc bnc" id="L298" title="All 4 branches missed.">                .filter(tagArray -&gt; (tagArray.length == 2 &amp;&amp; tagArray[0].equals(prefix)))</span>
<span class="nc" id="L299">                .map(tagArray -&gt; tagArray[1])</span>
<span class="nc" id="L300">                .findFirst();</span>

          // Try to get a language for this subtitle track. We first check the proper tag.
<span class="nc" id="L303">          var lang = findTag.apply(&quot;lang&quot;);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">          if (lang.isEmpty()) {</span>
            // But for compatibility, we also check in the flavor.
<span class="nc" id="L306">            final var subflavor = track.getFlavor().getSubtype();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">            if (subflavor.startsWith(&quot;vtt+&quot;)) {</span>
<span class="nc" id="L308">              final var suffix = subflavor.substring(&quot;vtt+&quot;.length());</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">              if (suffix.length() &gt; 0) {</span>
<span class="nc" id="L310">                lang = Optional.of(suffix);</span>
              }
            }
          }

<span class="nc" id="L315">          return Jsons.obj(</span>
<span class="nc" id="L316">            Jsons.p(&quot;uri&quot;, track.getURI().toString()),</span>
<span class="nc" id="L317">            Jsons.p(&quot;lang&quot;, lang.orElse(null)),</span>
<span class="nc" id="L318">            Jsons.p(&quot;generatorType&quot;, findTag.apply(&quot;generator-type&quot;).orElse(null)),</span>
<span class="nc" id="L319">            Jsons.p(&quot;generator&quot;, findTag.apply(&quot;generator&quot;).orElse(null)),</span>
<span class="nc" id="L320">            Jsons.p(&quot;type&quot;, findTag.apply(&quot;type&quot;).orElse(null))</span>
          );
        })
<span class="nc" id="L323">        .collect(Collectors.toCollection(ArrayList::new));</span>
  }

  private static String findThumbnail(MediaPackage mp) {
    // Find a suitable thumbnail.
    // TODO: This certainly has to be improved in the future.
<span class="nc" id="L329">    return Arrays.stream(mp.getAttachments())</span>
<span class="nc" id="L330">        .filter(a -&gt; a.getFlavor().getSubtype().equals(&quot;player+preview&quot;))</span>
<span class="nc" id="L331">        .map(a -&gt; a.getURI().toString())</span>
<span class="nc" id="L332">        .findFirst()</span>
<span class="nc" id="L333">        .orElse(null);</span>
  }

  private static List&lt;Jsons.Val&gt; findSegments(MediaPackage mp) {
<span class="nc" id="L337">    return Arrays.stream(mp.getAttachments())</span>
<span class="nc" id="L338">      .filter(a -&gt; a.getFlavor().getSubtype().equals(&quot;segment+preview&quot;))</span>
<span class="nc" id="L339">      .map(s -&gt; Jsons.obj(</span>
<span class="nc" id="L340">          Jsons.p(&quot;uri&quot;, s.getURI().toString()),</span>
<span class="nc" id="L341">          Jsons.p(&quot;startTime&quot;, MediaTimePointImpl.parseTimePoint(</span>
<span class="nc" id="L342">              s.getReference().getProperty(&quot;time&quot;)</span>
<span class="nc" id="L343">          ).getTimeInMilliseconds())</span>
      ))
<span class="nc" id="L345">      .collect(Collectors.toCollection(ArrayList::new));</span>
  }

  private static Jsons.Val findTimelinePreview(MediaPackage mp) {
<span class="nc" id="L349">    return Arrays.stream(mp.getAttachments())</span>
<span class="nc" id="L350">        .filter(a -&gt; a.getFlavor().getSubtype().equals(&quot;timeline+preview&quot;))</span>
<span class="nc" id="L351">        .map(a -&gt; {</span>
<span class="nc" id="L352">          final var props = a.getProperties();</span>
<span class="nc" id="L353">          final var imageCountX = props.get(&quot;imageSizeX&quot;);</span>
<span class="nc" id="L354">          final var imageCountY = props.get(&quot;imageSizeY&quot;);</span>
<span class="nc" id="L355">          final var resolutionX = props.get(&quot;resolutionX&quot;);</span>
<span class="nc" id="L356">          final var resolutionY = props.get(&quot;resolutionY&quot;);</span>

<span class="nc bnc" id="L358" title="All 8 branches missed.">          final var anyNull = imageCountX == null</span>
              || imageCountY == null
              || resolutionX == null
              || resolutionY == null;

<span class="nc bnc" id="L363" title="All 2 branches missed.">          if (anyNull) {</span>
<span class="nc" id="L364">            return null;</span>
          }

<span class="nc" id="L367">          return (Jsons.Val) Jsons.obj(</span>
<span class="nc" id="L368">            Jsons.p(&quot;url&quot;, a.getURI().toString()),</span>
<span class="nc" id="L369">            Jsons.p(&quot;imageCountX&quot;, imageCountX),</span>
<span class="nc" id="L370">            Jsons.p(&quot;imageCountY&quot;, imageCountY),</span>
<span class="nc" id="L371">            Jsons.p(&quot;resolutionX&quot;, resolutionX),</span>
<span class="nc" id="L372">            Jsons.p(&quot;resolutionY&quot;, resolutionY)</span>
          );
        })
<span class="nc bnc" id="L375" title="All 2 branches missed.">        .filter(o -&gt; o != null)</span>
<span class="nc" id="L376">        .findFirst()</span>
<span class="nc" id="L377">        .orElse(Jsons.NULL);</span>
  }

  /** Converts a series into the corresponding JSON representation */
<span class="nc" id="L381">  Item(Series series) {</span>
<span class="nc" id="L382">    this.modifiedDate = series.getModifiedDate();</span>

<span class="nc" id="L384">    var serializedACL = series.getAccessControl();</span>
<span class="nc" id="L385">    var acl = new AccessControlList();</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">    if (serializedACL != null) {</span>
      try {
<span class="nc" id="L388">        acl = AccessControlParser.parseAcl(serializedACL);</span>
<span class="nc" id="L389">      } catch (Exception e) {</span>
<span class="nc" id="L390">        throw new RuntimeException(e);</span>
<span class="nc" id="L391">      }</span>
    }

<span class="nc bnc" id="L394" title="All 2 branches missed.">    if (series.isDeleted()) {</span>
<span class="nc" id="L395">      this.obj = Jsons.obj(</span>
<span class="nc" id="L396">        Jsons.p(&quot;kind&quot;, &quot;series-deleted&quot;),</span>
<span class="nc" id="L397">        Jsons.p(&quot;id&quot;, series.getId()),</span>
<span class="nc" id="L398">        Jsons.p(&quot;updated&quot;, series.getModifiedDate().getTime())</span>
      );
    } else {
      // Created date
<span class="nc" id="L402">      var createdDateString = series.getDublinCore().getFirst(PROPERTY_CREATED);</span>
<span class="nc" id="L403">      var created = Jsons.NULL;</span>
<span class="nc" id="L404">      var date = EncodingSchemeUtils.decodeDate(createdDateString);</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">      if (date != null) {</span>
<span class="nc" id="L406">        created = Jsons.v(date.getTime());</span>
      } else {
<span class="nc" id="L408">        logger.warn(&quot;Series {} has unparsable created-date: {}&quot;, series.getId(), createdDateString);</span>
      }

<span class="nc" id="L411">      var additionalMetadata = dccToMetadata(Arrays.asList(series.getDublinCore()), Set.of(new String[] {</span>
          &quot;created&quot;, &quot;title&quot;, &quot;description&quot;, &quot;identifier&quot;,
      }));

<span class="nc" id="L415">      this.obj = Jsons.obj(</span>
<span class="nc" id="L416">        Jsons.p(&quot;kind&quot;, &quot;series&quot;),</span>
<span class="nc" id="L417">        Jsons.p(&quot;id&quot;, series.getId()),</span>
<span class="nc" id="L418">        Jsons.p(&quot;title&quot;, series.getDublinCore().getFirst(PROPERTY_TITLE)),</span>
<span class="nc" id="L419">        Jsons.p(&quot;description&quot;, series.getDublinCore().getFirst(PROPERTY_DESCRIPTION)),</span>
<span class="nc" id="L420">        Jsons.p(&quot;acl&quot;, assembleAcl(acl.getEntries())),</span>
<span class="nc" id="L421">        Jsons.p(&quot;metadata&quot;, additionalMetadata),</span>
<span class="nc" id="L422">        Jsons.p(&quot;created&quot;, created),</span>
<span class="nc" id="L423">        Jsons.p(&quot;updated&quot;, series.getModifiedDate().getTime())</span>
      );
    }
<span class="nc" id="L426">  }</span>

  /** Converts a series into the corresponding JSON representation */
<span class="nc" id="L429">  Item(Playlist playlist) {</span>
<span class="nc" id="L430">    this.modifiedDate = playlist.getUpdated();</span>

<span class="nc" id="L432">    final var acl = assembleAcl(</span>
<span class="nc" id="L433">        playlist.getAccessControlEntries()</span>
<span class="nc" id="L434">            .stream()</span>
<span class="nc" id="L435">            .map(entry -&gt; entry.toAccessControlEntry())</span>
<span class="nc" id="L436">            .collect(Collectors.toList())</span>
    );

    // Assemble entries
<span class="nc" id="L440">    final List&lt;Jsons.Val&gt; entries = playlist.getEntries().stream().map(entry -&gt; Jsons.obj(</span>
<span class="nc" id="L441">          Jsons.p(&quot;id&quot;, entry.getId()),</span>
<span class="nc" id="L442">          Jsons.p(&quot;contentId&quot;, entry.getContentId()),</span>
<span class="nc" id="L443">          Jsons.p(&quot;type&quot;, entry.getType().getCode())</span>
<span class="nc" id="L444">    )).collect(Collectors.toCollection(ArrayList::new));</span>

<span class="nc bnc" id="L446" title="All 2 branches missed.">    if (playlist.isDeleted()) {</span>
<span class="nc" id="L447">      this.obj = Jsons.obj(</span>
<span class="nc" id="L448">        Jsons.p(&quot;kind&quot;, &quot;playlist-deleted&quot;),</span>
<span class="nc" id="L449">        Jsons.p(&quot;id&quot;, playlist.getId()),</span>
<span class="nc" id="L450">        Jsons.p(&quot;updated&quot;, playlist.getUpdated().getTime())</span>
      );
    } else {
<span class="nc" id="L453">      this.obj = Jsons.obj(</span>
<span class="nc" id="L454">        Jsons.p(&quot;kind&quot;, &quot;playlist&quot;),</span>
<span class="nc" id="L455">        Jsons.p(&quot;id&quot;, playlist.getId()),</span>
<span class="nc" id="L456">        Jsons.p(&quot;title&quot;, playlist.getTitle()),</span>
<span class="nc" id="L457">        Jsons.p(&quot;description&quot;, playlist.getDescription()),</span>
<span class="nc" id="L458">        Jsons.p(&quot;creator&quot;, playlist.getCreator()),</span>
<span class="nc" id="L459">        Jsons.p(&quot;entries&quot;, Jsons.arr(entries)),</span>
<span class="nc" id="L460">        Jsons.p(&quot;acl&quot;, acl),</span>
<span class="nc" id="L461">        Jsons.p(&quot;updated&quot;, this.modifiedDate.getTime())</span>
      );
    }
<span class="nc" id="L464">  }</span>

  Date getModifiedDate() {
<span class="nc" id="L467">    return this.modifiedDate;</span>
  }

  Jsons.Val getJson() {
<span class="nc" id="L471">    return this.obj;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>