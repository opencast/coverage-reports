<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RuntimeInfo.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-runtime-info</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.runtimeinfo</a> &gt; <span class="el_source">RuntimeInfo.java</span></div><h1>RuntimeInfo.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.runtimeinfo;

import static org.opencastproject.rest.RestConstants.SERVICES_FILTER;

import org.opencastproject.rest.RestConstants;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.Role;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.User;
import org.opencastproject.serviceregistry.api.HostRegistration;
import org.opencastproject.serviceregistry.api.ServiceRegistration;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.userdirectory.UserIdRoleProvider;
import org.opencastproject.util.UrlSupport;
import org.opencastproject.util.doc.rest.RestQuery;
import org.opencastproject.util.doc.rest.RestResponse;
import org.opencastproject.util.doc.rest.RestService;

import com.google.gson.Gson;

import org.apache.commons.lang3.StringUtils;
import org.osgi.framework.BundleContext;
import org.osgi.framework.Constants;
import org.osgi.framework.InvalidSyntaxException;
import org.osgi.framework.ServiceReference;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.osgi.service.jaxrs.whiteboard.propertytypes.JaxrsResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Collectors;

import javax.servlet.Servlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * This REST endpoint provides information about the runtime environment, including the services and user interfaces
 * deployed and the current login context.
 *
 * If the 'org.opencastproject.anonymous.feedback.url' is set in config.properties, this service will also update the
 * opencast project with the contents of the getRuntimeInfo() json feed.
 */
@Path(&quot;/info&quot;)
@RestService(
    name = &quot;RuntimeInfo&quot;,
    title = &quot;Runtime Information&quot;,
    abstractText = &quot;This service provides information about the runtime environment, including the services that are &quot;
      + &quot;deployed and the current user context.&quot;,
    notes = {}
)
@Tag(name = &quot;Runtime Information&quot;, description = &quot;This service provides information about the runtime environment, &quot;
    + &quot;including the services that are deployed and the current user context.&quot;)
@Component(
    service = RuntimeInfo.class,
    property = {
        &quot;service.description=Runtime Information REST Endpoint&quot;,
        &quot;opencast.service.type=org.opencastproject.info&quot;,
        &quot;opencast.service.path=/info&quot;,
    }
)
@JaxrsResource
<span class="fc" id="L110">public class RuntimeInfo {</span>

<span class="fc" id="L112">  private static final Logger logger = LoggerFactory.getLogger(RuntimeInfo.class);</span>

  /** Configuration properties id */
  private static final String ADMIN_URL_PROPERTY = &quot;org.opencastproject.admin.ui.url&quot;;
  private static final String ENGAGE_URL_PROPERTY = &quot;org.opencastproject.engage.ui.url&quot;;

<span class="fc" id="L118">  private static final Gson gson = new Gson();</span>

  /* Health Check values */
  public static final String HEALTH_CHECK_VERSION = &quot;1&quot;;
  public static final String HEALTH_CHECK_STATUS_PASS = &quot;pass&quot;;
  public static final String HEALTH_CHECK_STATUS_WARN = &quot;warn&quot;;
  public static final String HEALTH_CHECK_STATUS_FAIL = &quot;fail&quot;;

  /**
   * The rest publisher looks for any non-servlet with the 'opencast.service.path' property
   */
  public static final String SERVICE_FILTER = &quot;(&amp;(!(objectClass=javax.servlet.Servlet))(&quot;
          + RestConstants.SERVICE_PATH_PROPERTY + &quot;=*))&quot;;

  private UserIdRoleProvider userIdRoleProvider;
  private SecurityService securityService;
  private ServiceRegistry serviceRegistry;
  private BundleContext bundleContext;
  private URL serverUrl;

  @Reference(
      cardinality = ReferenceCardinality.OPTIONAL,
      policy = ReferencePolicy.DYNAMIC,
      unbind = &quot;unsetUserIdRoleProvider&quot;
  )
  protected void setUserIdRoleProvider(UserIdRoleProvider userIdRoleProvider) {
<span class="nc" id="L144">    this.userIdRoleProvider = userIdRoleProvider;</span>
<span class="nc" id="L145">  }</span>

  protected void unsetUserIdRoleProvider(UserIdRoleProvider userIdRoleProvider) {
<span class="nc bnc" id="L148" title="All 2 branches missed.">    if (this.userIdRoleProvider == userIdRoleProvider) {</span>
<span class="nc" id="L149">      this.userIdRoleProvider = null;</span>
    }
<span class="nc" id="L151">  }</span>

  @Reference
  protected void setSecurityService(SecurityService securityService) {
<span class="nc" id="L155">    this.securityService = securityService;</span>
<span class="nc" id="L156">  }</span>

  @Reference
  protected void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L160">    this.serviceRegistry = serviceRegistry;</span>
<span class="fc" id="L161">  }</span>

  private ServiceReference[] getRestServiceReferences() throws InvalidSyntaxException {
<span class="nc" id="L164">    return bundleContext.getAllServiceReferences(null, SERVICES_FILTER);</span>
  }

  private ServiceReference[] getUserInterfaceServiceReferences() throws InvalidSyntaxException {
<span class="nc" id="L168">    return bundleContext.getAllServiceReferences(Servlet.class.getName(), &quot;(&amp;(alias=*)(classpath=*))&quot;);</span>
  }

  @Activate
  public void activate(ComponentContext cc) throws MalformedURLException {
<span class="nc" id="L173">    logger.debug(&quot;start()&quot;);</span>
<span class="nc" id="L174">    this.bundleContext = cc.getBundleContext();</span>
<span class="nc" id="L175">    serverUrl = new URL(bundleContext.getProperty(OpencastConstants.SERVER_URL_PROPERTY));</span>
<span class="nc" id="L176">  }</span>

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path(&quot;components.json&quot;)
  @RestQuery(
      name = &quot;services&quot;,
      description = &quot;List the REST services and user interfaces running on this host&quot;,
      responses = {
          @RestResponse(description = &quot;The components running on this host&quot;, responseCode = HttpServletResponse.SC_OK)
      },
      returnDescription = &quot;&quot;
  )
  @Operation(
      summary = &quot;List the REST services and user interfaces running on this host&quot;,
      description = &quot;List the REST services and user interfaces running on this host&quot;
  )
  @ApiResponse(
      responseCode = &quot;200&quot;,
      description = &quot;The components running on this host&quot;
  )
  public String getRuntimeInfo(@Context HttpServletRequest request) throws MalformedURLException,
          InvalidSyntaxException {
<span class="nc" id="L199">    final Organization organization = securityService.getOrganization();</span>

    // Get request protocol and port
<span class="nc" id="L202">    final String targetScheme = request.getScheme();</span>

    // Create the engage target URL
<span class="nc" id="L205">    URL targetEngageBaseUrl = null;</span>
<span class="nc" id="L206">    final String orgEngageBaseUrl = organization.getProperties().get(ENGAGE_URL_PROPERTY);</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">    if (StringUtils.isNotBlank(orgEngageBaseUrl)) {</span>
      try {
<span class="nc" id="L209">        targetEngageBaseUrl = new URL(orgEngageBaseUrl);</span>
<span class="nc" id="L210">      } catch (MalformedURLException e) {</span>
<span class="nc" id="L211">        logger.warn(&quot;Engage url '{}' of organization '{}' is malformed&quot;, orgEngageBaseUrl, organization.getId());</span>
<span class="nc" id="L212">      }</span>
    }

<span class="nc bnc" id="L215" title="All 2 branches missed.">    if (targetEngageBaseUrl == null) {</span>
<span class="nc" id="L216">      logger.debug(</span>
          &quot;Using 'org.opencastproject.server.url' as a fallback for the non-existing organization &quot;
              + &quot;level key '{}' for the components.json response&quot;,
          ENGAGE_URL_PROPERTY);
<span class="nc" id="L220">      targetEngageBaseUrl = new URL(targetScheme, serverUrl.getHost(), serverUrl.getPort(), serverUrl.getFile());</span>
    }

    // Create the admin target URL
<span class="nc" id="L224">    URL targetAdminBaseUrl = null;</span>
<span class="nc" id="L225">    final String orgAdminBaseUrl = organization.getProperties().get(ADMIN_URL_PROPERTY);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">    if (StringUtils.isNotBlank(orgAdminBaseUrl)) {</span>
      try {
<span class="nc" id="L228">        targetAdminBaseUrl = new URL(orgAdminBaseUrl);</span>
<span class="nc" id="L229">      } catch (MalformedURLException e) {</span>
<span class="nc" id="L230">        logger.warn(&quot;Admin url '{}' of organization '{}' is malformed&quot;, orgAdminBaseUrl, organization.getId());</span>
<span class="nc" id="L231">      }</span>
    }

<span class="nc bnc" id="L234" title="All 2 branches missed.">    if (targetAdminBaseUrl == null) {</span>
<span class="nc" id="L235">      logger.debug(</span>
          &quot;Using 'org.opencastproject.server.url' as a fallback for the non-existing &quot;
              + &quot;organization level key '{}' for the components.json response&quot;,
          ADMIN_URL_PROPERTY);
<span class="nc" id="L239">      targetAdminBaseUrl = new URL(targetScheme, serverUrl.getHost(), serverUrl.getPort(), serverUrl.getFile());</span>
    }

<span class="nc" id="L242">    Map&lt;String, Object&gt; json = new HashMap&lt;&gt;();</span>
<span class="nc" id="L243">    json.put(&quot;engage&quot;, targetEngageBaseUrl.toString());</span>
<span class="nc" id="L244">    json.put(&quot;admin&quot;, targetAdminBaseUrl.toString());</span>
<span class="nc" id="L245">    json.put(&quot;rest&quot;, getRestEndpointsAsJson(request));</span>
<span class="nc" id="L246">    json.put(&quot;ui&quot;, getUserInterfacesAsJson());</span>

<span class="nc" id="L248">    return gson.toJson(json);</span>
  }

  @GET
  @Path(&quot;me.json&quot;)
  @Produces(MediaType.APPLICATION_JSON)
  @RestQuery(
      name = &quot;me&quot;,
      description = &quot;Information about the curent user&quot;,
      responses = {
          @RestResponse(
              description = &quot;Returns information about the current user&quot;,
              responseCode = HttpServletResponse.SC_OK
          ),
      },
      returnDescription = &quot;&quot;
  )
  @Operation(
      summary = &quot;Information about the curent user&quot;,
      description = &quot;Returns information about the current user&quot;
  )
  @ApiResponse(
      responseCode = &quot;200&quot;,
      description = &quot;Returns information about the current user&quot;
  )
  public String getMyInfo() {
<span class="nc" id="L274">    Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span>

<span class="nc" id="L276">    User user = securityService.getUser();</span>
<span class="nc" id="L277">    Map&lt;String, String&gt; jsonUser = new HashMap&lt;&gt;();</span>
<span class="nc" id="L278">    jsonUser.put(&quot;username&quot;, user.getUsername());</span>
<span class="nc" id="L279">    jsonUser.put(&quot;name&quot;, user.getName());</span>
<span class="nc" id="L280">    jsonUser.put(&quot;email&quot;, user.getEmail());</span>
<span class="nc" id="L281">    jsonUser.put(&quot;provider&quot;, user.getProvider());</span>
<span class="nc" id="L282">    result.put(&quot;user&quot;, jsonUser);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">    if (userIdRoleProvider != null) {</span>
<span class="nc" id="L284">      result.put(&quot;userRole&quot;, UserIdRoleProvider.getUserIdRole(user.getUsername()));</span>
    }

    // Add the current user's roles
<span class="nc" id="L288">    result.put(&quot;roles&quot;, user.getRoles().stream()</span>
<span class="nc" id="L289">            .map(Role::getName)</span>
<span class="nc" id="L290">            .collect(Collectors.toList()));</span>

    // Add the current user's organizational information
<span class="nc" id="L293">    Organization org = securityService.getOrganization();</span>

<span class="nc" id="L295">    Map&lt;String, Object&gt; jsonOrg = new HashMap&lt;&gt;();</span>
<span class="nc" id="L296">    jsonOrg.put(&quot;id&quot;, org.getId());</span>
<span class="nc" id="L297">    jsonOrg.put(&quot;name&quot;, org.getName());</span>
<span class="nc" id="L298">    jsonOrg.put(&quot;adminRole&quot;, org.getAdminRole());</span>
<span class="nc" id="L299">    jsonOrg.put(&quot;anonymousRole&quot;, org.getAnonymousRole());</span>
<span class="nc" id="L300">    jsonOrg.put(&quot;properties&quot;, org.getProperties());</span>
<span class="nc" id="L301">    result.put(&quot;org&quot;, jsonOrg);</span>

<span class="nc" id="L303">    return gson.toJson(result);</span>
  }

  @GET
  @Path(&quot;health&quot;)
  @Produces(&quot;application/health+json&quot;)
  @RestQuery(
      name = &quot;health&quot;,
      description = &quot;Opencast node health check. Implements this internet-draft health check api &quot;
          + &quot;https://inadarei.github.io/rfc-healthcheck&quot;,
      responses = {
          @RestResponse(
              responseCode = HttpServletResponse.SC_OK,
              description = &quot;Node is running, check reponse for details&quot;
          ),
          @RestResponse(
              responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE,
              description = &quot;Node is offline or unresponsive, check response for details&quot;
          ),
      },
      returnDescription = &quot;Details of the Opencast node's health status&quot;
  )
  @Operation(
      summary = &quot;Opencast node health check&quot;,
      description = &quot;Implements this internet-draft health check api &quot;
          + &quot;https://inadarei.github.io/rfc-healthcheck&quot;
  )
  @ApiResponses(
      value = {
          @ApiResponse(
              responseCode = &quot;200&quot;,
              description = &quot;Node is running, check response for details&quot;
          ),
          @ApiResponse(
              responseCode = &quot;503&quot;,
              description = &quot;Node is offline or unresponsive, check response for details&quot;
          )
      }
  )
  public String getHealth(@Context HttpServletResponse response) {
    /* Response implements https://inadarei.github.io/rfc-healthcheck
     * Example reponse
    {
        &quot;description&quot; : &quot;Opencast node's health status&quot;,
        &quot;releaseId&quot; : &quot;TEST&quot;,
        &quot;checks&quot; : {
           &quot;service:states&quot; : [
              {
                 &quot;observedValue&quot; : &quot;WARNING&quot;,
                 &quot;links&quot; : {
                    &quot;path&quot; : &quot;service1&quot;
                 },
                 &quot;changed&quot; : &quot;Tue Jun 04 11:15:27 BST 2019&quot;,
                 &quot;componentId&quot; : &quot;service1&quot;
              },
              {
                 &quot;changed&quot; : &quot;Tue Jun 04 11:15:27 BST 2019&quot;,
                 &quot;links&quot; : {
                    &quot;path&quot; : &quot;service2&quot;
                 },
                 &quot;observedValue&quot; : &quot;ERROR&quot;,
                 &quot;componentId&quot; : &quot;service2&quot;
              }
           ]
        },
        &quot;notes&quot; : [
           &quot;service(s) in WARN state&quot;,
           &quot;service(s) in ERROR state&quot;
        ],
        &quot;status&quot; : &quot;warn&quot;,
        &quot;serviceId&quot; : &quot;http://localhost&quot;,
        &quot;version&quot; : &quot;1&quot;
    }
     */

    // Conditional workaround for unit tests
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">    String releaseId = this.bundleContext != null ? this.bundleContext.getBundle().getVersion().toString() : &quot;TEST&quot;;</span>
<span class="fc" id="L380">    String hostname = serviceRegistry.getRegistryHostname();</span>
    Health health;
<span class="fc" id="L382">    Map&lt;String, Object&gt; checks = new HashMap&lt;&gt;();</span>

    try {
<span class="fc" id="L385">      HostRegistration host = serviceRegistry.getHostRegistration(hostname);</span>
<span class="fc" id="L386">      health = checkHostHealth(host);</span>
<span class="nc" id="L387">    } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L388">      logger.error(&quot;Failed to get host registration: &quot;, e);</span>
<span class="nc" id="L389">      health = new Health();</span>
<span class="nc" id="L390">      health.setStatus(HEALTH_CHECK_STATUS_FAIL);</span>
<span class="nc" id="L391">      health.addNote(&quot;internal health check error!&quot;);</span>
<span class="fc" id="L392">    }</span>

    // format response
<span class="fc" id="L395">    Map&lt;String, Object&gt; json = new HashMap&lt;&gt;();</span>
<span class="fc" id="L396">    json.put(&quot;status&quot;, health.getStatus());</span>
<span class="fc" id="L397">    json.put(&quot;version&quot;, HEALTH_CHECK_VERSION);</span>
<span class="fc" id="L398">    json.put(&quot;releaseId&quot;, releaseId);</span>
<span class="fc" id="L399">    json.put(&quot;serviceId&quot;, hostname);</span>
<span class="fc" id="L400">    json.put(&quot;description&quot;, &quot;Opencast node's health status&quot;);</span>

<span class="fc bfc" id="L402" title="All 2 branches covered.">    if (!health.getNotes().isEmpty()) {</span>
<span class="fc" id="L403">      json.put(&quot;notes&quot;, health.getNotes());</span>
    }

<span class="fc bfc" id="L406" title="All 2 branches covered.">    if (!health.getServiceStates().isEmpty()) {</span>
<span class="fc" id="L407">      checks.put(&quot;service:states&quot;, health.getServiceStates());</span>
    }

<span class="fc bfc" id="L410" title="All 2 branches covered.">    if (!checks.isEmpty()) {</span>
<span class="fc" id="L411">      json.put(&quot;checks&quot;, checks);</span>
    }

<span class="fc bfc" id="L414" title="All 2 branches covered.">    if (HEALTH_CHECK_STATUS_FAIL.equalsIgnoreCase(health.getStatus())) {</span>
<span class="fc" id="L415">      response.setStatus(HttpServletResponse.SC_SERVICE_UNAVAILABLE);</span>
    } else {
<span class="fc" id="L417">      response.setStatus(HttpServletResponse.SC_OK);</span>
    }

<span class="fc" id="L420">    return gson.toJson(json);</span>
  }

  private class Health {

    private String status;
    private List&lt;String&gt; notes;
    private List&lt;Object&gt; serviceStates;

<span class="fc" id="L429">    Health() {</span>
<span class="fc" id="L430">      status = HEALTH_CHECK_STATUS_PASS;</span>
<span class="fc" id="L431">      notes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L432">      serviceStates = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L433">    }</span>

    public String getStatus() {
<span class="fc" id="L436">      return status;</span>
    }

    public void setStatus(String status) {
<span class="fc" id="L440">      this.status = status;</span>
<span class="fc" id="L441">    }</span>

    public List&lt;String&gt; getNotes() {
<span class="fc" id="L444">      return notes;</span>
    }

    public void setNotes(List&lt;String&gt; notes) {
<span class="nc" id="L448">      this.notes = notes;</span>
<span class="nc" id="L449">    }</span>

    public List&lt;Object&gt; getServiceStates() {
<span class="fc" id="L452">      return serviceStates;</span>
    }

    public void setServiceStates(List&lt;Object&gt; serviceStates) {
<span class="nc" id="L456">      this.serviceStates = serviceStates;</span>
<span class="nc" id="L457">    }</span>

    public void addNote(String note) {
<span class="fc" id="L460">      notes.add(note);</span>
<span class="fc" id="L461">    }</span>

    public void addServiceState(Object serviceState) {
<span class="fc" id="L464">      serviceStates.add(serviceState);</span>
<span class="fc" id="L465">    }</span>
  }

  private Health checkHostHealth(HostRegistration host) {
<span class="fc" id="L469">    Health health = new Health();</span>

    // check most severe conditions first
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">    if (!host.isOnline()) {</span>
      // NOTE: This is not strictly possible as a node can't test if it's offline
<span class="nc" id="L474">      health.setStatus(HEALTH_CHECK_STATUS_FAIL);</span>
<span class="nc" id="L475">      health.addNote(&quot;node is offline&quot;);</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">    } else if (!host.isActive()) {</span>
<span class="fc" id="L477">      health.setStatus(HEALTH_CHECK_STATUS_FAIL);</span>
<span class="fc" id="L478">      health.addNote(&quot;node is disabled&quot;);</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">    } else if (host.isMaintenanceMode()) {</span>
<span class="fc" id="L480">      health.setStatus(HEALTH_CHECK_STATUS_FAIL);</span>
<span class="fc" id="L481">      health.addNote(&quot;node is in maintenance&quot;);</span>
    } else {
      // find non normal services
      try {
<span class="fc" id="L485">        List&lt;ServiceRegistration&gt; services = serviceRegistry.getServiceRegistrationsByHost(host.getBaseUrl());</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">        for (ServiceRegistration service : services) {</span>
<span class="fc bfc" id="L487" title="All 3 branches covered.">          switch (service.getServiceState()) {</span>
            case WARNING: {
<span class="fc" id="L489">              health.setStatus(HEALTH_CHECK_STATUS_WARN);</span>
<span class="fc" id="L490">              health.addNote(&quot;service(s) in WARN state&quot;);</span>
<span class="fc" id="L491">              health.addServiceState(getServiceStateAsJson(service));</span>
<span class="fc" id="L492">              break;</span>
            }
            case ERROR: {
<span class="fc" id="L495">              health.setStatus(HEALTH_CHECK_STATUS_WARN);</span>
<span class="fc" id="L496">              health.addNote(&quot;service(s) in ERROR state&quot;);</span>
<span class="fc" id="L497">              health.addServiceState(getServiceStateAsJson(service));</span>
<span class="fc" id="L498">              break;</span>
            }
            default:
              break;
          }
<span class="fc" id="L503">        }</span>
<span class="nc" id="L504">      } catch (ServiceRegistryException e) {</span>
<span class="nc" id="L505">        logger.error(&quot;Failed to get services: &quot;, e);</span>
<span class="nc" id="L506">        health.setStatus(HEALTH_CHECK_STATUS_FAIL);</span>
<span class="nc" id="L507">        health.addNote(&quot;internal health check error!&quot;);</span>
<span class="fc" id="L508">      }</span>
    }

<span class="fc" id="L511">    return health;</span>
  }

  protected Map&lt;String, Object&gt; getServiceStateAsJson(ServiceRegistration service) {
<span class="fc" id="L515">    Map&lt;String, Object&gt; json = new HashMap&lt;&gt;();</span>
<span class="fc" id="L516">    json.put(&quot;componentId&quot;, service.getServiceType());</span>
<span class="fc" id="L517">    json.put(&quot;observedValue&quot;, service.getServiceState().toString());</span>
<span class="fc" id="L518">    json.put(&quot;changed&quot;, service.getStateChanged().toString());</span>
<span class="fc" id="L519">    Map&lt;String, Object&gt; links = new HashMap&lt;&gt;();</span>
<span class="fc" id="L520">    links.put(&quot;path&quot;, service.getPath());</span>
<span class="fc" id="L521">    json.put(&quot;links&quot;, links);</span>

<span class="fc" id="L523">    return json;</span>
  }

  private List&lt;Map&lt;String, String&gt;&gt; getRestEndpointsAsJson(HttpServletRequest request)
          throws MalformedURLException, InvalidSyntaxException {
<span class="nc" id="L528">    List&lt;Map&lt;String, String&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L529">    ServiceReference[] serviceRefs = getRestServiceReferences();</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">    if (serviceRefs == null) {</span>
<span class="nc" id="L531">      return result;</span>
    }
<span class="nc bnc" id="L533" title="All 2 branches missed.">    for (ServiceReference servletRef : sort(serviceRefs)) {</span>
<span class="nc" id="L534">      final String servletContextPath = (String) servletRef.getProperty(RestConstants.SERVICE_PATH_PROPERTY);</span>
<span class="nc" id="L535">      final Map&lt;String, String&gt; endpoint = new HashMap&lt;&gt;();</span>
<span class="nc" id="L536">      endpoint.put(&quot;description&quot;, (String) servletRef.getProperty(Constants.SERVICE_DESCRIPTION));</span>
<span class="nc" id="L537">      endpoint.put(&quot;version&quot;, servletRef.getBundle().getVersion().toString());</span>
<span class="nc" id="L538">      endpoint.put(&quot;type&quot;, (String) servletRef.getProperty(RestConstants.SERVICE_TYPE_PROPERTY));</span>
<span class="nc" id="L539">      URL url = new URL(request.getScheme(), request.getServerName(), request.getServerPort(), servletContextPath);</span>
<span class="nc" id="L540">      endpoint.put(&quot;path&quot;, servletContextPath);</span>
<span class="nc" id="L541">      endpoint.put(&quot;docs&quot;, UrlSupport.concat(url.toExternalForm(), &quot;/docs&quot;)); // This is a Opencast convention</span>
<span class="nc" id="L542">      result.add(endpoint);</span>
<span class="nc" id="L543">    }</span>
<span class="nc" id="L544">    return result;</span>
  }

  private List&lt;Map&lt;String, String&gt;&gt; getUserInterfacesAsJson() throws InvalidSyntaxException {
<span class="nc" id="L548">    List&lt;Map&lt;String, String&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L549">    ServiceReference[] serviceRefs = getUserInterfaceServiceReferences();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">    if (serviceRefs == null) {</span>
<span class="nc" id="L551">      return result;</span>
    }
<span class="nc bnc" id="L553" title="All 2 branches missed.">    for (ServiceReference ref : sort(serviceRefs)) {</span>
<span class="nc" id="L554">      String description = (String) ref.getProperty(Constants.SERVICE_DESCRIPTION);</span>
<span class="nc" id="L555">      String version = ref.getBundle().getVersion().toString();</span>
<span class="nc" id="L556">      String alias = (String) ref.getProperty(&quot;alias&quot;);</span>
<span class="nc" id="L557">      String welcomeFile = (String) ref.getProperty(&quot;welcome.file&quot;);</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">      String welcomePath = &quot;/&quot;.equals(alias) ? alias + welcomeFile : alias + &quot;/&quot; + welcomeFile;</span>
<span class="nc" id="L559">      Map&lt;String, String&gt; endpoint = new HashMap&lt;&gt;();</span>
<span class="nc" id="L560">      endpoint.put(&quot;description&quot;, description);</span>
<span class="nc" id="L561">      endpoint.put(&quot;version&quot;, version);</span>
<span class="nc" id="L562">      endpoint.put(&quot;welcomepage&quot;, serverUrl + welcomePath);</span>
<span class="nc" id="L563">      result.add(endpoint);</span>
<span class="nc" id="L564">    }</span>
<span class="nc" id="L565">    return result;</span>
  }

  /**
   * Returns the array of references sorted by their Constants.SERVICE_DESCRIPTION property.
   *
   * @param references
   *          the references
   * @return the sorted set of references
   */
  private static SortedSet&lt;ServiceReference&gt; sort(ServiceReference[] references) {
<span class="nc" id="L576">    SortedSet&lt;ServiceReference&gt; sortedServiceRefs = new TreeSet&lt;&gt;((o1, o2) -&gt; {</span>
<span class="nc" id="L577">      final String o1Description = Objects.toString(o1.getProperty(Constants.SERVICE_DESCRIPTION), o1.toString());</span>
<span class="nc" id="L578">      final String o2Description = Objects.toString(o2.getProperty(Constants.SERVICE_DESCRIPTION), o2.toString());</span>
<span class="nc" id="L579">      return o1Description.compareTo(o2Description);</span>
    });
<span class="nc" id="L581">    sortedServiceRefs.addAll(Arrays.asList(references));</span>
<span class="nc" id="L582">    return sortedServiceRefs;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>