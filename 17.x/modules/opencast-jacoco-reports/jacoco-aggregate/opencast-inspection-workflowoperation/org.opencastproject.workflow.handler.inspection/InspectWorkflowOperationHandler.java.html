<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>InspectWorkflowOperationHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-inspection-workflowoperation</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.workflow.handler.inspection</a> &gt; <span class="el_source">InspectWorkflowOperationHandler.java</span></div><h1>InspectWorkflowOperationHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.workflow.handler.inspection;

import static java.lang.String.format;

import org.opencastproject.inspection.api.MediaInspectionException;
import org.opencastproject.inspection.api.MediaInspectionOptions;
import org.opencastproject.inspection.api.MediaInspectionService;
import org.opencastproject.job.api.Job;
import org.opencastproject.job.api.JobContext;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.MediaPackage;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.MediaPackageElements;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.MediaPackageReferenceImpl;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.UnsupportedElementException;
import org.opencastproject.metadata.dublincore.DCMIPeriod;
import org.opencastproject.metadata.dublincore.DublinCore;
import org.opencastproject.metadata.dublincore.DublinCoreCatalog;
import org.opencastproject.metadata.dublincore.DublinCoreCatalogService;
import org.opencastproject.metadata.dublincore.DublinCoreValue;
import org.opencastproject.metadata.dublincore.EncodingSchemeUtils;
import org.opencastproject.metadata.dublincore.Precision;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowInstance;
import org.opencastproject.workflow.api.WorkflowOperationException;
import org.opencastproject.workflow.api.WorkflowOperationHandler;
import org.opencastproject.workflow.api.WorkflowOperationInstance;
import org.opencastproject.workflow.api.WorkflowOperationResult;
import org.opencastproject.workflow.api.WorkflowOperationResult.Action;
import org.opencastproject.workspace.api.Workspace;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * Workflow operation used to inspect all tracks of a media package.
 */
@Component(
    immediate = true,
    service = WorkflowOperationHandler.class,
    property = {
        &quot;service.description=Compose Workflow Operation Handler&quot;,
        &quot;workflow.operation=inspect&quot;
    }
)
<span class="fc" id="L84">public class InspectWorkflowOperationHandler extends AbstractWorkflowOperationHandler {</span>

  /** The logging facility */
<span class="fc" id="L87">  private static final Logger logger = LoggerFactory.getLogger(InspectWorkflowOperationHandler.class);</span>

  /** Option for rewriting existing metadata */
  private static final String OPT_OVERWRITE = &quot;overwrite&quot;;

  /** Option to adjust whether mediapackages without media should be accepted */
  private static final String OPT_ACCEPT_NO_MEDIA = &quot;accept-no-media&quot;;

  /** Option to adjust whether the exact frame count should be determined
      Note that this is an expensive operation. Its use should be avoided if not depending on the exact framecount
      Default: false */
  private static final String OPT_ACCURATE_FRAME_COUNT = &quot;accurate-frame-count&quot;;

  /** The inspection service */
<span class="fc" id="L101">  private MediaInspectionService inspectionService = null;</span>

  /** The dublin core catalog service */
  private DublinCoreCatalogService dcService;

  /** The local workspace */
  private Workspace workspace;

  @Reference
  public void setDublincoreService(DublinCoreCatalogService dcService) {
<span class="fc" id="L111">    this.dcService = dcService;</span>
<span class="fc" id="L112">  }</span>

  /**
   * Callback for the OSGi declarative services configuration.
   *
   * @param inspectionService
   *          the inspection service
   */
  @Reference
  protected void setInspectionService(MediaInspectionService inspectionService) {
<span class="fc" id="L122">    this.inspectionService = inspectionService;</span>
<span class="fc" id="L123">  }</span>

  /**
   * Callback for declarative services configuration that will introduce us to the local workspace service.
   * Implementation assumes that the reference is configured as being static.
   *
   * @param workspace
   *          an instance of the workspace
   */
  @Reference
  public void setWorkspace(Workspace workspace) {
<span class="fc" id="L134">    this.workspace = workspace;</span>
<span class="fc" id="L135">  }</span>

  /**
   * {@inheritDoc}
   *
   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(
   *          org.opencastproject.workflow.api.WorkflowInstance, JobContext)
   */
  @Override
  public WorkflowOperationResult start(WorkflowInstance workflowInstance, JobContext context)
          throws WorkflowOperationException {
<span class="fc" id="L146">    MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();</span>
    // Inspect the tracks
<span class="fc" id="L148">    long totalTimeInQueue = 0;</span>

<span class="fc" id="L150">    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();</span>
<span class="fc" id="L151">    boolean rewrite = &quot;true&quot;.equalsIgnoreCase(operation.getConfiguration(OPT_OVERWRITE));</span>
<span class="fc" id="L152">    boolean acceptNoMedia = &quot;true&quot;.equalsIgnoreCase(operation.getConfiguration(OPT_ACCEPT_NO_MEDIA));</span>

<span class="fc" id="L154">    final Map&lt;String, String&gt; options = new HashMap&lt;String, String&gt;();</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">    if (&quot;true&quot;.equalsIgnoreCase(operation.getConfiguration(OPT_ACCURATE_FRAME_COUNT))) {</span>
<span class="nc" id="L156">      logger.info(&quot;Using accurate frame count for inspection media package {}&quot;, mediaPackage);</span>
<span class="nc" id="L157">      options.put(MediaInspectionOptions.OPTION_ACCURATE_FRAME_COUNT, Boolean.TRUE.toString());</span>
    }

    // Test if there are tracks in the mediapackage
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">    if (mediaPackage.getTracks().length == 0) {</span>
<span class="nc" id="L162">      logger.warn(&quot;Recording {} contains no media&quot;, mediaPackage);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">      if (!acceptNoMedia) {</span>
<span class="nc" id="L164">        throw new WorkflowOperationException(&quot;Mediapackage &quot; + mediaPackage + &quot; contains no media&quot;);</span>
      }
    }

<span class="fc bfc" id="L168" title="All 2 branches covered.">    for (Track track : mediaPackage.getTracks()) {</span>

<span class="fc" id="L170">      logger.info(&quot;Inspecting track '{}' of {}&quot;, track.getIdentifier(), mediaPackage);</span>

<span class="fc" id="L172">      Job inspectJob = null;</span>
      Track inspectedTrack;
      try {
<span class="fc" id="L175">        inspectJob = inspectionService.enrich(track, rewrite, options);</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (!waitForStatus(inspectJob).isSuccess()) {</span>
<span class="nc" id="L177">          throw new WorkflowOperationException(&quot;Track &quot; + track + &quot; could not be inspected&quot;);</span>
        }
<span class="nc" id="L179">      } catch (MediaInspectionException e) {</span>
<span class="nc" id="L180">        throw new WorkflowOperationException(&quot;Error inspecting media package&quot;, e);</span>
<span class="nc" id="L181">      } catch (MediaPackageException e) {</span>
<span class="nc" id="L182">        throw new WorkflowOperationException(&quot;Error parsing media package&quot;, e);</span>
<span class="fc" id="L183">      }</span>

      // add this receipt's queue and execution times to the total
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">      long timeInQueue = inspectJob.getQueueTime() == null ? 0 : inspectJob.getQueueTime();</span>
<span class="fc" id="L187">      totalTimeInQueue += timeInQueue;</span>


      try {
<span class="fc" id="L191">        inspectedTrack = (Track) MediaPackageElementParser.getFromXml(inspectJob.getPayload());</span>
<span class="nc" id="L192">      } catch (MediaPackageException e) {</span>
<span class="nc" id="L193">        throw new WorkflowOperationException(&quot;Unable to parse track from job &quot; + inspectJob.getId(), e);</span>
<span class="fc" id="L194">      }</span>

<span class="pc bpc" id="L196" title="1 of 2 branches missed.">      if (inspectedTrack == null) {</span>
<span class="nc" id="L197">        throw new WorkflowOperationException(&quot;Track &quot; + track + &quot; could not be inspected&quot;);</span>
      }

<span class="pc bpc" id="L200" title="1 of 2 branches missed.">      if (inspectedTrack.getStreams().length == 0) {</span>
<span class="nc" id="L201">        throw new WorkflowOperationException(format(&quot;Track %s does not contain any streams&quot;, track));</span>
      }

      // Replace the original track with the inspected one
      try {
<span class="fc" id="L206">        mediaPackage.remove(track);</span>
<span class="fc" id="L207">        mediaPackage.add(inspectedTrack);</span>
<span class="nc" id="L208">      } catch (UnsupportedElementException e) {</span>
<span class="nc" id="L209">        logger.error(&quot;Error adding {} to media package&quot;, inspectedTrack, e);</span>
<span class="fc" id="L210">      }</span>
    }

    // Update dublin core with metadata
    try {
<span class="fc" id="L215">      updateDublinCore(mediaPackage);</span>
<span class="nc" id="L216">    } catch (Exception e) {</span>
<span class="nc" id="L217">      logger.warn(&quot;Unable to update dublin core data: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L218">      throw new WorkflowOperationException(e.getMessage());</span>
<span class="fc" id="L219">    }</span>

<span class="fc" id="L221">    return createResult(mediaPackage, Action.CONTINUE, totalTimeInQueue);</span>
  }

  /**
   * Updates those dublin core fields that can be gathered from the technical metadata.
   *
   * @param mediaPackage
   *          the media package
   */
  protected void updateDublinCore(MediaPackage mediaPackage) throws Exception {
    // Complete episode dublin core catalog (if available)
<span class="fc" id="L232">    Catalog[] dcCatalogs = mediaPackage.getCatalogs(MediaPackageElements.EPISODE,</span>
            MediaPackageReferenceImpl.ANY_MEDIAPACKAGE);
<span class="fc bfc" id="L234" title="All 2 branches covered.">    if (dcCatalogs.length &gt; 0) {</span>
<span class="fc" id="L235">      DublinCoreCatalog dublinCore = loadDublinCoreCatalog(dcCatalogs[0]);</span>

      // Extent
<span class="pc bpc" id="L238" title="2 of 4 branches missed.">      if (mediaPackage.getDuration() != null &amp;&amp; !dublinCore.hasValue(DublinCore.PROPERTY_EXTENT)) {</span>
<span class="fc" id="L239">        DublinCoreValue extent = EncodingSchemeUtils.encodeDuration(mediaPackage.getDuration());</span>
<span class="fc" id="L240">        dublinCore.set(DublinCore.PROPERTY_EXTENT, extent);</span>
<span class="fc" id="L241">        logger.debug(&quot;Setting dc:extent to '{}'&quot;, extent.getValue());</span>
      }

      // Date created
<span class="pc bpc" id="L245" title="2 of 4 branches missed.">      if (mediaPackage.getDate() != null &amp;&amp; !dublinCore.hasValue(DublinCore.PROPERTY_CREATED)) {</span>
<span class="fc" id="L246">        DublinCoreValue date = EncodingSchemeUtils.encodeDate(mediaPackage.getDate(), Precision.Minute);</span>
<span class="fc" id="L247">        dublinCore.set(DublinCore.PROPERTY_CREATED, date);</span>
<span class="fc" id="L248">        logger.debug(&quot;Setting dc:date to '{}'&quot;, date.getValue());</span>
      }

      // Temporal
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">      if (mediaPackage.getDuration() != null</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">          &amp;&amp; dublinCore.hasValue(DublinCore.PROPERTY_CREATED)</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">          &amp;&amp; !dublinCore.hasValue(DublinCore.PROPERTY_TEMPORAL)) {</span>
<span class="fc" id="L255">        var created = EncodingSchemeUtils.decodeDate(dublinCore.getFirst(DublinCore.PROPERTY_CREATED));</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if (created != null) {</span>
          // Instant end =
<span class="fc" id="L258">          var end = Date.from(created.toInstant().plus(mediaPackage.getDuration(), ChronoUnit.MILLIS));</span>
<span class="fc" id="L259">          var temporal = EncodingSchemeUtils.encodePeriod(new DCMIPeriod(created, end), Precision.Second);</span>
<span class="fc" id="L260">          dublinCore.set(DublinCore.PROPERTY_TEMPORAL, temporal);</span>
<span class="fc" id="L261">          logger.debug(&quot;Setting dc:temporal to '{}'&quot;, temporal.getValue());</span>
<span class="fc" id="L262">        } else {</span>
<span class="nc" id="L263">          logger.warn(&quot;Unable to parse dc:created value '{}'; mediapackage '{}'&quot;,</span>
<span class="nc" id="L264">              dublinCore.getFirst(DublinCore.PROPERTY_CREATED),</span>
<span class="nc" id="L265">              mediaPackage.getIdentifier()</span>
          );
        }
      }

      // Serialize changed dublin core
<span class="fc" id="L271">      InputStream in = dcService.serialize(dublinCore);</span>
<span class="fc" id="L272">      String mpId = mediaPackage.getIdentifier().toString();</span>
<span class="fc" id="L273">      String elementId = dcCatalogs[0].getIdentifier();</span>
<span class="fc" id="L274">      workspace.put(mpId, elementId, FilenameUtils.getName(dcCatalogs[0].getURI().getPath()), in);</span>
<span class="fc" id="L275">      dcCatalogs[0].setURI(workspace.getURI(mpId, elementId));</span>
    }
<span class="fc" id="L277">  }</span>

  /**
   * Loads a dublin core catalog from a mediapackage's catalog reference
   *
   * @param catalog
   *          the mediapackage's reference to this catalog
   * @return the dublin core
   * @throws IOException
   *           if there is a problem loading or parsing the dublin core object
   */
  protected DublinCoreCatalog loadDublinCoreCatalog(Catalog catalog) throws IOException {
<span class="fc" id="L289">    InputStream in = null;</span>
    try {
<span class="fc" id="L291">      File f = workspace.get(catalog.getURI());</span>
<span class="fc" id="L292">      in = new FileInputStream(f);</span>
<span class="fc" id="L293">      return dcService.load(in);</span>
<span class="nc" id="L294">    } catch (NotFoundException e) {</span>
<span class="nc" id="L295">      throw new IOException(&quot;Unable to open catalog &quot; + catalog, e);</span>
    } finally {
<span class="fc" id="L297">      IOUtils.closeQuietly(in);</span>
    }
  }

  @Reference
  @Override
  public void setServiceRegistry(ServiceRegistry serviceRegistry) {
<span class="fc" id="L304">    super.setServiceRegistry(serviceRegistry);</span>
<span class="fc" id="L305">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>