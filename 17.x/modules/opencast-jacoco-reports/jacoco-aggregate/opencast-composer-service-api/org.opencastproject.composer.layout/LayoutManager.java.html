<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LayoutManager.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-composer-service-api</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.composer.layout</a> &gt; <span class="el_source">LayoutManager.java</span></div><h1>LayoutManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.composer.layout;

import static org.opencastproject.util.data.Monadics.mlist;

import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Tuple;

import java.util.List;

public final class LayoutManager {
  private LayoutManager() {
  }

  /**
   * Compose two shapes on a canvas.
   * It is guaranteed that shapes to not extend the underlying canvas.
   *
   * @param canvas
   *         the dimension of the target canvas
   * @param upper
   *         the dimension of the upper (z-axis) source shape
   * @param lower
   *         the dimension of the lower (z-axis) source shape
   * @param spec
   *         the layout specification
   */
  public static TwoShapeLayout twoShapeLayout(Dimension canvas,
                                              Dimension upper,
                                              Dimension lower,
                                              TwoShapeLayouts.TwoShapeLayoutSpec spec) {
<span class="fc" id="L52">    return new TwoShapeLayout(canvas,</span>
<span class="fc" id="L53">                              calcLayout(canvas, upper, spec.getUpper()),</span>
<span class="fc" id="L54">                              calcLayout(canvas, lower, spec.getLower()));</span>
  }

  private static Layout calcLayout(Dimension canvas,
                                   Dimension shape,
                                   HorizontalCoverageLayoutSpec posSpec) {
<span class="fc" id="L60">    final Dimension slice = new Dimension(limitMin(canvas.getWidth() * posSpec.getHorizontalCoverage(), 0),</span>
<span class="fc" id="L61">                                          canvas.getHeight());</span>
<span class="fc" id="L62">    final Dimension scaled = scaleToFit(slice, shape);</span>
<span class="fc" id="L63">    final AnchorOffset dist = posSpec.getAnchorOffset();</span>
<span class="fc" id="L64">    final Offset anchorOfReference = offset(dist.getReferenceAnchor(), canvas);</span>
<span class="fc" id="L65">    final Offset anchorOfReferring = offset(dist.getReferringAnchor(), scaled);</span>
<span class="fc" id="L66">    return new Layout(</span>
            scaled,
<span class="fc" id="L68">            new Offset(limitMin(anchorOfReference.getX() + dist.getOffset().getX() - anchorOfReferring.getX(), 0),</span>
<span class="fc" id="L69">                       limitMin(anchorOfReference.getY() + dist.getOffset().getY() - anchorOfReferring.getY(), 0)));</span>
  }

  private static Layout calcLayout(Dimension canvas,
                                   Dimension shape,
                                   AbsolutePositionLayoutSpec posSpec) {
<span class="fc" id="L75">    final AnchorOffset dist = posSpec.getAnchorOffset();</span>
<span class="fc" id="L76">    final Offset anchorOfReference = offset(dist.getReferenceAnchor(), canvas);</span>
<span class="fc" id="L77">    final Offset anchorOfReferring = offset(dist.getReferringAnchor(), shape);</span>
<span class="fc" id="L78">    return new Layout(</span>
            shape,
<span class="fc" id="L80">            new Offset(limitMin(anchorOfReference.getX() + dist.getOffset().getX() - anchorOfReferring.getX(), 0),</span>
<span class="fc" id="L81">                       limitMin(anchorOfReference.getY() + dist.getOffset().getY() - anchorOfReferring.getY(), 0)));</span>
  }

  /**
   * Compose a list of shapes on a canvas.
   *
   * @param canvas
   *         the dimension of the target canvas
   * @param shapes
   *         A list of shapes sorted in z-order with the first shape in the list being the lowermost one.
   *         The list consists of the dimension of the source shape tupled with a layout specification.
   */
  public static MultiShapeLayout multiShapeLayout(final Dimension canvas,
                                                  final List&lt;Tuple&lt;Dimension, HorizontalCoverageLayoutSpec&gt;&gt; shapes) {
<span class="fc" id="L95">    return new MultiShapeLayout(</span>
            canvas,
<span class="fc" id="L97">            mlist(shapes).map(new Function&lt;Tuple&lt;Dimension, HorizontalCoverageLayoutSpec&gt;, Layout&gt;() {</span>
              @Override public Layout apply(Tuple&lt;Dimension, HorizontalCoverageLayoutSpec&gt; a) {
<span class="fc" id="L99">                return calcLayout(canvas, a.getA(), a.getB());</span>
              }
<span class="fc" id="L101">            }).value());</span>
  }

  /**
   * Compose a list of shapes on a canvas.
   *
   * @param canvas
   *         the dimension of the target canvas
   * @param shapes
   *         A list of shapes sorted in z-order with the first shape in the list being the lowermost one.
   *         The list consists of the dimension of the source shape tupled with a layout specification.
   */
  public static MultiShapeLayout absoluteMultiShapeLayout(
          final Dimension canvas,
          final List&lt;Tuple&lt;Dimension, AbsolutePositionLayoutSpec&gt;&gt; shapes) {
<span class="fc" id="L116">    return new MultiShapeLayout(</span>
            canvas,
<span class="fc" id="L118">            mlist(shapes).map(new Function&lt;Tuple&lt;Dimension, AbsolutePositionLayoutSpec&gt;, Layout&gt;() {</span>
              @Override public Layout apply(Tuple&lt;Dimension, AbsolutePositionLayoutSpec&gt; a) {
<span class="fc" id="L120">                return calcLayout(canvas, a.getA(), a.getB());</span>
              }
<span class="fc" id="L122">            }).value());</span>
  }

  public static int limitMax(double v, int max) {
<span class="fc" id="L126">    return (int) Math.min(Math.round(v), max);</span>
  }

  public static int limitMin(double v, int min) {
<span class="fc" id="L130">    return (int) Math.max(Math.round(v), min);</span>
  }

  /** Test if &lt;code&gt;shape&lt;/code&gt; fits into &lt;code&gt;into&lt;/code&gt;. */
  public static boolean fits(Dimension into, Dimension shape) {
<span class="nc bnc" id="L135" title="All 4 branches missed.">    return shape.getHeight() &lt;= into.getHeight() &amp;&amp; shape.getWidth() &lt;= into.getHeight();</span>
  }

  /** Calculate the area of a dimension. */
  public static int area(Dimension a) {
<span class="nc" id="L140">    return a.getWidth() * a.getHeight();</span>
  }

  /** Return the dimension with the bigger area. */
  public static Dimension max(Dimension a, Dimension b) {
<span class="nc bnc" id="L145" title="All 2 branches missed.">    return area(a) &gt; area(b) ? a : b;</span>
  }

  /** Get the aspect ratio of a dimension. */
  public static double aspectRatio(Dimension a) {
<span class="fc" id="L150">    return d(a.getWidth()) / d(a.getHeight());</span>
  }

  /** Test if layouts &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; overlap. */
  public static boolean overlap(Layout a, Layout b) {
<span class="nc bnc" id="L155" title="All 4 branches missed.">    return (between(left(a), right(a), left(b)) || between(left(a), right(a), right(b)))</span>
<span class="nc bnc" id="L156" title="All 4 branches missed.">            &amp;&amp; (between(top(a), bottom(a), top(b)) || between(top(a), bottom(a), bottom(b)));</span>
  }

  /** Get the X coordinate of the left bound of the layout. */
  public static int left(Layout a) {
<span class="nc" id="L161">    return a.getOffset().getX();</span>
  }

  /** Get the X coordinate of the right bound of the layout. */
  public static int right(Layout a) {
<span class="nc" id="L166">    return a.getOffset().getX() + a.getDimension().getWidth();</span>
  }

  /** Get the Y coordinate of the top bound of the layout. */
  public static int top(Layout a) {
<span class="nc" id="L171">    return a.getOffset().getY();</span>
  }

  /** Get the Y coordinate of the bottom bound of the layout. */
  public static int bottom(Layout a) {
<span class="nc" id="L176">    return a.getOffset().getY() + a.getDimension().getHeight();</span>
  }

  /** Calculate the offset of an anchor point for a given shape relative to its upper left corner. */
  public static Offset offset(Anchor a, Dimension dim) {
<span class="fc" id="L181">    return new Offset(limitMax(a.getLeft() * d(dim.getWidth()), dim.getWidth()),</span>
<span class="fc" id="L182">                      limitMax(a.getTop() * d(dim.getHeight()), dim.getHeight()));</span>
  }

  /**
   * Scale &lt;code&gt;shape&lt;/code&gt; by &lt;code&gt;scale&lt;/code&gt; and ensure that any rounding errors are limited so that
   * the resulting dimension does not exceed &lt;code&gt;limit&lt;/code&gt;.
   */
  public static Dimension scale(Dimension limit, Dimension shape, double scale) {
<span class="fc" id="L190">    return Dimension.dimension(</span>
<span class="fc" id="L191">            limitMax(d(shape.getWidth()) * scale, limit.getWidth()),</span>
<span class="fc" id="L192">            limitMax(d(shape.getHeight()) * scale, limit.getHeight()));</span>
  }

  /** Scale &lt;code&gt;d&lt;/code&gt; to fit into &lt;code&gt;canvas&lt;/code&gt; . */
  public static Dimension scaleToFit(Dimension canvas, Dimension d) {
<span class="fc" id="L197">    final double scaleToWidth = d(canvas.getWidth()) / d(d.getWidth());</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">    if (d.getHeight() * scaleToWidth &gt; canvas.getHeight()) {</span>
<span class="fc" id="L199">      final double scaleToHeight = d(canvas.getHeight()) / d(d.getHeight());</span>
<span class="fc" id="L200">      return scale(canvas, d, scaleToHeight);</span>
    } else {
<span class="fc" id="L202">      return scale(canvas, d, scaleToWidth);</span>
    }
  }

  /** a &amp;lt;= x &amp;lt;= b */
  public static boolean between(int a, int b, int x) {
<span class="nc bnc" id="L208" title="All 4 branches missed.">    return a &lt;= x &amp;&amp; x &lt;= b;</span>
  }

  private static double d(int v) {
<span class="fc" id="L212">    return v;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>