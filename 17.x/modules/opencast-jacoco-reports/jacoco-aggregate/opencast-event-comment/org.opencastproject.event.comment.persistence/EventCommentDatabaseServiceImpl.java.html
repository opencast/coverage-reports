<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>EventCommentDatabaseServiceImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-event-comment</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.event.comment.persistence</a> &gt; <span class="el_source">EventCommentDatabaseServiceImpl.java</span></div><h1>EventCommentDatabaseServiceImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */
package org.opencastproject.event.comment.persistence;

import static org.opencastproject.db.Queries.namedQuery;

import org.opencastproject.db.DBSession;
import org.opencastproject.db.DBSessionFactory;
import org.opencastproject.elasticsearch.api.SearchIndexException;
import org.opencastproject.elasticsearch.index.ElasticsearchIndex;
import org.opencastproject.elasticsearch.index.objects.event.Comment;
import org.opencastproject.elasticsearch.index.objects.event.Event;
import org.opencastproject.elasticsearch.index.rebuild.AbstractIndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexProducer;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildException;
import org.opencastproject.elasticsearch.index.rebuild.IndexRebuildService;
import org.opencastproject.event.comment.EventComment;
import org.opencastproject.security.api.Organization;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.User;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.security.util.SecurityUtil;
import org.opencastproject.util.NotFoundException;

import com.entwinemedia.fn.Fn;
import com.entwinemedia.fn.Stream;

import org.apache.commons.lang3.tuple.Pair;
import org.osgi.service.component.ComponentContext;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;

/**
 * Implements permanent storage for event comments.
 */
@Component(
    immediate = true,
    service = { EventCommentDatabaseService.class, IndexProducer.class },
    property = {
        &quot;service.description=Event Comment Database Service&quot;
    }
)
<span class="fc" id="L77">public class EventCommentDatabaseServiceImpl extends AbstractIndexProducer implements EventCommentDatabaseService {</span>
  /** Logging utilities */
<span class="fc" id="L79">  private static final Logger logger = LoggerFactory.getLogger(EventCommentDatabaseServiceImpl.class);</span>

  public static final String PERSISTENCE_UNIT = &quot;org.opencastproject.event.comment&quot;;

  /** Factory used to create {@link EntityManager}s for transactions */
  private EntityManagerFactory emf;

  private DBSessionFactory dbSessionFactory;
  private DBSession db;

  /** The security service used to retrieve organizations. */
  private OrganizationDirectoryService organizationDirectoryService;

  /** The security service used to run the security context with. */
  private SecurityService securityService;

  /** The user directory service */
  private UserDirectoryService userDirectoryService;

  /** The component context this bundle is running in. */
  private ComponentContext cc;

  /** The elasticsearch indices */
  private ElasticsearchIndex index;

  /** OSGi component activation callback */
  @Activate
  public void activate(ComponentContext cc) {
<span class="fc" id="L107">    logger.info(&quot;Activating persistence manager for event comments&quot;);</span>
<span class="fc" id="L108">    this.cc = cc;</span>
<span class="fc" id="L109">    db = dbSessionFactory.createSession(emf);</span>
<span class="fc" id="L110">  }</span>

  /** OSGi DI */
  @Reference(target = &quot;(osgi.unit.name=org.opencastproject.event.comment)&quot;)
  public void setEntityManagerFactory(EntityManagerFactory emf) {
<span class="fc" id="L115">    this.emf = emf;</span>
<span class="fc" id="L116">  }</span>

  @Reference
  public void setDBSessionFactory(DBSessionFactory dbSessionFactory) {
<span class="fc" id="L120">    this.dbSessionFactory = dbSessionFactory;</span>
<span class="fc" id="L121">  }</span>

  /**
   * OSGi callback to set the security context to run with.
   *
   * @param securityService
   *          The security service
   */
  @Reference
  public void setSecurityService(SecurityService securityService) {
<span class="fc" id="L131">    this.securityService = securityService;</span>
<span class="fc" id="L132">  }</span>

  /**
   * OSGi callback to set the user directory service.
   *
   * @param userDirectoryService
   *          the user directory service
   */
  @Reference
  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {
<span class="fc" id="L142">    this.userDirectoryService = userDirectoryService;</span>
<span class="fc" id="L143">  }</span>

  /**
   * OSGi callback to set the organization directory service.
   *
   * @param organizationDirectoryService
   *          the organization directory service
   */
  @Reference
  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectoryService) {
<span class="nc" id="L153">    this.organizationDirectoryService = organizationDirectoryService;</span>
<span class="nc" id="L154">  }</span>

  /**
   * OSgi callback for the Elasticsearch index.
   *
   * @param index
   *          the Elasticsearch index.
   */
  @Reference
  public void setIndex(ElasticsearchIndex index) {
<span class="fc" id="L164">    this.index = index;</span>
<span class="fc" id="L165">  }</span>

  @Override
  public List&lt;String&gt; getReasons() throws EventCommentDatabaseException {
    try {
<span class="nc" id="L170">      return db.exec(namedQuery.findAll(</span>
          &quot;EventComment.findReasons&quot;,
          String.class,
<span class="nc" id="L173">          Pair.of(&quot;org&quot;, securityService.getOrganization().getId())</span>
      ));
<span class="nc" id="L175">    } catch (Exception e) {</span>
<span class="nc" id="L176">      logger.error(&quot;Could not get reasons&quot;, e);</span>
<span class="nc" id="L177">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  @Override
  public EventComment getComment(long commentId) throws NotFoundException, EventCommentDatabaseException {
    try {
<span class="fc" id="L184">      Optional&lt;EventCommentDto&gt; event = db.exec(getEventCommentQuery(commentId));</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">      if (event.isEmpty()) {</span>
<span class="nc" id="L186">        throw new NotFoundException(&quot;Event comment with ID &quot; + commentId + &quot; does not exist&quot;);</span>
      }
<span class="fc" id="L188">      return event.get().toComment(userDirectoryService, organizationDirectoryService);</span>
<span class="nc" id="L189">    } catch (NotFoundException e) {</span>
<span class="nc" id="L190">      throw e;</span>
<span class="nc" id="L191">    } catch (Exception e) {</span>
<span class="nc" id="L192">      logger.error(&quot;Could not get event comment {}&quot;, commentId, e);</span>
<span class="nc" id="L193">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  @Override
  public void deleteComment(long commentId) throws NotFoundException, EventCommentDatabaseException {
    try {
<span class="nc" id="L200">      EventCommentDto event = db.execTxChecked(em -&gt; {</span>
<span class="nc" id="L201">        Optional&lt;EventCommentDto&gt; eventOpt = getEventCommentQuery(commentId).apply(em);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (eventOpt.isEmpty()) {</span>
<span class="nc" id="L203">          throw new NotFoundException(&quot;Event comment with ID &quot; + commentId + &quot; does not exist&quot;);</span>
        }
<span class="nc" id="L205">        em.remove(eventOpt.get());</span>
<span class="nc" id="L206">        return eventOpt.get();</span>
      });
<span class="nc" id="L208">      updateIndices(event.getEventId());</span>
<span class="nc" id="L209">    } catch (NotFoundException e) {</span>
<span class="nc" id="L210">      throw e;</span>
<span class="nc" id="L211">    } catch (Exception e) {</span>
<span class="nc" id="L212">      logger.error(&quot;Could not delete event comment&quot;, e);</span>
<span class="nc" id="L213">      throw new EventCommentDatabaseException(e);</span>
<span class="nc" id="L214">    }</span>
<span class="nc" id="L215">  }</span>

  @Override
  public void deleteComments(String eventId) throws NotFoundException, EventCommentDatabaseException {
    // Similar to deleteComment but we want to avoid sending a message for each deletion

<span class="nc" id="L221">    int count = 0;</span>
    try {
<span class="nc" id="L223">      count = db.execTxChecked(em -&gt; {</span>
<span class="nc" id="L224">        List&lt;EventComment&gt; comments = getComments(eventId);</span>

<span class="nc bnc" id="L226" title="All 2 branches missed.">        for (EventComment comment : comments) {</span>
<span class="nc" id="L227">          long commentId = comment.getId().get().intValue();</span>
<span class="nc" id="L228">          Optional&lt;EventCommentDto&gt; event = getEventCommentQuery(commentId).apply(em);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">          if (event.isEmpty()) {</span>
<span class="nc" id="L230">            throw new NotFoundException(&quot;Event comment with ID &quot; + commentId + &quot; does not exist&quot;);</span>
          }
<span class="nc" id="L232">          em.remove(event.get());</span>
<span class="nc" id="L233">        }</span>

<span class="nc" id="L235">        return comments.size();</span>
      });
<span class="nc" id="L237">    } catch (NotFoundException e) {</span>
<span class="nc" id="L238">      throw e;</span>
<span class="nc" id="L239">    } catch (Exception e) {</span>
<span class="nc" id="L240">      logger.error(&quot;Could not delete event comments&quot;, e);</span>
<span class="nc" id="L241">      throw new EventCommentDatabaseException(e);</span>
<span class="nc" id="L242">    }</span>

    // send updates only if we actually modified anything
<span class="nc bnc" id="L245" title="All 2 branches missed.">    if (count &gt; 0) {</span>
<span class="nc" id="L246">      updateIndices(eventId);</span>
    }
<span class="nc" id="L248">  }</span>

  @Override
  public EventComment updateComment(EventComment comment) throws EventCommentDatabaseException {
    try {
<span class="fc" id="L253">      final EventCommentDto commentDto = EventCommentDto.from(comment);</span>
<span class="fc" id="L254">      final EventComment updatedComment = db.execTx(namedQuery.persistOrUpdate(commentDto))</span>
<span class="fc" id="L255">          .toComment(userDirectoryService, organizationDirectoryService);</span>
<span class="fc" id="L256">      updateIndices(updatedComment.getEventId());</span>
<span class="fc" id="L257">      return updatedComment;</span>
<span class="nc" id="L258">    } catch (Exception e) {</span>
<span class="nc" id="L259">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  /**
   * Gets an event comment, using the current organizational context.
   *
   * @param commentId
   *          the comment identifier
   *
   * @return the event comment entity, or null if not found
   */
  private Function&lt;EntityManager, Optional&lt;EventCommentDto&gt;&gt; getEventCommentQuery(long commentId) {
<span class="fc" id="L272">    return namedQuery.findOpt(</span>
        &quot;EventComment.findByCommentId&quot;,
        EventCommentDto.class,
<span class="fc" id="L275">        Pair.of(&quot;commentId&quot;, commentId)</span>
    );
  }

  @Override
  public List&lt;EventComment&gt; getComments(String eventId) throws EventCommentDatabaseException {
    try {
<span class="fc" id="L282">      return db.exec(namedQuery.findAll(</span>
          &quot;EventComment.findByEvent&quot;,
              EventCommentDto.class,
<span class="fc" id="L285">              Pair.of(&quot;eventId&quot;, eventId),</span>
<span class="fc" id="L286">              Pair.of(&quot;org&quot;, securityService.getOrganization().getId())</span>
<span class="fc" id="L287">          )).stream()</span>
<span class="fc" id="L288">          .map(c -&gt; c.toComment(userDirectoryService, organizationDirectoryService))</span>
<span class="fc" id="L289">          .sorted((c1, c2) -&gt; {</span>
<span class="nc" id="L290">            boolean v1 = c1.isResolvedStatus();</span>
<span class="nc" id="L291">            boolean v2 = c2.isResolvedStatus();</span>
<span class="nc bnc" id="L292" title="All 4 branches missed.">            return (v1 ^ v2) ? ((v1 ^ false) ? 1 : -1) : 0;</span>
          })
<span class="fc" id="L294">          .collect(Collectors.toList());</span>
<span class="nc" id="L295">    } catch (Exception e) {</span>
<span class="nc" id="L296">      logger.error(&quot;Could not retreive comments for event {}&quot;, eventId, e);</span>
<span class="nc" id="L297">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  public Iterator&lt;EventCommentDto&gt; getComments() throws EventCommentDatabaseException {
    try {
<span class="nc" id="L303">      return db.exec(namedQuery.findAll(&quot;EventComment.findAll&quot;, EventCommentDto.class)).iterator();</span>
<span class="nc" id="L304">    } catch (Exception e) {</span>
<span class="nc" id="L305">      logger.error(&quot;Could not retreive event comments&quot;, e);</span>
<span class="nc" id="L306">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  public int countComments() throws EventCommentDatabaseException {
    try {
<span class="nc" id="L312">      return db.exec(namedQuery.find(&quot;EventComment.countAll&quot;, Number.class)).intValue();</span>
<span class="nc" id="L313">    } catch (Exception e) {</span>
<span class="nc" id="L314">      logger.error(&quot;Could not find the number of comments.&quot;, e);</span>
<span class="nc" id="L315">      throw new EventCommentDatabaseException(e);</span>
    }
  }

  /**
   * Return all known event ID's with existing comments, grouped by organization ID
   *
   * @return a list of all event ID's grouped by organization ID
   */
  public Map&lt;String, List&lt;String&gt;&gt; getEventsWithComments() {
<span class="fc" id="L325">    List&lt;Object[]&gt; orgIDsEventIDs = db.exec(namedQuery.findAll(&quot;EventComment.findAllWIthOrg&quot;, Object[].class));</span>
<span class="fc" id="L326">    Map&lt;String, List&lt;String&gt;&gt; orgEventsMap = new Hashtable&lt;&gt;();</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">    for (Object[] orgEventResult : orgIDsEventIDs) {</span>
<span class="fc" id="L328">      String orgId = (String) orgEventResult[0];</span>
<span class="fc" id="L329">      String eventId = (String) orgEventResult[1];</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">      if (!orgEventsMap.containsKey(orgId)) {</span>
<span class="fc" id="L331">        List&lt;String&gt; eventIds = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L332">        eventIds.add(eventId);</span>
<span class="fc" id="L333">        orgEventsMap.put(orgId, eventIds);</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">      } else if (!orgEventsMap.get(orgId).contains(eventId)) {</span>
<span class="fc" id="L335">        orgEventsMap.get(orgId).add(eventId);</span>
      }
<span class="fc" id="L337">    }</span>
<span class="fc" id="L338">    return orgEventsMap;</span>
  }

  private void updateIndices(String eventId) throws EventCommentDatabaseException {
<span class="fc" id="L342">    List&lt;EventComment&gt; comments = getComments(eventId);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">    boolean hasOpenComments = !Stream.$(comments).filter(filterOpenComments).toList().isEmpty();</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">    boolean needsCutting = !Stream.$(comments).filter(filterNeedsCuttingComment).toList().isEmpty();</span>

<span class="fc" id="L346">    String organization = securityService.getOrganization().getId();</span>
<span class="fc" id="L347">    User user = securityService.getUser();</span>

<span class="fc bfc" id="L349" title="All 2 branches covered.">    updateIndex(eventId, !comments.isEmpty(), hasOpenComments, comments, needsCutting, organization, user);</span>
<span class="fc" id="L350">  }</span>

  private void updateIndex(String eventId, boolean hasComments, boolean hasOpenComments, List&lt;EventComment&gt; comments,
          boolean needsCutting, String organization, User user) {
<span class="fc" id="L354">    logger.debug(&quot;Updating comment status of event {} in the {} index.&quot;, eventId, index.getIndexName());</span>
<span class="pc bpc" id="L355" title="1 of 4 branches missed.">    if (!hasComments &amp;&amp; hasOpenComments) {</span>
<span class="nc" id="L356">      throw new IllegalStateException(</span>
              &quot;Invalid comment update request: You can't have open comments without having any comments!&quot;);
    }
<span class="pc bpc" id="L359" title="1 of 4 branches missed.">    if (!hasOpenComments &amp;&amp; needsCutting) {</span>
<span class="nc" id="L360">      throw new IllegalStateException(</span>
              &quot;Invalid comment update request: You can't have an needs cutting comment without having any open &quot;
                      + &quot;comments!&quot;);
    }

<span class="fc" id="L365">    Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; updateFunction = (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">      if (eventOpt.isEmpty()) {</span>
<span class="nc" id="L367">        logger.debug(&quot;Event {} not found for comment status updating&quot;, eventId);</span>
<span class="nc" id="L368">        return Optional.empty();</span>
      }
<span class="nc" id="L370">      Event event = eventOpt.get();</span>
<span class="nc" id="L371">      event.setHasComments(hasComments);</span>
<span class="nc" id="L372">      event.setHasOpenComments(hasOpenComments);</span>
<span class="nc" id="L373">      List&lt;Comment&gt; indexComments = new ArrayList&lt;Comment&gt;();</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">      for (EventComment comment : comments) {</span>
<span class="nc" id="L375">        indexComments.add(new Comment(</span>
<span class="nc" id="L376">                comment.getId().get().toString(), comment.getReason(), comment.getText(), comment.isResolvedStatus()</span>
        ));
        // Do we want to include replies? Maybe not, no good reason to filter for them?
<span class="nc" id="L379">      }</span>
<span class="nc" id="L380">      event.setComments(indexComments);</span>
<span class="nc" id="L381">      event.setNeedsCutting(needsCutting);</span>
<span class="nc" id="L382">      return Optional.of(event);</span>
    };

    try {
<span class="fc" id="L386">      index.addOrUpdateEvent(eventId, updateFunction, organization, user);</span>
<span class="nc" id="L387">    } catch (SearchIndexException e) {</span>
<span class="nc" id="L388">      logger.error(&quot;Error updating comment status of event {} in the {} index:&quot;, eventId, index.getIndexName(), e);</span>
<span class="fc" id="L389">    }</span>
<span class="fc" id="L390">  }</span>

<span class="fc" id="L392">  private static final Fn&lt;EventComment, Boolean&gt; filterOpenComments = new Fn&lt;EventComment, Boolean&gt;() {</span>
    @Override
    public Boolean apply(EventComment comment) {
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">      return !comment.isResolvedStatus();</span>
    }
  };

<span class="fc" id="L399">  private static final Fn&lt;EventComment, Boolean&gt; filterNeedsCuttingComment = new Fn&lt;EventComment, Boolean&gt;() {</span>
    @Override
    public Boolean apply(EventComment comment) {
<span class="pc bpc" id="L402" title="3 of 4 branches missed.">      return EventComment.REASON_NEEDS_CUTTING.equals(comment.getReason()) &amp;&amp; !comment.isResolvedStatus();</span>
    }
  };

  @Override
  public void repopulate(IndexRebuildService.DataType type) throws IndexRebuildException {
    try {
<span class="nc" id="L409">      final int total = countComments();</span>
<span class="nc" id="L410">      logIndexRebuildBegin(logger, total, &quot;events with comment&quot;);</span>
<span class="nc" id="L411">      final int[] current = new int[1];</span>
<span class="nc" id="L412">      current[0] = 0;</span>
<span class="nc" id="L413">      int n = 20;</span>
<span class="nc" id="L414">      var updatedEventRange = new ArrayList&lt;Event&gt;();</span>

<span class="nc" id="L416">      final Map&lt;String, List&lt;String&gt;&gt; eventsWithComments = getEventsWithComments();</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">      for (String orgId : eventsWithComments.keySet()) {</span>
<span class="nc" id="L418">        Organization organization = organizationDirectoryService.getOrganization(orgId);</span>
<span class="nc" id="L419">        User systemUser = SecurityUtil.createSystemUser(cc, organization);</span>
<span class="nc" id="L420">        SecurityUtil.runAs(securityService, organization, systemUser,</span>
                () -&gt; {
<span class="nc" id="L422">                  int i = 0;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                  for (String eventId : eventsWithComments.get(orgId)) {</span>
                    try {
<span class="nc" id="L425">                      current[0] += getComments(eventId).size();</span>
<span class="nc" id="L426">                      i++;</span>

<span class="nc" id="L428">                      var updatedEventData = index.getEvent(eventId, orgId, securityService.getUser());</span>
<span class="nc" id="L429">                      updatedEventData = getEventUpdateFunction(eventId).apply(updatedEventData);</span>
<span class="nc" id="L430">                      updatedEventRange.add(updatedEventData.get());</span>

<span class="nc bnc" id="L432" title="All 4 branches missed.">                      if (updatedEventRange.size() &gt;= n || i &gt;= eventsWithComments.get(orgId).size()) {</span>
<span class="nc" id="L433">                        index.bulkEventUpdate(updatedEventRange);</span>
<span class="nc" id="L434">                        logIndexRebuildProgress(logger, total, current[0], n);</span>
<span class="nc" id="L435">                        updatedEventRange.clear();</span>
                      }
<span class="nc" id="L437">                    } catch (Throwable t) {</span>
<span class="nc" id="L438">                      logSkippingElement(logger, &quot;comment of event&quot;, eventId, organization, t);</span>
<span class="nc" id="L439">                    }</span>
<span class="nc" id="L440">                  }</span>
<span class="nc" id="L441">                });</span>
<span class="nc" id="L442">      }</span>
<span class="nc" id="L443">    } catch (Exception e) {</span>
<span class="nc" id="L444">      logIndexRebuildError(logger, e);</span>
<span class="nc" id="L445">      throw new IndexRebuildException(getService(), e);</span>
<span class="nc" id="L446">    }</span>
<span class="nc" id="L447">  }</span>

  @Override
  public IndexRebuildService.Service getService() {
<span class="nc" id="L451">    return IndexRebuildService.Service.Comments;</span>
  }
  /**
   * Get the function to update a commented event in the Elasticsearch index.
   *
   * @param eventId
   *          The id of the current event
   * @return the function to do the update
   */
  private Function&lt;Optional&lt;Event&gt;, Optional&lt;Event&gt;&gt; getEventUpdateFunction(String eventId) {
<span class="nc" id="L461">    return (Optional&lt;Event&gt; eventOpt) -&gt; {</span>
      List&lt;EventComment&gt; comments;
      try {
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (eventOpt.isEmpty()) {</span>
<span class="nc" id="L465">          logger.debug(&quot;Event {} not found for comment status updating&quot;, eventId);</span>
<span class="nc" id="L466">          return Optional.empty();</span>
        }
<span class="nc" id="L468">        comments = getComments(eventId);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        Boolean hasComments = !comments.isEmpty();</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        Boolean hasOpenComments = !Stream.$(comments).filter(filterOpenComments).toList().isEmpty();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        Boolean needsCutting = !Stream.$(comments).filter(filterNeedsCuttingComment).toList().isEmpty();</span>

<span class="nc" id="L473">        logger.debug(&quot;Updating comment status of event {} in the {} index.&quot;, eventId, index.getIndexName());</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">        if (!hasComments &amp;&amp; hasOpenComments) {</span>
<span class="nc" id="L475">          throw new IllegalStateException(</span>
                  &quot;Invalid comment update request: You can't have open comments without having any comments!&quot;);
        }
<span class="nc bnc" id="L478" title="All 4 branches missed.">        if (!hasOpenComments &amp;&amp; needsCutting) {</span>
<span class="nc" id="L479">          throw new IllegalStateException(</span>
                  &quot;Invalid comment update request: You can't have an needs cutting comment without having any open &quot;
                          + &quot;comments!&quot;);
        }
<span class="nc" id="L483">        Event event = eventOpt.get();</span>
<span class="nc" id="L484">        event.setHasComments(hasComments);</span>
<span class="nc" id="L485">        event.setHasOpenComments(hasOpenComments);</span>
<span class="nc" id="L486">        List&lt;Comment&gt; indexComments = new ArrayList&lt;Comment&gt;();</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">        for (EventComment comment : comments) {</span>
<span class="nc" id="L488">          indexComments.add(new Comment(</span>
<span class="nc" id="L489">                  comment.getId().get().toString(), comment.getReason(), comment.getText(), comment.isResolvedStatus()</span>
          ));
          // Do we want to include replies? Maybe not, no good reason to filter for them?
<span class="nc" id="L492">        }</span>
<span class="nc" id="L493">        event.setComments(indexComments);</span>
<span class="nc" id="L494">        event.setNeedsCutting(needsCutting);</span>
<span class="nc" id="L495">        return Optional.of(event);</span>
<span class="nc" id="L496">      } catch (EventCommentDatabaseException e) {</span>
<span class="nc" id="L497">        logger.error(&quot;Unable to get comments from event {}&quot;, eventId, e);</span>
<span class="nc" id="L498">        return Optional.empty();</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>