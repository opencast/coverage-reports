<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Queries.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.db</a> &gt; <span class="el_source">Queries.java</span></div><h1>Queries.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.db;

import org.apache.commons.lang3.tuple.Pair;
import org.joda.time.base.AbstractInstant;

import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;

import javax.persistence.EntityManager;
import javax.persistence.NoResultException;
import javax.persistence.NonUniqueResultException;
import javax.persistence.Query;
import javax.persistence.TemporalType;
import javax.persistence.TypedQuery;

/**
 * Helper class defining common query functions that can be used with DBSession query execution methods.
 */
public final class Queries {
  private Queries() {
  }

  /**
   * Execute a typed named query.
   */
<span class="fc" id="L51">  public static final TypedQueriesBase namedQuery = new TypedQueriesBase() {</span>
    @Override
    protected Query createQuery(EntityManager em, String queryName, Object... params) {
<span class="fc" id="L54">      return configureQuery(em.createNamedQuery(queryName), params);</span>
    }

    @Override
    protected &lt;T&gt; TypedQuery&lt;T&gt; createTypedQuery(EntityManager em, String queryName, Class&lt;T&gt; clazz, Object... params) {
<span class="fc" id="L59">      return configureQuery(em.createNamedQuery(queryName, clazz), params);</span>
    }
  };

  /**
   * Execute a native SQL query.
   */
<span class="fc" id="L66">  public static final QueriesBase nativeQuery = new QueriesBase() {</span>
    @Override
    protected Query createQuery(EntityManager em, String sql, Object... params) {
<span class="fc" id="L69">      return configureQuery(em.createNativeQuery(sql), params);</span>
    }
  };

<span class="fc" id="L73">  public abstract static class TypedQueriesBase extends QueriesBase {</span>
    /**
     * Find entity by its id.
     *
     * @param clazz Entity class.
     * @param id ID of the entity.
     * @return The entity or null if not found.
     * @param &lt;T&gt; Entity type.
     */
    public &lt;T&gt; Function&lt;EntityManager, T&gt; findById(Class&lt;T&gt; clazz, Object id) {
<span class="fc" id="L83">      return em -&gt; em.find(clazz, id);</span>
    }

    /**
     * Find entity by its id.
     *
     * @param clazz Entity class.
     * @param id ID of the entity.
     * @return An Optional with the entity or an empty Optional if not found.
     * @param &lt;T&gt; Entity type.
     */
    public &lt;T&gt; Function&lt;EntityManager, Optional&lt;T&gt;&gt; findByIdOpt(Class&lt;T&gt; clazz, Object id) {
<span class="fc" id="L95">      return em -&gt; {</span>
        try {
<span class="fc" id="L97">          T e = em.find(clazz, id);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">          if (e == null) {</span>
<span class="fc" id="L99">            return Optional.empty();</span>
          }
<span class="fc" id="L101">          return Optional.of(e);</span>
<span class="nc" id="L102">        } catch (NoResultException e) {</span>
<span class="nc" id="L103">          return Optional.empty();</span>
        }
      };
    }

    /**
     * Execute a named query and return a single result.
     *
     * @param q Name of the query.
     * @param clazz Entity class.
     * @param params Parameters passed to the query.
     * @return The entity. An exception is thrown if not found.
     * @param &lt;T&gt; Entity type.
     */
    public &lt;T&gt; Function&lt;EntityManager, T&gt; find(String q, Class&lt;T&gt; clazz, Object... params) {
<span class="fc" id="L118">      return em -&gt; createTypedQuery(em, q, clazz, params).getSingleResult();</span>
    }

    /**
     * Execute a named query and return a single result.
     *
     * @param q Name of the query.
     * @param clazz Entity class.
     * @param params Parameters passed to the query.
     * @return An Optional with the entity or an empty Optional if not found.
     * @param &lt;T&gt; Entity type.
     */
    public &lt;T&gt; Function&lt;EntityManager, Optional&lt;T&gt;&gt; findOpt(String q, Class&lt;T&gt; clazz, Object... params) {
<span class="fc" id="L131">      return em -&gt; {</span>
        try {
<span class="fc" id="L133">          return Optional.of(createTypedQuery(em, q, clazz, params).getSingleResult());</span>
<span class="fc" id="L134">        } catch (NoResultException | NonUniqueResultException e) {</span>
<span class="fc" id="L135">          return Optional.empty();</span>
        }
      };
    }

    /**
     * Execute a named query and return all results.
     *
     * @param q Name of the query.
     * @param clazz Entity class.
     * @param params Parameters passed to the query.
     * @return A list of entities.
     * @param &lt;T&gt; Entity type.
     */
    public &lt;T&gt; Function&lt;EntityManager, List&lt;T&gt;&gt; findAll(String q, Class&lt;T&gt; clazz, Object... params) {
<span class="fc" id="L150">      return em -&gt; createTypedQuery(em, q, clazz, params).getResultList();</span>
    }

    /**
     * Execute a named query and return a subset of the results.
     *
     * @param q Name of the query.
     * @param firstResult The index of the first result returned.  Gets passed into the JPA internals.
     * @param maxResults How many results to return
     * @param clazz Entity class.
     * @param params Parameters passed to the query.
     * @return A list of entities.
     * @param &lt;T&gt; Entity type.
     */
    public &lt;T&gt; Function&lt;EntityManager, List&lt;T&gt;&gt; findSome(String q, int firstResult, int maxResults, Class&lt;T&gt; clazz, Object... params) {
<span class="fc" id="L165">      return em -&gt; createTypedQuery(em, q, clazz, params)</span>
<span class="fc" id="L166">          .setFirstResult(firstResult)</span>
<span class="fc" id="L167">          .setMaxResults(maxResults)</span>
<span class="fc" id="L168">          .getResultList();</span>
    }

    protected abstract &lt;T&gt; TypedQuery&lt;T&gt; createTypedQuery(EntityManager em, String queryName, Class&lt;T&gt; clazz,
        Object... params);

    protected &lt;T&gt; TypedQuery&lt;T&gt; configureQuery(TypedQuery&lt;T&gt; q, Object... params) {
<span class="fc" id="L175">      return (TypedQuery&lt;T&gt;) configureQuery((Query) q, params);</span>
    }
  }

<span class="fc" id="L179">  public abstract static class QueriesBase {</span>
    /**
     * Execute a named query and return a single result.
     *
     * @param q Name of the query.
     * @param params Parameters passed to the query.
     * @return The entity. An exception is thrown if not found.
     */
    public Function&lt;EntityManager, Object&gt; find(String q, Object... params) {
<span class="nc" id="L188">      return em -&gt; createQuery(em, q, params).getSingleResult();</span>
    }

    /**
     * Execute a named query and return a single result.
     *
     * @param q Name of the query.
     * @param params Parameters passed to the query.
     * @return An Optional with the entity or an empty Optional if not found.
     */
    public Function&lt;EntityManager, Optional&lt;Object&gt;&gt; findOpt(String q, Object... params) {
<span class="nc" id="L199">      return em -&gt; {</span>
        try {
<span class="nc" id="L201">          return Optional.of(createQuery(em, q, params).getSingleResult());</span>
<span class="nc" id="L202">        } catch (NoResultException | NonUniqueResultException e) {</span>
<span class="nc" id="L203">          return Optional.empty();</span>
        }
      };
    }

    /**
     * Execute a named query and return all results.
     *
     * @param q Name of the query.
     * @param params Parameters passed to the query.
     * @return A list of entities.
     */
    public Function&lt;EntityManager, List&gt; findAll(String q, Object... params) {
<span class="nc" id="L216">      return em -&gt; createQuery(em, q, params).getResultList();</span>
    }

    /**
     * Execute a named update query.
     *
     * @param q Name of the query.
     * @param params Parameters passed to the query.
     * @return The number of updated entities.
     */
    public Function&lt;EntityManager, Integer&gt; update(String q, Object... params) {
<span class="fc" id="L227">      return em -&gt; createQuery(em, q, params).executeUpdate();</span>
    }

    /**
     * Execute a named delete query.
     *
     * @param q Name of the query.
     * @param params Parameters passed to the query.
     * @return The number of deleted entities.
     */
    public Function&lt;EntityManager, Integer&gt; delete(String q, Object... params) {
<span class="fc" id="L238">      return em -&gt; createQuery(em, q, params).executeUpdate();</span>
    }

    /**
     * Create or update passed entity.
     *
     * @param entity Entity to create or update.
     * @return Created or updated entity.
     * @param &lt;E&gt; Entity type.
     */
    public &lt;E&gt; Function&lt;EntityManager, E&gt; persistOrUpdate(final E entity) {
<span class="fc" id="L249">      return em -&gt; {</span>
<span class="fc" id="L250">        final Object id = em.getEntityManagerFactory().getPersistenceUnitUtil().getIdentifier(entity);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (id == null) {</span>
<span class="fc" id="L252">          em.persist(entity);</span>
<span class="fc" id="L253">          return entity;</span>
        } else {
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L256">          final E dto = (E) em.find(entity.getClass(), id);</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">          if (dto == null) {</span>
<span class="fc" id="L258">            em.persist(entity);</span>
<span class="fc" id="L259">            return entity;</span>
          } else {
<span class="fc" id="L261">            return em.merge(entity);</span>
          }
        }
      };
    }

    /**
     * Delete passed entity.
     *
     * @param entity Entity to delete.
     * @return Deleted entity.
     * @param &lt;E&gt; Entity type.
     */
    public &lt;E&gt; Consumer&lt;EntityManager&gt; remove(final E entity) {
<span class="fc" id="L275">      return em -&gt; {</span>
<span class="fc" id="L276">        em.remove(entity);</span>
<span class="fc" id="L277">      };</span>
    }

    /**
     * Create passed entity.
     *
     * @param entity Entity to create.
     * @return Created entity.
     * @param &lt;E&gt; Entity type.
     */
    public &lt;E&gt; Function&lt;EntityManager, E&gt; persist(final E entity) {
<span class="fc" id="L288">      return em -&gt; {</span>
<span class="fc" id="L289">        em.persist(entity);</span>
<span class="fc" id="L290">        return entity;</span>
      };
    }

    /**
     * Create passed entity.
     *
     * @param entity Entity to create.
     * @return Optional with the created entity.
     * @param &lt;E&gt; Entity type.
     */
    public &lt;E&gt; Function&lt;EntityManager, Optional&lt;E&gt;&gt; persistOpt(final E entity) {
<span class="fc" id="L302">      return em -&gt; {</span>
<span class="fc" id="L303">        em.persist(entity);</span>
<span class="fc" id="L304">        return Optional.of(entity);</span>
      };
    }

    protected abstract Query createQuery(EntityManager em, String q, Object... params);

    protected Query configureQuery(Query q, Object... params) {
<span class="fc bfc" id="L311" title="All 2 branches covered.">      for (int i = 0; i &lt; params.length; i++) {</span>
<span class="fc" id="L312">        Object p = params[i];</span>

<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        if (p instanceof Pair) { // named parameters</span>
<span class="fc" id="L315">          Pair&lt;String, ?&gt; pair = (Pair&lt;String, ?&gt;) p;</span>
<span class="fc" id="L316">          String key = pair.getKey();</span>
<span class="fc" id="L317">          Object value = pair.getValue();</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">          if (value instanceof Date) {</span>
<span class="fc" id="L319">            q.setParameter(key, (Date) value, TemporalType.TIMESTAMP);</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">          } else if (value instanceof Calendar) {</span>
<span class="fc" id="L321">            q.setParameter(key, (Calendar) value, TemporalType.TIMESTAMP);</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">          } else if (value instanceof AbstractInstant) {</span>
<span class="nc" id="L323">            q.setParameter(key, ((AbstractInstant) value).toDate(), TemporalType.TIMESTAMP);</span>
          } else {
<span class="fc" id="L325">            q.setParameter(key, value);</span>
          }
<span class="fc" id="L327">        } else { // positional parameters</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">          if (p instanceof Date) {</span>
<span class="nc" id="L329">            q.setParameter(i + 1, (Date) p, TemporalType.TIMESTAMP);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">          } else if (p instanceof AbstractInstant) {</span>
<span class="nc" id="L331">            q.setParameter(i + 1, ((AbstractInstant) p).toDate(), TemporalType.TIMESTAMP);</span>
          } else {
<span class="nc" id="L333">            q.setParameter(i + 1, p);</span>
          }
        }
      }

<span class="fc" id="L338">      return q;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>