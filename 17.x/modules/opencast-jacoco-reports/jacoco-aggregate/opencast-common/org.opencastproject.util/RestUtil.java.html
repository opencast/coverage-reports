<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RestUtil.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.util</a> &gt; <span class="el_source">RestUtil.java</span></div><h1>RestUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.util;

import static org.opencastproject.util.Jsons.obj;
import static org.opencastproject.util.Jsons.p;
import static org.opencastproject.util.data.Monadics.mlist;
import static org.opencastproject.util.data.Option.option;
import static org.opencastproject.util.data.Tuple.tuple;
import static org.opencastproject.util.data.functions.Strings.split;
import static org.opencastproject.util.data.functions.Strings.trimToNil;

import org.opencastproject.job.api.JaxbJob;
import org.opencastproject.job.api.Job;
import org.opencastproject.rest.ErrorCodeException;
import org.opencastproject.rest.RestConstants;
import org.opencastproject.systems.OpencastConstants;
import org.opencastproject.util.Jsons.Obj;
import org.opencastproject.util.data.Function;
import org.opencastproject.util.data.Monadics;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.Tuple;

import org.apache.commons.lang3.StringUtils;
import org.osgi.service.component.ComponentContext;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.regex.Pattern;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

/** Utility functions for REST endpoints. */
public final class RestUtil {

  private RestUtil() {
  }

  /**
   * Return the endpoint's server URL and the service path by extracting the relevant parameters from the
   * ComponentContext.
   *
   * @param cc
   *          ComponentContext to get configuration from
   * @return (serverUrl, servicePath)
   * @throws Error
   *           if the service path is not configured for this component
   */
  public static Tuple&lt;String, String&gt; getEndpointUrl(ComponentContext cc) {
<span class="nc" id="L72">    return getEndpointUrl(cc, OpencastConstants.SERVER_URL_PROPERTY, RestConstants.SERVICE_PATH_PROPERTY);</span>
  }

  /**
   * Return the endpoint's server URL and the service path by extracting the relevant parameters from the
   * ComponentContext.
   *
   * @param cc
   *          ComponentContext to get configuration from
   * @param serverUrlKey
   *          Configuration key for the server URL
   * @param servicePathKey
   *          Configuration key for the service path
   * @return (serverUrl, servicePath)
   * @throws Error
   *           if the service path is not configured for this component
   */
  public static Tuple&lt;String, String&gt; getEndpointUrl(ComponentContext cc, String serverUrlKey, String servicePathKey) {
<span class="nc" id="L90">    final String serverUrl = option(cc.getBundleContext().getProperty(serverUrlKey)).getOrElse(</span>
            UrlSupport.DEFAULT_BASE_URL);
<span class="nc" id="L92">    final String servicePath = option((String) cc.getProperties().get(servicePathKey)).getOrElse(</span>
<span class="nc" id="L93">            Option.&lt;String&gt; error(RestConstants.SERVICE_PATH_PROPERTY + &quot; property not configured&quot;));</span>
<span class="nc" id="L94">    return tuple(serverUrl, servicePath);</span>
  }

  /** Create a file response. */
  public static Response.ResponseBuilder fileResponse(File f, String contentType, Option&lt;String&gt; fileName) {
<span class="fc" id="L99">    final Response.ResponseBuilder b = Response.ok(f).header(&quot;Content-Type&quot;, contentType)</span>
<span class="fc" id="L100">            .header(&quot;Content-Length&quot;, f.length());</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">    for (String fn : fileName)</span>
<span class="fc" id="L102">      b.header(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + fn);</span>
<span class="fc" id="L103">    return b;</span>
  }

  /**
   * create a partial file response
   *
   * @param f
   *          the requested file
   * @param contentType
   *          the contentType to send
   * @param fileName
   *          the filename to send
   * @param rangeHeader
   *          the range header
   * @return the Responsebuilder
   * @throws IOException
   *           if something goes wrong
   */
  public static Response.ResponseBuilder partialFileResponse(File f, String contentType, Option&lt;String&gt; fileName,
          String rangeHeader) throws IOException {

<span class="nc" id="L124">    String rangeValue = rangeHeader.trim().substring(&quot;bytes=&quot;.length());</span>
<span class="nc" id="L125">    long fileLength = f.length();</span>
    long start;
    long end;
<span class="nc bnc" id="L128" title="All 2 branches missed.">    if (rangeValue.startsWith(&quot;-&quot;)) {</span>
<span class="nc" id="L129">      end = fileLength - 1;</span>
<span class="nc" id="L130">      start = fileLength - 1 - Long.parseLong(rangeValue.substring(&quot;-&quot;.length()));</span>
    } else {
<span class="nc" id="L132">      String[] range = rangeValue.split(&quot;-&quot;);</span>
<span class="nc" id="L133">      start = Long.parseLong(range[0]);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">      end = range.length &gt; 1 ? Long.parseLong(range[1]) : fileLength - 1;</span>
    }
<span class="nc bnc" id="L136" title="All 2 branches missed.">    if (end &gt; fileLength - 1) {</span>
<span class="nc" id="L137">      end = fileLength - 1;</span>
    }

    // send partial response status code
<span class="nc" id="L141">    Response.ResponseBuilder response = Response.status(206);</span>

<span class="nc bnc" id="L143" title="All 2 branches missed.">    if (start &lt;= end) {</span>
<span class="nc" id="L144">      long contentLength = end - start + 1;</span>
<span class="nc" id="L145">      response.header(&quot;Accept-Ranges&quot;, &quot;bytes&quot;);</span>
<span class="nc" id="L146">      response.header(&quot;Connection&quot;, &quot;Close&quot;);</span>
<span class="nc" id="L147">      response.header(&quot;Content-Length&quot;, contentLength + &quot;&quot;);</span>
<span class="nc" id="L148">      response.header(&quot;Content-Range&quot;, &quot;bytes &quot; + start + &quot;-&quot; + end + &quot;/&quot; + fileLength);</span>
<span class="nc" id="L149">      response.header(&quot;Content-Type&quot;, contentType);</span>
<span class="nc" id="L150">      response.entity(new ChunkedFileInputStream(f, start, end));</span>
    }

<span class="nc" id="L153">    return response;</span>
  }

  /**
   * Create a stream response.
   *
   * @deprecated use
   *             {@link org.opencastproject.util.RestUtil.R#ok(java.io.InputStream, String, org.opencastproject.util.data.Option, org.opencastproject.util.data.Option)}
   *             instead
   */
  @Deprecated
  public static Response.ResponseBuilder streamResponse(InputStream in, String contentType, Option&lt;Long&gt; streamLength,
          Option&lt;String&gt; fileName) {
<span class="nc" id="L166">    final Response.ResponseBuilder b = Response.ok(in).header(&quot;Content-Type&quot;, contentType);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">    for (Long l : streamLength)</span>
<span class="nc" id="L168">      b.header(&quot;Content-Length&quot;, l);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">    for (String fn : fileName)</span>
<span class="nc" id="L170">      b.header(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + fn);</span>
<span class="nc" id="L171">    return b;</span>
  }

  /**
   * Return JSON if &lt;code&gt;format&lt;/code&gt; == json, XML else.
   *
   * @deprecated use {@link #getResponseType(String)}
   */
  @Deprecated
  public static MediaType getResponseFormat(String format) {
<span class="nc bnc" id="L181" title="All 2 branches missed.">    return &quot;json&quot;.equalsIgnoreCase(format) ? MediaType.APPLICATION_JSON_TYPE : MediaType.APPLICATION_XML_TYPE;</span>
  }

  /** Return JSON if &lt;code&gt;type&lt;/code&gt; == json, XML else. */
  public static MediaType getResponseType(String type) {
<span class="nc bnc" id="L186" title="All 2 branches missed.">    return &quot;json&quot;.equalsIgnoreCase(type) ? MediaType.APPLICATION_JSON_TYPE : MediaType.APPLICATION_XML_TYPE;</span>
  }

<span class="fc" id="L189">  private static final Function&lt;String, String[]&gt; CSV_SPLIT = split(Pattern.compile(&quot;,&quot;));</span>

  /**
   * Split a comma separated request param into a list of trimmed strings discarding any blank parts.
   * &lt;p&gt;
   * x=comma,separated,,%20value -&amp;gt; [&quot;comma&quot;, &quot;separated&quot;, &quot;value&quot;]
   */
  public static Monadics.ListMonadic&lt;String&gt; splitCommaSeparatedParam(Option&lt;String&gt; param) {
<span class="fc bfc" id="L197" title="All 2 branches covered.">    for (String p : param)</span>
<span class="fc" id="L198">      return mlist(CSV_SPLIT.apply(p)).bind(trimToNil);</span>
<span class="fc" id="L199">    return mlist();</span>
  }

  public static String generateErrorResponse(ErrorCodeException e) {
<span class="nc" id="L203">    Obj json = obj(p(&quot;error&quot;, obj(p(&quot;code&quot;, e.getErrorCode()), p(&quot;message&quot;, StringUtils.trimToEmpty(e.getMessage())))));</span>
<span class="nc" id="L204">    return json.toJson();</span>
  }

  /** Response builder functions. */
  public static final class R {
    private R() {
    }

    public static Response ok() {
<span class="fc" id="L213">      return Response.ok().build();</span>
    }

    public static Response ok(Object entity) {
<span class="fc" id="L217">      return Response.ok().entity(entity).build();</span>
    }

    public static Response ok(boolean entity) {
<span class="fc" id="L221">      return Response.ok().entity(Boolean.toString(entity)).build();</span>
    }

    public static Response ok(Jsons.Obj json) {
<span class="fc" id="L225">      return Response.ok().entity(json.toJson()).type(MediaType.APPLICATION_JSON_TYPE).build();</span>
    }

    public static Response ok(Job job) {
<span class="nc" id="L229">      return Response.ok().entity(new JaxbJob(job)).build();</span>
    }

    public static Response ok(MediaType type, Object entity) {
<span class="fc" id="L233">      return Response.ok(entity, type).build();</span>
    }

    /**
     * Create a response with status OK from a stream.
     *
     * @param in
     *          the input stream to read from
     * @param contentType
     *          the content type to set the Content-Type response header to
     * @param streamLength
     *          an optional value for the Content-Length response header
     * @param fileName
     *          an optional file name for the Content-Disposition response header
     */
    public static Response ok(InputStream in, String contentType, Option&lt;Long&gt; streamLength, Option&lt;String&gt; fileName) {
<span class="fc" id="L249">      return ok(in, option(contentType), streamLength, fileName);</span>
    }

    /**
     * Create a response with status OK from a stream.
     *
     * @param in
     *          the input stream to read from
     * @param contentType
     *          the content type to set the Content-Type response header to
     * @param streamLength
     *          an optional value for the Content-Length response header
     * @param fileName
     *          an optional file name for the Content-Disposition response header
     */
    public static Response ok(InputStream in, Option&lt;String&gt; contentType, Option&lt;Long&gt; streamLength,
            Option&lt;String&gt; fileName) {
<span class="fc" id="L266">      final Response.ResponseBuilder b = Response.ok(in);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">      for (String t : contentType)</span>
<span class="fc" id="L268">        b.header(&quot;Content-Type&quot;, t);</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">      for (Long l : streamLength)</span>
<span class="fc" id="L270">        b.header(&quot;Content-Length&quot;, l);</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">      for (String fn : fileName)</span>
<span class="nc" id="L272">        b.header(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + fn);</span>
<span class="fc" id="L273">      return b.build();</span>
    }

    public static Response created(URI location) {
<span class="nc" id="L277">      return Response.created(location).build();</span>
    }

    public static Response notFound() {
<span class="fc" id="L281">      return Response.status(Response.Status.NOT_FOUND).build();</span>
    }

    public static Response notFound(Object entity) {
<span class="fc" id="L285">      return Response.status(Response.Status.NOT_FOUND).entity(entity).build();</span>
    }

    public static Response notFound(Object entity, MediaType type) {
<span class="nc" id="L289">      return Response.status(Response.Status.NOT_FOUND).entity(entity).type(type).build();</span>
    }

    public static Response locked() {
<span class="nc" id="L293">      return Response.status(423).build();</span>
    }

    public static Response serverError() {
<span class="fc" id="L297">      return Response.serverError().build();</span>
    }

    public static Response conflict() {
<span class="nc" id="L301">      return Response.status(Response.Status.CONFLICT).build();</span>
    }

    public static Response noContent() {
<span class="fc" id="L305">      return Response.noContent().build();</span>
    }

    public static Response badRequest() {
<span class="fc" id="L309">      return Response.status(Response.Status.BAD_REQUEST).build();</span>
    }

    public static Response badRequest(String msg) {
<span class="fc" id="L313">      return Response.status(Response.Status.BAD_REQUEST).entity(msg).build();</span>
    }

    public static Response forbidden() {
<span class="nc" id="L317">      return Response.status(Response.Status.FORBIDDEN).build();</span>
    }

    public static Response forbidden(String msg) {
<span class="nc" id="L321">      return Response.status(Response.Status.FORBIDDEN).entity(msg).build();</span>
    }

    public static Response unauthorized(Object entity) {
<span class="nc" id="L325">      return Response.status(Response.Status.UNAUTHORIZED).entity(entity).build();</span>
    }

    public static Response conflict(String msg) {
<span class="fc" id="L329">      return Response.status(Response.Status.CONFLICT).entity(msg).build();</span>
    }

    /**
     * create a partial file response
     *
     * @param f
     *          the requested file
     * @param contentType
     *          the contentType to send
     * @param fileName
     *          the filename to send
     * @param rangeHeader
     *          the range header
     * @return the Responsebuilder
     * @throws IOException
     *           if something goes wrong
     */

    /**
     * Creates a precondition failed status response
     *
     * @return a precondition failed status response
     */
    public static Response preconditionFailed() {
<span class="nc" id="L354">      return Response.status(Response.Status.PRECONDITION_FAILED).build();</span>
    }

    /**
     * Creates a precondition failed status response with a message
     *
     * @param message
     *          The message body
     * @return a precondition failed status response with a message
     */
    public static Response preconditionFailed(String message) {
<span class="nc" id="L365">      return Response.status(Response.Status.PRECONDITION_FAILED).entity(message).build();</span>
    }

  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>