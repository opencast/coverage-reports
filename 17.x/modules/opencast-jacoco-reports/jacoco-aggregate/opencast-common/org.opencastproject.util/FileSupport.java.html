<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FileSupport.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Opencast :: jacoco-reports</a> &gt; <a href="../index.html" class="el_bundle">opencast-common</a> &gt; <a href="index.source.html" class="el_package">org.opencastproject.util</a> &gt; <span class="el_source">FileSupport.java</span></div><h1>FileSupport.java</h1><pre class="source lang-java linenums">/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 *   http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.util;

import static java.lang.String.format;
import static java.nio.file.Files.createLink;
import static java.nio.file.Files.deleteIfExists;
import static java.nio.file.Files.exists;
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
import static java.util.Objects.requireNonNull;

import org.apache.commons.lang3.exception.ExceptionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.nio.file.Files;
import java.nio.file.Path;

/** Utility class, dealing with files. */
public final class FileSupport {

  /** Only files will be deleted, the directory structure remains untouched. */
  public static final int DELETE_FILES = 0;

  /** Delete everything including the root directory. */
  public static final int DELETE_ROOT = 1;

  /** Name of the java environment variable for the temp directory */
  private static final String IO_TMPDIR = &quot;java.io.tmpdir&quot;;

  /** Work directory */
<span class="fc" id="L56">  private static File tmpDir = null;</span>

  /** Logging facility provided by log4j */
<span class="fc" id="L59">  private static final Logger logger = LoggerFactory.getLogger(FileSupport.class);</span>

  /** Disable construction of this utility class */
  private FileSupport() {
  }

  /**
   * Copies the specified file from &lt;code&gt;sourceLocation&lt;/code&gt; to &lt;code&gt;targetLocation&lt;/code&gt; and returns a reference
   * to the newly created file or directory.
   * &lt;p&gt;
   * If &lt;code&gt;targetLocation&lt;/code&gt; is an existing directory, then the source file or directory will be copied into this
   * directory, otherwise the source file will be copied to the file identified by &lt;code&gt;targetLocation&lt;/code&gt;.
   * &lt;p&gt;
   * Note that existing files and directories will be overwritten.
   * &lt;p&gt;
   * Also note that if &lt;code&gt;targetLocation&lt;/code&gt; is a directory than the directory itself, not only its content is
   * copied.
   *
   * @param sourceLocation
   *          the source file or directory
   * @param targetLocation
   *          the directory to copy the source file or directory to
   * @return the created copy
   * @throws IOException
   *           if copying of the file or directory failed
   */
  public static File copy(File sourceLocation, File targetLocation) throws IOException {
<span class="fc" id="L86">    return copy(sourceLocation, targetLocation, true);</span>
  }

  /**
   * Copies the specified &lt;code&gt;sourceLocation&lt;/code&gt; to &lt;code&gt;targetLocation&lt;/code&gt; and returns a reference to the
   * newly created file or directory.
   * &lt;p&gt;
   * If &lt;code&gt;targetLocation&lt;/code&gt; is an existing directory, then the source file or directory will be copied into this
   * directory, otherwise the source file will be copied to the file identified by &lt;code&gt;targetLocation&lt;/code&gt;.
   * &lt;p&gt;
   * If &lt;code&gt;overwrite&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, this method throws an {@link IOException} if the target
   * file already exists.
   * &lt;p&gt;
   * Note that if &lt;code&gt;targetLocation&lt;/code&gt; is a directory than the directory itself, not only its content is copied.
   *
   * @param sourceFile
   *          the source file or directory
   * @param targetFile
   *          the directory to copy the source file or directory to
   * @param overwrite
   *          &lt;code&gt;true&lt;/code&gt; to overwrite existing files
   * @return the created copy
   * @throws IOException
   *           if copying of the file or directory failed
   */
  public static File copy(File sourceFile, File targetFile, boolean overwrite) throws IOException {

    // This variable is used when the channel copy files, and stores the maximum size of the file parts copied from
    // source to target
<span class="fc" id="L115">    final int chunk = 1024 * 1024 * 512; // 512 MB</span>

    // This variable is used when the cannel copy fails completely, as the size of the memory buffer used to copy the
    // data from one stream to the other.
<span class="fc" id="L119">    final int bufferSize = 1024 * 1024; // 1 MB</span>

<span class="fc" id="L121">    File dest = determineDestination(targetFile, sourceFile, overwrite);</span>

    // We are copying a directory
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">    if (sourceFile.isDirectory()) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">      if (!dest.exists()) {</span>
<span class="nc" id="L126">        dest.mkdirs();</span>
      }
<span class="nc" id="L128">      File[] children = sourceFile.listFiles();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      for (File child : children) {</span>
<span class="nc" id="L130">        copy(child, dest, overwrite);</span>
      }
<span class="nc" id="L132">    }</span>
    // We are copying a file
    else {
      // If dest is not an &quot;absolute file&quot;, getParentFile may return null, even if there *is* a parent file.
      // That's why &quot;getAbsoluteFile&quot; is used here
<span class="fc" id="L137">      dest.getAbsoluteFile().getParentFile().mkdirs();</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">      if (dest.exists())</span>
<span class="fc" id="L139">        delete(dest);</span>

<span class="fc" id="L141">      FileChannel sourceChannel = null;</span>
<span class="fc" id="L142">      FileChannel targetChannel = null;</span>
<span class="fc" id="L143">      FileInputStream sourceStream = null;</span>
<span class="fc" id="L144">      FileOutputStream targetStream = null;</span>
<span class="fc" id="L145">      long size = 0;</span>

      try {
<span class="fc" id="L148">        sourceStream = new FileInputStream(sourceFile);</span>
<span class="fc" id="L149">        targetStream = new FileOutputStream(dest);</span>
        try {
<span class="fc" id="L151">          sourceChannel = sourceStream.getChannel();</span>
<span class="fc" id="L152">          targetChannel = targetStream.getChannel();</span>
<span class="fc" id="L153">          size = targetChannel.transferFrom(sourceChannel, 0, sourceChannel.size());</span>
<span class="nc" id="L154">        } catch (IOException ioe) {</span>
<span class="nc" id="L155">          logger.warn(&quot;Got IOException using Channels for copying.&quot;);</span>
        } finally {
          // This has to be in &quot;finally&quot;, because in 64-bit machines the channel copy may fail to copy the whole file
          // without causing a exception
<span class="pc bpc" id="L159" title="3 of 6 branches missed.">          if ((sourceChannel != null) &amp;&amp; (targetChannel != null) &amp;&amp; (size &lt; sourceFile.length())) {</span>
            // Failing back to using FileChannels *but* with chunks and not altogether
<span class="nc" id="L161">            logger.info(&quot;Trying to copy the file in chunks using Channels&quot;);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            while (size &lt; sourceFile.length())</span>
<span class="nc" id="L163">              size += targetChannel.transferFrom(sourceChannel, size, chunk);</span>
          }
        }
<span class="nc" id="L166">      } catch (IOException ioe) {</span>
<span class="nc bnc" id="L167" title="All 6 branches missed.">        if ((sourceStream != null) &amp;&amp; (targetStream != null) &amp;&amp; (size &lt; sourceFile.length())) {</span>
<span class="nc" id="L168">          logger.warn(&quot;Got IOException using Channels for copying in chunks. Trying to use stream copy instead...&quot;);</span>
<span class="nc" id="L169">          int copied = 0;</span>
<span class="nc" id="L170">          byte[] buffer = new byte[bufferSize];</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">          while ((copied = sourceStream.read(buffer, 0, buffer.length)) != -1)</span>
<span class="nc" id="L172">            targetStream.write(buffer, 0, copied);</span>
<span class="nc" id="L173">        } else</span>
<span class="nc" id="L174">          throw ioe;</span>
      } finally {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (sourceChannel != null)</span>
<span class="fc" id="L177">          sourceChannel.close();</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (sourceStream != null)</span>
<span class="fc" id="L179">          sourceStream.close();</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (targetChannel != null)</span>
<span class="fc" id="L181">          targetChannel.close();</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        if (targetStream != null)</span>
<span class="fc" id="L183">          targetStream.close();</span>
      }

<span class="pc bpc" id="L186" title="1 of 2 branches missed.">      if (sourceFile.length() != dest.length()) {</span>
<span class="nc" id="L187">        logger.warn(&quot;Source &quot; + sourceFile + &quot; and target &quot; + dest + &quot; do not have the same length&quot;);</span>
        // TOOD: Why would this happen?
        // throw new IOException(&quot;Source &quot; + sourceLocation + &quot; and target &quot; +
        // dest + &quot; do not have the same length&quot;);
      }
    }
<span class="fc" id="L193">    return dest;</span>
  }

  /**
   * Links the specified file or directory from &lt;code&gt;sourceLocation&lt;/code&gt; to &lt;code&gt;targetLocation&lt;/code&gt;. If
   * &lt;code&gt;targetLocation&lt;/code&gt; does not exist, it will be created, if the target file already exists, an
   * {@link IOException} will be thrown.
   * &lt;p&gt;
   * If this fails (because linking is not supported on the current filesystem, then a copy is made.
   * &lt;/p&gt;
   *
   * @param sourceLocation
   *          the source file or directory
   * @param targetLocation
   *          the targetLocation
   * @return the created link
   * @throws IOException
   *           if linking of the file or directory failed
   */
  public static File link(File sourceLocation, File targetLocation) throws IOException {
<span class="fc" id="L213">    return link(sourceLocation, targetLocation, false);</span>
  }

  /**
   * Links the specified file or directory from &lt;code&gt;sourceLocation&lt;/code&gt; to &lt;code&gt;targetLocation&lt;/code&gt;. If
   * &lt;code&gt;targetLocation&lt;/code&gt; does not exist, it will be created.
   * &lt;p&gt;
   * If this fails (because linking is not supported on the current filesystem, then a copy is made.
   * &lt;/p&gt;
   * If &lt;code&gt;overwrite&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, this method throws an {@link IOException} if the target
   * file already exists.
   *
   * @param sourceLocation
   *          the source file or directory
   * @param targetLocation
   *          the targetLocation
   * @param overwrite
   *          &lt;code&gt;true&lt;/code&gt; to overwrite existing files
   * @return the created link
   * @throws IOException
   *           if linking of the file or directory failed
   */
  public static File link(final File sourceLocation, final File targetLocation, final boolean overwrite)
          throws IOException {
<span class="fc" id="L237">    final Path sourcePath = requireNonNull(sourceLocation).toPath();</span>
<span class="fc" id="L238">    final Path targetPath = requireNonNull(targetLocation).toPath();</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">    if (exists(sourcePath)) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">      if (overwrite) {</span>
<span class="fc" id="L242">        deleteIfExists(targetPath);</span>
      } else {
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (exists(targetPath)) {</span>
<span class="nc" id="L245">          throw new IOException(format(&quot;There is already a file/directory at %s&quot;, targetPath));</span>
        }
      }

      try {
<span class="fc" id="L250">        createLink(targetPath, sourcePath);</span>
<span class="fc" id="L251">        targetPath.toFile().length(); // this forces a stat call which is a quickfix for a bug in ceph (https://www.mail-archive.com/ceph-users@lists.ceph.com/msg53368.html)</span>
<span class="nc" id="L252">      } catch (UnsupportedOperationException e) {</span>
<span class="nc" id="L253">        logger.debug(&quot;Copy file because creating hard-links is not supported by the current file system: {}&quot;,</span>
<span class="nc" id="L254">                ExceptionUtils.getMessage(e));</span>
<span class="nc" id="L255">        Files.copy(sourcePath, targetPath);</span>
<span class="nc" id="L256">      } catch (IOException e) {</span>
<span class="nc" id="L257">        logger.debug(&quot;Copy file because creating a hard-link at '{}' for existing file '{}' did not work:&quot;,</span>
                targetPath, sourcePath, e);
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (overwrite) {</span>
<span class="nc" id="L260">          Files.copy(sourcePath, targetPath, REPLACE_EXISTING);</span>
        } else {
<span class="nc" id="L262">          Files.copy(sourcePath, targetPath);</span>
        }
<span class="pc" id="L264">      }</span>
    } else {
<span class="fc" id="L266">      throw new IOException(format(&quot;No file/directory found at %s&quot;, sourcePath));</span>
    }

<span class="fc" id="L269">    return targetPath.toFile();</span>
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if the operating system as well as the disk layout support creating a hard link from
   * &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt;. Note that this implementation requires two files rather than directories and
   * will overwrite any existing file that might already be present at the destination.
   *
   * @param sourceLocation
   *          the source file
   * @param targetLocation
   *          the target file
   * @return &lt;code&gt;true&lt;/code&gt; if the link was created, &lt;code&gt;false&lt;/code&gt; otherwhise
   */
  public static boolean supportsLinking(File sourceLocation, File targetLocation) {
<span class="fc" id="L284">    final Path sourcePath = requireNonNull(sourceLocation).toPath();</span>
<span class="fc" id="L285">    final Path targetPath = requireNonNull(targetLocation).toPath();</span>

<span class="fc bfc" id="L287" title="All 2 branches covered.">    if (!exists(sourcePath))</span>
<span class="fc" id="L288">      throw new IllegalArgumentException(format(&quot;Source %s does not exist&quot;, sourcePath));</span>

<span class="fc" id="L290">    logger.debug(&quot;Creating hard link from {} to {}&quot;, sourcePath, targetPath);</span>
    try {
<span class="fc" id="L292">      deleteIfExists(targetPath);</span>
<span class="fc" id="L293">      createLink(targetPath, sourcePath);</span>
<span class="fc" id="L294">      targetPath.toFile().length(); // this forces a stat call which is a quickfix for a bug in ceph (https://www.mail-archive.com/ceph-users@lists.ceph.com/msg53368.html)</span>
<span class="nc" id="L295">    } catch (Exception e) {</span>
<span class="nc" id="L296">      logger.debug(&quot;Unable to create a link from {} to {}&quot;, sourcePath, targetPath, e);</span>
<span class="nc" id="L297">      return false;</span>
<span class="fc" id="L298">    }</span>

<span class="fc" id="L300">    return true;</span>
  }

  private static File determineDestination(File targetLocation, File sourceLocation, boolean overwrite)
          throws IOException {
<span class="fc" id="L305">    File dest = null;</span>

    // Source location exists
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">    if (sourceLocation.exists()) {</span>
      // Is the source file/directory readable
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">      if (sourceLocation.canRead()) {</span>
        // If a directory...
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (targetLocation.isDirectory()) {</span>
          // Create a destination file within it, with the same name of the source target
<span class="fc" id="L314">          dest = new File(targetLocation, sourceLocation.getName());</span>
        } else {
          // targetLocation is either a normal file or doesn't exist
<span class="fc" id="L317">          dest = targetLocation;</span>
        }

        // Source and target locations can not be the same
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (sourceLocation.equals(dest)) {</span>
<span class="nc" id="L322">          throw new IOException(&quot;Source and target locations must be different&quot;);</span>
        }

        // Search the first existing parent of the target file, to check if it can be written
        // getParentFile can return null even though there *is* a parent file, if the file is not absolute
        // That's the reason why getAbsoluteFile is used here
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        for (File iter = dest.getAbsoluteFile(); iter != null; iter = iter.getParentFile()) {</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">          if (iter.exists()) {</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if (iter.canWrite()) {</span>
<span class="fc" id="L331">              break;</span>
            } else {
<span class="nc" id="L333">              throw new IOException(&quot;Destination &quot; + dest + &quot;cannot be written/modified&quot;);</span>
            }
          }
        }

        // Check the target file can be overwritten
<span class="pc bpc" id="L339" title="2 of 6 branches missed.">        if (dest.exists() &amp;&amp; !dest.isDirectory() &amp;&amp; !overwrite) {</span>
<span class="nc" id="L340">          throw new IOException(&quot;Destination &quot; + dest + &quot; already exists&quot;);</span>
        }

      } else {
<span class="nc" id="L344">        throw new IOException(sourceLocation + &quot; cannot be read&quot;);</span>
      }
    } else {
<span class="nc" id="L347">      throw new IOException(&quot;Source &quot; + sourceLocation + &quot; does not exist&quot;);</span>
    }

<span class="fc" id="L350">    return dest;</span>
  }

  /**
   * Delete all directories from &lt;code&gt;start&lt;/code&gt; up to directory &lt;code&gt;limit&lt;/code&gt; if they are empty. Directory
   * &lt;code&gt;limit&lt;/code&gt; is &lt;em&gt;exclusive&lt;/em&gt; and will not be deleted.
   *
   * @return true if the &lt;em&gt;complete&lt;/em&gt; hierarchy has been deleted. false in any other case.
   */
  public static boolean deleteHierarchyIfEmpty(File limit, File start) {
<span class="fc bfc" id="L360" title="All 2 branches covered.">    return limit.isDirectory()</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">            &amp;&amp; start.isDirectory()</span>
<span class="pc bpc" id="L362" title="3 of 10 branches missed.">            &amp;&amp; (isEqual(limit, start) || (isParent(limit, start) &amp;&amp; start.list().length == 0 &amp;&amp; start.delete() &amp;&amp; deleteHierarchyIfEmpty(</span>
<span class="fc" id="L363">                    limit, start.getParentFile())));</span>
  }

  /** Compare two files by their canonical paths. */
  public static boolean isEqual(File a, File b) {
    try {
<span class="fc" id="L369">      return a.getCanonicalPath().equals(b.getCanonicalPath());</span>
<span class="nc" id="L370">    } catch (IOException e) {</span>
<span class="nc" id="L371">      return false;</span>
    }
  }

  /**
   * Check if &lt;code&gt;a&lt;/code&gt; is a parent of &lt;code&gt;b&lt;/code&gt;. This can only be the case if &lt;code&gt;a&lt;/code&gt; is a directory
   * and a sub path of &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;isParent(a, a) == true&lt;/code&gt;.
   */
  public static boolean isParent(File a, File b) {
    try {
<span class="fc" id="L381">      final String aCanonical = a.getCanonicalPath();</span>
<span class="fc" id="L382">      final String bCanonical = b.getCanonicalPath();</span>
<span class="fc bfc" id="L383" title="All 4 branches covered.">      return (!aCanonical.equals(bCanonical) &amp;&amp; bCanonical.startsWith(aCanonical));</span>
<span class="nc" id="L384">    } catch (IOException e) {</span>
<span class="nc" id="L385">      return false;</span>
    }
  }

  /**
   * Deletes the specified file and returns &lt;code&gt;true&lt;/code&gt; if the file was deleted.
   * &lt;p&gt;
   * If &lt;code&gt;f&lt;/code&gt; is a directory, it will only be deleted if it doesn't contain any other files or directories. To
   * do a recursive delete, you may use {@link #delete(File, boolean)}.
   *
   * @param f
   *          the file or directory
   * @see #delete(File, boolean)
   */
  public static boolean delete(File f) throws IOException {
<span class="fc" id="L400">    return delete(f, false);</span>
  }

  /**
   * Like {@link #delete(File)} but does not throw any IO exceptions.
   * In case of an IOException it will only be logged at warning level and the method returns false.
   */
  public static boolean deleteQuietly(File f) {
<span class="fc" id="L408">    return deleteQuietly(f, false);</span>
  }

  /**
   * Like {@link #delete(File, boolean)} but does not throw any IO exceptions.
   * In case of an IOException it will only be logged at warning level and the method returns false.
   */
  public static boolean deleteQuietly(File f, boolean recurse) {
    try {
<span class="fc" id="L417">      return delete(f, recurse);</span>
<span class="nc" id="L418">    } catch (IOException e) {</span>
<span class="nc" id="L419">      logger.warn(&quot;Cannot delete &quot; + f.getAbsolutePath() + &quot; because of IOException&quot;</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                       + (e.getMessage() != null ? &quot; &quot; + e.getMessage() : &quot;&quot;));</span>
<span class="nc" id="L421">      return false;</span>
    }
  }

  /**
   * Deletes the specified file and returns &lt;code&gt;true&lt;/code&gt; if the file was deleted.
   * &lt;p&gt;
   * In the case that &lt;code&gt;f&lt;/code&gt; references a directory, it will only be deleted if it doesn't contain other files
   * or directories, unless &lt;code&gt;recurse&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @param f
   *          the file or directory
   * @param recurse
   *          &lt;code&gt;true&lt;/code&gt; to do a recursive deletes for directories
   */
  public static boolean delete(File f, boolean recurse) throws IOException {
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">    if (f == null)</span>
<span class="nc" id="L439">      return false;</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">    if (!f.exists())</span>
<span class="fc" id="L441">      return false;</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">    if (f.isDirectory()) {</span>
<span class="fc" id="L443">      String[] children = f.list();</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">      if (children == null) {</span>
<span class="nc" id="L445">        throw new IOException(&quot;Cannot list content of directory &quot; + f.getAbsolutePath());</span>
      }
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">      if (children != null) {</span>
<span class="pc bpc" id="L448" title="1 of 4 branches missed.">        if (children.length &gt; 0 &amp;&amp; !recurse)</span>
<span class="nc" id="L449">          return false;</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">        for (String child : children) {</span>
<span class="fc" id="L451">          delete(new File(f, child), true);</span>
        }
      } else {
<span class="nc" id="L454">        logger.debug(&quot;Unexpected null listing files in {}&quot;, f.getAbsolutePath());</span>
      }
    }
<span class="fc" id="L457">    return f.delete();</span>
  }

  /**
   * Deletes the content of directory &lt;code&gt;dir&lt;/code&gt; and, if specified, the directory itself. If &lt;code&gt;dir&lt;/code&gt; is a
   * normal file it will always be deleted.
   *
   * @return true everthing was deleted, false otherwise
   */
  public static boolean delete(File dir, int mode) {
<span class="nc bnc" id="L467" title="All 2 branches missed.">    if (dir.isDirectory()) {</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">      boolean ok = delete(dir.listFiles(), mode != DELETE_FILES);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">      if (mode == DELETE_ROOT) {</span>
<span class="nc" id="L470">        ok &amp;= dir.delete();</span>
      }
<span class="nc" id="L472">      return ok;</span>
    } else {
<span class="nc" id="L474">      return dir.delete();</span>
    }
  }

  /**
   * Deletes the content of directory &lt;code&gt;dir&lt;/code&gt; and, if specified, the directory itself. If &lt;code&gt;dir&lt;/code&gt; is a
   * normal file it will be deleted always.
   */
  private static boolean delete(File[] files, boolean deleteDir) {
<span class="nc" id="L483">    boolean ok = true;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">    for (File f : files) {</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">      if (f.isDirectory()) {</span>
<span class="nc" id="L486">        delete(f.listFiles(), deleteDir);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (deleteDir) {</span>
<span class="nc" id="L488">          ok &amp;= f.delete();</span>
        }
      } else {
<span class="nc" id="L491">        ok &amp;= f.delete();</span>
      }
    }
<span class="nc" id="L494">    return ok;</span>
  }

  /**
   * Sets the webapp's temporary directory. Make sure that directory exists and has write permissions turned on.
   *
   * @param tmpDir
   *          the new temporary directory
   * @throws IllegalArgumentException
   *           if the file object doesn't represent a directory
   * @throws IllegalStateException
   *           if the directory is write protected
   */
  public static void setTempDirectory(File tmpDir) throws IllegalArgumentException, IllegalStateException {
<span class="pc bpc" id="L508" title="2 of 4 branches missed.">    if (tmpDir == null || !tmpDir.isDirectory())</span>
<span class="nc" id="L509">      throw new IllegalArgumentException(tmpDir + &quot; is not a directory&quot;);</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">    if (!tmpDir.canWrite())</span>
<span class="nc" id="L511">      throw new IllegalStateException(tmpDir + &quot; is not writable&quot;);</span>
<span class="fc" id="L512">    FileSupport.tmpDir = tmpDir;</span>
<span class="fc" id="L513">  }</span>

  /**
   * Returns the webapp's temporary work directory.
   *
   * @return the temp directory
   */
  public static File getTempDirectory() {
<span class="fc bfc" id="L521" title="All 2 branches covered.">    if (tmpDir == null) {</span>
<span class="fc" id="L522">      setTempDirectory(new File(System.getProperty(IO_TMPDIR)));</span>
    }
<span class="fc" id="L524">    return tmpDir;</span>
  }

  /**
   * Returns a directory &lt;code&gt;subdir&lt;/code&gt; inside the webapp's temporary work directory.
   *
   * @param subdir
   *          name of the subdirectory
   * @return the ready to use temp directory
   */
  public static File getTempDirectory(String subdir) {
<span class="fc" id="L535">    File tmp = new File(getTempDirectory(), subdir);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">    if (!tmp.exists())</span>
<span class="fc" id="L537">      tmp.mkdirs();</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">    if (!tmp.isDirectory())</span>
<span class="nc" id="L539">      throw new IllegalStateException(tmp + &quot; is not a directory!&quot;);</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">    if (!tmp.canRead())</span>
<span class="nc" id="L541">      throw new IllegalStateException(&quot;Temp directory &quot; + tmp + &quot; is not readable!&quot;);</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">    if (!tmp.canWrite())</span>
<span class="nc" id="L543">      throw new IllegalStateException(&quot;Temp directory &quot; + tmp + &quot; is not writable!&quot;);</span>
<span class="fc" id="L544">    return tmp;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>